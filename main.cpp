#include <iostream>
#include "opencv2/opencv.hpp"

using namespace cv;
using namespace std;

//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int __cdecl sub_401000(void (__cdecl *a1)(int, double *, int, int, int), void (__cdecl *a2)(int, int, int, int, int), int a3, int a4, int Src, int a6, int a7, double *a8, double *a9, double *Block, double *a11, int a12);
void __cdecl sub_401EB0(int a1, double *a2, int a3, int a4);
// int __usercall sub_4020A0@<eax>(int a1@<esi>, int a2, double *a3);
int __cdecl sub_4029D0(int a1, double *a2, double a3, int a4, int a5);
double __cdecl sub_402A70(int a1, int a2, int a3, signed int a4);
int __cdecl sub_402D90(void *Src, void *a2, char *a3, int a4);
int sub_4035E0();
int sub_4035F0();
int sub_403600();
_DWORD *__thiscall sub_403610(_DWORD *this, char a2);
void __thiscall __noreturn sub_403640(_DWORD *this, int a2, size_t Size);
void *__stdcall sub_403790(unsigned int a1);
_DWORD *__thiscall sub_4037C0(_DWORD *this, _DWORD *a2, unsigned int a3, size_t Size);
_DWORD *__thiscall sub_4038E0(_DWORD *this, _BYTE *Src, size_t Size);
_DWORD *__stdcall sub_4039E0(_DWORD *a1, int a2);
bool __thiscall sub_403A40(void *this, _DWORD *a2, int a3);
bool __thiscall sub_403A60(void *this, int a2, _DWORD *a3);
_DWORD *__thiscall sub_403AA0(_DWORD *this, unsigned int a2, unsigned int a3);
_DWORD *__stdcall sub_403B40(_DWORD *a1, int a2);
_DWORD *__stdcall sub_403BC0(_DWORD *a1, int a2);
_DWORD *__stdcall sub_403C10(_DWORD *a1, int a2);
const char *sub_403C90();
const char *sub_403CA0();
const char *sub_403CB0();
int __thiscall sub_403CC0(int this, unsigned int a2);
int *__thiscall sub_403D10(int *this, unsigned int a2);
void __thiscall sub_403D50(int this);
char __thiscall sub_403D80(_DWORD *this, unsigned int a2);
int __thiscall sub_403DF0(_DWORD *this, int a2);
int __thiscall sub_403E20(int *this, int a2, int a3);
_DWORD *__thiscall sub_403E60(_DWORD *this);
int __thiscall sub_403E70(_DWORD *this);
_DWORD *__thiscall sub_403EA0(_DWORD *this, char a2);
int __thiscall sub_403EE0(_DWORD *this);
char *__thiscall sub_403F00(char *this, char *a2);
int __thiscall sub_403F40(char *this);
char *__thiscall sub_403FA0(char *this, char a2);
int __cdecl sub_404010(int a1, int a2, int a3, _DWORD *a4, unsigned __int8 (__cdecl *a5)(_DWORD *, _DWORD *));
__m128i *__cdecl sub_404090(const __m128i *a1, const __m128i *a2, __m128i *a3);
int __cdecl sub_4040D0(const __m128i **a1, const __m128i **a2, int a3);
void __cdecl sub_404130(int a1, int a2);
void __cdecl sub_404180(int *a1, int *a2, unsigned __int8 (__cdecl *a3)(int *, int *));
int __cdecl sub_404280(int a1, int a2, unsigned __int8 (__cdecl *a3)(_DWORD *, _DWORD *));
int __cdecl sub_404370(int *a1, int *a2, int *a3, unsigned __int8 (__cdecl *a4)(int *, int *));
int __cdecl sub_4043F0(int *a1, int *a2, int *a3, unsigned __int8 (__cdecl *a4)(int *, int *));
int __cdecl sub_404490(int a1, int a2, int a3, _DWORD *a4, unsigned __int8 (__cdecl *a5)(_DWORD *, _DWORD *));
void __cdecl sub_404510(int *a1, int *a2, int a3, unsigned __int8 (__cdecl *a4)(int *, int *));
signed int __cdecl sub_4045F0(int *a1, int a2, unsigned __int8 (__cdecl *a3)(_DWORD *, _DWORD *));
__m128i *__stdcall sub_404680(const __m128i *a1, const __m128i *a2, __m128i *a3);
int __stdcall sub_4046B0(int a1, int a2, int a3);
int **__cdecl sub_4046E0(int **a1, int *a2, int *a3, unsigned __int8 (__cdecl *a4)(int *, int *));
__m128i *__cdecl sub_404940(const __m128i *a1, const __m128i *a2, __m128i *a3);
_DWORD *__cdecl sub_404980(_DWORD *a1, _DWORD *a2, _DWORD *a3);
void __stdcall sub_4049C0(_DWORD *a1);
int __thiscall sub_404A00(int this, const __m128i **a2);
int __thiscall sub_404AC0(int this, const __m128i **a2);
int *__thiscall sub_404C30(int *this, const __m128i ***a2);
int __stdcall sub_404D80(_DWORD *a1, _DWORD *a2);
double __thiscall sub_404E30(_DWORD *this);
int __thiscall sub_404F30(_DWORD *this);
void __thiscall sub_404F90(_DWORD *this, _DWORD *a2);
int __thiscall sub_405120(_DWORD *this, _DWORD *a2, _DWORD **a3);
char __thiscall sub_405320(_DWORD *this, unsigned int a2);
char __thiscall sub_405390(_DWORD *this, unsigned int a2);
char *__thiscall sub_405400(int this, unsigned int a2);
char *__thiscall sub_405480(_DWORD **this, unsigned int a2);
unsigned int __thiscall sub_405560(_DWORD *this, unsigned int a2);
unsigned int __thiscall sub_4055E0(int this, unsigned int a2);
void __thiscall sub_405660(int *this);
bool __cdecl sub_4056B0(_DWORD *a1, _DWORD *a2);
unsigned int __thiscall sub_4056D0(unsigned int *this, _DWORD *a2);
int __thiscall sub_405750(_DWORD *this, unsigned int a2);
char __thiscall sub_4057B0(_DWORD *this);
void __cdecl sub_405DC0(_OWORD *a1, int a2);
_QWORD *__cdecl sub_405DE0(_QWORD *a1, _QWORD *a2, _QWORD *a3);
int __thiscall sub_405E20(int this, int a2, int a3, __int64 a4);
int __thiscall sub_405EB0(int this, int a2, int a3, __int64 a4);
void __thiscall sub_406030(int this);
double __thiscall sub_4060D0(_DWORD *this, double a2);
char __thiscall sub_406170(_DWORD *this, double a2, double *a3);
char __thiscall sub_406280(_DWORD *this, double a2, double *a3);
// _OWORD *__usercall sub_406310@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>);
_DWORD *__thiscall sub_406840(_QWORD **this, unsigned int a2);
unsigned int __thiscall sub_406920(int this, unsigned int a2);
int __thiscall sub_4069A0(_DWORD *this, unsigned int a2);
double __thiscall sub_406A70(int this, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
double *__cdecl sub_406C30(__int64 a1, double a2, double a3, double *a4);
double *__cdecl sub_406E50(double *a1, double *a2, double *a3);
double *__cdecl sub_407120(double *a1, double *a2, double *a3);
double *__cdecl sub_407400(double *a1, double *a2, double *a3);
char *__thiscall sub_4076E0(int this, unsigned int a2);
unsigned int __thiscall sub_407760(_DWORD *this, unsigned int a2);
int __thiscall sub_4077E0(_DWORD *this, unsigned int a2);
_DWORD *__thiscall sub_407850(_DWORD *this, int a2, int a3, int a4);
void __thiscall sub_4078C0(void *this);
void *__thiscall sub_4078E0(void *this, char a2);
// int __usercall sub_407920@<eax>(int a1@<edi>, int a2@<esi>, int a3, int a4, int a5, int a6, int a7);
void __thiscall sub_4089A0(int *this, int a2, _DWORD **a3, _DWORD *a4, double a5, double a6);
// char *__usercall sub_408C60@<eax>(int a1@<edi>, int a2@<esi>, int a3, char *a4, int a5, int a6, int a7);
double __thiscall sub_40C4E0(int *this);
_DWORD *__thiscall sub_40C640(_DWORD *this, int a2, int a3, int a4);
void __thiscall sub_40C6B0(void *this);
void *__thiscall sub_40C6D0(void *this, char a2);
// int __usercall sub_40C710@<eax>(int a1@<edi>, int a2@<esi>, int a3, int a4, int a5, int a6, int a7);
int *__thiscall sub_40D630(int this, char *a2, int a3);
// char *__usercall sub_40D690@<eax>(int a1@<edi>, int a2@<esi>, int a3, char *a4, int a5, int a6, int a7);
double __thiscall sub_410E70(int *this);
_DWORD *__thiscall sub_411000(_DWORD *this, int a2, int a3, int a4);
void __thiscall sub_411070(void *this);
void *__thiscall sub_411090(void *this, char a2);
// int __usercall sub_4110D0@<eax>(int a1@<edi>, int a2@<esi>, int a3, int a4, int a5, int a6, int a7);
// void __userpurge sub_4122B0(int *a1@<ecx>, int a2@<edi>, _DWORD *a3, _DWORD **a4, _DWORD *a5, double a6, double a7);
// char *__usercall sub_412610@<eax>(int a1@<edi>, int a2@<esi>, int a3, char *a4, int a5, int a6, int a7);
void *__thiscall sub_416640(int this, void *Src);
double __thiscall sub_416680(int *this);
void __cdecl sub_416820(_DWORD *a1, int a2);
// void __usercall sub_416880(double a1@<st0>, int a2, _DWORD *a3, float a4);
int __cdecl sub_416B30(int a1, int a2, int a3, _DWORD *a4, unsigned __int8 (__cdecl *a5)(_DWORD, _DWORD));
void *__cdecl sub_416BD0(char *Src, char *a2, unsigned __int8 (__cdecl *a3)(int, int));
int __cdecl sub_416C80(int a1, int a2, unsigned __int8 (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_416D30(int *a1, int *a2, int *a3, unsigned __int8 (__cdecl *a4)(int, int));
int __cdecl sub_416F10(int a1, int a2, int a3, _DWORD *a4, unsigned __int8 (__cdecl *a5)(_DWORD, _DWORD));
void *__cdecl sub_416F80(char *Src, char *a2, int a3, unsigned __int8 (__cdecl *a4)(int, int));
signed int __cdecl sub_417060(_DWORD *a1, int a2, unsigned __int8 (__cdecl *a3)(_DWORD, _DWORD));
int **__cdecl sub_4170C0(int **a1, int *a2, int *a3, unsigned __int8 (__cdecl *a4)(int, int));
bool __cdecl sub_4172A0(int a1, int a2);
bool __cdecl sub_4172C0(int a1, int a2, int a3, int a4, int a5, int a6, double a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, double a16);
unsigned int __thiscall sub_4172E0(_DWORD *this);
int __cdecl sub_4173B0(int a1, int a2, int a3, const __m128i *a4, unsigned __int8 (__cdecl *a5)(__int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32));
void __cdecl sub_417570(int a1, int a2);
__m128i *__cdecl sub_4175B0(const __m128i *a1, __m128i *a2, unsigned __int8 (__cdecl *a3)(__int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32));
int __cdecl sub_4177B0(int a1, int a2, unsigned __int8 (__cdecl *a3)(__int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32));
int __cdecl sub_417920(__m128i *a1, __m128i *a2, __m128i *a3, unsigned __int8 (__cdecl *a4)(__int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32));
int __cdecl sub_417AC0(__m128i *a1, __m128i *a2, __m128i *a3, unsigned __int8 (__cdecl *a4)(__int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32));
int __cdecl sub_417B70(int a1, int a2, int a3, const __m128i *a4, unsigned __int8 (__cdecl *a5)(__int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32));
int __cdecl sub_417C60(__m128i *a1, __m128i *a2, int a3, unsigned __int8 (__cdecl *a4)(__int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32));
int __cdecl sub_417DA0(const __m128i *a1, int a2, unsigned __int8 (__cdecl *a3)(__int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32));
__m128i **__cdecl sub_417E60(__m128i **a1, __m128i *a2, __m128i *a3, unsigned __int8 (__cdecl *a4)(__int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32));
void __cdecl sub_4183C0(_OWORD *a1, int a2);
__m128i *__cdecl sub_4183F0(const __m128i *a1, const __m128i *a2, __m128i *a3);
__m128i *__cdecl sub_418430(const __m128i *a1, const __m128i *a2, __m128i *a3);
_DWORD *__cdecl sub_418470(_DWORD *a1, _DWORD *a2, _DWORD *a3);
int __thiscall sub_4184D0(int this, double a2, int a3, int a4, double a5);
// _DWORD *__userpurge sub_418880@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, int a4, int a5, __int64 a6);
void __thiscall sub_419150(unsigned int *this, double a2, int a3, int a4, double a5);
void __thiscall sub_419BD0(int this, int a2, int a3, __int64 a4);
void __thiscall sub_41AC40(int this, double a2, int a3, int a4, __int64 a5);
void __thiscall sub_41DA90(int this, int a2, int a3, double a4);
__int8 *__thiscall sub_420E20(int this, unsigned int a2);
__m128i **__thiscall sub_420F10(const __m128i **this, unsigned int a2);
__int8 *__thiscall sub_420FF0(int this, unsigned int a2);
char *__thiscall sub_4210E0(int *this, unsigned int a2);
unsigned int __thiscall sub_4211E0(_DWORD *this, unsigned int a2);
unsigned int __thiscall sub_421290(int this, unsigned int a2);
unsigned int __thiscall sub_421310(_DWORD *this, unsigned int a2);
unsigned int __thiscall sub_4213C0(int *this, unsigned int a2);
unsigned int __thiscall sub_421460(_DWORD *this, unsigned int *a2);
__m128i *__thiscall sub_4214D0(_DWORD *this, const __m128i *a2);
__m128i *__thiscall sub_421580(_DWORD *this, const __m128i *a2);
void __thiscall sub_421620(int *this, const __m128i **a2);
int __thiscall sub_4216E0(_DWORD *this, unsigned int a2);
// int __usercall sub_4217B0@<eax>(double a1@<st0>, _DWORD *a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, __int64 a11, int Count, _DWORD *a13, unsigned int *a14, _DWORD *a15);
int __cdecl sub_421E50(_DWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
double __cdecl sub_421F30(double a1, double a2);
BOOL __cdecl sub_421FB0(double a1, double a2);
void *__cdecl sub_422020(int a1);
void __cdecl __noreturn sub_422090(const char *a1);
void __cdecl sub_4220C0(void **Block);
void __cdecl sub_4220F0(void *Block);
void __cdecl sub_422130(_DWORD *a1, double a2);
_DWORD *__cdecl sub_422240(_DWORD *a1, double a2, double a3);
// double __usercall sub_422760@<st0>(__int64 a1@<esi:edi>, int a2, int a3, double a4, double a5, _DWORD *a6, double a7, double a8);
double __cdecl sub_422A60(double a1, double a2, double a3, double a4, double a5);
double __cdecl sub_422BB0(double a1, double a2, double a3, double a4, double a5);
BOOL __cdecl sub_422D00(int a1, int a2, _DWORD *a3, double a4, double a5);
// _DWORD *__usercall sub_422DD0@<eax>(int a1@<edi>, _DWORD *a2, __int64 a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, size_t Count);
// double __usercall sub_423270@<st0>(int a1@<esi>, double a2);
double __cdecl sub_423330(double a1);
// int __usercall sub_4233F0@<eax>(double a1@<st0>, _DWORD *a2, int a3, int a4, int a5);
_DWORD *__cdecl sub_423450(unsigned int a1, unsigned int a2);
void **__cdecl sub_4234C0(unsigned int a1, unsigned int a2, unsigned __int8 a3);
_DWORD *__cdecl sub_423520(unsigned int a1, unsigned int a2);
_DWORD *__cdecl sub_423590(int a1, int a2, int a3);
_DWORD *__cdecl sub_4235F0(unsigned int a1, unsigned int a2);
_DWORD *__cdecl sub_423660(unsigned int a1);
// double __usercall sub_4236E0@<st0>(int a1@<esi>, int a2, int a3, double a4, double a5);
// double __usercall sub_423A70@<st0>(double result@<st0>, double *a2, _DWORD *a3, double a4, double a5);
void __cdecl sub_4243C0(double *, _DWORD *, double);
int __cdecl sub_4244C0(int a1, int *a2, _DWORD *a3, double a4, double a5, __int64 a6, int a7, _DWORD *a8, _DWORD *a9, double a10);
int __cdecl sub_424790(int *a1, int *a2, _DWORD *a3, double a4, double a5, __int64 a6, int a7, _DWORD *a8, _DWORD *a9, double a10);
int __cdecl sub_424B60(int a1, int a2, _DWORD *a3, double a4, double a5, __int64 a6, int a7);
int __cdecl sub_424E00(int a1, int a2, _DWORD *a3, int *a4, _DWORD *a5, double *a6, _DWORD *a7, double a8);
// __int64 __usercall sub_425060@<xmm0>(int a1);
double *__cdecl sub_425200(double *a1);
// int __userpurge sub_425400@<eax>(int result@<eax>, int a2@<ecx>, int a3);
int __fastcall sub_425440(int a1, int a2, int a3);
void __cdecl sub_425550(int a1, int a2, int a3, int *a4, double a5, double a6, int a7, double a8, double a9, double a10);
void __cdecl sub_425F90(int a1, int a2, int a3, int a4, int a5, int a6, double a7, double a8, int a9, double a10, double a11, double a12);
int __stdcall sub_426520(_DWORD *a1, _DWORD *a2, _DWORD *a3);
_DWORD *__thiscall sub_426540(_DWORD *this, int a2, _DWORD **a3, int a4);
void __stdcall sub_426570(_DWORD *a1, _DWORD *a2, _DWORD *a3);
_DWORD *__thiscall sub_4265A0(_DWORD *this, _DWORD *a2, char a3, _DWORD *a4, int a5, void *a6);
_DWORD *__thiscall sub_4267B0(_DWORD **this, _DWORD *a2, _DWORD *a3, int *a4, void *a5);
int __thiscall sub_426950(_DWORD *this, int a2, _DWORD *a3, _DWORD *a4, void *a5);
int __stdcall sub_426A70(int a1, int *a2);
int __stdcall sub_426A90(int a1, _DWORD *a2);
int __cdecl sub_426AB0(int a1, int a2, int a3);
void __cdecl sub_426B70(int a1, int a2);
// _DWORD *__usercall sub_426BA0@<eax>(_DWORD *result@<eax>, int a2, int a3);
// _DWORD *__usercall sub_426BE0@<eax>(_DWORD *result@<eax>, int a2, int a3);
int __cdecl sub_426C20(int a1, int a2, int a3);
_DWORD *__thiscall sub_426CE0(_DWORD *this, _DWORD *a2, _DWORD *a3);
_DWORD *__thiscall sub_426DD0(_DWORD *this, _DWORD *a2, _DWORD *a3);
void __thiscall sub_426EC0(_DWORD *this);
int *__thiscall sub_426EE0(int *this, int *a2);
_DWORD *__thiscall sub_426F90(_DWORD *this);
_DWORD *__thiscall sub_4270F0(_DWORD *this, int a2, int a3);
void __thiscall sub_427130(_DWORD *this);
void __thiscall sub_4271F0(_DWORD *this);
void __thiscall sub_427250(int this);
void __thiscall sub_427310(void **this);
_DWORD *__thiscall sub_4273C0(_DWORD *this, _DWORD *a2);
int *__thiscall sub_427450(int *this);
void *__thiscall sub_4274A0(void *this);
char *__thiscall sub_427500(char *this, char a2);
void **__thiscall sub_427560(void **this, char a2);
void *__thiscall sub_4275B0(void *this, char a2);
char *__thiscall sub_4275E0(char *this, char a2);
_DWORD *__thiscall sub_427610(_DWORD *this, char a2);
void **__thiscall sub_427690(void **this, char a2);
int __thiscall sub_4276C0(_DWORD *this);
void __thiscall sub_427C60(_DWORD *this, float a2);
void __thiscall sub_427CA0(_DWORD *this, float a2);
int __thiscall sub_427CE0(_DWORD *this, int a2);
void __thiscall sub_427FB0(_DWORD *this);
void __thiscall sub_428040(int *this, int a2, int a3, int a4);
void __thiscall sub_428080(int *this);
int __thiscall sub_428190(int *this);
void __thiscall sub_4283B0(_DWORD *this);
void __thiscall sub_4285B0(_DWORD *this);
int __thiscall sub_428700(int *this, int a2, int a3);
double __thiscall sub_429780(_DWORD *this, int a2, int a3);
double __cdecl sub_429AE0(int a1, int a2, int a3, int a4);
void __thiscall sub_429C20(int this);
// void __userpurge sub_429EB0(int *a1@<ecx>, __m128d a2@<xmm5>, __int64 a3, unsigned int a4);
void __stdcall sub_429F10(float a1, float a2, float a3, float a4, int a5, int a6, int a7, int a8);
_DWORD *__thiscall sub_42A0F0(_DWORD *this, int a2, int a3);
void __thiscall sub_42A1D0(_DWORD *this, int a2);
int __thiscall sub_42A690(_DWORD *this);
// int __usercall sub_42A9E0@<eax>(int a1@<ecx>, int a2@<edi>);
void __thiscall sub_42AAF0(int *this);
// int __userpurge sub_42AB30@<eax>(int a1@<ecx>, __m128d a2@<xmm5>, int a3);
float *__thiscall sub_42AB70(_DWORD *this);
void __thiscall sub_42ABA0(int this);
void sub_42AD50();
void __stdcall sub_42AD80(_DWORD *a1, _DWORD *a2);
void __stdcall sub_42ADC0(_DWORD *a1, _DWORD *a2);
_DWORD *__thiscall sub_42AE00(_DWORD *this);
void __stdcall sub_42AE40(void **a1);
unsigned int __thiscall sub_42AE80(_DWORD *this, unsigned int a2);
void __thiscall sub_42AED0(int this, unsigned int a2);
_DWORD *__thiscall sub_42B050(void *this, int a2);
char *__thiscall sub_42B0B0(int *this, unsigned int a2);
int *__thiscall sub_42B1E0(int *this, unsigned int a2);
char *__thiscall sub_42B2D0(int *this, unsigned int a2);
unsigned int __thiscall sub_42B340(int *this, unsigned int a2);
_DWORD *__thiscall sub_42B3C0(void *this, _DWORD *a2);
void __thiscall sub_42B420(int this);
void __thiscall sub_42B480(int this);
_DWORD *__thiscall sub_42B4D0(int *this, _DWORD *a2);
int __thiscall sub_42B4F0(_DWORD *this);
_DWORD *__thiscall sub_42B540(_DWORD *this);
int *__thiscall sub_42B580(int **this, int *a2, int *a3, int *a4);
_DWORD *__thiscall sub_42B630(int **this, _DWORD *a2, _DWORD *a3);
_DWORD *__thiscall sub_42B8B0(_DWORD *this, _DWORD *a2, _DWORD **a3, _DWORD **a4);
int __thiscall sub_42B920(_DWORD *this);
int __thiscall sub_42B930(_DWORD *this, int a2);
int sub_42B950();
double sub_42B960();
int __thiscall sub_42B970(_DWORD *this, _DWORD *a2);
int *__thiscall sub_42BA10(_DWORD *this, _DWORD *a2);
int __thiscall sub_42BA60(_DWORD *this, unsigned int a2);
int __thiscall sub_42BB40(int *this, unsigned int a2);
void __thiscall sub_42BC70(int *this, unsigned int a2);
int __thiscall sub_42BD50(_DWORD *this, int a2, int a3);
_DWORD *__thiscall sub_42BD70(_DWORD *this);
void __thiscall sub_42BDA0(void *this);
void *__thiscall sub_42BDC0(void *this, char a2);
void __thiscall sub_42BE00(int this, double a2, __int64 a3, int a4);
// double __usercall sub_42D210@<st0>(int a1@<ecx>, int a2@<esi>);
// double __userpurge sub_42D2D0@<st0>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, int a4, _DWORD **a5);
// void __usercall sub_42D580(int a1@<ecx>, int a2@<edi>, int a3@<esi>);
void __thiscall sub_42D7B0(char *this);
int __thiscall sub_42D810(int *this);
_DWORD *__thiscall sub_42DA20(int *this, _DWORD *a2, int *a3);
int __thiscall sub_42DA70(int this, void *a2, int a3, _DWORD *a4);
void __thiscall sub_42DB50(_BYTE *this);
void __thiscall sub_42DB60(void **this);
_DWORD *__thiscall sub_42DC20(_DWORD *this, char a2);
int __thiscall sub_42DC50(_DWORD *this, float *a2, int a3, int a4, int a5);
_DWORD *__thiscall sub_42DCC0(float *this, _DWORD *a2, int a3, float a4, float a5, float a6, float a7);
void *__thiscall sub_42DE60(_DWORD *this);
void __thiscall sub_42DE90(int this, int a2, int a3);
double __thiscall sub_42DF70(_DWORD *this);
double __fastcall sub_42DFC0(_DWORD *a1);
double __fastcall sub_42E0A0(_DWORD *a1);
double __thiscall sub_42E1A0(_DWORD *this);
double __thiscall sub_42E2C0(_DWORD *this);
double __thiscall sub_42E380(_DWORD *this);
double __thiscall sub_42E420(_DWORD *this);
int __thiscall sub_42E4B0(_DWORD *this);
void __thiscall sub_42E540(_DWORD *this, int a2);
void __thiscall sub_42E560(_DWORD *this, int a2);
int __thiscall sub_42E790(_DWORD *this, int a2, int a3);
int __thiscall sub_42E7B0(_DWORD *this, int a2);
int __thiscall sub_42E7C0(_DWORD *this, int a2);
int __thiscall sub_42E7D0(_DWORD *this, int a2, int a3, int a4);
char __thiscall sub_42E840(_BYTE *this, int a2, char *a3);
float *__thiscall sub_42E870(int this, int a2, float a3, float a4);
int __thiscall sub_42E940(_DWORD *this, int a2);
int __thiscall sub_42E960(_DWORD *this, int a2, int a3, float *a4, int a5);
int __thiscall sub_42EC30(_DWORD *this, int a2, int a3, float *a4, int a5);
int __thiscall sub_42EF70(_DWORD *this, int a2, int a3, float *a4, int a5);
void __thiscall sub_42F260(_DWORD *this, int a2, int a3, float *a4, int a5);
void __thiscall sub_42F3F0(_DWORD *this, int a2, int a3, float *a4, int a5);
double __thiscall sub_42F560(_DWORD *a1);
double __thiscall sub_42F590(_DWORD *this, int a2);
_DWORD *__thiscall sub_42F6D0(_DWORD *this, int a2);
void __thiscall sub_42F700(int this);
_DWORD *__thiscall sub_42F770(_DWORD *this, _DWORD *a2, int a3, int a4, int a5);
_DWORD *__thiscall sub_42F890(_DWORD **this);
int __thiscall sub_42F910(float *this, int a2, float a3, float a4);
_DWORD *__thiscall sub_42F970(int this);
void __thiscall sub_42FE20(unsigned __int8 *this);
int __thiscall sub_42FE90(_BYTE *this, int a2);
bool __thiscall sub_42FED0(_DWORD *this);
int __thiscall sub_42FEE0(_BYTE *this);
_DWORD *__thiscall sub_42FF30(_DWORD *this);
// unsigned int __userpurge sub_42FFB0@<eax>(int a1@<ecx>, char a2@<efl>, int a3, int a4, float *a5, float *a6);
double __thiscall sub_4302B0(int this);
void __thiscall sub_430740(_DWORD *this);
int __thiscall sub_4307F0(_DWORD *this);
// float *__userpurge sub_430850@<eax>(int a1@<ecx>, char a2@<efl>, _DWORD *a3);
// float *__userpurge sub_430BD0@<eax>(int a1@<ecx>, char a2@<efl>, _DWORD *a3);
BOOL __stdcall sub_430F50(int a1);
_DWORD *__thiscall sub_430F80(_DWORD *this, int a2, int a3, _DWORD *a4);
_DWORD *__thiscall sub_430FD0(_DWORD *this, int a2);
char __thiscall sub_431060(_BYTE *this);
int __thiscall sub_431090(int *this);
float *__thiscall sub_431170(_BYTE *this, int a2, float *a3);
double __thiscall sub_4311F0(_BYTE *this);
void __thiscall sub_431250(_DWORD *this);
void __thiscall sub_4313A0(_DWORD *this);
void __thiscall sub_431480(void *this); // idb
void __thiscall sub_4316D0(_DWORD *this);
char *__thiscall sub_4316E0(char *this, char a2);
void **__thiscall sub_431750(void **this, char a2);
int __thiscall sub_4317A0(_DWORD *this, int a2, int a3, double a4);
void *__thiscall sub_4317E0(int this, int a2);
void __thiscall sub_431850(void *this, float a2);
void __thiscall sub_431870(int this, float a2);
void __thiscall sub_431900(int this);
void __thiscall sub_431970(int this, int a2, int a3, int a4, int a5, int a6, int a7);
double __thiscall sub_431B10(int this, int a2, int a3, int a4, double a5);
double __cdecl sub_431D50(int a1, int a2, int a3, int a4);
int __thiscall sub_431D80(int this);
char __thiscall sub_431F70(int this, int a2, int a3, int a4);
int *__cdecl sub_432060(int a1, int *a2, float *a3);
void __thiscall sub_4320C0(int this);
// void __userpurge sub_432150(int a1@<ecx>, __m128d a2@<xmm5>, float a3, float a4, unsigned int a5);
void __thiscall sub_432870(_DWORD *this, float a2, float a3, int a4, int a5, int a6, int a7);
float *__thiscall sub_432B30(int *this, int a2, float *a3, float *a4);
void __fastcall sub_432D20(int a1, float a2);
char __thiscall sub_433070(_DWORD *this);
// void __userpurge sub_433090(int a1@<ecx>, __m128d a2@<xmm5>, int a3, int a4, int a5, __int64 a6, unsigned int a7);
char __thiscall sub_4330F0(_DWORD *this, int a2, int a3, int a4, float a5, float a6, double a7, char a8);
void __thiscall sub_433490(_DWORD *this, int a2, __int64 a3, int a4, int a5);
int __stdcall sub_4335C0(const __m128i *a1, int a2);
BOOL __cdecl sub_4337C0(float *a1, float *a2);
void __thiscall sub_433A80(__m128i *this, __int128 a2, __int128 a3);
void __thiscall sub_433AA0(int this, int a2, int a3, int a4);
// int __userpurge sub_433D90@<eax>(int a1@<ecx>, __m128d a2@<xmm5>, int a3);
float *__thiscall sub_434030(_DWORD *this);
void __thiscall sub_4340F0(int this);
double __thiscall sub_434290(_DWORD *this, int a2);
// void __userpurge sub_4345E0(int a1@<ecx>, int a2@<edi>, int a3@<esi>, __m128d a4@<xmm5>, int a5, int a6, int a7);
void __thiscall sub_4348C0(_DWORD *this, __int64 a2, int a3);
double __thiscall sub_434990(int this, int a2, int a3);
double __thiscall sub_434A20(int this, int a2);
double __thiscall sub_434A80(int this);
void __thiscall sub_434AE0(_DWORD *this, int a2);
_DWORD *__thiscall sub_434B20(_DWORD *this, int a2);
void __thiscall sub_434C30(void *this);
void __thiscall sub_434CA0(void *this);
void *__thiscall sub_434E70(void *this, char a2);
int __cdecl sub_434EA0(_DWORD *a1, int a2, int a3);
// void __usercall sub_435000(__m128d a1@<xmm5>, int a2, int a3, __m128i *a4, double a5, char a6);
int __cdecl sub_435200(int a1, int a2);
int __cdecl sub_4352D0(int a1, int a2, int *a3, int a4, _DWORD *a5, int a6);
int __cdecl sub_435570(int a1, int a2, int *a3);
int __cdecl sub_435770(int a1, int a2, __m128i *a3, int *a4, int *a5, int *a6, double a7);
int __cdecl sub_435A50(int a1, _DWORD *a2, int a3);
// unsigned int __usercall sub_435B20@<eax>(int a1@<edi>, int *a2, _DWORD *a3, int a4);
// int __usercall sub_435DD0@<eax>(__m128d a1@<xmm5>, int a2, _DWORD *a3);
void __cdecl sub_436030(__int64 a1, _DWORD *a2, _DWORD *a3, int *a4, double a5, double a6);
void __cdecl sub_4363E0(__int64 a1, _DWORD *a2, _DWORD *a3, int *a4);
int __cdecl main(int argc, const char **argv, const char **envp);
// int __cdecl cvResize(_DWORD, _DWORD, _DWORD); weak
// int __cdecl cvInitSubdivDelaunay2D(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl cvCreateSubdiv2D(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl cvSubdivDelaunay2DInsert(_DWORD, _DWORD, _DWORD); weak
// int __cdecl cvSmooth(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// double __cdecl cvCvtColor(_DWORD, _DWORD, _DWORD); weak
// int __cdecl cvReleaseMat(_DWORD); weak
// int __cdecl cvCreateImage(_DWORD); weak
// int __cdecl cvReleaseImage(_DWORD); weak
// int __cdecl cvCircle(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl cvSetZero(_DWORD); weak
// int __cdecl cvCreateMat(_DWORD, _DWORD, _DWORD); weak
// __int64 __cdecl cvGetSize(_DWORD); weak
// int __cdecl cvCopy(_DWORD, _DWORD, _DWORD); weak
// int __cdecl cvSVD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl cvDFT(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl cvCreateMemStorage(_DWORD); weak
// int __cdecl cvGEMM(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// double __cdecl cvInvert(_DWORD, _DWORD, _DWORD); weak
// int __cdecl cvReleaseMemStorage(_DWORD); weak
// int __cdecl cvStartReadSeq(_DWORD, _DWORD, _DWORD); weak
// int __cdecl cvChangeSeqBlock(_DWORD, _DWORD); weak
// int __cdecl cvLine(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl cvShowImage(_DWORD, _DWORD); weak
// int cvDestroyAllWindows(void); weak
// int __cdecl cvLoadImage(_DWORD, _DWORD); weak
// int __cdecl cvSaveImage(_DWORD, _DWORD, _DWORD); weak
// int __cdecl cvWaitKey(_DWORD); weak
// void *__cdecl operator new[](unsigned int); idb
// void *__cdecl operator new(unsigned int); idb
// void __cdecl operator delete(void *); idb
// int __cdecl atexit(void (__cdecl *)());
// void __fastcall __security_check_cookie(uintptr_t StackCookie);
// void __stdcall __noreturn CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD); weak
// void *__cdecl memset(void *, int Val, size_t Size);
// void __cdecl operator delete[](void *); idb
// __m128 __stdcall libm_sse2_cos_precise(_DWORD, _DWORD); weak
// __m128 libm_sse2_sin_precise(void); weak
// __m128 libm_sse2_pow_precise(void); weak
// __m128 libm_sse2_exp_precise(void); weak
// __m128 libm_sse2_log10_precise(void); weak
// __m128 __stdcall libm_sse2_log_precise(_DWORD); weak
// double __cdecl ceil(double X);
// double __cdecl floor(double X);
// void __stdcall `eh vector constructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *), void (__thiscall *)(void *)); idb
// void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *)); idb
// __m128 libm_sse2_atan_precise(void); weak
// int __stdcall __CxxUnhandledExceptionFilter(struct _EXCEPTION_POINTERS *); idb
int sub_437697();
int __cdecl UserMathErrorFunction();
void sub_4378A0();
void __cdecl sub_4378C0(); // idb
// int __cdecl _crtSetUnhandledExceptionFilter(_DWORD); weak
void __cdecl sub_438C40(); // idb
void __cdecl sub_438C50(); // idb
void __cdecl sub_438C60(); // idb
// void __thiscall std::_Container_base0::_Orphan_all(std::_Container_base0 *__hidden this); weak
// const char *__cdecl std::_Winerror_map(_DWORD); weak
// const char *__cdecl std::_Syserror_map(_DWORD); weak
// void __cdecl std::_Xout_of_range(const char *); weak
// void __cdecl __noreturn std::_Xlength_error(const char *); weak
// void __cdecl std::_Xbad_alloc(); weak

//-------------------------------------------------------------------------
// Data declarations

// extern DWORD (__stdcall *GetTickCount)();
// extern void *(__cdecl *memmove)(void *, const void *Src, size_t Size);
// extern FILE *(__cdecl *_iob_func)();
// extern int (*fprintf)(FILE *const Stream, const char *const Format, ...);
// extern int (__cdecl *rand)();
// extern void (__cdecl __noreturn *exit)(int Code);
// extern void *(__cdecl *calloc)(size_t Count, size_t Size);
// extern void (__cdecl *free)(void *Block);
// extern void *(__cdecl *malloc)(size_t Size);
// extern void *(__cdecl *realloc)(void *Block, size_t Size);
// extern int (*printf)(const char *const Format, ...);
// extern clock_t (__cdecl *clock)();
// extern double (__cdecl *atof)(const char *String);
// extern int (__cdecl *finite)(double X);
void *std::error_category::`vftable' = &sub_403610; // weak
void *CMyMatrix::`vftable' = &sub_403EA0; // weak
void *CMyTimer::`vftable' = &sub_403FA0; // weak
double qword_439340[2] = { 0.0, 4.294967296e9 }; // weak
__int128 xmmword_439410 = 0x3F1A36E2EB1C432D3F50624DD2F1A9FCi64; // weak
void *CLevmarForGCM_LineGap_LS::`vftable' = &sub_4078E0; // weak
void *CLevmarForGCM_LS::`vftable' = &sub_40C6D0; // weak
void *CLevmarForGCM_VerticalLine_LS::`vftable' = &sub_411090; // weak
__int128 xmmword_43A0E0 = 0xFFEFFFFFFFFFFFFFFFEFFFFFFFFFFFFFi64; // weak
void *DwCDelaunayTriangulation::`vftable' = &sub_4275E0; // weak
void *Expansion::`vftable' = &sub_427690; // weak
void *DwCTwoDimArray<float>::`vftable' = &sub_427560; // weak
void *DwCParagraph::`vftable' = &sub_427610; // weak
void *CConnectedAnalysis::`vftable' = &sub_4275B0; // weak
__int128 xmmword_43A210 = 4621819117588971520i64; // weak
__int128 xmmword_43A220 = 4636033603912859648i64; // weak
__int128 xmmword_43A230 = 4636244710145392640i64; // weak
__int128 xmmword_43A240 = 4637018766331346944i64; // weak
__int128 xmmword_43A250 = 4640537203540230144i64; // weak
__int128 xmmword_43A260 = 4640818678516940800i64; // weak
__int128 xmmword_43A270 = 4641416812842450944i64; // weak
__int128 xmmword_43A280 = 4643176031446892544i64; // weak
__int128 xmmword_43A290 = 0x3F8000003F8000003F8000003F800000i64; // weak
__int128 xmmword_43A2A0 = 0x402E0000000000004067A00000000000i64; // weak
__int128 xmmword_43A2B0 = 0x40340000000000004024000000000000i64; // weak
__int128 xmmword_43A2C0 = 0x40488000000000004042800000000000i64; // weak
__int128 xmmword_43A2D0 = 0x4052800000000000405A800000000000i64; // weak
__int128 xmmword_43A2E0 = 0x40580000000000004063C00000000000i64; // weak
__int128 xmmword_43A2F0 = 0x40590000000000000000000000000000i64; // weak
__int128 xmmword_43A300 = 0x405E000000000000405E000000000000i64; // weak
__int128 xmmword_43A310 = 0x40600000000000000000000000000000i64; // weak
__int128 xmmword_43A320 = 0x40620000000000004049000000000000i64; // weak
__int128 xmmword_43A330 = 0x406FE000000000004060000000000000i64; // weak
void *CCurveFit::`vftable' = &sub_42BDC0; // weak
__int128 xmmword_43A370 = 0xC2374876E800000042374876E8000000i64; // weak
void *MRF::`vftable' = &sub_42DC20; // weak
void *GCoptimization::`vftable' = &sub_427690; // weak
void *TdCTextLine::`vftable' = &sub_4316E0; // weak
void *DwCTwoDimArray<int>::`vftable' = &sub_431750; // weak
void *TdCParagraph::`vftable' = &sub_427500; // weak
__int128 xmmword_43A7A0 = 0x3FE33333333333333FE0000000000000i64; // weak
void *CLMInformation::`vftable' = &nullsub_2; // weak
void *CDocument::`vftable' = &sub_434E70; // weak
void *CLMInformation1P::`vftable' = &sub_4184D0; // weak
__int128 xmmword_43A890 = 0x3F847AE147AE147B3FA999999999999Ai64; // weak
void (*dword_43B498[2])(void) = { NULL, NULL }; // weak
void (*dword_43B4A0[2])(void) = { NULL, NULL }; // weak
int (__thiscall **off_43E000[3])(void *, char) = { &off_439248, &off_43927C, &off_4392BC }; // weak
int (__thiscall **off_43E004[2])(void *, char) = { &off_43927C, &off_4392BC }; // weak
int (__thiscall **off_43E008)(void *, char) = &off_4392BC; // weak
double qword_43E010[7] =
{
  75122.633153,
  80916.6278952,
  36308.2951477,
  8687.24529705,
  1168.92649479,
  83.8676043424,
  2.50662827511
}; // weak
float dword_43E048[10] = { 12.8, 16.0, 21.0, 25.6, 32.0, 43.0, 51.0, 64.0, 85.0, 128.0 }; // weak
float dword_43E070[14] =
{
  163.84001,
  256.0,
  441.0,
  655.36005,
  1024.0,
  1849.0,
  2601.0,
  4096.0,
  7225.0,
  16384.0,
  0.0,
  2.125,
  0.0,
  2.0
}; // weak
__int64 qword_43E0A8 = 4607182418800017408i64; // weak
__int64 qword_43E0B8 = 4600877379321698714i64; // weak
__int64 qword_43E0D0 = 4593671619917905920i64; // weak
__int64 qword_43E0E0 = 4593671619917905920i64; // weak
__int64 qword_43E0E8 = 4562254508917369340i64; // weak
double qword_43E468[100001] =
{
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  
}; // weak
int dword_501974; // weak
int dword_501978; // weak
int dword_50197C; // weak
_UNKNOWN unk_501983; // weak
int dword_50198C; // weak
void *Block; // idb
int dword_5019A8; // weak
int dword_5019B4; // weak


//----- (00401000) --------------------------------------------------------
int __cdecl sub_401000(
        void (__cdecl *a1)(int, double *, int, int, int),
        void (__cdecl *a2)(int, int, int, int, int),
        int a3,
        int a4,
        int Src,
        int a6,
        int a7,
        double *a8,
        double *a9,
        double *Block,
        double *a11,
        int a12)
{
  FILE *v13; // eax
  FILE *v15; // eax
  double v16; // st7
  double *v17; // ebx
  double v18; // st7
  double v19; // st6
  double v20; // rt0
  int v21; // edi
  int v22; // eax
  double i; // st7
  int j; // eax
  double *v25; // edi
  int v26; // ebx
  char *v27; // edx
  double v28; // st6
  int v29; // ecx
  double *v30; // eax
  double v31; // st5
  bool v32; // zf
  int v33; // eax
  int v34; // edx
  int v35; // ecx
  int v36; // edi
  int v37; // ebx
  int v38; // ebx
  int v39; // edi
  double *v40; // edx
  int v41; // ecx
  unsigned int v42; // eax
  double v43; // st6
  double v44; // st6
  double v45; // st6
  double v46; // st6
  double *v47; // edx
  double *v48; // ebx
  char *v49; // eax
  double *v50; // edx
  int v51; // ecx
  int v52; // edi
  double v53; // st7
  int v54; // ebx
  int v55; // ecx
  double *v56; // eax
  unsigned int v57; // edx
  double v58; // st6
  double *v59; // eax
  char *v60; // ecx
  double v61; // st6
  double v62; // st6
  int v63; // edx
  double v64; // st5
  double *v65; // edi
  int v66; // ecx
  double *v67; // ebx
  double v68; // rt1
  double v69; // st5
  double v70; // st7
  double v71; // st4
  double v72; // st7
  double v73; // st4
  double v74; // st7
  double v75; // st4
  double v76; // st7
  double v77; // st4
  double v78; // rt2
  double v79; // rtt
  double v80; // st5
  double v81; // st6
  double *v82; // ecx
  double *v83; // edi
  char *v84; // ebx
  double v85; // rt1
  double v86; // rt2
  double v87; // st5
  double v88; // st7
  double v89; // st4
  double v90; // st4
  double v91; // st6
  double v92; // st7
  int v93; // edi
  unsigned int v94; // edx
  double *v95; // ecx
  double v96; // st7
  int v97; // edi
  double *v98; // edi
  int v99; // eax
  double *v100; // ecx
  unsigned int v101; // edx
  double *v102; // ebx
  double *v103; // ebx
  double *v104; // eax
  char *v105; // ecx
  char *v106; // edi
  double v107; // st7
  int v108; // edx
  int v109; // ecx
  int v110; // eax
  double v111; // st6
  double v112; // st5
  double v113; // st7
  double v114; // st6
  double v115; // st7
  double v116; // st6
  double v117; // st7
  double v118; // st6
  int v119; // eax
  char *v120; // ecx
  double v121; // st6
  int v122; // ebx
  double v123; // st6
  double *v124; // ecx
  unsigned int v125; // edx
  char *v126; // eax
  double v127; // st4
  double *v128; // eax
  char *v129; // ecx
  double v130; // st4
  double v131; // st4
  double v132; // st7
  int v133; // eax
  double *v134; // edx
  int v135; // eax
  double *v136; // ecx
  unsigned int v137; // edi
  double *v138; // ebx
  double *v139; // ebx
  double *v140; // ebx
  double v141; // st6
  double *v142; // ecx
  double v143; // st6
  double v144; // st6
  double v145; // st7
  int v146; // ebx
  double v147; // st6
  int v148; // eax
  int v149; // ecx
  unsigned int v150; // edx
  int v151; // eax
  char *v152; // ecx
  double v153; // st5
  int v154; // edx
  int v155; // ebx
  int v156; // ecx
  unsigned int v157; // edx
  double *v158; // eax
  double *v159; // eax
  int v160; // ecx
  double v161; // st5
  double v162; // st5
  double v163; // rt0
  double v164; // st5
  double v165; // st5
  double v166; // rt2
  int v167; // ecx
  double *v168; // edx
  int v169; // eax
  double *v170; // ecx
  unsigned int v171; // edi
  double *v172; // ebx
  double *v173; // ebx
  double *v174; // ebx
  double v175; // st4
  int v176; // ebx
  double *v177; // eax
  double v178; // st4
  double v179; // st6
  int v180; // ecx
  double *v181; // edi
  unsigned int v182; // edx
  double *v183; // ecx
  char *v184; // edx
  const char *X_4; // [esp+Ch] [ebp-D0h]
  double v186; // [esp+1Ch] [ebp-C0h]
  double v187; // [esp+24h] [ebp-B8h]
  double v188; // [esp+2Ch] [ebp-B0h]
  double v189; // [esp+34h] [ebp-A8h]
  double v190; // [esp+3Ch] [ebp-A0h]
  double v191; // [esp+44h] [ebp-98h]
  double X; // [esp+4Ch] [ebp-90h]
  int v193; // [esp+54h] [ebp-88h]
  int v194; // [esp+58h] [ebp-84h]
  int (__cdecl *v195)(void *, void *, char *, int); // [esp+5Ch] [ebp-80h]
  int v196; // [esp+60h] [ebp-7Ch]
  int v197; // [esp+64h] [ebp-78h]
  int v198; // [esp+68h] [ebp-74h]
  int v199; // [esp+6Ch] [ebp-70h]
  double v200; // [esp+70h] [ebp-6Ch]
  int v201; // [esp+74h] [ebp-68h]
  int v202; // [esp+78h] [ebp-64h]
  double v203; // [esp+7Ch] [ebp-60h]
  double v204; // [esp+84h] [ebp-58h]
  int v205; // [esp+88h] [ebp-54h]
  int v206; // [esp+8Ch] [ebp-50h]
  double v207; // [esp+90h] [ebp-4Ch]
  int v208; // [esp+98h] [ebp-44h]
  double *v209; // [esp+98h] [ebp-44h]
  double v210; // [esp+9Ch] [ebp-40h]
  int v211; // [esp+A0h] [ebp-3Ch]
  int v212; // [esp+A0h] [ebp-3Ch]
  double *v213; // [esp+A0h] [ebp-3Ch]
  int v214; // [esp+A4h] [ebp-38h]
  int v215; // [esp+A8h] [ebp-34h]
  double *v216; // [esp+A8h] [ebp-34h]
  char *v217; // [esp+B0h] [ebp-2Ch]
  double *v218; // [esp+B0h] [ebp-2Ch]
  int v219; // [esp+B4h] [ebp-28h]
  double *v220; // [esp+B4h] [ebp-28h]
  int v221; // [esp+B8h] [ebp-24h]
  char *v222; // [esp+BCh] [ebp-20h]
  int v223; // [esp+BCh] [ebp-20h]
  char *v224; // [esp+C0h] [ebp-1Ch]
  double *v225; // [esp+C4h] [ebp-18h]
  double *v226; // [esp+C8h] [ebp-14h]
  double *v227; // [esp+C8h] [ebp-14h]
  double *v228; // [esp+C8h] [ebp-14h]
  int v229; // [esp+CCh] [ebp-10h]
  double *v230; // [esp+CCh] [ebp-10h]
  int v231; // [esp+D0h] [ebp-Ch]
  double *v232; // [esp+D0h] [ebp-Ch]
  double *v233; // [esp+D0h] [ebp-Ch]
  double *v234; // [esp+D0h] [ebp-Ch]
  int v235; // [esp+D0h] [ebp-Ch]
  double *v236; // [esp+D0h] [ebp-Ch]
  int v237; // [esp+D4h] [ebp-8h]
  int v238; // [esp+D4h] [ebp-8h]
  int v239; // [esp+D4h] [ebp-8h]
  int v240; // [esp+D4h] [ebp-8h]
  int v241; // [esp+D4h] [ebp-8h]
  int v242; // [esp+D4h] [ebp-8h]
  int v243; // [esp+D4h] [ebp-8h]
  int v244; // [esp+D4h] [ebp-8h]
  int v245; // [esp+D8h] [ebp-4h]
  int v246; // [esp+D8h] [ebp-4h]
  double *v247; // [esp+D8h] [ebp-4h]
  int v248; // [esp+D8h] [ebp-4h]
  double *v249; // [esp+D8h] [ebp-4h]
  int v250; // [esp+D8h] [ebp-4h]
  double *Srca; // [esp+F4h] [ebp+18h]

  v203 = 1.797693134862316e308;
  v204 = 0.0;
  v207 = 0.0;
  v193 = 0;
  v219 = 2;
  v221 = 0;
  v202 = 0;
  v196 = 0;
  v198 = a6 * Src;
  v195 = 0;
  if ( a6 < Src )
  {
    v13 = _iob_func();
    fprintf(v13 + 2, "dlevmar_der(): cannot solve a problem with fewer measurements [%d] than unknowns [%d]\n", a6, Src);
    return -1;
  }
  if ( !a2 )
  {
    X_4 = "No function specified for computing the Jacobian in dlevmar_der().\n"
          "If no such function is available, use dlevmar_dif() rather than dlevmar_der()\n";
LABEL_6:
    v15 = _iob_func();
    fprintf(v15 + 2, X_4);
    return -1;
  }
  if ( a8 )
  {
    v187 = *a8;
    v191 = a8[1];
    v188 = a8[2];
    v190 = v188 * v188;
    v16 = a8[3];
  }
  else
  {
    v187 = 0.001;
    v16 = 1.0e-17;
    v191 = 1.0e-17;
    v188 = 1.0e-17;
    v190 = 1.0e-34;
  }
  v189 = v16;
  if ( !Block )
  {
    Block = (double *)malloc(8 * (Src * (Src + a6 + 4) + 2 * a6));
    if ( !Block )
    {
      X_4 = "dlevmar_der(): memory allocation request failed\n";
      goto LABEL_6;
    }
    v193 = 1;
  }
  v17 = &Block[a6];
  v225 = &v17[a6];
  v199 = (int)&v225[Src];
  v194 = Src * Src;
  v217 = (char *)(v199 + 8 * v198 + 8 * Src * Src);
  v224 = &v217[8 * Src];
  Srca = (double *)(v199 + 8 * v198);
  v215 = (int)v17;
  v214 = (int)&v217[8 * Src + 8 * Src];
  a1(a3, v17, Src, a6, a12);
  v197 = 1;
  X = sub_402A70((int)Block, a4, (int)v17, a6);
  v186 = X;
  if ( !finite(X) )
    v221 = 7;
  v206 = 0;
  if ( a7 <= 0 )
  {
    v19 = 1.797693134862316e308;
    v164 = 0.0;
    v18 = 0.0;
    goto LABEL_183;
  }
  v18 = 0.0;
  v19 = 1.797693134862316e308;
LABEL_19:
  if ( v221 )
    goto LABEL_178;
  if ( v189 >= X )
  {
    v221 = 6;
LABEL_178:
    v164 = v204;
    goto LABEL_180;
  }
  v21 = a6;
  a2(a3, v199, Src, a6, a12);
  ++v202;
  if ( v198 >= 1024 )
  {
    sub_401EB0(v199, Srca, a6, Src);
    v50 = v225;
    if ( Src > 0 )
    {
      memset(v225, 0, 8 * Src);
      v21 = a6;
    }
    v51 = 0;
    v239 = 0;
    if ( v21 > 0 )
    {
      v52 = v199 - (_DWORD)v225;
      do
      {
        v53 = Block[v51];
        v54 = 0;
        if ( Src >= 4 )
        {
          v55 = (int)v50 + v52 + 24;
          v56 = v50 + 1;
          v57 = ((unsigned int)(Src - 4) >> 2) + 1;
          v54 = 4 * v57;
          do
          {
            v56 += 4;
            v58 = *(double *)(v55 - 24) * v53;
            v55 += 32;
            --v57;
            *(v56 - 5) = v58 + *(v56 - 5);
            *(v56 - 4) = *(double *)((char *)v56 + v52 - 32) * v53 + *(v56 - 4);
            *(v56 - 3) = *(double *)(v55 - 40) * v53 + *(v56 - 3);
            *(v56 - 2) = *(double *)(v55 - 32) * v53 + *(v56 - 2);
          }
          while ( v57 );
          v50 = v225;
        }
        if ( v54 < Src )
        {
          v59 = &v50[v54];
          v60 = (char *)(Src - v54);
          do
          {
            v61 = *(double *)((char *)v59++ + v52);
            --v60;
            *(v59 - 1) = v61 * v53 + *(v59 - 1);
          }
          while ( v60 );
        }
        v51 = v239 + 1;
        v52 += 8 * Src;
        v239 = v51;
      }
      while ( v51 < a6 );
    }
    i = 0.0;
  }
  else
  {
    v22 = v194;
    for ( i = 0.0; v22 > 0; Srca[v22] = 0.0 )
      --v22;
    for ( j = Src; j > 0; v225[j] = 0.0 )
      --j;
    v237 = a6;
    if ( a6 > 0 )
    {
      v245 = -8 * Src;
      v229 = v199 + 8 * v198 - 8;
      v208 = 8 * Src * (a6 - Src) - 8 * v198;
      do
      {
        --v237;
        v208 += v245;
        v229 += v245;
        if ( Src > 0 )
        {
          v25 = (double *)v199;
          v26 = 8 - (_DWORD)v225;
          v27 = (char *)(Src + 1);
          v222 = v217;
          v211 = v208;
          v231 = Src;
          do
          {
            v222 += v245;
            v211 += 8 * Src;
            --v25;
            --v27;
            v28 = *(double *)((char *)v25 + v26 + v229);
            v29 = (int)v27;
            if ( (int)v27 > 0 )
            {
              v30 = (double *)((int)v25 + v26 + (_DWORD)v222);
              do
              {
                v31 = *(double *)((char *)v30-- + v211 - 8);
                --v29;
                *v30 = v31 * v28 + *v30;
              }
              while ( v29 > 0 );
              v26 = 8 - (_DWORD)v225;
            }
            v32 = v231-- == 1;
            *v25 = v28 * Block[v237] + *v25;
          }
          while ( !v32 );
        }
      }
      while ( v237 > 0 );
    }
    v33 = Src;
    if ( Src > 0 )
    {
      v34 = v194;
      v223 = Src * (Src + 2);
      v212 = Src * (Src + 3);
      v35 = -Src;
      v36 = Src * (Src + 4);
      v37 = -1;
      while ( 1 )
      {
        v212 += v35;
        v223 += v35;
        --v33;
        v205 = v35 + v36;
        v38 = v37 + 1;
        v34 += v35;
        v39 = v33 + 1;
        v238 = v33;
        v201 = v38;
        v246 = v34;
        if ( v33 + 1 < Src )
        {
          if ( v38 >= 4 )
          {
            v40 = &Srca[v39 + 2 + v34];
            v230 = &Srca[Src + v33 + v246];
            v232 = &Srca[v33 + v205];
            v41 = 32 * Src;
            v226 = &Srca[v33 + v212];
            v209 = &Srca[v33 + v223];
            v42 = ((unsigned int)(Src - v39 - 4) >> 2) + 1;
            v39 += 4 * v42;
            do
            {
              v43 = *v230;
              v230 = (double *)((char *)v230 + v41);
              *(v40 - 2) = v43;
              v44 = *v209;
              v209 = (double *)((char *)v209 + v41);
              *(v40 - 1) = v44;
              v45 = *v226;
              v226 = (double *)((char *)v226 + v41);
              *v40 = v45;
              v46 = *v232;
              v232 = (double *)((char *)v232 + v41);
              v40[1] = v46;
              v40 += 4;
              --v42;
            }
            while ( v42 );
            v35 = -Src;
            v34 = v246;
            v33 = v238;
          }
          if ( v39 < Src )
          {
            v47 = &Srca[v39 + v34];
            v48 = &Srca[v33 + Src * v39];
            v49 = (char *)(Src - v39);
            do
            {
              *v47++ = *v48;
              v48 += Src;
              --v49;
            }
            while ( v49 );
            v33 = v238;
            v34 = v246;
          }
        }
        if ( v33 <= 0 )
          break;
        v37 = v201;
        v36 = v205;
      }
    }
  }
  v62 = i;
  v63 = 0;
  v204 = i;
  v64 = i;
  v210 = i;
  if ( Src < 4 )
  {
    v80 = i;
    v81 = i;
  }
  else
  {
    v213 = &Srca[3 * Src + 3];
    v227 = &Srca[2 * Src + 2];
    v233 = &Srca[Src + 1];
    v247 = (double *)(v199 + 8 * v198);
    v65 = v225 + 1;
    v66 = 32 * (Src + 1);
    v67 = (double *)(a3 + 16);
    do
    {
      v68 = v64;
      v69 = i;
      v70 = v68;
      v71 = *(v65 - 1);
      if ( v69 > v71 )
        v71 = -v71;
      if ( v71 > v62 )
        v62 = v71;
      *(double *)&v224[8 * v63] = *v247;
      v72 = v70 + *(v67 - 2) * *(v67 - 2);
      v73 = *v65;
      if ( v69 > v73 )
        v73 = -v73;
      if ( v73 > v62 )
        v62 = v73;
      *(double *)((char *)v65 + v224 - (char *)v225) = *v233;
      v74 = v72 + *(double *)((char *)v65 + a3 - (_DWORD)v225) * *(double *)((char *)v65 + a3 - (_DWORD)v225);
      v75 = v65[1];
      if ( v69 > v75 )
        v75 = -v75;
      if ( v75 > v62 )
        v62 = v75;
      *(double *)&v224[(_DWORD)v67 - a3] = *v227;
      v76 = v74 + *v67 * *v67;
      v77 = v65[2];
      if ( v69 > v77 )
        v77 = -v77;
      if ( v77 > v62 )
        v62 = v77;
      v247 = (double *)((char *)v247 + v66);
      *(double *)&v224[8 * v63 + 24] = *v213;
      v233 = (double *)((char *)v233 + v66);
      v227 = (double *)((char *)v227 + v66);
      v213 = (double *)((char *)v213 + v66);
      v63 += 4;
      v65 += 4;
      v78 = v69;
      v64 = v76 + v67[1] * v67[1];
      i = v78;
      v67 += 4;
    }
    while ( v63 < Src - 3 );
    v210 = v64;
    v79 = v64;
    v80 = v62;
    v81 = v79;
    v204 = v80;
  }
  if ( v63 >= Src )
  {
    v91 = v80;
  }
  else
  {
    v82 = (double *)((char *)Srca + v63 * (8 * Src + 8));
    v83 = &v225[v63];
    v84 = (char *)(Src - v63);
    while ( 1 )
    {
      v86 = v80;
      v87 = i;
      v88 = v86;
      v89 = *v83;
      if ( v87 > v89 )
        v89 = -v89;
      if ( v89 > v88 )
        v88 = v89;
      *(double *)((char *)v83 + v224 - (char *)v225) = *v82;
      v82 += Src + 1;
      v90 = *(double *)((char *)v83 + a3 - (_DWORD)v225) * *(double *)((char *)v83 + a3 - (_DWORD)v225);
      ++v83;
      --v84;
      v81 = v81 + v90;
      if ( !v84 )
        break;
      v85 = v87;
      v80 = v88;
      i = v85;
    }
    v210 = v81;
    v91 = v88;
    i = v87;
    v204 = v91;
  }
  if ( v191 < v91 )
  {
    if ( v206 )
    {
      v96 = v207;
    }
    else
    {
      v92 = -1.797693134862316e308;
      v93 = 0;
      if ( Src >= 4 )
      {
        v94 = ((unsigned int)(Src - 4) >> 2) + 1;
        v95 = (double *)(v224 + 16);
        v93 = 4 * v94;
        do
        {
          if ( v92 < *(v95 - 2) )
            v92 = *(v95 - 2);
          if ( v92 < *(v95 - 1) )
            v92 = *(v95 - 1);
          if ( v92 < *v95 )
            v92 = *v95;
          if ( v92 < v95[1] )
            v92 = v95[1];
          v95 += 4;
          --v94;
        }
        while ( v94 );
      }
      for ( ; v93 < Src; ++v93 )
      {
        if ( v92 < *(double *)&v224[8 * v93] )
          v92 = *(double *)&v224[8 * v93];
      }
      v96 = v92 * v187;
      v207 = v96;
    }
    v195 = sub_402D90;
    while ( 1 )
    {
      v97 = 0;
      if ( Src >= 4 )
      {
        v98 = (double *)(v199 + 8 * v198);
        v234 = &Srca[3 * Src + 3];
        v248 = (int)&Srca[Src + 1];
        v99 = 32 * (Src + 1);
        v100 = &Srca[2 * Src + 2];
        v101 = ((unsigned int)(Src - 4) >> 2) + 1;
        v240 = 4 * v101;
        do
        {
          v102 = (double *)v248;
          v248 += v99;
          *v98 = v96 + *v98;
          v98 = (double *)((char *)v98 + v99);
          *v102 = *v102 + v96;
          v103 = v234;
          v234 = (double *)((char *)v234 + v99);
          *v100 = v96 + *v100;
          v100 = (double *)((char *)v100 + v99);
          --v101;
          *v103 = *v103 + v96;
        }
        while ( v101 );
        v97 = v240;
      }
      if ( v97 < Src )
      {
        v104 = (double *)((char *)Srca + v97 * (8 * Src + 8));
        v105 = (char *)(Src - v97);
        do
        {
          *v104 = v96 + *v104;
          v104 += Src + 1;
          --v105;
        }
        while ( v105 );
      }
      v106 = v217;
      ++v196;
      if ( sub_402D90(Srca, v225, v217, Src) )
      {
        v107 = 0.0;
        v108 = 0;
        v203 = 0.0;
        if ( Src >= 4 )
        {
          v109 = v214 + 16;
          v110 = a3 + 8;
          v106 = v217;
          do
          {
            v111 = *(double *)&v217[8 * v108];
            v108 += 4;
            v112 = *(double *)(v110 - 8) + v111;
            v110 += 32;
            v109 += 32;
            *(double *)(v109 - 48) = v112;
            v113 = v107 + v111 * v111;
            v114 = *(double *)&v217[v110 - a3 - 32];
            *(double *)(v214 - a3 + v110 - 32) = v114 + *(double *)(v110 - 32);
            v115 = v113 + v114 * v114;
            v116 = *(double *)(-16 * Src + v109 - 32);
            *(double *)(v109 - 32) = *(double *)(v110 - 24) + v116;
            v117 = v115 + v116 * v116;
            v118 = *(double *)&v217[8 * v108 - 8];
            *(double *)(v109 - 24) = *(double *)(v110 - 16) + v118;
            v107 = v117 + v118 * v118;
          }
          while ( v108 < Src - 3 );
          v203 = v107;
        }
        if ( v108 < Src )
        {
          v119 = a3 + 8 * v108;
          v120 = (char *)(Src - v108);
          do
          {
            v121 = *(double *)&v106[v119 - a3];
            v119 += 8;
            --v120;
            *(double *)(v214 - a3 + v119 - 8) = v121 + *(double *)(v119 - 8);
            v107 = v107 + v121 * v121;
          }
          while ( v120 );
          v203 = v107;
        }
        if ( v190 * v210 >= v107 )
        {
          v221 = 2;
          v144 = v207;
          goto LABEL_175;
        }
        if ( (v210 + v188) / 9.999999999999999e-25 <= v107 )
        {
          v144 = v207;
          v221 = 4;
          goto LABEL_175;
        }
        a1(v214, (double *)v215, Src, a6, a12);
        ++v197;
        v200 = sub_402A70(v215, a4, v215, a6);
        if ( !finite(v200) )
        {
          v96 = v207;
          v221 = 7;
          goto LABEL_174;
        }
        v122 = 0;
        v123 = 0.0;
        if ( Src >= 4 )
        {
          v124 = v225 + 3;
          v125 = ((unsigned int)(Src - 4) >> 2) + 1;
          v241 = 4 * v125;
          v126 = v106 + 8;
          do
          {
            v127 = *((double *)v126 - 1);
            v126 += 32;
            v124 += 4;
            --v125;
            v123 = v123
                 + (v127 * v207 + *(v124 - 7)) * *((double *)v126 - 5)
                 + (*((double *)v126 - 4) * v207 + *(double *)&v126[(char *)v225 - v106 - 32]) * *((double *)v126 - 4)
                 + (*((double *)v126 - 3) * v207 + *(v124 - 5)) * *((double *)v126 - 3)
                 + (*((double *)v126 - 2) * v207 + *(v124 - 4)) * *((double *)v126 - 2);
          }
          while ( v125 );
          v122 = v241;
        }
        if ( v122 < Src )
        {
          v128 = (double *)&v106[8 * v122];
          v129 = (char *)(Src - v122);
          do
          {
            v130 = *v128++;
            --v129;
            v123 = v123 + (v130 * v207 + *(double *)((char *)v128 + (char *)v225 - v106 - 8)) * *(v128 - 1);
          }
          while ( v129 );
        }
        v131 = X - v200;
        if ( v123 > 0.0 && v131 > 0.0 )
        {
          v145 = 1.0 - ((v131 + v131) / v123 - 1.0) * (((v131 + v131) / v123 - 1.0) * ((v131 + v131) / v123 - 1.0));
          if ( v145 < 0.3333333334 )
            v145 = 0.3333333334;
          v146 = 0;
          v147 = v145 * v207;
          v219 = 2;
          v207 = v147;
          if ( Src >= 4 )
          {
            v148 = a3 + 8;
            v149 = v214 + 24;
            v150 = ((unsigned int)(Src - 4) >> 2) + 1;
            v146 = 4 * v150;
            do
            {
              v148 += 32;
              *(double *)(v148 - 40) = *(double *)(v149 - 24);
              v149 += 32;
              --v150;
              *(double *)(v148 - 32) = *(double *)(v214 - a3 + v148 - 32);
              *(double *)(v148 - 24) = *(double *)(v149 - 40);
              *(double *)(v148 - 16) = *(double *)(v149 - 32);
            }
            while ( v150 );
          }
          if ( v146 < Src )
          {
            v151 = a3 + 8 * v146;
            v152 = (char *)(Src - v146);
            do
            {
              v153 = *(double *)(v214 - a3 + v151);
              v151 += 8;
              --v152;
              *(double *)(v151 - 8) = v153;
            }
            while ( v152 );
          }
          v154 = a6;
          v155 = 0;
          if ( a6 >= 4 )
          {
            v156 = v215 + 24;
            v157 = ((unsigned int)(a6 - 4) >> 2) + 1;
            v158 = Block + 1;
            v155 = 4 * v157;
            do
            {
              v158 += 4;
              *(v158 - 5) = *(double *)(v156 - 24);
              v156 += 32;
              --v157;
              *(v158 - 4) = v158[a6 - 4];
              *(v158 - 3) = *(double *)(v156 - 40);
              *(v158 - 2) = *(double *)(v156 - 32);
            }
            while ( v157 );
            v154 = a6;
          }
          if ( v155 < v154 )
          {
            v159 = &Block[v155];
            v160 = v154 - v155;
            do
            {
              v161 = v159[a6];
              ++v159;
              --v160;
              *(v159 - 1) = v161;
            }
            while ( v160 );
          }
          v96 = v147;
          X = v200;
LABEL_174:
          v144 = v96;
          v107 = v203;
LABEL_175:
          if ( ++v206 >= a7 )
          {
            v162 = v107;
            v18 = v144;
            v163 = v162;
            v164 = v204;
            v19 = v163;
            goto LABEL_183;
          }
          v20 = v144;
          v19 = v107;
          v18 = v20;
          goto LABEL_19;
        }
        v132 = v207;
      }
      else
      {
        v132 = v207;
      }
      v96 = v132 * (double)v219;
      v207 = v96;
      if ( 2 * v219 <= v219 )
      {
        v221 = 5;
        goto LABEL_174;
      }
      v219 *= 2;
      v133 = 0;
      if ( Src >= 4 )
      {
        v228 = &Srca[3 * Src + 3];
        v249 = (double *)(v199 + 8 * v198);
        v134 = &Srca[2 * Src + 2];
        v235 = (int)&Srca[Src + 1];
        v135 = 32 * (Src + 1);
        v136 = (double *)(v224 + 16);
        v137 = ((unsigned int)(Src - 4) >> 2) + 1;
        v242 = 4 * v137;
        do
        {
          v138 = v249;
          v249 = (double *)((char *)v249 + v135);
          *v138 = *(v136 - 2);
          v139 = (double *)v235;
          v235 += v135;
          *v139 = *(v136 - 1);
          v140 = v228;
          v228 = (double *)((char *)v228 + v135);
          *v134 = *v136;
          v141 = v136[1];
          v134 = (double *)((char *)v134 + v135);
          v136 += 4;
          *v140 = v141;
          --v137;
        }
        while ( v137 );
        v133 = v242;
      }
      if ( v133 < Src )
      {
        v142 = (double *)((char *)Srca + v133 * (8 * Src + 8));
        do
        {
          v143 = *(double *)&v224[8 * v133++];
          *v142 = v143;
          v142 += Src + 1;
        }
        while ( v133 < Src );
      }
    }
  }
  v221 = 1;
  v165 = i;
  v18 = v207;
  v166 = v165;
  v164 = v91;
  v19 = v166;
LABEL_180:
  if ( v206 >= a7 )
LABEL_183:
    v221 = 3;
  v167 = 0;
  if ( Src >= 4 )
  {
    v236 = &Srca[3 * Src + 3];
    v216 = (double *)(v199 + 8 * v198);
    v168 = &Srca[2 * Src + 2];
    v250 = (int)&Srca[Src + 1];
    v169 = 32 * (Src + 1);
    v170 = (double *)(v224 + 16);
    v171 = ((unsigned int)(Src - 4) >> 2) + 1;
    v243 = 4 * v171;
    do
    {
      v172 = v216;
      v216 = (double *)((char *)v216 + v169);
      *v172 = *(v170 - 2);
      v173 = (double *)v250;
      v250 += v169;
      *v173 = *(v170 - 1);
      v174 = v236;
      v236 = (double *)((char *)v236 + v169);
      *v168 = *v170;
      v175 = v170[1];
      v168 = (double *)((char *)v168 + v169);
      v170 += 4;
      *v174 = v175;
      --v171;
    }
    while ( v171 );
    v167 = v243;
  }
  v176 = v199 + 8 * v198;
  if ( v167 < Src )
  {
    v177 = (double *)((char *)Srca + v167 * (8 * Src + 8));
    do
    {
      v178 = *(double *)&v224[8 * v167++];
      *v177 = v178;
      v177 += Src + 1;
    }
    while ( v167 < Src );
  }
  if ( a9 )
  {
    v244 = 0;
    *a9 = v186;
    a9[1] = X;
    a9[2] = v164;
    a9[3] = v19;
    v179 = -1.797693134862316e308;
    if ( Src >= 4 )
    {
      v218 = &Srca[3 * Src + 3];
      v180 = 32 * (Src + 1);
      v181 = &Srca[2 * Src + 2];
      v182 = ((unsigned int)(Src - 4) >> 2) + 1;
      v220 = &Srca[Src + 1];
      v244 = 4 * v182;
      do
      {
        if ( v179 < *Srca )
          v179 = *Srca;
        if ( v179 < *v220 )
          v179 = *v220;
        if ( v179 < *v181 )
          v179 = *v181;
        if ( v179 < *v218 )
          v179 = *v218;
        Srca = (double *)((char *)Srca + v180);
        v220 = (double *)((char *)v220 + v180);
        v218 = (double *)((char *)v218 + v180);
        v181 = (double *)((char *)v181 + v180);
        --v182;
      }
      while ( v182 );
    }
    if ( v244 < Src )
    {
      v183 = (double *)(v176 + v244 * (8 * Src + 8));
      v184 = (char *)(Src - v244);
      do
      {
        if ( v179 < *v183 )
          v179 = *v183;
        v183 += Src + 1;
        --v184;
      }
      while ( v184 );
    }
    a9[4] = v18 / v179;
    a9[5] = (double)v206;
    a9[6] = (double)v221;
    a9[7] = (double)v197;
    a9[8] = (double)v202;
    a9[9] = (double)v196;
  }
  if ( a11 )
    sub_4029D0(v176, a11, X, Src, a6);
  if ( v193 )
    free(Block);
  if ( v195 )
    v195(0, 0, 0, 0);
  if ( v221 == 4 || v221 == 7 )
    return -1;
  return v206;
}

//----- (00401EB0) --------------------------------------------------------
void __cdecl sub_401EB0(int a1, double *a2, int a3, int a4)
{
  int v4; // ebx
  int v5; // edi
  double *v6; // esi
  int j; // edx
  int v8; // ecx
  int v9; // eax
  int v10; // ecx
  int v11; // edx
  int v12; // esi
  int v13; // eax
  double v14; // st6
  int v15; // edi
  int v16; // eax
  int v17; // edx
  bool v18; // cc
  double v19; // st5
  double v20; // st6
  int v21; // esi
  double *v22; // ecx
  int v23; // edi
  double *v24; // edi
  int v25; // eax
  unsigned int v26; // edx
  double *v27; // ebx
  double v28; // st7
  double *v29; // ebx
  double v30; // st7
  double *v31; // ebx
  double *v32; // ecx
  double *v33; // edx
  int v34; // eax
  int v35; // [esp+Ch] [ebp-20h]
  double *v36; // [esp+10h] [ebp-1Ch]
  int k; // [esp+14h] [ebp-18h]
  int v38; // [esp+14h] [ebp-18h]
  int i; // [esp+18h] [ebp-14h]
  double *v40; // [esp+18h] [ebp-14h]
  double *v41; // [esp+1Ch] [ebp-10h]
  double *v42; // [esp+20h] [ebp-Ch]
  double *v43; // [esp+24h] [ebp-8h]
  double *v44; // [esp+24h] [ebp-8h]
  int v45; // [esp+28h] [ebp-4h]
  double *v46; // [esp+28h] [ebp-4h]

  v4 = a4;
  v5 = 0;
  for ( i = 0; v5 < a4; i = v5 )
  {
    v6 = a2;
    for ( j = 0; j < a4; ++j )
    {
      v8 = v5;
      if ( v5 < j )
        v8 = j;
      while ( 1 )
      {
        v9 = v5 + 32;
        if ( v5 + 32 > a4 )
          v9 = a4;
        if ( v8 >= v9 )
          break;
        v6[v8++] = 0.0;
      }
      v6 += a4;
    }
    v10 = 0;
    for ( k = 0; v10 < a3; k = v10 )
    {
      v11 = 0;
      v45 = 0;
      v43 = a2;
      do
      {
        v12 = v5;
        if ( v5 < v11 )
          v12 = v11;
        while ( 1 )
        {
          v13 = v5 + 32;
          if ( v5 + 32 > a4 )
            v13 = a4;
          if ( v12 >= v13 )
            break;
          v14 = 0.0;
          v15 = v10 + 32;
          v16 = a1 + 8 * a4 * v10;
          while ( 1 )
          {
            v17 = v15;
            if ( v15 > a3 )
              v17 = a3;
            v18 = v10 < v17;
            v11 = v45;
            if ( !v18 )
              break;
            ++v10;
            v19 = *(double *)(v16 + 8 * v12) * *(double *)(v16 + 8 * v45);
            v16 += 8 * a4;
            v14 = v14 + v19;
          }
          v20 = v14 + v43[v12];
          v10 = k;
          v5 = i;
          v43[v12++] = v20;
        }
        ++v11;
        v43 += a4;
        v45 = v11;
      }
      while ( v11 < a4 );
      v10 += 32;
    }
    v5 += 32;
  }
  v21 = 0;
  if ( a4 > 0 )
  {
    v40 = &a2[a4];
    v38 = 0;
    v41 = a2;
    v22 = a2;
    v36 = a2;
    do
    {
      v23 = 0;
      if ( v21 >= 4 )
      {
        v24 = v41;
        v42 = &a2[2 * v4 + v4 + v21];
        v46 = &a2[2 * a4 + v21];
        v44 = v40;
        v25 = 32 * v4;
        v26 = ((unsigned int)(v21 - 4) >> 2) + 1;
        v35 = 4 * v26;
        do
        {
          v27 = v44;
          v44 = (double *)((char *)v44 + v25);
          *v22 = *v24;
          v28 = *v27;
          v29 = v46;
          v46 = (double *)((char *)v46 + v25);
          v22[1] = v28;
          v30 = *v29;
          v31 = v42;
          v42 = (double *)((char *)v42 + v25);
          v22[2] = v30;
          v22 += 4;
          *(v22 - 1) = *v31;
          v24 = (double *)((char *)v24 + v25);
          --v26;
        }
        while ( v26 );
        v4 = a4;
        v23 = v35;
      }
      if ( v23 < v21 )
      {
        v32 = &a2[v23 + v38];
        v33 = &a2[v21 + v4 * v23];
        v34 = v21 - v23;
        do
        {
          *v32++ = *v33;
          v33 += v4;
          --v34;
        }
        while ( v34 );
      }
      v38 += v4;
      ++v41;
      ++v40;
      ++v21;
      v22 = &v36[v4];
      v36 = v22;
    }
    while ( v21 < v4 );
  }
}

//----- (004020A0) --------------------------------------------------------
int __usercall sub_4020A0@<eax>(int a1@<esi>, int a2, double *a3)
{
  int v3; // edi
  double *v4; // eax
  double *v5; // ebx
  FILE *v6; // eax
  int v8; // ecx
  int v9; // ecx
  double *v10; // eax
  bool v11; // zf
  double *v12; // eax
  int v13; // edi
  double v14; // st7
  double v15; // st7
  int v16; // edx
  double v17; // st5
  double *v18; // ecx
  unsigned int v19; // edi
  double v20; // rt0
  double v21; // st5
  double v22; // st7
  double v23; // st4
  double v24; // st4
  double v25; // st4
  double v26; // st4
  double v27; // rt1
  double *v28; // edi
  int v29; // ecx
  double v30; // rt2
  double v31; // st5
  double v32; // st7
  double v33; // st4
  double v34; // rtt
  int v35; // ecx
  int v36; // edi
  double v37; // st4
  int v38; // edx
  double *v39; // edx
  int v40; // eax
  unsigned int v41; // edi
  double v42; // st3
  double *v43; // ebx
  double v44; // st4
  double v45; // st3
  double *v46; // ebx
  double v47; // st4
  double v48; // st3
  double *v49; // ebx
  double *v50; // edi
  int v51; // eax
  FILE *v52; // eax
  double v53; // st3
  int v54; // edx
  double v55; // st4
  long double v56; // st3
  int v57; // eax
  double *v58; // edx
  int v59; // eax
  unsigned int v60; // edi
  double v61; // st2
  double *v62; // ebx
  long double v63; // st3
  double v64; // st2
  double *v65; // ebx
  long double v66; // st3
  double v67; // st2
  double *v68; // ebx
  int v69; // edx
  double *v70; // edi
  int v71; // eax
  double *i; // edx
  double v73; // st2
  long double v74; // st3
  int v75; // eax
  signed int v76; // eax
  double *v77; // eax
  unsigned int v78; // edi
  int v79; // edx
  double v80; // st4
  double v81; // st4
  double v82; // st4
  double v83; // st4
  int v84; // edx
  double *v85; // eax
  unsigned int v86; // edi
  double *v87; // edx
  double v88; // st4
  double v89; // st3
  double v90; // st4
  int v91; // edi
  int v92; // edx
  unsigned int v93; // eax
  double *v94; // edi
  double v95; // st3
  double *v96; // edi
  double v97; // st3
  double *v98; // edi
  double v99; // st3
  double *v100; // edi
  double v101; // st3
  double *v102; // eax
  int v103; // edx
  double *v104; // edx
  int v105; // ecx
  int v106; // edi
  int v107; // eax
  double v108; // st5
  int v109; // eax
  int v110; // edi
  unsigned int v111; // ecx
  int v112; // edx
  double v113; // st4
  double v114; // st4
  double *v115; // edi
  double v116; // st4
  double v117; // st4
  int v118; // eax
  double *v119; // ecx
  int v120; // edi
  double v121; // st5
  int v122; // ecx
  int v123; // edx
  unsigned int v124; // eax
  double v125; // st4
  double v126; // st4
  double v127; // st4
  double v128; // st5
  int v129; // eax
  int v130; // eax
  double *v131; // ecx
  unsigned int v132; // edx
  double *v133; // edi
  double *v134; // edi
  double *v135; // edi
  double *v136; // edi
  double *v137; // ecx
  int v138; // [esp+Ch] [ebp-58h]
  char *v139; // [esp+10h] [ebp-54h]
  double *v140; // [esp+14h] [ebp-50h]
  double *v141; // [esp+14h] [ebp-50h]
  double *v142; // [esp+14h] [ebp-50h]
  unsigned int v143; // [esp+18h] [ebp-4Ch]
  int v144; // [esp+18h] [ebp-4Ch]
  int v145; // [esp+18h] [ebp-4Ch]
  double *v146; // [esp+18h] [ebp-4Ch]
  int v147; // [esp+1Ch] [ebp-48h]
  double *v148; // [esp+1Ch] [ebp-48h]
  double *v149; // [esp+1Ch] [ebp-48h]
  double *v150; // [esp+1Ch] [ebp-48h]
  double *v151; // [esp+1Ch] [ebp-48h]
  int v152; // [esp+20h] [ebp-44h]
  double *v153; // [esp+20h] [ebp-44h]
  double *v154; // [esp+20h] [ebp-44h]
  double *v155; // [esp+20h] [ebp-44h]
  double *v156; // [esp+24h] [ebp-40h]
  double *v157; // [esp+24h] [ebp-40h]
  double *v158; // [esp+24h] [ebp-40h]
  double *v159; // [esp+24h] [ebp-40h]
  double *v160; // [esp+24h] [ebp-40h]
  double *v161; // [esp+28h] [ebp-3Ch]
  double *v162; // [esp+28h] [ebp-3Ch]
  double *v163; // [esp+28h] [ebp-3Ch]
  double *v164; // [esp+2Ch] [ebp-38h]
  int v165; // [esp+2Ch] [ebp-38h]
  double *v166; // [esp+30h] [ebp-34h]
  double *v167; // [esp+30h] [ebp-34h]
  int v168; // [esp+34h] [ebp-30h]
  int v169; // [esp+34h] [ebp-30h]
  int v170; // [esp+34h] [ebp-30h]
  int v171; // [esp+34h] [ebp-30h]
  double *v172; // [esp+38h] [ebp-2Ch]
  double *v173; // [esp+38h] [ebp-2Ch]
  double *v174; // [esp+38h] [ebp-2Ch]
  double *v175; // [esp+3Ch] [ebp-28h]
  double *v176; // [esp+40h] [ebp-24h]
  double *v177; // [esp+44h] [ebp-20h]
  long double *v178; // [esp+44h] [ebp-20h]
  double *v179; // [esp+44h] [ebp-20h]
  double *v180; // [esp+48h] [ebp-1Ch]
  int v181; // [esp+48h] [ebp-1Ch]
  int v182; // [esp+4Ch] [ebp-18h]
  int v183; // [esp+4Ch] [ebp-18h]
  int v184; // [esp+50h] [ebp-14h]
  double *v185; // [esp+54h] [ebp-10h]
  double *v186; // [esp+58h] [ebp-Ch]
  int v187; // [esp+5Ch] [ebp-8h]
  int v188; // [esp+5Ch] [ebp-8h]
  unsigned int v189; // [esp+5Ch] [ebp-8h]
  int v190; // [esp+5Ch] [ebp-8h]
  int v191; // [esp+60h] [ebp-4h]
  int v192; // [esp+60h] [ebp-4h]
  int v193; // [esp+60h] [ebp-4h]
  int v194; // [esp+60h] [ebp-4h]
  int v195; // [esp+60h] [ebp-4h]
  int v196; // [esp+60h] [ebp-4h]
  int v197; // [esp+60h] [ebp-4h]
  int v198; // [esp+60h] [ebp-4h]

  v3 = a1 * a1;
  v184 = -1;
  v4 = (double *)malloc(4 * (a1 + 2 * (a1 * a1 + 2 * a1)));
  v5 = v4;
  v140 = v4;
  if ( v4 )
  {
    v186 = &v4[v3];
    v8 = 0;
    v176 = &v186[a1];
    v139 = (char *)&v176[a1];
    if ( v3 >= 4 )
    {
      v9 = a2 + 24;
      v147 = a2 - (_DWORD)v4;
      v143 = ((unsigned int)(v3 - 4) >> 2) + 1;
      v10 = v4 + 1;
      v191 = 4 * v143;
      do
      {
        *(v10 - 1) = *(double *)(v9 - 24);
        v10 += 4;
        v9 += 32;
        v11 = v143-- == 1;
        *(v10 - 4) = *(double *)((char *)v10 + v147 - 32);
        *(v10 - 3) = *(double *)(v9 - 40);
        *(v10 - 2) = *(double *)(v9 - 32);
      }
      while ( !v11 );
      v8 = v191;
    }
    if ( v8 < v3 )
    {
      v12 = &v5[v8];
      v13 = v3 - v8;
      do
      {
        v14 = *(double *)((char *)v12++ + a2 - (_DWORD)v5);
        --v13;
        *(v12 - 1) = v14;
      }
      while ( v13 );
    }
    v15 = 0.0;
    v192 = 0;
    if ( a1 <= 0 )
    {
LABEL_40:
      v35 = 0;
      if ( a1 > 0 )
      {
        v144 = a1 - 1;
        v175 = &v5[a1];
        v182 = 0;
        v180 = v5;
        v185 = v5;
        v169 = 3 * a1;
        v173 = v5;
        v138 = (char *)v176 - (char *)v5;
        do
        {
          v36 = 0;
          v193 = 0;
          if ( v35 > 0 )
          {
            v152 = 0;
            v148 = v5;
            v177 = v185;
            do
            {
              v37 = *v177;
              v38 = 0;
              if ( v36 >= 4 )
              {
                v166 = v185;
                v39 = v148;
                v156 = &v5[3 * a1 + v35];
                v161 = &v5[2 * a1 + v35];
                v164 = v175;
                v40 = 32 * a1;
                v41 = ((unsigned int)(v193 - 4) >> 2) + 1;
                v187 = 4 * v41;
                do
                {
                  v42 = *v39 * *v166;
                  v43 = v164;
                  v166 = (double *)((char *)v166 + v40);
                  v164 = (double *)((char *)v164 + v40);
                  v44 = v37 - v42;
                  v39 += 4;
                  v45 = *(v39 - 3) * *v43;
                  v46 = v161;
                  v161 = (double *)((char *)v161 + v40);
                  v47 = v44 - v45;
                  v48 = *(v39 - 2) * *v46;
                  v49 = v156;
                  v156 = (double *)((char *)v156 + v40);
                  --v41;
                  v37 = v47 - v48 - *(v39 - 1) * *v49;
                }
                while ( v41 );
                v36 = v193;
                v38 = v187;
                v5 = v140;
              }
              if ( v38 < v36 )
              {
                v50 = &v5[v38 + v152];
                v157 = &v5[v35 + a1 * v38];
                v51 = v193 - v38;
                while ( 1 )
                {
                  v53 = *v50 * *v157;
                  v157 += a1;
                  --v51;
                  v37 = v37 - v53;
                  if ( !v51 )
                    break;
                  ++v50;
                }
                v36 = v193;
              }
              v152 += a1;
              *v177 = v37;
              v148 += a1;
              v177 += a1;
              v193 = ++v36;
            }
            while ( v36 < v35 );
          }
          v54 = v35;
          v55 = v15;
          v194 = v35;
          if ( v35 < a1 )
          {
            v165 = v182;
            v178 = v180;
            v167 = v173 + 2;
            do
            {
              v56 = *v178;
              v57 = 0;
              v188 = 0;
              if ( v35 >= 4 )
              {
                v58 = v167;
                v149 = v185;
                v162 = &v5[3 * a1 + v35];
                v158 = &v5[2 * a1 + v35];
                v153 = v175;
                v59 = 32 * a1;
                v60 = ((unsigned int)(v35 - 4) >> 2) + 1;
                v188 = 4 * v60;
                do
                {
                  v61 = *(v58 - 2) * *v149;
                  v62 = v153;
                  v149 = (double *)((char *)v149 + v59);
                  v153 = (double *)((char *)v153 + v59);
                  v63 = v56 - v61;
                  v58 += 4;
                  v64 = *(v58 - 5) * *v62;
                  v65 = v158;
                  v158 = (double *)((char *)v158 + v59);
                  v66 = v63 - v64;
                  v67 = *v65;
                  v68 = v162;
                  v162 = (double *)((char *)v162 + v59);
                  --v60;
                  v56 = v66 - v67 * *(v58 - 4) - *(v58 - 3) * *v68;
                }
                while ( v60 );
                v54 = v194;
                v5 = v140;
                v57 = v188;
              }
              if ( v57 < v35 )
              {
                v69 = v57 + v165;
                v70 = &v5[v35 + a1 * v57];
                v71 = v35 - v188;
                for ( i = &v5[v69]; ; ++i )
                {
                  v73 = *i * *v70;
                  v70 += a1;
                  --v71;
                  v56 = v56 - v73;
                  if ( !v71 )
                    break;
                }
                v54 = v194;
              }
              *v178 = v56;
              v74 = fabs(v56) * v176[v54];
              if ( v74 >= v55 )
              {
                v55 = v74;
                v184 = v54;
              }
              v165 += a1;
              v167 += a1;
              v178 += a1;
              v194 = ++v54;
            }
            while ( v54 < a1 );
          }
          v75 = v184;
          if ( v35 != v184 )
          {
            v76 = 0;
            v189 = 0;
            if ( a1 >= 4 )
            {
              v77 = v173;
              v189 = 4 * (((unsigned int)(a1 - 4) >> 2) + 1);
              v78 = ((unsigned int)(a1 - 4) >> 2) + 1;
              v79 = (int)&v5[a1 * v184 + 2];
              do
              {
                v80 = *(double *)(v79 - 16);
                v77 += 4;
                v79 += 32;
                --v78;
                *(double *)(v79 - 48) = *(v77 - 4);
                *(v77 - 4) = v80;
                v81 = *(double *)(v79 - 40);
                *(double *)(v79 - 40) = *(v77 - 3);
                *(v77 - 3) = v81;
                v82 = *(double *)(v79 - 32);
                *(double *)(v79 - 32) = *(v77 - 2);
                *(v77 - 2) = v82;
                v83 = *(double *)(v79 - 24);
                *(double *)(v79 - 24) = *(v77 - 1);
                *(v77 - 1) = v83;
              }
              while ( v78 );
              v76 = 4 * (((unsigned int)(a1 - 4) >> 2) + 1);
            }
            if ( v76 < a1 )
            {
              v84 = v76 + v182;
              v85 = &v5[v76 + a1 * v184];
              v86 = a1 - v189;
              v87 = &v5[v84];
              do
              {
                v88 = *v85++;
                v89 = *v87++;
                --v86;
                *(v85 - 1) = v89;
                *(v87 - 1) = v88;
              }
              while ( v86 );
            }
            v75 = v184;
            v176[v184] = *(double *)((char *)v185 + v138);
          }
          *(_DWORD *)&v139[4 * v35] = v75;
          if ( v15 == *v180 )
            *v180 = 2.220446049250313e-16;
          if ( v35 != a1 - 1 )
          {
            v90 = 1.0 / *v180;
            v91 = v35 + 1;
            if ( v35 + 1 < a1 )
            {
              if ( v144 >= 4 )
              {
                v179 = &v5[v35 + a1 + v182];
                v159 = &v5[a1 + v35 + v169];
                v154 = &v5[v35 + v169];
                v150 = &v5[a1 + v35 + a1 + v182];
                v92 = 32 * a1;
                v93 = ((unsigned int)(a1 - v91 - 4) >> 2) + 1;
                v195 = v91 + 4 * v93;
                do
                {
                  v94 = v179;
                  v95 = *v179;
                  v179 = (double *)((char *)v179 + v92);
                  *v94 = v95 * v90;
                  v96 = v150;
                  v97 = *v150;
                  v150 = (double *)((char *)v150 + v92);
                  *v96 = v97 * v90;
                  v98 = v154;
                  v99 = *v154;
                  v154 = (double *)((char *)v154 + v92);
                  *v98 = v99 * v90;
                  v100 = v159;
                  v101 = *v159;
                  v159 = (double *)((char *)v159 + v92);
                  --v93;
                  *v100 = v101 * v90;
                }
                while ( v93 );
                v91 = v195;
              }
              if ( v91 < a1 )
              {
                v102 = &v5[v35 + a1 * v91];
                v103 = a1 - v91;
                do
                {
                  *v102 = *v102 * v90;
                  v102 += a1;
                  --v103;
                }
                while ( v103 );
              }
            }
          }
          --v144;
          v182 += a1;
          v169 += a1;
          v173 += a1;
          v180 += a1 + 1;
          ++v175;
          ++v185;
          ++v35;
        }
        while ( v35 < a1 );
      }
      v183 = 0;
      if ( a1 > 0 )
      {
        v163 = &a3[a1];
        v174 = a3;
        do
        {
          v104 = v186;
          memset(v186, 0, 4 * ((unsigned int)(8 * a1) >> 2));
          *(double *)((char *)v174 + (char *)v186 - (char *)a3) = 1.0;
          v105 = 0;
          v106 = 0;
          v190 = 0;
          v196 = 0;
          v170 = 0;
          while ( 1 )
          {
            v107 = *(_DWORD *)&v139[4 * v105];
            v108 = v104[v107];
            v104[v107] = v104[v105];
            if ( v106 )
            {
              v109 = v106 - 1;
              if ( v106 - 1 < v105 )
              {
                if ( v105 - v109 >= 4 )
                {
                  v110 = (int)&v104[v109 + 2];
                  v111 = ((unsigned int)(v105 - v109 - 4) >> 2) + 1;
                  v112 = (int)&v5[v109 + 2 + v170];
                  v109 += 4 * v111;
                  do
                  {
                    v113 = *(double *)(v110 - 16);
                    v110 += 32;
                    v114 = v113 * *(double *)(v112 - 16);
                    v112 += 32;
                    --v111;
                    v108 = v108
                         - v114
                         - *(double *)(v110 - 40) * *(double *)(v112 - 40)
                         - *(double *)(v112 - 32) * *(double *)(v110 - 32)
                         - *(double *)(v110 - 24) * *(double *)(v112 - 24);
                  }
                  while ( v111 );
                  v105 = v196;
                  v104 = v186;
                }
                if ( v109 < v105 )
                {
                  v115 = &v5[v109 + v170];
                  do
                  {
                    v116 = v104[v109++];
                    v117 = v116 * *v115++;
                    v108 = v108 - v117;
                  }
                  while ( v109 < v105 );
                }
              }
            }
            else if ( v15 != v108 )
            {
              v190 = v105 + 1;
            }
            v170 += a1;
            v104[v105++] = v108;
            v196 = v105;
            if ( v105 >= a1 )
              break;
            v106 = v190;
          }
          v118 = a1 - 1;
          v197 = a1 - 1;
          if ( a1 - 1 >= 0 )
          {
            v171 = a1 * v118;
            v181 = a1;
            v119 = (double *)((char *)v5 + v118 * (8 * a1 + 8));
            v141 = v119;
            v145 = 0;
            do
            {
              v120 = v181;
              v121 = v186[v118];
              if ( v181 < a1 )
              {
                if ( v145 >= 4 )
                {
                  v122 = (int)&v186[v118 + 3];
                  v123 = (int)&v5[v181 + 2 + v171];
                  v124 = ((unsigned int)(a1 - v181 - 4) >> 2) + 1;
                  v120 = v181 + 4 * v124;
                  do
                  {
                    v125 = *(double *)(v122 - 16);
                    v122 += 32;
                    v126 = v125 * *(double *)(v123 - 16);
                    v123 += 32;
                    --v124;
                    v121 = v121
                         - v126
                         - *(double *)(v122 - 40) * *(double *)(v123 - 40)
                         - *(double *)(v123 - 32) * *(double *)(v122 - 32)
                         - *(double *)(v122 - 24) * *(double *)(v123 - 24);
                  }
                  while ( v124 );
                  v118 = v197;
                  v119 = v141;
                }
                if ( v120 < a1 )
                {
                  v142 = &v5[v120 + v171];
                  do
                  {
                    v127 = v186[v120++] * *v142++;
                    v121 = v121 - v127;
                  }
                  while ( v120 < a1 );
                }
              }
              v128 = v121 / *v119;
              v119 = (double *)((char *)v119 - 8 - 8 * a1);
              v141 = v119;
              v186[v118] = v128;
              ++v145;
              --v181;
              --v118;
              v171 -= a1;
              v197 = v118;
            }
            while ( v118 >= 0 );
          }
          v129 = 0;
          if ( a1 >= 4 )
          {
            v146 = v174;
            v160 = &a3[2 * a1 + a1 + v183];
            v155 = &a3[2 * a1 + v183];
            v151 = v163;
            v130 = 32 * a1;
            v131 = v186 + 2;
            v132 = ((unsigned int)(a1 - 4) >> 2) + 1;
            v198 = 4 * v132;
            do
            {
              v133 = v146;
              v146 = (double *)((char *)v146 + v130);
              *v133 = *(v131 - 2);
              v134 = v151;
              v151 = (double *)((char *)v151 + v130);
              *v134 = *(v131 - 1);
              v135 = v155;
              v155 = (double *)((char *)v155 + v130);
              *v135 = *v131;
              v136 = v160;
              v160 = (double *)((char *)v160 + v130);
              *v136 = v131[1];
              v131 += 4;
              --v132;
            }
            while ( v132 );
            v129 = v198;
          }
          if ( v129 < a1 )
          {
            v137 = &a3[v183 + a1 * v129];
            do
            {
              *v137 = v186[v129++];
              v137 += a1;
            }
            while ( v129 < a1 );
          }
          ++v174;
          ++v163;
          ++v183;
        }
        while ( v183 < a1 );
      }
      free(v5);
      return 1;
    }
    else
    {
      v168 = 0;
      v172 = v5;
      while ( 1 )
      {
        v16 = 0;
        v17 = v15;
        if ( a1 >= 4 )
        {
          v18 = v172;
          v19 = ((unsigned int)(a1 - 4) >> 2) + 1;
          v16 = 4 * v19;
          do
          {
            v20 = v17;
            v21 = v15;
            v22 = v20;
            v23 = *v18;
            if ( v21 > v23 )
              v23 = -v23;
            if ( v23 > v22 )
              v22 = v23;
            v24 = v18[1];
            if ( v21 > v24 )
              v24 = -v24;
            if ( v24 > v22 )
              v22 = v24;
            v25 = v18[2];
            if ( v21 > v25 )
              v25 = -v25;
            if ( v25 > v22 )
              v22 = v25;
            v26 = v18[3];
            if ( v21 > v26 )
              v26 = -v26;
            if ( v26 > v22 )
              v22 = v26;
            v18 += 4;
            v27 = v21;
            v17 = v22;
            v15 = v27;
            --v19;
          }
          while ( v19 );
        }
        if ( v16 < a1 )
        {
          v28 = &v5[v16 + v168];
          v29 = a1 - v16;
          do
          {
            v30 = v17;
            v31 = v15;
            v32 = v30;
            v33 = *v28;
            if ( v31 > v33 )
              v33 = -v33;
            if ( v33 > v32 )
              v32 = v33;
            ++v28;
            v34 = v31;
            v17 = v32;
            v15 = v34;
            --v29;
          }
          while ( v29 );
        }
        if ( v15 == v17 )
          break;
        v168 += a1;
        v172 += a1;
        v176[v192++] = 1.0 / v17;
        if ( v192 >= a1 )
          goto LABEL_40;
      }
      v52 = _iob_func();
      fprintf(v52 + 2, "Singular matrix A in dlevmar_LUinverse_noLapack()!\n");
      free(v5);
      return 0;
    }
  }
  else
  {
    v6 = _iob_func();
    fprintf(v6 + 2, "memory allocation in dlevmar_LUinverse_noLapack() failed!\n");
    return 0;
  }
}

//----- (004029D0) --------------------------------------------------------
int __cdecl sub_4029D0(int a1, double *a2, double a3, int a4, int a5)
{
  int result; // eax
  int v6; // edi
  int v7; // ecx
  double v8; // st7
  unsigned int v9; // edx
  double *v10; // eax
  double v11; // st6
  double v12; // st6

  result = sub_4020A0(a4, a1, a2);
  if ( result )
  {
    v6 = a4 * a4;
    v7 = 0;
    v8 = a3 / (double)(a5 - a4);
    if ( a4 * a4 >= 4 )
    {
      v9 = ((unsigned int)(v6 - 4) >> 2) + 1;
      v10 = a2 + 2;
      v7 = 4 * v9;
      do
      {
        v11 = *(v10 - 2);
        v10 += 4;
        --v9;
        *(v10 - 6) = v11 * v8;
        *(v10 - 5) = *(v10 - 5) * v8;
        *(v10 - 4) = *(v10 - 4) * v8;
        *(v10 - 3) = *(v10 - 3) * v8;
      }
      while ( v9 );
    }
    for ( ; v7 < v6; a2[v7 - 1] = v12 * v8 )
      v12 = a2[v7++];
    return a4;
  }
  return result;
}

//----- (00402A70) --------------------------------------------------------
double __cdecl sub_402A70(int a1, int a2, int a3, signed int a4)
{
  signed int v4; // ecx
  double v5; // st7
  double v6; // st6
  int v7; // ebx
  double v8; // st5
  double v9; // st4
  signed int v10; // edx
  int v11; // edi
  signed int v12; // esi
  double *v13; // edx
  double *v14; // ecx
  double *v15; // eax
  unsigned int v16; // esi
  double v17; // st3
  double v18; // st6
  double v19; // st3
  double v20; // st5
  double v21; // st3
  double v22; // st4
  double v23; // st3
  double v24; // st7
  double v25; // st3
  double v26; // st3
  double v27; // st3
  double v28; // st2
  signed int v29; // eax
  double v30; // st3
  double v31; // st3
  double v32; // st3
  double v33; // st3
  double v34; // st3
  double v35; // st3
  double v36; // st3
  double result; // st7
  int v38; // ebx
  double *v39; // eax
  double *v40; // ecx
  unsigned int v41; // esi
  double v42; // st3
  double v43; // st6
  double v44; // st3
  double v45; // st5
  double v46; // st3
  double v47; // st4
  double v48; // st3
  double v49; // st7
  double v50; // st3
  double v51; // st3
  double v52; // st3
  double v53; // st2
  unsigned int v54; // eax
  double v55; // st3
  double v56; // st3
  double v57; // st3
  double v58; // st3
  double v59; // st3
  double v60; // st3
  double v61; // st3
  double v62; // st3
  double v63; // st3
  double v64; // st3
  double v65; // st3
  double v66; // st3

  v4 = a4;
  v5 = 0.0;
  v6 = 0.0;
  v7 = a2;
  v8 = 0.0;
  v9 = 0.0;
  v10 = a4 & 0xFFFFFFF8;
  v11 = a3;
  v12 = (a4 & 0xFFFFFFF8) - 1;
  if ( !a2 )
  {
    v38 = a1;
    if ( v12 > 0 )
    {
      v39 = (double *)(a1 + 8 * v12 - 8);
      v40 = (double *)(a3 + 8 * v12 - 24);
      v41 = (((a4 & 0xFFFFFFF8) - 2) >> 3) + 1;
      do
      {
        v39 -= 8;
        v42 = -v40[3];
        v40 -= 8;
        --v41;
        v39[9] = v42;
        v43 = v6 + v42 * v42;
        v44 = -*(double *)((char *)v39 + a3 - a1 + 64);
        v39[8] = v44;
        v45 = v8 + v44 * v44;
        v46 = -v40[9];
        v39[7] = v46;
        v47 = v9 + v46 * v46;
        v48 = -v40[8];
        v39[6] = v48;
        v49 = v5 + v48 * v48;
        v50 = -v40[7];
        v39[5] = v50;
        v6 = v43 + v50 * v50;
        v51 = -v40[6];
        v39[4] = v51;
        v8 = v45 + v51 * v51;
        v52 = -v40[5];
        v39[3] = v52;
        v9 = v47 + v52 * v52;
        v53 = -v40[4];
        v39[2] = v53;
        v5 = v49 + v53 * v53;
      }
      while ( v41 );
      v4 = a4;
      v38 = a1;
    }
    v54 = a4 & 0xFFFFFFF8;
    if ( v10 < v4 )
    {
      switch ( v4 - v10 )
      {
        case 1:
          goto LABEL_27;
        case 2:
          goto LABEL_26;
        case 3:
          goto LABEL_25;
        case 4:
          goto LABEL_24;
        case 5:
          goto LABEL_23;
        case 6:
          goto LABEL_22;
        case 7:
          v54 = v10 + 1;
          v55 = -*(double *)(a3 + 8 * v10);
          *(double *)(v38 + 8 * v10) = v55;
          v6 = v6 + v55 * v55;
LABEL_22:
          v56 = *(double *)(a3 + 8 * v54++);
          v57 = -v56;
          *(double *)(v38 + 8 * v54 - 8) = v57;
          v8 = v8 + v57 * v57;
LABEL_23:
          v58 = *(double *)(a3 + 8 * v54++);
          v59 = -v58;
          *(double *)(v38 + 8 * v54 - 8) = v59;
          v9 = v9 + v59 * v59;
LABEL_24:
          v60 = *(double *)(a3 + 8 * v54++);
          v61 = -v60;
          *(double *)(v38 + 8 * v54 - 8) = v61;
          v5 = v5 + v61 * v61;
LABEL_25:
          v62 = *(double *)(a3 + 8 * v54++);
          v63 = -v62;
          *(double *)(v38 + 8 * v54 - 8) = v63;
          v6 = v6 + v63 * v63;
LABEL_26:
          v64 = *(double *)(a3 + 8 * v54++);
          v65 = -v64;
          *(double *)(v38 + 8 * v54 - 8) = v65;
          v8 = v8 + v65 * v65;
LABEL_27:
          v66 = -*(double *)(a3 + 8 * v54);
          *(double *)(v38 + 8 * v54) = v66;
          v9 = v9 + v66 * v66;
          break;
        default:
          return v5 + v6 + v8 + v9;
      }
    }
    return v5 + v6 + v8 + v9;
  }
  if ( v12 > 0 )
  {
    v13 = (double *)(a2 + 8 * v12 - 32);
    v14 = (double *)(a1 + 8 * v12 - 16);
    v15 = (double *)(a3 + 8 * v12 - 8);
    v16 = (((a4 & 0xFFFFFFF8) - 2) >> 3) + 1;
    do
    {
      v17 = v13[4] - v15[1];
      v15 -= 8;
      v14 -= 8;
      v13 -= 8;
      --v16;
      v14[10] = v17;
      v18 = v6 + v17 * v17;
      v19 = *(double *)((char *)v15 + a2 - a3 + 64) - v15[8];
      *(double *)((char *)v15 + a1 - a3 + 64) = v19;
      v20 = v8 + v19 * v19;
      v21 = *(double *)((char *)v14 + a2 - a1 + 64) - v15[7];
      v14[8] = v21;
      v22 = v9 + v21 * v21;
      v23 = v13[9] - v15[6];
      v14[7] = v23;
      v24 = v5 + v23 * v23;
      v25 = v13[8] - v15[5];
      v14[6] = v25;
      v6 = v18 + v25 * v25;
      v26 = v13[7] - v15[4];
      v14[5] = v26;
      v8 = v20 + v26 * v26;
      v27 = v13[6] - v15[3];
      v14[4] = v27;
      v9 = v22 + v27 * v27;
      v28 = v13[5] - v15[2];
      v14[3] = v28;
      v5 = v24 + v28 * v28;
    }
    while ( v16 );
    v10 = a4 & 0xFFFFFFF8;
    v7 = a2;
    v11 = a3;
    v4 = a4;
  }
  v29 = v10;
  if ( v10 >= v4 )
    return v5 + v6 + v8 + v9;
  switch ( v4 - v10 )
  {
    case 1:
      goto LABEL_14;
    case 2:
      goto LABEL_13;
    case 3:
      goto LABEL_12;
    case 4:
      goto LABEL_11;
    case 5:
      goto LABEL_10;
    case 6:
      goto LABEL_9;
    case 7:
      v30 = *(double *)(v7 + 8 * v10) - *(double *)(v11 + 8 * v10);
      v29 = v10 + 1;
      *(double *)(a1 + 8 * v10) = v30;
      v6 = v6 + v30 * v30;
LABEL_9:
      v31 = *(double *)(v7 + 8 * v29) - *(double *)(v11 + 8 * v29);
      ++v29;
      *(double *)(a1 + 8 * v29 - 8) = v31;
      v8 = v8 + v31 * v31;
LABEL_10:
      v32 = *(double *)(v7 + 8 * v29) - *(double *)(v11 + 8 * v29);
      ++v29;
      *(double *)(a1 + 8 * v29 - 8) = v32;
      v9 = v9 + v32 * v32;
LABEL_11:
      v33 = *(double *)(v7 + 8 * v29) - *(double *)(v11 + 8 * v29);
      ++v29;
      *(double *)(a1 + 8 * v29 - 8) = v33;
      v5 = v5 + v33 * v33;
LABEL_12:
      v34 = *(double *)(v7 + 8 * v29) - *(double *)(v11 + 8 * v29);
      ++v29;
      *(double *)(a1 + 8 * v29 - 8) = v34;
      v6 = v6 + v34 * v34;
LABEL_13:
      v35 = *(double *)(v7 + 8 * v29) - *(double *)(v11 + 8 * v29);
      ++v29;
      *(double *)(a1 + 8 * v29 - 8) = v35;
      v8 = v8 + v35 * v35;
LABEL_14:
      v36 = *(double *)(v7 + 8 * v29) - *(double *)(v11 + 8 * v29);
      *(double *)(a1 + 8 * v29) = v36;
      result = v5 + v6 + v8 + v9 + v36 * v36;
      break;
    default:
      return v5 + v6 + v8 + v9;
  }
  return result;
}

//----- (00402D90) --------------------------------------------------------
int __cdecl sub_402D90(void *Src, void *a2, char *a3, int a4)
{
  int v5; // ebx
  signed int v6; // edi
  char *v7; // edi
  FILE *v8; // eax
  int v9; // ebx
  double v10; // st7
  int v11; // edx
  double v12; // st5
  double *v13; // ecx
  unsigned int v14; // ebx
  double v15; // rt0
  double v16; // st5
  double v17; // st7
  double v18; // st4
  double v19; // st4
  double v20; // st4
  double v21; // st4
  double v22; // rt1
  double *v23; // ebx
  int v24; // ecx
  double v25; // rt2
  double v26; // st5
  double v27; // st7
  double v28; // st4
  double v29; // rtt
  int v30; // ecx
  int v31; // edx
  double v32; // st4
  int v33; // ebx
  double *v34; // edx
  int v35; // eax
  unsigned int v36; // edi
  double v37; // st3
  double *v38; // ebx
  double v39; // st4
  double v40; // st3
  double *v41; // ebx
  double v42; // st4
  double v43; // st3
  double *v44; // ebx
  int v45; // edx
  char *v46; // eax
  double *v47; // ebx
  double *i; // edx
  FILE *v49; // eax
  double v50; // st3
  int v51; // edx
  double v52; // st4
  long double v53; // st3
  int v54; // ebx
  char *v55; // edx
  int v56; // eax
  unsigned int v57; // edi
  double v58; // st2
  double *v59; // ebx
  long double v60; // st3
  double v61; // st2
  double *v62; // ebx
  long double v63; // st3
  double v64; // st2
  double *v65; // ebx
  int v66; // edx
  int v67; // eax
  double *v68; // ebx
  double *j; // edx
  double v70; // st2
  long double v71; // st3
  signed int v72; // eax
  double *v73; // eax
  unsigned int v74; // ebx
  int v75; // edx
  double v76; // st4
  double v77; // st4
  double v78; // st4
  double v79; // st4
  int v80; // edx
  double *v81; // eax
  int v82; // ebx
  double *v83; // edx
  double v84; // st4
  double v85; // st3
  double v86; // st4
  int v87; // ebx
  int v88; // edx
  unsigned int v89; // eax
  double *v90; // ebx
  double v91; // st3
  double *v92; // ebx
  double v93; // st3
  double *v94; // ebx
  double v95; // st3
  double *v96; // ebx
  double v97; // st3
  double *v98; // eax
  int v99; // edx
  char *v100; // edx
  int v101; // ecx
  int v102; // ebx
  int v103; // eax
  double v104; // st6
  int v105; // eax
  unsigned int v106; // ecx
  double v107; // st6
  double v108; // st5
  double *v109; // ebx
  double v110; // st6
  double v111; // st5
  double *v112; // ebx
  double v113; // st5
  double v114; // st5
  int v115; // eax
  int v116; // ebx
  double v117; // st7
  int v118; // edx
  unsigned int v119; // eax
  double *v120; // ecx
  double v121; // st6
  double *v122; // ecx
  double v123; // st6
  double v124; // st6
  size_t v125; // [esp-10h] [ebp-60h]
  int v126; // [esp+0h] [ebp-50h]
  int v127; // [esp+4h] [ebp-4Ch]
  char *v128; // [esp+8h] [ebp-48h]
  int v129; // [esp+Ch] [ebp-44h]
  int v130; // [esp+Ch] [ebp-44h]
  double *v131; // [esp+10h] [ebp-40h]
  double *v132; // [esp+10h] [ebp-40h]
  double *v133; // [esp+10h] [ebp-40h]
  double *v134; // [esp+10h] [ebp-40h]
  int v135; // [esp+14h] [ebp-3Ch]
  double *v136; // [esp+14h] [ebp-3Ch]
  double *v137; // [esp+14h] [ebp-3Ch]
  double *v138; // [esp+18h] [ebp-38h]
  double *v139; // [esp+18h] [ebp-38h]
  double *v140; // [esp+18h] [ebp-38h]
  double *v141; // [esp+1Ch] [ebp-34h]
  double *v142; // [esp+1Ch] [ebp-34h]
  double *v143; // [esp+20h] [ebp-30h]
  int v144; // [esp+20h] [ebp-30h]
  double *v145; // [esp+24h] [ebp-2Ch]
  char *v146; // [esp+24h] [ebp-2Ch]
  int v147; // [esp+28h] [ebp-28h]
  int v148; // [esp+28h] [ebp-28h]
  int v149; // [esp+28h] [ebp-28h]
  int v150; // [esp+28h] [ebp-28h]
  double *v151; // [esp+2Ch] [ebp-24h]
  char *v152; // [esp+2Ch] [ebp-24h]
  int v153; // [esp+2Ch] [ebp-24h]
  double *v154; // [esp+30h] [ebp-20h]
  char *v155; // [esp+34h] [ebp-1Ch]
  double *v156; // [esp+38h] [ebp-18h]
  long double *v157; // [esp+38h] [ebp-18h]
  double *v158; // [esp+38h] [ebp-18h]
  double *v159; // [esp+3Ch] [ebp-14h]
  double *v160; // [esp+3Ch] [ebp-14h]
  int v161; // [esp+40h] [ebp-10h]
  double *v162; // [esp+44h] [ebp-Ch]
  double *v163; // [esp+44h] [ebp-Ch]
  int v164; // [esp+48h] [ebp-8h]
  int v165; // [esp+4Ch] [ebp-4h]
  int v166; // [esp+4Ch] [ebp-4h]
  unsigned int v167; // [esp+4Ch] [ebp-4h]
  int v168; // [esp+4Ch] [ebp-4h]
  int Srca; // [esp+58h] [ebp+8h]
  char *Srcb; // [esp+58h] [ebp+8h]
  void *Srcc; // [esp+58h] [ebp+8h]
  void *Srcd; // [esp+58h] [ebp+8h]
  void *Srce; // [esp+58h] [ebp+8h]
  void *Srcf; // [esp+58h] [ebp+8h]

  v164 = -1;
  if ( Src )
  {
    v5 = a4 * a4;
    v6 = 4 * (a4 + 2 * (a4 * a4 + a4));
    if ( v6 <= dword_5019A8 )
    {
      v7 = (char *)Block;
    }
    else
    {
      if ( Block )
        free(Block);
      dword_5019A8 = 4 * (a4 + 2 * (a4 * a4 + a4));
      v7 = (char *)malloc(v6);
      Block = v7;
      if ( !v7 )
      {
        v8 = _iob_func();
        fprintf(v8 + 2, "memory allocation in dAx_eq_b_LU_noLapack() failed!\n");
        exit(1);
      }
    }
    v125 = 8 * v5;
    v155 = &v7[8 * v5];
    v9 = 8 * a4;
    v128 = &v155[8 * a4];
    memcpy(v7, Src, v125);
    memcpy(a3, a2, 8 * a4);
    v10 = 0.0;
    Srca = 0;
    if ( a4 <= 0 )
    {
LABEL_41:
      v30 = 0;
      if ( a4 > 0 )
      {
        v129 = a4 - 1;
        v126 = v9 + 8;
        v161 = 0;
        v159 = (double *)v7;
        v162 = (double *)v7;
        v148 = 3 * a4;
        v152 = v7;
        v154 = (double *)&v7[v9];
        v127 = v155 - v7;
        do
        {
          v31 = 0;
          Srcb = 0;
          if ( v30 > 0 )
          {
            v135 = 0;
            v131 = (double *)v7;
            v156 = v162;
            do
            {
              v32 = *v156;
              v33 = 0;
              if ( v31 >= 4 )
              {
                v34 = v131;
                v145 = v162;
                v138 = (double *)&v7[24 * a4 + 8 * v30];
                v141 = (double *)&v7[16 * a4 + 8 * v30];
                v143 = v154;
                v35 = 32 * a4;
                v36 = ((unsigned int)(Srcb - 4) >> 2) + 1;
                v165 = 4 * v36;
                do
                {
                  v37 = *v34 * *v145;
                  v38 = v143;
                  v145 = (double *)((char *)v145 + v35);
                  v143 = (double *)((char *)v143 + v35);
                  v39 = v32 - v37;
                  v34 += 4;
                  v40 = *(v34 - 3) * *v38;
                  v41 = v141;
                  v141 = (double *)((char *)v141 + v35);
                  v42 = v39 - v40;
                  v43 = *(v34 - 2) * *v41;
                  v44 = v138;
                  v138 = (double *)((char *)v138 + v35);
                  --v36;
                  v32 = v42 - v43 - *(v34 - 1) * *v44;
                }
                while ( v36 );
                v31 = (int)Srcb;
                v7 = (char *)Block;
                v33 = v165;
              }
              if ( v33 < v31 )
              {
                v45 = v33 + v135;
                v46 = &Srcb[-v33];
                v47 = (double *)&v7[8 * v30 + 8 * a4 * v33];
                for ( i = (double *)&v7[8 * v45]; ; ++i )
                {
                  v50 = *i * *v47;
                  v47 += a4;
                  --v46;
                  v32 = v32 - v50;
                  if ( !v46 )
                    break;
                }
                v31 = (int)Srcb;
              }
              v135 += a4;
              *v156 = v32;
              v131 += a4;
              v156 += a4;
              Srcb = (char *)++v31;
            }
            while ( v31 < v30 );
          }
          v51 = v30;
          v52 = v10;
          Srcc = (void *)v30;
          if ( v30 < a4 )
          {
            v144 = v161;
            v157 = v159;
            v146 = v152 + 16;
            do
            {
              v53 = *v157;
              v54 = 0;
              if ( v30 >= 4 )
              {
                v55 = v146;
                v132 = v162;
                v142 = (double *)&v7[24 * a4 + 8 * v30];
                v139 = (double *)&v7[16 * a4 + 8 * v30];
                v136 = v154;
                v56 = 32 * a4;
                v57 = ((unsigned int)(v30 - 4) >> 2) + 1;
                v166 = 4 * v57;
                do
                {
                  v58 = *((double *)v55 - 2) * *v132;
                  v59 = v136;
                  v132 = (double *)((char *)v132 + v56);
                  v136 = (double *)((char *)v136 + v56);
                  v60 = v53 - v58;
                  v55 += 32;
                  v61 = *((double *)v55 - 5) * *v59;
                  v62 = v139;
                  v139 = (double *)((char *)v139 + v56);
                  v63 = v60 - v61;
                  v64 = *v62;
                  v65 = v142;
                  v142 = (double *)((char *)v142 + v56);
                  --v57;
                  v53 = v63 - v64 * *((double *)v55 - 4) - *((double *)v55 - 3) * *v65;
                }
                while ( v57 );
                v51 = (int)Srcc;
                v7 = (char *)Block;
                v54 = v166;
              }
              if ( v54 < v30 )
              {
                v66 = v54 + v144;
                v67 = v30 - v54;
                v68 = (double *)&v7[8 * v30 + 8 * a4 * v54];
                for ( j = (double *)&v7[8 * v66]; ; ++j )
                {
                  v70 = *j * *v68;
                  v68 += a4;
                  --v67;
                  v53 = v53 - v70;
                  if ( !v67 )
                    break;
                }
                v51 = (int)Srcc;
              }
              *v157 = v53;
              v71 = fabs(v53) * *(double *)&v155[8 * v51];
              if ( v71 >= v52 )
              {
                v52 = v71;
                v164 = v51;
              }
              v144 += a4;
              v146 += 8 * a4;
              v157 += a4;
              Srcc = (void *)++v51;
            }
            while ( v51 < a4 );
          }
          if ( v30 != v164 )
          {
            v72 = 0;
            v167 = 0;
            if ( a4 >= 4 )
            {
              v73 = (double *)v152;
              v167 = 4 * (((unsigned int)(a4 - 4) >> 2) + 1);
              v74 = ((unsigned int)(a4 - 4) >> 2) + 1;
              v75 = (int)&v7[8 * a4 * v164 + 16];
              do
              {
                v76 = *(double *)(v75 - 16);
                v73 += 4;
                v75 += 32;
                --v74;
                *(double *)(v75 - 48) = *(v73 - 4);
                *(v73 - 4) = v76;
                v77 = *(double *)(v75 - 40);
                *(double *)(v75 - 40) = *(v73 - 3);
                *(v73 - 3) = v77;
                v78 = *(double *)(v75 - 32);
                *(double *)(v75 - 32) = *(v73 - 2);
                *(v73 - 2) = v78;
                v79 = *(double *)(v75 - 24);
                *(double *)(v75 - 24) = *(v73 - 1);
                *(v73 - 1) = v79;
              }
              while ( v74 );
              v72 = 4 * (((unsigned int)(a4 - 4) >> 2) + 1);
            }
            if ( v72 < a4 )
            {
              v80 = v72 + v161;
              v81 = (double *)&v7[8 * v72 + 8 * a4 * v164];
              v82 = a4 - v167;
              v83 = (double *)&v7[8 * v80];
              do
              {
                v84 = *v81++;
                v85 = *v83++;
                --v82;
                *(v81 - 1) = v85;
                *(v83 - 1) = v84;
              }
              while ( v82 );
            }
            *(double *)&v155[8 * v164] = *(double *)((char *)v162 + v127);
          }
          *(_DWORD *)&v128[4 * v30] = v164;
          if ( v10 == *v159 )
            *v159 = 2.220446049250313e-16;
          if ( v30 != a4 - 1 )
          {
            v86 = 1.0 / *v159;
            v87 = v30 + 1;
            if ( v30 + 1 < a4 )
            {
              if ( v129 >= 4 )
              {
                v158 = (double *)&v7[8 * v30 + 8 * a4 + 8 * v161];
                v140 = (double *)&v7[8 * a4 + 8 * v30 + 8 * v148];
                v137 = (double *)&v7[8 * v30 + 8 * v148];
                v133 = (double *)&v7[8 * a4 + 8 * v30 + 8 * a4 + 8 * v161];
                v88 = 32 * a4;
                v89 = ((unsigned int)(a4 - v87 - 4) >> 2) + 1;
                Srcd = (void *)(v87 + 4 * v89);
                do
                {
                  v90 = v158;
                  v91 = *v158;
                  v158 = (double *)((char *)v158 + v88);
                  *v90 = v91 * v86;
                  v92 = v133;
                  v93 = *v133;
                  v133 = (double *)((char *)v133 + v88);
                  *v92 = v93 * v86;
                  v94 = v137;
                  v95 = *v137;
                  v137 = (double *)((char *)v137 + v88);
                  *v94 = v95 * v86;
                  v96 = v140;
                  v97 = *v140;
                  v140 = (double *)((char *)v140 + v88);
                  --v89;
                  *v96 = v97 * v86;
                }
                while ( v89 );
                v87 = (int)Srcd;
              }
              if ( v87 < a4 )
              {
                v98 = (double *)&v7[8 * v30 + 8 * a4 * v87];
                v99 = a4 - v87;
                do
                {
                  *v98 = *v98 * v86;
                  v98 += a4;
                  --v99;
                }
                while ( v99 );
              }
            }
          }
          --v129;
          v161 += a4;
          v148 += a4;
          v152 += 8 * a4;
          v159 = (double *)((char *)v159 + v126);
          ++v154;
          ++v162;
          ++v30;
        }
        while ( v30 < a4 );
      }
      v100 = a3;
      v101 = 0;
      v102 = 0;
      v168 = 0;
      Srce = 0;
      if ( a4 > 0 )
      {
        v149 = 0;
        while ( 1 )
        {
          v103 = *(_DWORD *)&v128[4 * v101];
          v104 = *(double *)&a3[8 * v103];
          *(double *)&a3[8 * v103] = *(double *)&a3[8 * v101];
          if ( v102 )
          {
            v105 = v102 - 1;
            if ( v102 - 1 < v101 )
            {
              if ( v101 - v105 >= 4 )
              {
                v163 = (double *)&a3[8 * v105 + 16];
                v106 = ((unsigned int)(v101 - v105 - 4) >> 2) + 1;
                v160 = (double *)&v7[8 * v105 + 8 * v149];
                v105 += 4 * v106;
                do
                {
                  v107 = v104 - *(v163 - 2) * *v160 - v160[1] * *(v163 - 1);
                  v108 = v160[2] * *v163;
                  v109 = v160;
                  v160 += 4;
                  v110 = v107 - v108;
                  v111 = v109[3] * v163[1];
                  v163 += 4;
                  --v106;
                  v104 = v110 - v111;
                }
                while ( v106 );
                v101 = (int)Srce;
              }
              if ( v105 < v101 )
              {
                v112 = (double *)&v7[8 * v105 + 8 * v149];
                do
                {
                  v113 = *(double *)&a3[8 * v105++];
                  v114 = v113 * *v112++;
                  v104 = v104 - v114;
                }
                while ( v105 < v101 );
              }
            }
          }
          else if ( v10 != v104 )
          {
            v168 = v101 + 1;
          }
          v149 += a4;
          *(double *)&a3[8 * v101++] = v104;
          Srce = (void *)v101;
          if ( v101 >= a4 )
            break;
          v102 = v168;
        }
      }
      v115 = a4 - 1;
      Srcf = (void *)(a4 - 1);
      if ( a4 - 1 >= 0 )
      {
        v153 = a4 * v115;
        v150 = a4;
        v134 = (double *)&v7[v115 * (8 * a4 + 8)];
        v130 = 0;
        do
        {
          v116 = v150;
          v117 = *(double *)&v100[8 * v115];
          if ( v150 < a4 )
          {
            if ( v130 >= 4 )
            {
              v118 = (int)&v100[8 * v115 + 24];
              v119 = ((unsigned int)(a4 - v150 - 4) >> 2) + 1;
              v120 = (double *)&v7[8 * v150 + 8 * v153];
              v116 = v150 + 4 * v119;
              do
              {
                v120 += 4;
                v121 = *(double *)(v118 - 16) * *(v120 - 4);
                v118 += 32;
                --v119;
                v117 = v117
                     - v121
                     - *(v120 - 3) * *(double *)(v118 - 40)
                     - *(v120 - 2) * *(double *)(v118 - 32)
                     - *(v120 - 1) * *(double *)(v118 - 24);
              }
              while ( v119 );
              v100 = a3;
              v115 = (int)Srcf;
            }
            if ( v116 < a4 )
            {
              v122 = (double *)&v7[8 * v116 + 8 * v153];
              do
              {
                v123 = *(double *)&v100[8 * v116++];
                v124 = v123 * *v122++;
                v117 = v117 - v124;
              }
              while ( v116 < a4 );
            }
          }
          ++v130;
          --v150;
          *(double *)&v100[8 * v115--] = v117 / *v134;
          v153 -= a4;
          v134 = (double *)((char *)v134 - 8 - 8 * a4);
          Srcf = (void *)v115;
        }
        while ( v115 >= 0 );
      }
      return 1;
    }
    else
    {
      v147 = 0;
      v151 = (double *)v7;
      while ( 1 )
      {
        v11 = 0;
        v12 = v10;
        if ( a4 >= 4 )
        {
          v13 = v151;
          v14 = ((unsigned int)(a4 - 4) >> 2) + 1;
          v11 = 4 * v14;
          do
          {
            v15 = v12;
            v16 = v10;
            v17 = v15;
            v18 = *v13;
            if ( v16 > v18 )
              v18 = -v18;
            if ( v18 > v17 )
              v17 = v18;
            v19 = v13[1];
            if ( v16 > v19 )
              v19 = -v19;
            if ( v19 > v17 )
              v17 = v19;
            v20 = v13[2];
            if ( v16 > v20 )
              v20 = -v20;
            if ( v20 > v17 )
              v17 = v20;
            v21 = v13[3];
            if ( v16 > v21 )
              v21 = -v21;
            if ( v21 > v17 )
              v17 = v21;
            v13 += 4;
            v22 = v16;
            v12 = v17;
            v10 = v22;
            --v14;
          }
          while ( v14 );
        }
        if ( v11 < a4 )
        {
          v23 = (double *)&v7[8 * v11 + 8 * v147];
          v24 = a4 - v11;
          do
          {
            v25 = v12;
            v26 = v10;
            v27 = v25;
            v28 = *v23;
            if ( v26 > v28 )
              v28 = -v28;
            if ( v28 > v27 )
              v27 = v28;
            ++v23;
            v29 = v26;
            v12 = v27;
            v10 = v29;
            --v24;
          }
          while ( v24 );
        }
        if ( v10 == v12 )
          break;
        v147 += a4;
        v9 = 8 * a4;
        v151 += a4;
        ++Srca;
        *(double *)&v155[8 * Srca - 8] = 1.0 / v12;
        if ( Srca >= a4 )
          goto LABEL_41;
      }
      v49 = _iob_func();
      fprintf(v49 + 2, "Singular matrix A in dAx_eq_b_LU_noLapack()!\n");
      return 0;
    }
  }
  else
  {
    if ( Block )
      free(Block);
    Block = 0;
    dword_5019A8 = 0;
    return 1;
  }
}
// 5019A8: using guessed type int dword_5019A8;

//----- (004035E0) --------------------------------------------------------
int sub_4035E0()
{
  return atexit(sub_438C40);
}

//----- (004035F0) --------------------------------------------------------
int sub_4035F0()
{
  return atexit(sub_438C50);
}

//----- (00403600) --------------------------------------------------------
int sub_403600()
{
  return atexit(sub_438C60);
}

//----- (00403610) --------------------------------------------------------
_DWORD *__thiscall sub_403610(_DWORD *this, char a2)
{
  *this = &std::error_category::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 43922C: using guessed type void *std::error_category::`vftable';

//----- (00403640) --------------------------------------------------------
void __thiscall __noreturn sub_403640(_DWORD *this, int a2, size_t Size)
{
  int v3; // esi
  unsigned int v4; // edi
  unsigned int v5; // ebx
  unsigned int v6; // ecx
  void *v7; // eax
  const void *v8; // ecx
  int v9; // eax
  _BYTE v10[16]; // [esp+0h] [ebp-28h] BYREF
  _DWORD *v11; // [esp+10h] [ebp-18h]
  unsigned int v12; // [esp+14h] [ebp-14h]
  _BYTE *v13; // [esp+18h] [ebp-10h]
  int v14; // [esp+24h] [ebp-4h]
  void *v15; // [esp+30h] [ebp+8h]

  v13 = v10;
  v3 = (int)this;
  v11 = this;
  v4 = a2 | 0xF;
  if ( (a2 | 0xF) == -1 )
  {
    v4 = a2;
  }
  else
  {
    v5 = this[5];
    v6 = v5 >> 1;
    if ( v5 >> 1 > v4 / 3 )
    {
      v4 = v6 + v5;
      if ( v5 > -2 - v6 )
        v4 = -2;
    }
  }
  v14 = 0;
  v7 = 0;
  v12 = 0;
  if ( v4 != -1 )
  {
    v7 = operator new(v4 + 1);
    v12 = (unsigned int)v7;
    if ( !v7 )
    {
      std::_Xbad_alloc();
      v12 = a2;
      v13 = v10;
      LOBYTE(v14) = 2;
      v15 = sub_403790(a2 + 1);
      v4 = v12;
      v7 = v15;
      v3 = (int)v11;
      v12 = (unsigned int)v15;
    }
  }
  if ( Size )
  {
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v8 = (const void *)v3;
    else
      v8 = *(const void **)v3;
    memcpy(v7, v8, Size);
  }
  if ( *(_DWORD *)(v3 + 20) >= 0x10u )
    operator delete(*(void **)v3);
  v9 = v12;
  *(_BYTE *)v3 = 0;
  *(_DWORD *)v3 = v9;
  *(_DWORD *)(v3 + 20) = v4;
  *(_DWORD *)(v3 + 16) = Size;
  if ( v4 >= 0x10 )
    v3 = v9;
  *(_BYTE *)(v3 + Size) = 0;
}
// 403744: conditional instruction was optimized away because %Size.4!=0
// 43903C: using guessed type void __cdecl std::_Xbad_alloc();

//----- (00403790) --------------------------------------------------------
void *__stdcall sub_403790(unsigned int a1)
{
  void *v1; // ecx

  v1 = 0;
  if ( a1 )
  {
    v1 = operator new(a1);
    if ( !v1 )
      std::_Xbad_alloc();
  }
  return v1;
}
// 4037B6: variable 'v1' is possibly undefined
// 43903C: using guessed type void __cdecl std::_Xbad_alloc();

//----- (004037C0) --------------------------------------------------------
_DWORD *__thiscall sub_4037C0(_DWORD *this, _DWORD *a2, unsigned int a3, size_t Size)
{
  _DWORD *v4; // ebx
  unsigned int v6; // ecx
  unsigned int v7; // edi
  size_t v8; // edi
  size_t v9; // eax
  bool v10; // cf
  _DWORD *result; // eax
  unsigned int v12; // eax
  void *v13; // edx

  v4 = a2;
  v6 = a3;
  v7 = a2[4];
  if ( v7 < a3 )
    std::_Xout_of_range("invalid string position");
  v8 = v7 - v6;
  if ( Size < v8 )
    v8 = Size;
  if ( this == a2 )
  {
    v9 = v8 + v6;
    if ( this[4] < v8 + v6 )
      std::_Xout_of_range("invalid string position");
    v10 = this[5] < 0x10u;
    this[4] = v9;
    if ( v10 )
      *((_BYTE *)this + v9) = 0;
    else
      *(_BYTE *)(*this + v9) = 0;
    sub_403AA0(this, 0, v6);
    return this;
  }
  else
  {
    if ( v8 == -1 )
      std::_Xlength_error("string too long");
    v12 = this[5];
    if ( v12 < v8 )
      sub_403640(this, v8, this[4]);
    if ( v8 )
    {
      if ( a2[5] >= 0x10u )
        v4 = (_DWORD *)*a2;
      if ( this[5] < 0x10u )
        v13 = this;
      else
        v13 = (void *)*this;
      memcpy(v13, (char *)v4 + v6, v8);
      v10 = this[5] < 0x10u;
      this[4] = v8;
      if ( v10 )
        *((_BYTE *)this + v8) = 0;
      else
        *(_BYTE *)(*this + v8) = 0;
      return this;
    }
    else
    {
      this[4] = 0;
      if ( v12 < 0x10 )
      {
        result = this;
        *(_BYTE *)this = 0;
      }
      else
      {
        *(_BYTE *)*this = 0;
        return this;
      }
    }
  }
  return result;
}
// 4038A0: conditional instruction was optimized away because edi.4 is in (1..FFFFFFFE)
// 4037E0: variable 'v6' is possibly undefined
// 403804: variable 'v9' is possibly undefined
// 439034: using guessed type void __cdecl std::_Xout_of_range(const char *);
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (004038E0) --------------------------------------------------------
_DWORD *__thiscall sub_4038E0(_DWORD *this, _BYTE *Src, size_t Size)
{
  unsigned int v4; // ecx
  _DWORD *v5; // eax
  _DWORD *v6; // edx
  _DWORD *result; // eax
  size_t v8; // eax
  void *v9; // eax
  bool v10; // cf

  if ( Src
    && ((v4 = this[5], v4 < 0x10) ? (v5 = this) : (v5 = (_DWORD *)*this),
        Src >= (_BYTE *)v5 && (v4 < 0x10 ? (v6 = this) : (v6 = (_DWORD *)*this), (char *)v6 + this[4] > Src)) )
  {
    if ( v4 < 0x10 )
      return sub_4037C0(this, this, Src - (_BYTE *)this, Size);
    else
      return sub_4037C0(this, this, (unsigned int)&Src[-*this], Size);
  }
  else
  {
    if ( Size == -1 )
      std::_Xlength_error("string too long");
    v8 = this[5];
    if ( v8 < Size )
      sub_403640(this, Size, this[4]);
    if ( Size )
    {
      if ( this[5] < 0x10u )
        v9 = this;
      else
        v9 = (void *)*this;
      memcpy(v9, Src, Size);
      v10 = this[5] < 0x10u;
      this[4] = Size;
      if ( v10 )
        *((_BYTE *)this + Size) = 0;
      else
        *(_BYTE *)(*this + Size) = 0;
      return this;
    }
    else
    {
      this[4] = 0;
      if ( v8 < 0x10 )
      {
        result = this;
        *(_BYTE *)this = 0;
      }
      else
      {
        *(_BYTE *)*this = 0;
        return this;
      }
    }
  }
  return result;
}
// 4039A3: conditional instruction was optimized away because %Size.4 is in (1..FFFFFFFE)
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (004039E0) --------------------------------------------------------
_DWORD *__stdcall sub_4039E0(_DWORD *a1, int a2)
{
  bool v2; // zf
  _DWORD *result; // eax

  v2 = std::_Syserror_map(a2) == 0;
  result = a1;
  *a1 = a2;
  if ( v2 )
    a1[1] = &off_43E008;
  else
    a1[1] = off_43E000;
  return result;
}
// 439030: using guessed type const char *__cdecl std::_Syserror_map(_DWORD);
// 43E000: using guessed type int (__thiscall **off_43E000[3])(void *, char);
// 43E008: using guessed type int (__thiscall **off_43E008)(void *, char);

//----- (00403A40) --------------------------------------------------------
bool __thiscall sub_403A40(void *this, _DWORD *a2, int a3)
{
  return this == (void *)a2[1] && *a2 == a3;
}

//----- (00403A60) --------------------------------------------------------
bool __thiscall sub_403A60(void *this, int a2, _DWORD *a3)
{
  _DWORD *v3; // eax
  char v5[8]; // [esp+0h] [ebp-8h] BYREF

  v3 = (_DWORD *)(*(int (__thiscall **)(void *, char *, int))(*(_DWORD *)this + 12))(this, v5, a2);
  return v3[1] == a3[1] && *v3 == *a3;
}
// 403A60: using guessed type char var_8[8];

//----- (00403AA0) --------------------------------------------------------
_DWORD *__thiscall sub_403AA0(_DWORD *this, unsigned int a2, unsigned int a3)
{
  unsigned int v4; // ecx
  unsigned int v5; // edi
  bool v6; // cf
  _DWORD *result; // eax
  _DWORD *v8; // eax
  unsigned int v9; // edi

  v4 = a2;
  v5 = this[4];
  if ( v5 < a2 )
    std::_Xout_of_range("invalid string position");
  if ( v5 - v4 > a3 )
  {
    if ( a3 )
    {
      if ( this[5] < 0x10u )
        v8 = this;
      else
        v8 = (_DWORD *)*this;
      v9 = v5 - a3;
      if ( v9 != v4 )
        memmove((char *)v8 + v4, (char *)v8 + v4 + a3, v9 - v4);
      v6 = this[5] < 0x10u;
      this[4] = v9;
      if ( !v6 )
      {
        *(_BYTE *)(*this + v9) = 0;
        return this;
      }
      *((_BYTE *)this + v9) = 0;
    }
    return this;
  }
  else
  {
    v6 = this[5] < 0x10u;
    this[4] = v4;
    if ( v6 )
    {
      result = this;
      *((_BYTE *)this + v4) = 0;
    }
    else
    {
      *(_BYTE *)(*this + v4) = 0;
      return this;
    }
  }
  return result;
}
// 403AC1: variable 'v4' is possibly undefined
// 439034: using guessed type void __cdecl std::_Xout_of_range(const char *);

//----- (00403B40) --------------------------------------------------------
_DWORD *__stdcall sub_403B40(_DWORD *a1, int a2)
{
  const char *v2; // eax
  char *v3; // edx

  v2 = std::_Syserror_map(a2);
  v3 = "unknown error";
  if ( v2 )
    v3 = (char *)v2;
  a1[5] = 15;
  a1[4] = 0;
  *(_BYTE *)a1 = 0;
  if ( *v3 )
    sub_4038E0(a1, v3, strlen(v3));
  else
    sub_4038E0(a1, v3, 0);
  return a1;
}
// 439030: using guessed type const char *__cdecl std::_Syserror_map(_DWORD);

//----- (00403BC0) --------------------------------------------------------
_DWORD *__stdcall sub_403BC0(_DWORD *a1, int a2)
{
  if ( a2 == 1 )
  {
    a1[5] = 15;
    a1[4] = 0;
    *(_BYTE *)a1 = 0;
    sub_4038E0(a1, "iostream stream error", 0x15u);
  }
  else
  {
    sub_403B40(a1, a2);
  }
  return a1;
}

//----- (00403C10) --------------------------------------------------------
_DWORD *__stdcall sub_403C10(_DWORD *a1, int a2)
{
  const char *v2; // eax
  char *v3; // edx

  v2 = std::_Winerror_map(a2);
  v3 = "unknown error";
  if ( v2 )
    v3 = (char *)v2;
  a1[5] = 15;
  a1[4] = 0;
  *(_BYTE *)a1 = 0;
  if ( *v3 )
    sub_4038E0(a1, v3, strlen(v3));
  else
    sub_4038E0(a1, v3, 0);
  return a1;
}
// 43902C: using guessed type const char *__cdecl std::_Winerror_map(_DWORD);

//----- (00403C90) --------------------------------------------------------
const char *sub_403C90()
{
  return "generic";
}

//----- (00403CA0) --------------------------------------------------------
const char *sub_403CA0()
{
  return "iostream";
}

//----- (00403CB0) --------------------------------------------------------
const char *sub_403CB0()
{
  return "system";
}

//----- (00403CC0) --------------------------------------------------------
int __thiscall sub_403CC0(int this, unsigned int a2)
{
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  if ( sub_403D80((_DWORD *)this, a2) )
  {
    if ( a2 )
      memset(*(void **)this, 0, 4 * a2);
    *(_DWORD *)(this + 4) += 4 * a2;
  }
  return this;
}

//----- (00403D10) --------------------------------------------------------
int *__thiscall sub_403D10(int *this, unsigned int a2)
{
  unsigned int v3; // eax
  int i; // edi

  sub_403CC0((int)this, a2);
  v3 = 0;
  for ( i = *this; v3 < (this[1] - *this) >> 2; i = *this )
    *(_DWORD *)(i + 4 * v3++) = -1;
  return this;
}

//----- (00403D50) --------------------------------------------------------
void __thiscall sub_403D50(int this)
{
  if ( *(_DWORD *)this )
  {
    operator delete(*(void **)this);
    *(_DWORD *)this = 0;
    *(_DWORD *)(this + 4) = 0;
    *(_DWORD *)(this + 8) = 0;
  }
}

//----- (00403D80) --------------------------------------------------------
char __thiscall sub_403D80(_DWORD *this, unsigned int a2)
{
  char *v4; // eax

  *this = 0;
  this[1] = 0;
  this[2] = 0;
  if ( !a2 )
    return 0;
  if ( a2 > 0x3FFFFFFF )
    std::_Xlength_error("vector<T> too long");
  v4 = (char *)operator new(4 * a2);
  if ( !v4 )
  {
    std::_Xbad_alloc();
    JUMPOUT(0x403DE7);
  }
  *this = v4;
  this[1] = v4;
  this[2] = &v4[4 * a2];
  return 1;
}
// 403DE1: control flows out of bounds to 403DE7
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);
// 43903C: using guessed type void __cdecl std::_Xbad_alloc();

//----- (00403DF0) --------------------------------------------------------
int __thiscall sub_403DF0(_DWORD *this, int a2)
{
  int result; // eax
  int v4; // ecx

  result = a2;
  v4 = *(_DWORD *)(4 * a2 + *this);
  if ( v4 >= 0 )
  {
    result = sub_403DF0(v4);
    *(_DWORD *)(4 * a2 + *this) = result;
  }
  return result;
}

//----- (00403E20) --------------------------------------------------------
int __thiscall sub_403E20(int *this, int a2, int a3)
{
  int v3; // ebx
  int *v4; // edx
  int result; // eax

  v3 = *(_DWORD *)(*this + 4 * a3);
  v4 = (int *)(*this + 4 * a2);
  result = *v4;
  if ( *v4 <= v3 )
  {
    if ( *v4 == v3 )
      *v4 = result - 1;
    result = *this;
    *(_DWORD *)(*this + 4 * a3) = a2;
  }
  else
  {
    *v4 = a3;
  }
  return result;
}

//----- (00403E60) --------------------------------------------------------
_DWORD *__thiscall sub_403E60(_DWORD *this)
{
  _DWORD *result; // eax

  *this = &CMyMatrix::`vftable';
  result = this;
  this[2] = 0;
  return result;
}
// 43931C: using guessed type void *CMyMatrix::`vftable';

//----- (00403E70) --------------------------------------------------------
int __thiscall sub_403E70(_DWORD *this)
{
  bool v1; // zf
  _DWORD *v2; // esi
  int result; // eax

  v1 = this[2] == 0;
  v2 = this + 2;
  *this = &CMyMatrix::`vftable';
  if ( !v1 )
  {
    result = cvReleaseMat(this + 2);
    *v2 = 0;
  }
  return result;
}
// 436842: using guessed type int __cdecl cvReleaseMat(_DWORD);
// 43931C: using guessed type void *CMyMatrix::`vftable';

//----- (00403EA0) --------------------------------------------------------
_DWORD *__thiscall sub_403EA0(_DWORD *this, char a2)
{
  bool v3; // zf
  _DWORD *v4; // edi

  v3 = this[2] == 0;
  v4 = this + 2;
  *this = &CMyMatrix::`vftable';
  if ( !v3 )
  {
    cvReleaseMat(this + 2);
    *v4 = 0;
  }
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 436842: using guessed type int __cdecl cvReleaseMat(_DWORD);
// 43931C: using guessed type void *CMyMatrix::`vftable';

//----- (00403EE0) --------------------------------------------------------
int __thiscall sub_403EE0(_DWORD *this)
{
  _DWORD *v1; // esi
  int result; // eax

  v1 = this + 2;
  if ( this[2] )
  {
    result = cvReleaseMat(this + 2);
    *v1 = 0;
  }
  return result;
}
// 436842: using guessed type int __cdecl cvReleaseMat(_DWORD);

//----- (00403F00) --------------------------------------------------------
char *__thiscall sub_403F00(char *this, char *a2)
{
  char *v2; // eax
  char *v4; // edx
  char v5; // cl

  v2 = a2;
  *(_DWORD *)this = &CMyTimer::`vftable';
  v4 = (char *)(this + 4 - a2);
  do
  {
    v5 = *v2++;
    v2[(_DWORD)v4 - 1] = v5;
  }
  while ( v5 );
  *((_DWORD *)this + 65) = GetTickCount();
  return this;
}
// 439324: using guessed type void *CMyTimer::`vftable';

//----- (00403F40) --------------------------------------------------------
int __thiscall sub_403F40(char *this)
{
  FILE *v2; // eax
  double v4; // [esp+0h] [ebp-Ch]

  *(_DWORD *)this = &CMyTimer::`vftable';
  v4 = (double)(GetTickCount() - *((_DWORD *)this + 65)) / 1000.0;
  v2 = _iob_func();
  return fprintf(v2 + 2, "%s = %lf (sec)\n", this + 4, v4);
}
// 439324: using guessed type void *CMyTimer::`vftable';

//----- (00403FA0) --------------------------------------------------------
char *__thiscall sub_403FA0(char *this, char a2)
{
  FILE *v3; // eax
  double v5; // [esp+0h] [ebp-Ch]

  *(_DWORD *)this = &CMyTimer::`vftable';
  v5 = (double)(GetTickCount() - *((_DWORD *)this + 65)) / 1000.0;
  v3 = _iob_func();
  fprintf(v3 + 2, "%s = %lf (sec)\n", this + 4, v5);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 439324: using guessed type void *CMyTimer::`vftable';

//----- (00404010) --------------------------------------------------------
int __cdecl sub_404010(int a1, int a2, int a3, _DWORD *a4, unsigned __int8 (__cdecl *a5)(_DWORD *, _DWORD *))
{
  int v5; // ecx
  unsigned __int8 (__cdecl *v6)(_DWORD *, _DWORD *); // edx
  int v7; // ebx
  int v8; // esi
  bool i; // zf

  v5 = a3;
  v6 = a5;
  v7 = a2;
  v8 = 2 * a2 + 2;
  for ( i = v8 == a3; v8 < a3; i = v8 == a3 )
  {
    if ( v6((_DWORD *)(a1 + 8 * v8), (_DWORD *)(a1 + 8 * v8 - 8)) )
      --v8;
    v5 = a3;
    v6 = a5;
    *(_DWORD *)(a1 + 8 * v7) = *(_DWORD *)(a1 + 8 * v8);
    *(_DWORD *)(a1 + 8 * v7 + 4) = *(_DWORD *)(a1 + 8 * v8 + 4);
    v7 = v8;
    v8 = 2 * v8 + 2;
  }
  if ( i )
  {
    *(_DWORD *)(a1 + 8 * v7) = *(_DWORD *)(a1 + 8 * v5 - 8);
    *(_DWORD *)(a1 + 8 * v7 + 4) = *(_DWORD *)(a1 + 8 * v5 - 4);
    v7 = v5 - 1;
  }
  return sub_404490(a1, v7, a2, a4, v6);
}

//----- (00404090) --------------------------------------------------------
__m128i *__cdecl sub_404090(const __m128i *a1, const __m128i *a2, __m128i *a3)
{
  const __m128i *v3; // ecx
  __m128i *result; // eax
  __int64 v5; // xmm0_8

  v3 = a1;
  for ( result = a3; v3 != a2; result = (__m128i *)((char *)result + 40) )
  {
    *result = _mm_loadu_si128(v3);
    result[1] = _mm_loadu_si128(v3 + 1);
    v5 = v3[2].m128i_i64[0];
    v3 = (const __m128i *)((char *)v3 + 40);
    result[2].m128i_i64[0] = v5;
  }
  return result;
}

//----- (004040D0) --------------------------------------------------------
int __cdecl sub_4040D0(const __m128i **a1, const __m128i **a2, int a3)
{
  int v3; // edi
  const __m128i **v4; // esi
  const __m128i *v5; // eax

  if ( a1 == a2 )
    return a3;
  v3 = a3;
  v4 = a1 + 5;
  do
  {
    *(_QWORD *)v3 = *(_QWORD *)(v4 - 5);
    sub_404AC0(v3 + 8, v4 - 3);
    v5 = *v4;
    v4 += 8;
    *(_DWORD *)(v3 + 20) = v5;
    *(_QWORD *)(v3 + 24) = *(_QWORD *)(v4 - 7);
    v3 += 32;
  }
  while ( v4 - 5 != a2 );
  return v3;
}

//----- (00404130) --------------------------------------------------------
void __cdecl sub_404130(int a1, int a2)
{
  int v2; // esi
  void *v3; // eax

  if ( a1 != a2 )
  {
    v2 = a1 + 8;
    do
    {
      v3 = *(void **)v2;
      *(_DWORD *)(v2 + 4) = *(_DWORD *)v2;
      if ( v3 )
      {
        operator delete(v3);
        *(_DWORD *)v2 = 0;
        *(_DWORD *)(v2 + 4) = 0;
        *(_DWORD *)(v2 + 8) = 0;
      }
      v2 += 32;
    }
    while ( v2 - 8 != a2 );
  }
}

//----- (00404180) --------------------------------------------------------
void __cdecl sub_404180(int *a1, int *a2, unsigned __int8 (__cdecl *a3)(int *, int *))
{
  unsigned __int8 (__cdecl *v3)(int *, int *); // edx
  int *v4; // ebx
  int *v5; // eax
  int *v6; // ecx
  int *v7; // edi
  _DWORD *v8; // esi
  int v9; // eax
  int *v10; // esi
  int *v11; // [esp+8h] [ebp-18h]
  int *v12; // [esp+Ch] [ebp-14h]
  int v13; // [esp+14h] [ebp-Ch] BYREF
  int v14; // [esp+18h] [ebp-8h]

  v3 = a3;
  v4 = a1;
  if ( a1 != a2 )
  {
    v5 = a1 + 2;
    v11 = a1 + 2;
    if ( a1 + 2 != a2 )
    {
      v6 = a1;
      v12 = a1;
      do
      {
        v7 = v5;
        v8 = v6 + 3;
        v13 = *v5;
        v14 = v6[3];
        if ( v3(&v13, v4) )
        {
          if ( v4 != v11 )
          {
            do
            {
              v9 = *(v8 - 3);
              v8 -= 2;
              v8[1] = v9;
              v8[2] = *v8;
            }
            while ( v8 - 1 != v4 );
          }
          *v4 = v13;
          v4[1] = v14;
        }
        else
        {
          v10 = v12;
          if ( a3(&v13, v12) )
          {
            do
            {
              *v7 = *v10;
              v7[1] = v10[1];
              v7 = v10;
              v10 -= 2;
            }
            while ( a3(&v13, v10) );
            v4 = a1;
          }
          *v7 = v13;
          v7[1] = v14;
        }
        v5 = v11 + 2;
        v3 = a3;
        v6 = v12 + 2;
        v11 = v5;
        v12 += 2;
      }
      while ( v5 != a2 );
    }
  }
}

//----- (00404280) --------------------------------------------------------
int __cdecl sub_404280(int a1, int a2, unsigned __int8 (__cdecl *a3)(_DWORD *, _DWORD *))
{
  int v3; // ecx
  int result; // eax
  int v5; // ebx
  int v6; // esi
  int v7; // eax
  int v8; // esi
  int v9; // edx
  int v10; // ecx
  int v11; // eax
  int v12; // [esp+Ch] [ebp-1Ch]
  int v13; // [esp+10h] [ebp-18h]
  int v14[2]; // [esp+1Ch] [ebp-Ch] BYREF

  v3 = (a2 - a1) >> 3;
  result = v3 - (v3 >> 31);
  v5 = v3 / 2;
  if ( v3 / 2 > 0 )
  {
    v6 = 2 * v5 + 2;
    do
    {
      v7 = *(_DWORD *)(a1 + 8 * v5-- - 8);
      v8 = v6 - 2;
      v14[0] = v7;
      v9 = v5;
      v12 = v8;
      v14[1] = *(_DWORD *)(a1 + 8 * v5 + 4);
      v13 = v5;
      if ( v8 < v3 )
      {
        do
        {
          if ( a3((_DWORD *)(a1 + 8 * v8), (_DWORD *)(a1 + 8 * v8 - 8)) )
            --v8;
          v10 = v13;
          v9 = v8;
          v13 = v8;
          *(_DWORD *)(a1 + 8 * v10) = *(_DWORD *)(a1 + 8 * v8);
          v11 = *(_DWORD *)(a1 + 8 * v8 + 4);
          v8 = 2 * v8 + 2;
          *(_DWORD *)(a1 + 8 * v10 + 4) = v11;
        }
        while ( v8 < (a2 - a1) >> 3 );
        v3 = (a2 - a1) >> 3;
      }
      if ( v8 == v3 )
      {
        *(_DWORD *)(a1 + 8 * v9) = *(_DWORD *)(a1 + 8 * v3 - 8);
        *(_DWORD *)(a1 + 8 * v9 + 4) = *(_DWORD *)(a1 + 8 * v3 - 4);
        v9 = v3 - 1;
      }
      result = sub_404490(a1, v9, v5, v14, a3);
      v3 = (a2 - a1) >> 3;
      v6 = v12;
    }
    while ( v5 > 0 );
  }
  return result;
}

//----- (00404370) --------------------------------------------------------
int __cdecl sub_404370(int *a1, int *a2, int *a3, unsigned __int8 (__cdecl *a4)(int *, int *))
{
  int v4; // ecx
  int v5; // ecx
  int result; // eax
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx

  if ( a4(a2, a1) && a2 != a1 )
  {
    v4 = *a2;
    *a2 = *a1;
    *a1 = v4;
    v5 = a2[1];
    a2[1] = a1[1];
    a1[1] = v5;
  }
  result = ((int (__cdecl *)(int *, int *))a4)(a3, a2);
  if ( (_BYTE)result )
  {
    if ( a3 != a2 )
    {
      v7 = *a3;
      *a3 = *a2;
      *a2 = v7;
      v8 = a3[1];
      a3[1] = a2[1];
      a2[1] = v8;
    }
    result = ((int (__cdecl *)(int *, int *))a4)(a2, a1);
    if ( (_BYTE)result )
    {
      if ( a2 != a1 )
      {
        v9 = *a2;
        *a2 = *a1;
        *a1 = v9;
        v10 = a2[1];
        result = a1[1];
        a2[1] = result;
        a1[1] = v10;
      }
    }
  }
  return result;
}

//----- (004043F0) --------------------------------------------------------
int __cdecl sub_4043F0(int *a1, int *a2, int *a3, unsigned __int8 (__cdecl *a4)(int *, int *))
{
  int v5; // eax
  int v6; // eax
  int v7; // ecx
  int v8; // ebx
  int *v9; // eax
  int v11; // [esp+10h] [ebp+8h]

  v5 = ((char *)a3 - (char *)a1) >> 3;
  if ( v5 <= 40 )
    return sub_404370(a1, a2, a3, a4);
  v6 = (v5 + 1) / 8;
  v7 = 16 * v6;
  v8 = 8 * v6;
  v9 = &a1[4 * v6];
  v11 = v7;
  sub_404370(a1, &a1[v8 / 4u], v9, a4);
  sub_404370(&a2[v8 / 0xFFFFFFFC], a2, &a2[v8 / 4u], a4);
  sub_404370((int *)((char *)a3 - v11), &a3[v8 / 0xFFFFFFFC], a3, a4);
  return sub_404370(&a1[v8 / 4u], a2, &a3[v8 / 0xFFFFFFFC], a4);
}

//----- (00404490) --------------------------------------------------------
int __cdecl sub_404490(int a1, int a2, int a3, _DWORD *a4, unsigned __int8 (__cdecl *a5)(_DWORD *, _DWORD *))
{
  int v5; // edi
  int v6; // esi
  _DWORD *v7; // edi
  int v8; // eax
  int v9; // edi
  int result; // eax

  v5 = a2;
  v6 = (a2 - 1) / 2;
  if ( a3 < a2 )
  {
    while ( 1 )
    {
      v7 = (_DWORD *)(a1 + 8 * v6);
      if ( !a5(v7, a4) )
        break;
      *(_DWORD *)(a1 + 8 * a2) = *v7;
      v8 = v7[1];
      v9 = v6;
      *(_DWORD *)(a1 + 8 * a2 + 4) = v8;
      a2 = v6;
      v6 = (v6 - 1) / 2;
      if ( a3 >= a2 )
      {
        *(_DWORD *)(a1 + 8 * v9) = *a4;
        result = a4[1];
        *(_DWORD *)(a1 + 8 * v9 + 4) = result;
        return result;
      }
    }
    v5 = a2;
  }
  *(_DWORD *)(a1 + 8 * v5) = *a4;
  result = a4[1];
  *(_DWORD *)(a1 + 8 * v5 + 4) = result;
  return result;
}

//----- (00404510) --------------------------------------------------------
void __cdecl sub_404510(int *a1, int *a2, int a3, unsigned __int8 (__cdecl *a4)(int *, int *))
{
  unsigned __int8 (__cdecl *v4)(int *, int *); // edx
  int *v5; // esi
  int *v6; // edi
  int v7; // ecx
  int *v9; // [esp+Ch] [ebp-8h] BYREF
  int *v10; // [esp+10h] [ebp-4h]

  v4 = a4;
  v5 = a2;
  v6 = a1;
  v7 = ((char *)a2 - (char *)a1) >> 3;
  if ( v7 <= 32 )
  {
LABEL_7:
    if ( v7 > 1 )
      sub_404180(v6, v5, v4);
  }
  else
  {
    while ( a3 > 0 )
    {
      sub_4046E0(&v9, v6, v5, v4);
      a3 = a3 / 2 / 2 + a3 / 2;
      if ( (int)(((char *)v9 - (char *)v6) & 0xFFFFFFF8) >= (int)(((char *)v5 - (char *)v10) & 0xFFFFFFF8) )
      {
        sub_404510(v10, v5, a3, a4);
        v5 = v9;
      }
      else
      {
        sub_404510(v6, v9, a3, a4);
        v6 = v10;
      }
      v4 = a4;
      v7 = ((char *)v5 - (char *)v6) >> 3;
      if ( v7 <= 32 )
        goto LABEL_7;
    }
    if ( (int)(((char *)v5 - (char *)v6) & 0xFFFFFFF8) > 8 )
    {
      sub_404280((int)v6, (int)v5, v4);
      v4 = a4;
    }
    sub_4045F0(v6, (int)v5, v4);
  }
}
// 4045BC: conditional instruction was optimized away because ecx.4>=21

//----- (004045F0) --------------------------------------------------------
signed int __cdecl sub_4045F0(int *a1, int a2, unsigned __int8 (__cdecl *a3)(_DWORD *, _DWORD *))
{
  unsigned __int8 (__cdecl *v3)(_DWORD *, _DWORD *); // ecx
  signed int result; // eax
  int *v5; // esi
  int v6[2]; // [esp+10h] [ebp-Ch] BYREF

  v3 = a3;
  result = (a2 - (_DWORD)a1) & 0xFFFFFFF8;
  if ( result > 8 )
  {
    v5 = (int *)(a2 - 4);
    do
    {
      v6[0] = *(v5 - 1);
      v6[1] = *v5;
      *(v5 - 1) = *a1;
      *v5 = a1[1];
      sub_404010((int)a1, 0, ((int)v5 - 4 - (int)a1) >> 3, v6, v3);
      v5 -= 2;
      v3 = a3;
      result = ((unsigned int)v5 + 4 - (_DWORD)a1) & 0xFFFFFFF8;
    }
    while ( result > 8 );
  }
  return result;
}

//----- (00404680) --------------------------------------------------------
__m128i *__stdcall sub_404680(const __m128i *a1, const __m128i *a2, __m128i *a3)
{
  return sub_404940(a1, a2, a3);
}

//----- (004046B0) --------------------------------------------------------
int __stdcall sub_4046B0(int a1, int a2, int a3)
{
  return sub_426AB0(a1, a2, a3);
}

//----- (004046E0) --------------------------------------------------------
int **__cdecl sub_4046E0(int **a1, int *a2, int *a3, unsigned __int8 (__cdecl *a4)(int *, int *))
{
  int *v4; // esi
  int *v5; // ebx
  int *v6; // edi
  int *v7; // edx
  unsigned int v8; // eax
  int *v9; // eax
  int *v10; // edx
  int v11; // ecx
  int v12; // ecx
  bool v13; // zf
  int *v14; // edi
  int *v15; // ebx
  int v16; // ecx
  int v17; // ecx
  int *v18; // eax
  int v19; // ecx
  int v20; // ecx
  int *v21; // eax
  int *v22; // ecx
  int v23; // ecx
  int v24; // ecx
  int v25; // ecx
  int v26; // ecx
  int v27; // ecx
  int v28; // ecx
  int v29; // ecx
  int v30; // ecx
  int **result; // eax
  int *v32; // [esp+Ch] [ebp-14h]
  int *v33; // [esp+10h] [ebp-10h]
  int *v34; // [esp+10h] [ebp-10h]
  int *v35; // [esp+10h] [ebp-10h]
  int *v36; // [esp+14h] [ebp-Ch]
  int *v37; // [esp+18h] [ebp-8h]
  int *v38; // [esp+1Ch] [ebp-4h]

  v4 = &a2[2 * ((((char *)a3 - (char *)a2) >> 3) / 2)];
  sub_4043F0(a2, v4, a3 - 2, a4);
  v5 = v4 + 2;
  v37 = v4 + 2;
  if ( a2 < v4 )
  {
    do
    {
      v33 = v4 - 2;
      if ( a4(v4 - 2, v4) )
        break;
      if ( a4(v4, v33) )
        break;
      v4 -= 2;
    }
    while ( a2 < v33 );
    v5 = v37;
  }
  if ( v5 < a3 )
  {
    do
    {
      if ( a4(v5, v4) )
        break;
      if ( a4(v4, v5) )
        break;
      v5 += 2;
    }
    while ( v5 < a3 );
    v37 = v5;
  }
  v6 = v5;
  v7 = v4;
  v36 = v5;
  v38 = v4;
  while ( 2 )
  {
    while ( 2 )
    {
      v8 = (unsigned int)a3;
LABEL_13:
      if ( (unsigned int)v6 < v8 )
      {
        v34 = v5 - 2;
        do
        {
          if ( !a4(v4, v6) )
          {
            if ( a4(v6, v4) )
              break;
            v9 = v5;
            v10 = v34 + 2;
            v5 += 2;
            v34 += 2;
            if ( v9 != v6 && v10 != v6 )
            {
              v11 = *v10;
              *v10 = *v6;
              *v6 = v11;
              v12 = v10[1];
              v10[1] = v6[1];
              v6[1] = v12;
            }
          }
          v6 += 2;
        }
        while ( v6 < a3 );
        v7 = v38;
        v37 = v5;
        v36 = v6;
      }
      v13 = v7 == a2;
      if ( v7 <= a2 )
        goto LABEL_32;
      v14 = v38;
      v15 = v38 - 2;
      while ( a4(v15, v4) )
      {
LABEL_28:
        v18 = a2;
        v14 -= 2;
        v15 -= 2;
        if ( a2 >= v14 )
          goto LABEL_31;
      }
      if ( !a4(v4, v15) )
      {
        v4 -= 2;
        if ( v4 != v15 )
        {
          v16 = *v4;
          *v4 = *v15;
          *v15 = v16;
          v17 = v4[1];
          v4[1] = v15[1];
          v15[1] = v17;
        }
        goto LABEL_28;
      }
      v18 = a2;
LABEL_31:
      v5 = v37;
      v38 = v14;
      v7 = v14;
      v13 = v14 == v18;
      v6 = v36;
LABEL_32:
      if ( !v13 )
      {
        v8 = (unsigned int)a3;
        v7 -= 2;
        v38 = v7;
        if ( v6 == a3 )
        {
          v4 -= 2;
          if ( v7 != v4 )
          {
            v25 = *v7;
            *v7 = *v4;
            *v4 = v25;
            v26 = v7[1];
            v7[1] = v4[1];
            v8 = (unsigned int)a3;
            v4[1] = v26;
          }
          v5 -= 2;
          v37 = v5;
          if ( v4 != v5 )
          {
            v27 = *v4;
            *v4 = *v5;
            *v5 = v27;
            v28 = v4[1];
            v4[1] = v5[1];
            v5[1] = v28;
            continue;
          }
        }
        else
        {
          if ( v6 != v7 )
          {
            v29 = *v6;
            *v6 = *v7;
            *v7 = v29;
            v30 = v6[1];
            v6[1] = v7[1];
            v8 = (unsigned int)a3;
            v7[1] = v30;
          }
          v6 += 2;
          v36 = v6;
        }
        goto LABEL_13;
      }
      break;
    }
    if ( v6 != a3 )
    {
      if ( v5 != v6 && v4 != v5 )
      {
        v19 = *v4;
        *v4 = *v5;
        *v5 = v19;
        v20 = v4[1];
        v4[1] = v5[1];
        v5[1] = v20;
      }
      v21 = v6;
      v22 = v4;
      v5 += 2;
      v32 = v6;
      v6 += 2;
      v37 = v5;
      v4 += 2;
      v35 = v22;
      v36 = v6;
      if ( v22 != v32 )
      {
        v23 = *v22;
        *v35 = *v21;
        *v32 = v23;
        v24 = v35[1];
        v35[1] = v32[1];
        v7 = v38;
        v32[1] = v24;
      }
      continue;
    }
    break;
  }
  result = a1;
  *a1 = v4;
  a1[1] = v5;
  return result;
}

//----- (00404940) --------------------------------------------------------
__m128i *__cdecl sub_404940(const __m128i *a1, const __m128i *a2, __m128i *a3)
{
  const __m128i *v3; // ecx
  __m128i *result; // eax

  v3 = a1;
  for ( result = a3; v3 != a2; result = (__m128i *)((char *)result + 40) )
  {
    if ( result )
    {
      *result = _mm_loadu_si128(v3);
      result[1] = _mm_loadu_si128(v3 + 1);
      result[2].m128i_i64[0] = v3[2].m128i_i64[0];
    }
    v3 = (const __m128i *)((char *)v3 + 40);
  }
  return result;
}

//----- (00404980) --------------------------------------------------------
_DWORD *__cdecl sub_404980(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // ecx
  _DWORD *v4; // esi

  v3 = a1;
  if ( a1 == a2 )
    return a3;
  v4 = a3;
  do
  {
    if ( v4 )
    {
      *v4 = *v3;
      v4[1] = v3[1];
    }
    v3 += 2;
    v4 += 2;
  }
  while ( v3 != a2 );
  return v4;
}

//----- (004049C0) --------------------------------------------------------
void __stdcall sub_4049C0(_DWORD *a1)
{
  void *v1; // eax

  v1 = (void *)a1[2];
  a1[3] = v1;
  if ( v1 )
  {
    operator delete(v1);
    a1[2] = 0;
    a1[3] = 0;
    a1[4] = 0;
  }
}

//----- (00404A00) --------------------------------------------------------
int __thiscall sub_404A00(int this, const __m128i **a2)
{
  int v3; // edx
  _DWORD v5[10]; // [esp+0h] [ebp-28h] BYREF

  v5[6] = v5;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  v3 = (unsigned __int64)(1717986919i64 * ((char *)a2[1] - (char *)*a2)) >> 32;
  v5[4] = this;
  if ( sub_405320((_DWORD *)this, (v3 >> 4) + ((unsigned int)v3 >> 31)) )
  {
    v5[9] = 0;
    *(_DWORD *)(this + 4) = sub_404940(*a2, a2[1], *(__m128i **)this);
  }
  return this;
}

//----- (00404AC0) --------------------------------------------------------
int __thiscall sub_404AC0(int this, const __m128i **a2)
{
  const __m128i *v3; // ecx
  __m128i *v4; // eax
  __m128i *v6; // esi
  int v7; // edx
  int v8; // ecx
  const __m128i *v9; // esi
  __m128i *v10; // [esp-4h] [ebp-34h]
  int v11; // [esp+0h] [ebp-30h] BYREF
  int v12; // [esp+10h] [ebp-20h]
  int v13; // [esp+14h] [ebp-1Ch]
  unsigned int v14; // [esp+18h] [ebp-18h]
  int *v15; // [esp+20h] [ebp-10h]
  int v16; // [esp+2Ch] [ebp-4h]

  v15 = &v11;
  v13 = this;
  if ( (const __m128i **)this != a2 )
  {
    v3 = a2[1];
    if ( *a2 == v3 )
    {
      v4 = *(__m128i **)this;
LABEL_4:
      *(_DWORD *)(this + 4) = v4;
      return this;
    }
    v6 = *(__m128i **)this;
    v7 = (unsigned __int64)(1717986919i64 * ((char *)v3 - (char *)*a2)) >> 32;
    v8 = *(_DWORD *)(this + 4) - *(_DWORD *)this;
    v14 = (v7 >> 4) + ((unsigned int)v7 >> 31);
    v12 = v8 / 40;
    if ( v14 <= v8 / 40 )
    {
      sub_404090(*a2, a2[1], v6);
      v4 = (__m128i *)(*(_DWORD *)this + 40 * (((char *)a2[1] - (char *)*a2) / 40));
      goto LABEL_4;
    }
    if ( v14 <= (*(_DWORD *)(this + 8) - (int)v6) / 40 )
    {
      v9 = (const __m128i *)((char *)*a2 + 40 * v12);
      sub_404090(*a2, v9, *(__m128i **)this);
      v4 = sub_404940(v9, a2[1], *(__m128i **)(this + 4));
      goto LABEL_4;
    }
    if ( v6 )
      operator delete(v6);
    if ( sub_405320((_DWORD *)this, ((char *)a2[1] - (char *)*a2) / 40) )
    {
      v10 = *(__m128i **)this;
      v16 = 0;
      v4 = sub_404680(*a2, a2[1], v10);
      goto LABEL_4;
    }
  }
  return this;
}

//----- (00404C30) --------------------------------------------------------
int *__thiscall sub_404C30(int *this, const __m128i ***a2)
{
  const __m128i **v3; // eax
  const __m128i **v4; // ecx
  unsigned int v5; // eax
  int v7; // edx
  unsigned int v8; // ecx
  unsigned int v9; // ebx
  int v10; // eax
  const __m128i **v11; // ebx
  int v12; // [esp-4h] [ebp-2Ch]
  _DWORD v13[10]; // [esp+0h] [ebp-28h] BYREF

  v13[6] = v13;
  v13[4] = this;
  if ( this != (int *)a2 )
  {
    v3 = *a2;
    v4 = a2[1];
    if ( *a2 == v4 )
    {
      sub_404130(*this, this[1]);
      v5 = *this;
LABEL_4:
      this[1] = v5;
      return this;
    }
    v7 = *this;
    v8 = ((char *)v4 - (char *)v3) >> 5;
    v9 = (this[1] - *this) >> 5;
    if ( v8 <= v9 )
    {
      v10 = sub_4040D0(v3, a2[1], v7);
      sub_404130(v10, this[1]);
      v5 = *this + (((char *)a2[1] - (char *)*a2) & 0xFFFFFFE0);
      goto LABEL_4;
    }
    if ( v8 <= (this[2] - v7) >> 5 )
    {
      v11 = &(*a2)[8 * v9];
      sub_4040D0(*a2, v11, v7);
      v5 = sub_426AB0((int)v11, (int)a2[1], this[1]);
      goto LABEL_4;
    }
    if ( v7 )
    {
      sub_404130(v7, this[1]);
      operator delete((void *)*this);
    }
    if ( sub_405390(this, ((char *)a2[1] - (char *)*a2) >> 5) )
    {
      v12 = *this;
      v13[9] = 0;
      v5 = sub_4046B0((int)*a2, (int)a2[1], v12);
      goto LABEL_4;
    }
  }
  return this;
}

//----- (00404D80) --------------------------------------------------------
int __stdcall sub_404D80(_DWORD *a1, _DWORD *a2)
{
  int v2; // ebx
  _DWORD *v3; // edi
  int v4; // esi
  int v5; // edi
  int result; // eax
  unsigned int v7; // [esp+Ch] [ebp-4h]

  v2 = 0;
  v3 = a2;
  a1[49] = a1[48];
  v7 = 0;
  v4 = *a2;
  if ( (v3[1] - *v3) / 40 )
  {
    v5 = 0;
    do
    {
      sub_4214D0(a1 + 48, (const __m128i *)(v5 + v4));
      v4 = *a2;
      if ( *(_BYTE *)(v5 + *a2 + 32) == 1 )
        ++v2;
      v5 += 40;
      ++v7;
    }
    while ( v7 < (a2[1] - v4) / 40 );
    v3 = a2;
  }
  result = (v3[1] - *v3) / 40;
  a1[7] = v2;
  a1[6] = result;
  return result;
}

//----- (00404E30) --------------------------------------------------------
double __thiscall sub_404E30(_DWORD *this)
{
  double v1; // xmm1_8
  int v2; // ebx
  int v3; // edi
  _DWORD *v4; // eax
  int v5; // esi
  int v6; // edi
  int v8; // [esp+0h] [ebp-28h]
  int v9; // [esp+4h] [ebp-24h]
  int v10; // [esp+8h] [ebp-20h]
  int v11; // [esp+Ch] [ebp-1Ch]
  int v12; // [esp+10h] [ebp-18h]
  int v13; // [esp+14h] [ebp-14h]
  int v14; // [esp+18h] [ebp-10h]
  int v15; // [esp+1Ch] [ebp-Ch]
  double v16; // [esp+20h] [ebp-8h]

  v1 = 0.0;
  v2 = 0;
  v3 = (this[3] - this[2]) >> 5;
  v13 = v3;
  v16 = 0.0;
  if ( v3 > 0 )
  {
    v14 = this[2];
    v4 = (_DWORD *)(v14 + 8);
    v11 = 0;
    v12 = v14 + 8;
    do
    {
      v5 = 0;
      if ( (v4[1] - *v4) / 40 > 0 )
      {
        v6 = *(_DWORD *)(v11 + v14 + 8);
        v15 = (*(_DWORD *)(v11 + v14 + 12) - v6) / 40;
        do
        {
          ++v2;
          ++v5;
          v6 += 40;
          v1 = (double)(int)*(double *)libm_sse2_sqrt_precise(v8, v9, v10, v11).m128_u64 + v16;
          v16 = v1;
        }
        while ( v5 < v15 );
        v3 = v13;
      }
      v11 += 32;
      v4 = (_DWORD *)(v12 + 32);
      --v3;
      v12 += 32;
      v13 = v3;
    }
    while ( v3 );
  }
  return v1 / (double)v2;
}
// 404EBC: variable 'v8' is possibly undefined
// 404EBC: variable 'v9' is possibly undefined
// 404EBC: variable 'v10' is possibly undefined
// 404EBC: variable 'v11' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00404F30) --------------------------------------------------------
int __thiscall sub_404F30(_DWORD *this)
{
  int v1; // edi
  int v2; // ebx
  int v3; // eax
  int v4; // esi
  int v5; // ecx
  int v6; // esi
  int v7; // ecx
  int v9; // [esp+8h] [ebp-4h]

  v1 = 0;
  v2 = 0;
  v3 = this[3] - this[2];
  if ( v3 >= 0 && (v3 & 0xFFFFFFE0) != 0 )
  {
    v4 = this[2];
    v5 = (this[3] - v4) >> 5;
    v6 = v4 + 8;
    v9 = v5;
    do
    {
      v7 = *(_DWORD *)(v6 + 4);
      v6 += 32;
      ++v2;
      v1 += (v7 - *(_DWORD *)(v6 - 32)) / 40;
    }
    while ( v2 < v9 );
  }
  return v1;
}

//----- (00404F90) --------------------------------------------------------
void __thiscall sub_404F90(_DWORD *this, _DWORD *a2)
{
  int v2; // esi
  int v3; // esi
  int *v4; // edi
  int *v5; // ecx
  int v6; // ebx
  int v7; // esi
  int v8; // esi
  int v9; // esi
  int v10; // edx
  int *v11; // esi
  int v12; // edi
  int v14[2]; // [esp+18h] [ebp-2Ch] BYREF
  int v15; // [esp+20h] [ebp-24h]
  int v16; // [esp+24h] [ebp-20h]
  __int64 v17; // [esp+28h] [ebp-1Ch] BYREF
  int *v18; // [esp+30h] [ebp-14h]
  int v19; // [esp+40h] [ebp-4h]

  v2 = this[3] - this[2];
  a2[1] = *a2;
  v3 = v2 / 56;
  v16 = v3;
  sub_405750(a2, v3);
  v4 = 0;
  v5 = 0;
  v17 = 0i64;
  v18 = 0;
  v6 = 0;
  v19 = 0;
  if ( v3 > 0 )
  {
    v7 = 0;
    v15 = 0;
    do
    {
      v14[1] = v6;
      v8 = (*(_DWORD *)(v7 + this[2] + 12) - *(_DWORD *)(v15 + this[2] + 8)) >> 5;
      v14[0] = v8;
      if ( v14 >= v5 || v4 > v14 )
      {
        if ( v5 == v18 )
        {
          sub_4055E0((int)&v17, 1u);
          v5 = (int *)HIDWORD(v17);
          v4 = (int *)v17;
        }
        if ( v5 )
        {
          *v5 = v8;
          v5[1] = v6;
        }
      }
      else
      {
        v9 = ((char *)v14 - (char *)v4) >> 3;
        if ( v5 == v18 )
        {
          sub_4055E0((int)&v17, 1u);
          v5 = (int *)HIDWORD(v17);
          v4 = (int *)v17;
        }
        if ( v5 )
        {
          *v5 = v4[2 * v9];
          v5[1] = v4[2 * v9 + 1];
        }
      }
      v5 += 2;
      ++v6;
      HIDWORD(v17) = v5;
      v7 = v15 + 56;
      v15 += 56;
    }
    while ( v6 < v16 );
    v3 = v16;
  }
  sub_404510(v4, v5, ((char *)v5 - (char *)v4) >> 3, (unsigned __int8 (__cdecl *)(int *, int *))sub_4056B0);
  v10 = 0;
  if ( v3 > 0 )
  {
    v11 = v4 + 1;
    v12 = v16;
    do
    {
      v11 += 2;
      *(_DWORD *)(*a2 + 4 * v10++) = *(v11 - 2);
    }
    while ( v10 < v12 );
    v4 = (int *)v17;
  }
  if ( v4 )
    operator delete(v4);
}

//----- (00405120) --------------------------------------------------------
int __thiscall sub_405120(_DWORD *this, _DWORD *a2, _DWORD **a3)
{
  int v4; // ecx
  int v5; // eax
  _DWORD *v6; // esi
  _DWORD *v7; // ebx
  int v8; // ecx
  unsigned int v9; // eax
  int v10; // ebx
  unsigned int v11; // ecx
  int v12; // edx
  int v13; // ebx
  int v14; // eax
  unsigned int v15; // edx
  unsigned int v16; // edx
  _DWORD *v17; // ecx
  int v18; // edx
  int v19; // eax
  unsigned int v20; // edx
  unsigned int v21; // edx
  int *v22; // eax
  unsigned int v23; // edx
  int result; // eax
  _DWORD *v25; // [esp+10h] [ebp-18h]
  unsigned int v26; // [esp+14h] [ebp-14h]
  int v27; // [esp+18h] [ebp-10h]
  int v28; // [esp+1Ch] [ebp-Ch]
  int v29; // [esp+20h] [ebp-8h]
  int v30; // [esp+24h] [ebp-4h] BYREF

  v4 = 0;
  v25 = this;
  v27 = 0;
  a2[25] = a2[24];
  v5 = 0;
  v6 = *a3;
  v28 = 0;
  if ( *a3 != a3[1] )
  {
    do
    {
      v26 = 0;
      v7 = (_DWORD *)(this[2] + 8 + 56 * *v6);
      if ( (v7[1] - *v7) >> 5 )
      {
        v8 = 0;
        v29 = 0;
        do
        {
          v9 = a2[25];
          v10 = v8 + *v7;
          v30 = v10;
          if ( (unsigned int)&v30 >= v9 || (v11 = a2[24], v11 > (unsigned int)&v30) )
          {
            v18 = a2[26];
            if ( v9 == v18 && !((int)(v18 - v9) >> 2) )
            {
              v19 = (int)(v9 - a2[24]) >> 2;
              if ( v19 == 0x3FFFFFFF )
LABEL_33:
                std::_Xlength_error("vector<T> too long");
              v20 = (v18 - a2[24]) >> 2;
              if ( 0x3FFFFFFF - (v20 >> 1) >= v20 )
                v21 = (v20 >> 1) + v20;
              else
                v21 = 0;
              if ( v21 < v19 + 1 )
                v21 = v19 + 1;
              sub_405400((int)(a2 + 24), v21);
            }
            v22 = (int *)a2[25];
            if ( v22 )
              *v22 = v10;
          }
          else
          {
            v12 = a2[26];
            v13 = (int)((int)&v30 - v11) >> 2;
            if ( v9 == v12 && !((int)(v12 - v9) >> 2) )
            {
              v14 = (int)(v9 - a2[24]) >> 2;
              if ( v14 == 0x3FFFFFFF )
                goto LABEL_33;
              v15 = (v12 - a2[24]) >> 2;
              if ( 0x3FFFFFFF - (v15 >> 1) >= v15 )
                v16 = (v15 >> 1) + v15;
              else
                v16 = 0;
              if ( v16 < v14 + 1 )
                v16 = v14 + 1;
              sub_405400((int)(a2 + 24), v16);
            }
            v17 = (_DWORD *)a2[25];
            if ( v17 )
              *v17 = *(_DWORD *)(a2[24] + 4 * v13);
          }
          a2[25] += 4;
          ++v27;
          v7 = (_DWORD *)(v25[2] + 8 + 56 * *v6);
          v23 = (int)((unsigned __int64)(1717986919i64 * (*(_DWORD *)(v29 + *v7 + 12) - *(_DWORD *)(v29 + *v7 + 8))) >> 32) >> 4;
          v8 = v29 + 32;
          v29 += 32;
          v28 += v23 + (v23 >> 31);
          ++v26;
        }
        while ( v26 < (v7[1] - *v7) >> 5 );
        this = v25;
      }
      ++v6;
    }
    while ( v6 != a3[1] );
    v5 = v28;
    v4 = v27;
  }
  a2[4] = v5;
  a2[2] = v4;
  result = (this[3] - this[2]) / 56;
  a2[3] = result;
  return result;
}
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (00405320) --------------------------------------------------------
char __thiscall sub_405320(_DWORD *this, unsigned int a2)
{
  char *v4; // eax

  *this = 0;
  this[1] = 0;
  this[2] = 0;
  if ( !a2 )
    return 0;
  if ( a2 > 0x6666666 )
    std::_Xlength_error("vector<T> too long");
  v4 = (char *)operator new(40 * a2);
  if ( !v4 )
  {
    std::_Xbad_alloc();
    JUMPOUT(0x405386);
  }
  *this = v4;
  this[1] = v4;
  this[2] = &v4[40 * a2];
  return 1;
}
// 405380: control flows out of bounds to 405386
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);
// 43903C: using guessed type void __cdecl std::_Xbad_alloc();

//----- (00405390) --------------------------------------------------------
char __thiscall sub_405390(_DWORD *this, unsigned int a2)
{
  char *v4; // eax

  *this = 0;
  this[1] = 0;
  this[2] = 0;
  if ( !a2 )
    return 0;
  if ( a2 > 0x7FFFFFF )
    std::_Xlength_error("vector<T> too long");
  v4 = (char *)operator new(32 * a2);
  if ( !v4 )
  {
    std::_Xbad_alloc();
    JUMPOUT(0x4053F5);
  }
  *this = v4;
  this[1] = v4;
  this[2] = &v4[32 * a2];
  return 1;
}
// 4053EF: control flows out of bounds to 4053F5
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);
// 43903C: using guessed type void __cdecl std::_Xbad_alloc();

//----- (00405400) --------------------------------------------------------
char *__thiscall sub_405400(int this, unsigned int a2)
{
  char *v2; // esi
  char *result; // eax
  int v5; // [esp+Ch] [ebp-4h]

  v2 = 0;
  if ( a2 )
  {
    if ( a2 > 0x3FFFFFFF || (v2 = (char *)operator new(4 * a2)) == 0 )
      std::_Xbad_alloc();
  }
  memmove(v2, *(const void **)this, (*(_DWORD *)(this + 4) - *(_DWORD *)this) & 0xFFFFFFFC);
  v5 = (*(_DWORD *)(this + 4) - *(_DWORD *)this) >> 2;
  if ( *(_DWORD *)this )
    operator delete(*(void **)this);
  *(_DWORD *)this = v2;
  *(_DWORD *)(this + 8) = &v2[4 * a2];
  result = &v2[4 * v5];
  *(_DWORD *)(this + 4) = result;
  return result;
}
// 43903C: using guessed type void __cdecl std::_Xbad_alloc();

//----- (00405480) --------------------------------------------------------
char *__thiscall sub_405480(_DWORD **this, unsigned int a2)
{
  char *v3; // esi
  _DWORD *v4; // ecx
  char *result; // eax
  int v6; // [esp+0h] [ebp-28h] BYREF
  void *v7; // [esp+14h] [ebp-14h]
  int *v8; // [esp+18h] [ebp-10h]
  int v9; // [esp+24h] [ebp-4h]

  v8 = &v6;
  v3 = 0;
  v7 = 0;
  if ( a2 )
  {
    if ( a2 > 0x1FFFFFFF || (v3 = (char *)operator new(8 * a2), (v7 = v3) == 0) )
      std::_Xbad_alloc();
  }
  v9 = 0;
  sub_404980(*this, this[1], v3);
  v4 = *this;
  v7 = (void *)(((char *)this[1] - (char *)*this) >> 3);
  if ( v4 )
    operator delete(v4);
  *this = v3;
  this[2] = &v3[8 * a2];
  result = &v3[8 * (_DWORD)v7];
  this[1] = result;
  return result;
}
// 43903C: using guessed type void __cdecl std::_Xbad_alloc();

//----- (00405560) --------------------------------------------------------
unsigned int __thiscall sub_405560(_DWORD *this, unsigned int a2)
{
  int v2; // esi
  unsigned int result; // eax
  int v4; // esi
  unsigned int v5; // esi
  unsigned int v6; // edx
  unsigned int v7; // edx

  v2 = this[1];
  result = (this[2] - v2) >> 2;
  if ( result < a2 )
  {
    v4 = (v2 - *this) >> 2;
    if ( 0x3FFFFFFF - v4 < a2 )
      std::_Xlength_error("vector<T> too long");
    v5 = a2 + v4;
    v6 = (this[2] - *this) >> 2;
    if ( 0x3FFFFFFF - (v6 >> 1) >= v6 )
    {
      v7 = (v6 >> 1) + v6;
      if ( v7 < v5 )
        v7 = v5;
    }
    else
    {
      v7 = 0;
      if ( v5 )
        v7 = v5;
    }
    return (unsigned int)sub_405400((int)this, v7);
  }
  return result;
}
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (004055E0) --------------------------------------------------------
unsigned int __thiscall sub_4055E0(int this, unsigned int a2)
{
  int v2; // esi
  unsigned int result; // eax
  int v4; // esi
  unsigned int v5; // esi
  unsigned int v6; // edx
  unsigned int v7; // edx

  v2 = *(_DWORD *)(this + 4);
  result = (*(_DWORD *)(this + 8) - v2) >> 3;
  if ( result < a2 )
  {
    v4 = (v2 - *(_DWORD *)this) >> 3;
    if ( 0x1FFFFFFF - v4 < a2 )
      std::_Xlength_error("vector<T> too long");
    v5 = a2 + v4;
    v6 = (*(_DWORD *)(this + 8) - *(_DWORD *)this) >> 3;
    if ( 0x1FFFFFFF - (v6 >> 1) >= v6 )
    {
      v7 = (v6 >> 1) + v6;
      if ( v7 < v5 )
        v7 = v5;
    }
    else
    {
      v7 = 0;
      if ( v5 )
        v7 = v5;
    }
    return (unsigned int)sub_405480((_DWORD **)this, v7);
  }
  return result;
}
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (00405660) --------------------------------------------------------
void __thiscall sub_405660(int *this)
{
  if ( *this )
  {
    sub_404130(*this, this[1]);
    operator delete((void *)*this);
    *this = 0;
    this[1] = 0;
    this[2] = 0;
  }
}

//----- (004056B0) --------------------------------------------------------
bool __cdecl sub_4056B0(_DWORD *a1, _DWORD *a2)
{
  return *a1 > *a2;
}

//----- (004056D0) --------------------------------------------------------
unsigned int __thiscall sub_4056D0(unsigned int *this, _DWORD *a2)
{
  unsigned int result; // eax
  int v4; // edi
  _DWORD *v5; // ecx
  _DWORD *v6; // edx
  _DWORD *v7; // ecx

  result = this[1];
  if ( (unsigned int)a2 >= result || *this > (unsigned int)a2 )
  {
    if ( result == this[2] )
      result = sub_4055E0((int)this, 1u);
    v7 = (_DWORD *)this[1];
    if ( v7 )
    {
      *v7 = *a2;
      result = a2[1];
      v7[1] = result;
    }
  }
  else
  {
    v4 = (int)((int)a2 - *this) >> 3;
    if ( result == this[2] )
      sub_4055E0((int)this, 1u);
    result = *this;
    v5 = (_DWORD *)this[1];
    v6 = (_DWORD *)(*this + 8 * v4);
    if ( v5 )
    {
      *v5 = *v6;
      result = v6[1];
      v5[1] = result;
      this[1] += 8;
      return result;
    }
  }
  this[1] += 8;
  return result;
}

//----- (00405750) --------------------------------------------------------
int __thiscall sub_405750(_DWORD *this, unsigned int a2)
{
  int result; // eax
  unsigned int v4; // edx
  int v5; // eax

  result = this[1];
  v4 = (result - *this) >> 2;
  if ( v4 <= a2 )
  {
    if ( v4 < a2 )
    {
      sub_405560(this, a2 - v4);
      v5 = (this[1] - *this) >> 2;
      if ( a2 != v5 )
        memset((void *)this[1], 0, 4 * (a2 - v5));
      result = this[1] + 4 * (a2 - ((this[1] - *this) >> 2));
      this[1] = result;
    }
  }
  else
  {
    result += 4 * (a2 - v4);
    this[1] = result;
  }
  return result;
}

//----- (004057B0) --------------------------------------------------------
char __thiscall sub_4057B0(_DWORD *this)
{
  _DWORD *v1; // edi
  int v2; // ebx
  _DWORD *v3; // esi
  int v4; // eax
  int v5; // edx
  _QWORD *v6; // edi
  int v7; // esi
  _QWORD *v8; // ebx
  int v9; // eax
  _DWORD *v10; // edi
  _DWORD *v11; // esi
  void *v12; // eax
  int v13; // eax
  unsigned int v14; // esi
  int v15; // ebx
  int v16; // eax
  int v17; // esi
  _QWORD *v18; // edi
  char *v19; // esi
  _QWORD *v20; // ebx
  int v21; // eax
  int v22; // eax
  _DWORD *v23; // edi
  _DWORD *v24; // esi
  void *v25; // eax
  int v26; // edx
  _DWORD *v27; // ebx
  int v28; // edi
  int v29; // esi
  int v30; // ecx
  int v31; // eax
  int v32; // eax
  int v33; // ebx
  int v34; // esi
  int v35; // ebx
  int v36; // ecx
  int v37; // ecx
  int v38; // eax
  int v39; // ebx
  int v40; // edi
  int v41; // esi
  __m128i v42; // xmm0
  void (__thiscall ***v43)(_DWORD, _DWORD); // esi
  void (__thiscall ***v44)(_DWORD, _DWORD); // ebx
  int v45; // esi
  int v46; // ecx
  int v47; // eax
  int v48; // eax
  int v49; // ebx
  int v50; // esi
  int v51; // ebx
  int v52; // ecx
  int v53; // ecx
  int v54; // eax
  int v55; // ebx
  int v56; // edi
  int v57; // esi
  __m128i v58; // xmm0
  void (__thiscall ***v59)(_DWORD, _DWORD); // esi
  void (__thiscall ***v60)(_DWORD, _DWORD); // ebx
  unsigned int v61; // esi
  unsigned int v62; // eax
  int v63; // ebx
  int v64; // ebx
  _DWORD *v65; // esi
  double v66; // xmm0_8
  int v68; // [esp+10h] [ebp-20h]
  int v69; // [esp+10h] [ebp-20h]
  int v70; // [esp+14h] [ebp-1Ch]
  int v71; // [esp+18h] [ebp-18h]
  int v72; // [esp+18h] [ebp-18h]
  int v73; // [esp+18h] [ebp-18h]
  unsigned int v74; // [esp+1Ch] [ebp-14h]
  int v75; // [esp+1Ch] [ebp-14h]
  int v76; // [esp+20h] [ebp-10h]
  int v77; // [esp+20h] [ebp-10h]
  int v78; // [esp+24h] [ebp-Ch]
  int v79; // [esp+24h] [ebp-Ch]
  int v80; // [esp+24h] [ebp-Ch]
  unsigned int v81; // [esp+28h] [ebp-8h]
  int v82; // [esp+28h] [ebp-8h]
  int v83; // [esp+28h] [ebp-8h]

  v1 = this;
  v81 = 0;
  if ( (this[3] - this[2]) / 56 )
  {
    v2 = 0;
    v76 = 0;
    do
    {
      v3 = (_DWORD *)(v2 + v1[2]);
      if ( sub_404F30(v3) >= 5000 )
      {
        v4 = v3[3] - v3[2];
        if ( v4 >= 0 && (v4 & 0xFFFFFFE0) != 0 )
        {
          do
          {
            v5 = v1[2];
            v78 = v5;
            v6 = (_QWORD *)(*(_DWORD *)(v2 + v5 + 8) + 32);
            if ( v6 != *(_QWORD **)(v2 + v5 + 12) )
            {
              v7 = *(_DWORD *)(v2 + v5 + 8) + 20;
              v8 = *(_QWORD **)(v2 + v5 + 12);
              do
              {
                *(_QWORD *)(v7 - 20) = *v6;
                sub_404AC0(v7 - 12, (const __m128i **)(v7 + 20));
                v9 = *(_DWORD *)(v7 + 32);
                v7 += 32;
                *(_DWORD *)(v7 - 32) = v9;
                v6 += 4;
                *(_QWORD *)(v7 - 28) = *(_QWORD *)(v7 + 4);
              }
              while ( v6 != v8 );
              v2 = v76;
              v5 = v78;
            }
            v10 = *(_DWORD **)(v2 + v5 + 12);
            v11 = v10 - 8;
            if ( v10 - 8 != v10 )
            {
              do
              {
                v12 = (void *)v11[2];
                v11[3] = v12;
                if ( v12 )
                {
                  operator delete(v12);
                  v11[2] = 0;
                  v11[3] = 0;
                  v11[4] = 0;
                }
                v11 += 8;
              }
              while ( v11 != v10 );
              v5 = v78;
            }
            v1 = this;
            *(_DWORD *)(v2 + v5 + 12) -= 32;
            v13 = *(_DWORD *)(v2 + v1[2] + 12) - *(_DWORD *)(v2 + v1[2] + 8);
          }
          while ( v13 >= 0 && (v13 & 0xFFFFFFE0) != 0 );
        }
      }
      v2 += 56;
      v76 = v2;
      ++v81;
    }
    while ( v81 < (v1[3] - v1[2]) / 56 );
  }
  v14 = 0;
  v74 = 0;
  if ( (v1[3] - v1[2]) / 56 )
  {
    v15 = 0;
    v71 = 0;
    do
    {
      v82 = 0;
      v16 = *(_DWORD *)(v15 + v1[2] + 12) - *(_DWORD *)(v15 + v1[2] + 8);
      if ( v16 >= 0 && (v16 & 0xFFFFFFE0) != 0 )
      {
        v17 = 0;
        v77 = 0;
        do
        {
          v79 = v1[2];
          v70 = *(_DWORD *)(v15 + v79 + 8);
          if ( (*(_DWORD *)(v70 + v17 + 12) - *(_DWORD *)(v70 + v17 + 8)) / 40 > 5 )
          {
            v26 = v82;
          }
          else
          {
            v18 = (_QWORD *)(v17 + v70 + 32);
            if ( v18 != *(_QWORD **)(v15 + v79 + 12) )
            {
              v19 = (char *)v18 - 12;
              v20 = *(_QWORD **)(v15 + v79 + 12);
              do
              {
                *(_QWORD *)(v19 - 20) = *v18;
                sub_404AC0((int)(v19 - 12), (const __m128i **)v19 + 5);
                v21 = *((_DWORD *)v19 + 8);
                v19 += 32;
                *((_DWORD *)v19 - 8) = v21;
                v18 += 4;
                *(_QWORD *)(v19 - 28) = *(_QWORD *)(v19 + 4);
              }
              while ( v18 != v20 );
              v15 = v71;
            }
            v22 = v79;
            v23 = *(_DWORD **)(v15 + v79 + 12);
            v24 = v23 - 8;
            if ( v23 - 8 != v23 )
            {
              do
              {
                v25 = (void *)v24[2];
                v24[3] = v25;
                if ( v25 )
                {
                  operator delete(v25);
                  v24[2] = 0;
                  v24[3] = 0;
                  v24[4] = 0;
                }
                v24 += 8;
              }
              while ( v24 != v23 );
              v22 = v79;
            }
            v26 = v82 - 1;
            *(_DWORD *)(v15 + v22 + 12) -= 32;
            v17 = v77 - 32;
            v1 = this;
          }
          v17 += 32;
          v82 = v26 + 1;
          v77 = v17;
        }
        while ( v26 + 1 < (*(_DWORD *)(v15 + v1[2] + 12) - *(_DWORD *)(v15 + v1[2] + 8)) >> 5 );
        v14 = v74;
      }
      ++v14;
      v15 += 56;
      v74 = v14;
      v71 = v15;
    }
    while ( v14 < (v1[3] - v1[2]) / 56 );
  }
  v80 = 0;
  if ( (v1[3] - v1[2]) / 56 )
  {
    v27 = this;
    v28 = 0;
    v83 = 0;
    while ( 1 )
    {
      v29 = v27[2];
      v75 = v29;
      if ( (int)((*(_DWORD *)(v28 + v29 + 12) - *(_DWORD *)(v28 + v29 + 8)) & 0xFFFFFFE0) > 64 )
        goto LABEL_52;
      v30 = 0;
      v31 = *(_DWORD *)(v28 + v29 + 12) - *(_DWORD *)(v28 + v29 + 8);
      v72 = 0;
      if ( v31 >= 0 && (v31 & 0xFFFFFFE0) != 0 )
      {
        v32 = *(_DWORD *)(v28 + v29 + 12) - *(_DWORD *)(v28 + v29 + 8);
        v33 = *(_DWORD *)(v28 + v29 + 8);
        v34 = 0;
        v35 = v33 + 8;
        do
        {
          v36 = *(_DWORD *)(v35 + 4);
          v35 += 32;
          ++v34;
          v30 = (v36 - *(_DWORD *)(v35 - 32)) / 40 + v72;
          v72 = v30;
        }
        while ( v34 < v32 >> 5 );
        v28 = v83;
        v27 = this;
        v29 = v75;
      }
      if ( (double)v30 / (double)((*(_DWORD *)(v28 + v29 + 12) - *(_DWORD *)(v28 + v29 + 8)) >> 5) >= 15.0 )
      {
LABEL_52:
        v46 = 0;
        v47 = *(_DWORD *)(v28 + v29 + 12) - *(_DWORD *)(v28 + v29 + 8);
        v73 = 0;
        if ( v47 >= 0 && (v47 & 0xFFFFFFE0) != 0 )
        {
          v48 = *(_DWORD *)(v28 + v29 + 12) - *(_DWORD *)(v28 + v29 + 8);
          v49 = *(_DWORD *)(v28 + v29 + 8);
          v50 = 0;
          v51 = v49 + 8;
          do
          {
            v52 = *(_DWORD *)(v51 + 4);
            v51 += 32;
            ++v50;
            v46 = (v52 - *(_DWORD *)(v51 - 32)) / 40 + v73;
            v73 = v46;
          }
          while ( v50 < v48 >> 5 );
          v28 = v83;
          v27 = this;
          v29 = v75;
        }
        if ( (double)v46 / (double)((*(_DWORD *)(v28 + v29 + 12) - *(_DWORD *)(v28 + v29 + 8)) >> 5) >= 10.0 )
        {
          v45 = v80;
          goto LABEL_66;
        }
        v53 = v27[3];
        v54 = v28 + v29 + 56;
        if ( v54 != v53 )
        {
          v55 = v28 + v29 + 56;
          v56 = v53;
          v57 = v54 - 32;
          do
          {
            sub_404C30((int *)(v57 - 16), (const __m128i ***)(v57 + 40));
            v58 = _mm_loadu_si128((const __m128i *)(v57 + 56));
            v55 += 56;
            v57 += 56;
            *(__m128i *)(v57 - 56) = v58;
            *(__m128i *)(v57 - 40) = _mm_loadu_si128((const __m128i *)(v57 + 16));
          }
          while ( v55 != v56 );
          v28 = v83;
          v27 = this;
        }
        v69 = v27[3];
        v59 = (void (__thiscall ***)(_DWORD, _DWORD))(v69 - 56);
        if ( v69 - 56 != v69 )
        {
          v60 = (void (__thiscall ***)(_DWORD, _DWORD))v27[3];
          do
          {
            (**v59)(v59, 0);
            v59 += 14;
          }
          while ( v59 != v60 );
          v27 = this;
          v45 = v80 - 1;
          this[3] -= 56;
          v28 -= 56;
          goto LABEL_66;
        }
      }
      else
      {
        v37 = v27[3];
        v38 = v28 + v29 + 56;
        if ( v38 != v37 )
        {
          v39 = v28 + v29 + 56;
          v40 = v37;
          v41 = v38 - 32;
          do
          {
            sub_404C30((int *)(v41 - 16), (const __m128i ***)(v41 + 40));
            v42 = _mm_loadu_si128((const __m128i *)(v41 + 56));
            v39 += 56;
            v41 += 56;
            *(__m128i *)(v41 - 56) = v42;
            *(__m128i *)(v41 - 40) = _mm_loadu_si128((const __m128i *)(v41 + 16));
          }
          while ( v39 != v40 );
          v28 = v83;
          v27 = this;
        }
        v68 = v27[3];
        v43 = (void (__thiscall ***)(_DWORD, _DWORD))(v68 - 56);
        if ( v68 - 56 != v68 )
        {
          v44 = (void (__thiscall ***)(_DWORD, _DWORD))v27[3];
          do
          {
            (**v43)(v43, 0);
            v43 += 14;
          }
          while ( v43 != v44 );
          v27 = this;
        }
      }
      v27[3] -= 56;
      v45 = v80 - 1;
      v28 -= 56;
LABEL_66:
      v28 += 56;
      v80 = v45 + 1;
      v83 = v28;
      if ( v45 + 1 >= (unsigned int)((v27[3] - v27[2]) / 56) )
      {
        v1 = this;
        break;
      }
    }
  }
  v61 = 0;
  v62 = (v1[3] - v1[2]) / 56;
  if ( v62 )
  {
    v63 = 0;
    do
    {
      sub_425400(v62, v63 + v1[2], v61++);
      v63 += 56;
      v62 = (v1[3] - v1[2]) / 56;
    }
    while ( v61 < v62 );
  }
  *((_QWORD *)v1 + 3) = 0i64;
  v64 = 0;
  if ( (v1[3] - v1[2]) / 56 > 0 )
  {
    v65 = (_DWORD *)v1[2];
    do
    {
      v66 = sub_404E30(v65);
      if ( v66 >= *((double *)v1 + 3) )
        *((double *)v1 + 3) = v66;
      ++v64;
      v65 += 14;
    }
    while ( v64 < (v1[3] - v1[2]) / 56 );
  }
  return 1;
}

//----- (00405DC0) --------------------------------------------------------
void __cdecl sub_405DC0(_OWORD *a1, int a2)
{
  int i; // ecx

  for ( i = a2; i; --i )
  {
    if ( a1 )
      *a1 = 0i64;
    ++a1;
  }
}

//----- (00405DE0) --------------------------------------------------------
_QWORD *__cdecl sub_405DE0(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v3; // ecx
  _QWORD *result; // eax

  v3 = a1;
  for ( result = a3; v3 != a2; result += 2 )
  {
    if ( result )
    {
      *result = *v3;
      result[1] = v3[1];
    }
    v3 += 2;
  }
  return result;
}

//----- (00405E20) --------------------------------------------------------
int __thiscall sub_405E20(int this, int a2, int a3, __int64 a4)
{
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 40) = 0;
  *(_DWORD *)(this + 44) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_QWORD *)(this + 8) = a4;
  *(_DWORD *)(this + 52) = 0;
  *(_DWORD *)(this + 56) = 0;
  *(_DWORD *)(this + 60) = 0;
  sub_405EB0(this + 64, a2, a3, a4);
  return this;
}

//----- (00405EB0) --------------------------------------------------------
int __thiscall sub_405EB0(int this, int a2, int a3, __int64 a4)
{
  int v4; // edx
  int v7; // ecx
  int v8; // edi
  int v9; // ecx
  int v10; // eax
  unsigned int v11; // esi
  int v12; // eax
  int v13; // ecx
  __int64 v14; // xmm0_8
  int v15; // ecx
  int v16; // edi
  unsigned int v17; // edx
  int v18; // esi
  double v19; // xmm0_8
  int v20; // eax
  __m128i v21; // xmm0
  int v22; // eax
  double v23; // xmm0_8
  int v25; // [esp+1Ch] [ebp+14h]
  int v26; // [esp+1Ch] [ebp+14h]

  v4 = a2;
  v7 = 0;
  v25 = 0;
  *(_DWORD *)(this + 160) = a2;
  *(_QWORD *)(this + 168) = a4;
  if ( a2 >= 0 )
  {
    v8 = a3;
    if ( a2 + 1 >= 4 )
    {
      v9 = a3 + 24;
      v10 = this + 8;
      v11 = (unsigned int)(a2 + 1) >> 2;
      v25 = 4 * v11;
      v8 = a3;
      do
      {
        v10 += 32;
        *(_QWORD *)(v10 - 40) = *(_QWORD *)(v9 - 24);
        v9 += 32;
        *(_QWORD *)(v10 - 32) = *(_QWORD *)(a3 - this + v10 - 32);
        *(_QWORD *)(v10 - 24) = *(_QWORD *)(v9 - 40);
        *(_QWORD *)(v10 - 16) = *(_QWORD *)(v9 - 32);
        --v11;
      }
      while ( v11 );
      v4 = a2;
      v7 = v25;
    }
    if ( v7 <= v4 )
    {
      v12 = this + 8 * v7;
      v13 = v4 - v25 + 1;
      do
      {
        v14 = *(_QWORD *)(v12 + v8 - this);
        v12 += 8;
        *(_QWORD *)(v12 - 8) = v14;
        --v13;
      }
      while ( v13 );
    }
  }
  v15 = 1;
  if ( v4 >= 4 )
  {
    v16 = this + 88;
    v26 = v4 - 3;
    v17 = 3;
    v18 = a3 + 24;
    do
    {
      v19 = (double)v15;
      v15 += 4;
      v16 += 32;
      v18 += 32;
      *(double *)(v16 - 40) = v19 * *(double *)(v18 - 48);
      v20 = v17 + 1;
      *(double *)(v16 - 32) = (double)(int)(v17 - 1) * *(double *)(v18 - 40);
      v21 = _mm_cvtsi32_si128(v17);
      v17 += 4;
      *(double *)(v16 - 24) = _mm_cvtepi32_pd(v21).m128d_f64[0] * *(double *)(v18 - 32);
      *(double *)(v16 - 16) = (double)v20 * *(double *)(v18 - 24);
    }
    while ( v15 <= v26 );
    v4 = a2;
  }
  if ( v15 <= v4 )
  {
    v22 = this + 8 * (v15 + 9);
    do
    {
      v22 += 8;
      v23 = (double)v15 * *(double *)(a3 + 8 * v15);
      ++v15;
      *(double *)(v22 - 8) = v23;
    }
    while ( v15 <= v4 );
  }
  return this;
}

//----- (00406030) --------------------------------------------------------
void __thiscall sub_406030(int this)
{
  if ( *(_DWORD *)(this + 52) )
  {
    operator delete(*(void **)(this + 52));
    *(_DWORD *)(this + 52) = 0;
    *(_DWORD *)(this + 56) = 0;
    *(_DWORD *)(this + 60) = 0;
  }
  if ( *(_DWORD *)(this + 40) )
  {
    operator delete(*(void **)(this + 40));
    *(_DWORD *)(this + 40) = 0;
    *(_DWORD *)(this + 44) = 0;
    *(_DWORD *)(this + 48) = 0;
  }
  if ( *(_DWORD *)(this + 28) )
  {
    operator delete(*(void **)(this + 28));
    *(_DWORD *)(this + 28) = 0;
    *(_DWORD *)(this + 32) = 0;
    *(_DWORD *)(this + 36) = 0;
  }
  if ( *(_DWORD *)(this + 16) )
  {
    operator delete(*(void **)(this + 16));
    *(_DWORD *)(this + 16) = 0;
    *(_DWORD *)(this + 20) = 0;
    *(_DWORD *)(this + 24) = 0;
  }
}

//----- (004060D0) --------------------------------------------------------
double __thiscall sub_4060D0(_DWORD *this, double a2)
{
  double v3; // xmm0_8
  int v4; // edx
  int v5; // esi
  double *v6; // ecx
  double *v7; // eax
  double v9; // [esp+4h] [ebp-8h]

  v3 = 0.0;
  v9 = 0.0;
  v4 = this[40] - 1;
  if ( v4 >= 0 )
  {
    if ( (int)this[40] >= 4 )
    {
      v5 = this[40] >> 2;
      v6 = (double *)&this[2 * v4 + 18];
      v4 -= 4 * v5;
      do
      {
        v3 = (((v3 * a2 + v6[1]) * a2 + *v6) * a2 + *(v6 - 1)) * a2 + *(v6 - 2);
        v6 -= 4;
        --v5;
      }
      while ( v5 );
      v9 = v3;
    }
    if ( v4 >= 0 )
    {
      v7 = (double *)&this[2 * v4 + 20];
      do
      {
        v3 = v3 * a2 + *v7--;
        --v4;
      }
      while ( v4 >= 0 );
      return v3;
    }
  }
  return v9;
}

//----- (00406170) --------------------------------------------------------
char __thiscall sub_406170(_DWORD *this, double a2, double *a3)
{
  int v3; // eax
  double v4; // xmm0_8
  int v6; // eax
  double v7; // xmm5_8
  double v8; // xmm3_8
  double v9; // xmm0_8
  int v10; // eax
  double v11; // xmm3_8

  v3 = *this - 2;
  if ( a2 < 0.0 )
  {
    v4 = -a2 / 0.1;
    if ( v3 >= (int)v4 )
    {
      v6 = this[7];
      v8 = *(double *)(v6 + 16 * (int)v4) - a2;
      if ( (*(double *)(v6 + 16 * (int)v4 + 16) - a2) * v8 <= 0.0 )
      {
        v7 = *(double *)(v6 + 16 * (int)v4 + 16);
        *a3 = -((*(double *)(v6 + 16 * (int)v4 + 8) * (a2 - v7) + *(double *)(v6 + 16 * (int)v4 + 24) * v8)
              / (a2 - v7 + v8));
        return 1;
      }
    }
    return 0;
  }
  v9 = a2 / 0.1;
  if ( v3 < (int)(a2 / 0.1) )
    return 0;
  v10 = this[4];
  v11 = *(double *)(v10 + 16 * (int)v9 + 16) - a2;
  if ( (*(double *)(v10 + 16 * (int)v9) - a2) * v11 > 0.0 )
    return 0;
  *a3 = (*(double *)(v10 + 16 * (int)v9 + 8) * v11
       + *(double *)(v10 + 16 * (int)v9 + 24) * (a2 - *(double *)(v10 + 16 * (int)v9)))
      / (v11 + a2 - *(double *)(v10 + 16 * (int)v9));
  return 1;
}

//----- (00406280) --------------------------------------------------------
char __thiscall sub_406280(_DWORD *this, double a2, double *a3)
{
  double v3; // xmm0_8
  int v4; // esi
  int v5; // eax
  unsigned int v6; // edx
  int v8; // edx
  double v9; // xmm2_8

  v3 = a2;
  if ( a2 >= 0.0 )
  {
    v4 = this[10];
    v5 = this[11];
  }
  else
  {
    v3 = -a2;
    v4 = this[13];
    v5 = this[14];
  }
  v6 = (int)(v3 / 0.1);
  if ( ((v5 - v4) >> 4) - 2 < v6 )
    return 0;
  v8 = 2 * v6;
  v9 = *(double *)(v4 + 8 * v8 + 16) - a2;
  *a3 = (*(double *)(v4 + 8 * v8 + 8) * v9 + *(double *)(v4 + 8 * v8 + 24) * (a2 - *(double *)(v4 + 8 * v8)))
      / (v9 + a2 - *(double *)(v4 + 8 * v8));
  return 1;
}

//----- (00406310) --------------------------------------------------------
_OWORD *__usercall sub_406310@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>)
{
  _OWORD **v3; // esi
  signed int v4; // edi
  _DWORD *v5; // edx
  double v6; // xmm1_8
  int v7; // esi
  int v8; // ecx
  _OWORD *v9; // esi
  _OWORD *v10; // esi
  bool v11; // zf
  double v12; // xmm0_8
  double v13; // xmm2_8
  int *v14; // edx
  double v15; // xmm0_8
  int v16; // ecx
  double v17; // xmm5_8
  _OWORD *result; // eax
  int v19; // esi
  int v20; // edx
  double *i; // eax
  double v22; // xmm3_8
  double v23; // xmm2_8
  double v24; // xmm0_8
  double v25; // xmm4_8
  int v26; // ecx
  int v27; // esi
  _OWORD *v28; // edx
  double *j; // eax
  double v30; // xmm4_8
  double v31; // xmm5_8
  double v32; // xmm2_8
  double v33; // xmm3_8
  int v34; // [esp+8h] [ebp-58h]
  int v35; // [esp+8h] [ebp-58h]
  int v36; // [esp+8h] [ebp-58h]
  int v37; // [esp+8h] [ebp-58h]
  int v38; // [esp+8h] [ebp-58h]
  int v39; // [esp+8h] [ebp-58h]
  int v40; // [esp+Ch] [ebp-54h]
  int v41; // [esp+Ch] [ebp-54h]
  int v42; // [esp+Ch] [ebp-54h]
  int v43; // [esp+Ch] [ebp-54h]
  int v44; // [esp+Ch] [ebp-54h]
  int v45; // [esp+Ch] [ebp-54h]
  int v46; // [esp+10h] [ebp-50h]
  int v47; // [esp+10h] [ebp-50h]
  int v48; // [esp+10h] [ebp-50h]
  int v49; // [esp+10h] [ebp-50h]
  int v50; // [esp+10h] [ebp-50h]
  int v51; // [esp+10h] [ebp-50h]
  int v52; // [esp+14h] [ebp-4Ch]
  int v53; // [esp+14h] [ebp-4Ch]
  int v54; // [esp+14h] [ebp-4Ch]
  double *v55; // [esp+14h] [ebp-4Ch]
  int v56; // [esp+14h] [ebp-4Ch]
  int v57; // [esp+14h] [ebp-4Ch]
  int v58; // [esp+14h] [ebp-4Ch]
  _DWORD *v60; // [esp+1Ch] [ebp-44h]
  _OWORD **v61; // [esp+20h] [ebp-40h]
  int v62; // [esp+24h] [ebp-3Ch]
  int v63; // [esp+24h] [ebp-3Ch]
  int v64; // [esp+28h] [ebp-38h]
  int v65; // [esp+28h] [ebp-38h]
  int v66; // [esp+28h] [ebp-38h]
  _DWORD *v67; // [esp+2Ch] [ebp-34h]
  double v68; // [esp+38h] [ebp-28h]
  double v69; // [esp+38h] [ebp-28h]
  double v70; // [esp+38h] [ebp-28h]
  double v71; // [esp+38h] [ebp-28h]

  v40 = a3;
  v34 = a2;
  v3 = (_OWORD **)(a1 + 16);
  v60 = (_DWORD *)(a1 + 16);
  v4 = (int)(3.0 / *(double *)(a1 + 8) / 0.1 + 1.0);
  *(_DWORD *)a1 = v4;
  sub_4069A0((_DWORD *)(a1 + 16), v4);
  v61 = (_OWORD **)(a1 + 28);
  sub_4069A0((_DWORD *)(a1 + 28), v4);
  v5 = v61;
  v6 = 0.0;
  **v3 = 0i64;
  **v61 = 0i64;
  if ( v4 > 1 )
  {
    v7 = a1 + 64;
    v8 = 16;
    v52 = a1 + 64;
    v62 = 1;
    v64 = v4 - 1;
    do
    {
      v6 = v6 + 0.1;
      *(double *)(v8 + *v60) = v6;
      sub_4060D0((_DWORD *)v7, *(double *)(v7 + 168) * v6);
      sub_4060D0((_DWORD *)v7, *(double *)(v7 + 168) * (v6 + 0.05));
      sub_4060D0((_DWORD *)v7, *(double *)(v7 + 168) * (v6 + 0.1));
      v9 = (_OWORD *)*v60;
      v68 = *(double *)libm_sse2_sqrt_precise(v34, v40, v46, v52).m128_u64 * 4.0;
      v69 = v68 + *(double *)libm_sse2_sqrt_precise(v35, v41, v47, v53).m128_u64;
      *((double *)&v9[v62] + 1) = (v69 + *(double *)libm_sse2_sqrt_precise(v36, v42, v48, v54).m128_u64)
                                * 0.01666666666666667
                                + *((double *)&v9[v62 - 1] + 1);
      *(double *)&(*v61)[v62] = -v6;
      sub_4060D0(v55, -(v55[21] * v6));
      sub_4060D0(v55, -(v55[21] * (v6 + 0.05)));
      sub_4060D0(v55, -((v6 + 0.1) * v55[21]));
      v10 = *v61;
      v70 = *(double *)libm_sse2_sqrt_precise(v37, v43, v49, v55).m128_u64 * 4.0;
      v71 = v70 + *(double *)libm_sse2_sqrt_precise(v38, v44, v50, v56).m128_u64;
      *((double *)&v10[v62] + 1) = (v71 + *(double *)libm_sse2_sqrt_precise(v39, v45, v51, v57).m128_u64)
                                 * 0.01666666666666667
                                 + *((double *)&v10[v62 - 1] + 1);
      v8 = v62 * 16 + 16;
      v11 = v64-- == 1;
      v7 = v52;
      ++v62;
    }
    while ( !v11 );
    v3 = (_OWORD **)v60;
    v5 = (_DWORD *)(a1 + 28);
  }
  v12 = *((double *)&(*v3)[v4 - 1] + 1) / 0.1 + 1.0;
  v13 = (double)(2 * v4);
  if ( v12 > v13 )
    v12 = (double)(2 * v4);
  v58 = (int)v12;
  if ( *(double *)(*v5 + 16 * v4 - 8) / 0.1 + 1.0 <= v13 )
    v13 = *(double *)(*v5 + 16 * v4 - 8) / 0.1 + 1.0;
  v63 = (int)v13;
  sub_4069A0((_DWORD *)(a1 + 40), (int)v12);
  v67 = (_DWORD *)(a1 + 52);
  sub_4069A0((_DWORD *)(a1 + 52), (int)v13);
  v14 = v60;
  v15 = 0.0;
  v16 = 1;
  v17 = 0.0;
  v65 = 1;
  *(_OWORD *)*v60 = 0i64;
  result = *(_OWORD **)(a1 + 28);
  *result = 0i64;
  if ( v58 > 1 )
  {
    v19 = 16;
    do
    {
      if ( v16 >= v4 )
        break;
      v20 = *v14;
      v17 = v17 + 0.1;
      for ( i = (double *)(v20 + 16 * v16 + 8); v17 > *i; ++v16 )
      {
        if ( v16 >= v4 )
          break;
        i += 2;
      }
      v22 = v17 - *(double *)(v20 + 16 * v16 - 8);
      v23 = *(double *)(v20 + 16 * v16 + 8);
      v24 = *(double *)(v20 + 16 * v16);
      v25 = *(double *)(v20 + 16 * v16 - 16);
      *(double *)(v19 + *(_DWORD *)(a1 + 40)) = v17;
      v14 = v60;
      *(double *)(v19 + *(_DWORD *)(a1 + 40) + 8) = (v22 * v24 + (v23 - v17) * v25) / (v23 - v17 + v22);
      v19 += 16;
      result = (_OWORD *)(v65 + 1);
      v65 = (int)result;
    }
    while ( (int)result < v58 );
    v15 = 0.0;
  }
  v26 = 1;
  v66 = 1;
  if ( v63 > 1 )
  {
    v27 = 16;
    do
    {
      if ( v26 >= v4 )
        break;
      v15 = v15 + 0.1;
      v28 = *v61;
      for ( j = (double *)&(*v61)[v26] + 1; v15 > *j; ++v26 )
      {
        if ( v26 >= v4 )
          break;
        j += 2;
      }
      v30 = v15 - *((double *)&v28[v26 - 1] + 1);
      v31 = *(double *)&v28[v26 - 1];
      v32 = *(double *)&v28[v26];
      v33 = *((double *)&v28[v26] + 1);
      *(double *)(v27 + *v67) = -v15;
      *(double *)(*v67 + v27 + 8) = (v30 * v32 + (v33 - v15) * v31) / (v33 - v15 + v30);
      v27 += 16;
      result = (_OWORD *)(v66 + 1);
      v66 = (int)result;
    }
    while ( (int)result < v63 );
  }
  return result;
}
// 406310: could not find valid save-restore pair for edi
// 406310: could not find valid save-restore pair for esi
// 40645A: variable 'v34' is possibly undefined
// 40645A: variable 'v40' is possibly undefined
// 40645A: variable 'v46' is possibly undefined
// 40645A: variable 'v52' is possibly undefined
// 40647F: variable 'v35' is possibly undefined
// 40647F: variable 'v41' is possibly undefined
// 40647F: variable 'v47' is possibly undefined
// 40647F: variable 'v53' is possibly undefined
// 4064A6: variable 'v36' is possibly undefined
// 4064A6: variable 'v42' is possibly undefined
// 4064A6: variable 'v48' is possibly undefined
// 4064A6: variable 'v54' is possibly undefined
// 406508: variable 'v55' is possibly undefined
// 40657F: variable 'v37' is possibly undefined
// 40657F: variable 'v43' is possibly undefined
// 40657F: variable 'v49' is possibly undefined
// 4065A4: variable 'v38' is possibly undefined
// 4065A4: variable 'v44' is possibly undefined
// 4065A4: variable 'v50' is possibly undefined
// 4065A4: variable 'v56' is possibly undefined
// 4065CB: variable 'v39' is possibly undefined
// 4065CB: variable 'v45' is possibly undefined
// 4065CB: variable 'v51' is possibly undefined
// 4065CB: variable 'v57' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00406840) --------------------------------------------------------
_DWORD *__thiscall sub_406840(_QWORD **this, unsigned int a2)
{
  char *v3; // edi
  _QWORD *v4; // eax
  int v5; // ebx
  _DWORD *result; // eax
  int v7; // [esp+0h] [ebp-2Ch] BYREF
  _QWORD **v8; // [esp+10h] [ebp-1Ch]
  void *v9; // [esp+14h] [ebp-18h]
  int *v10; // [esp+1Ch] [ebp-10h]
  int v11; // [esp+28h] [ebp-4h]

  v10 = &v7;
  v8 = this;
  v3 = 0;
  v9 = 0;
  if ( a2 )
  {
    if ( a2 > 0xFFFFFFF || (v3 = (char *)operator new(16 * a2), (v9 = v3) == 0) )
      std::_Xbad_alloc();
  }
  v11 = 0;
  sub_405DE0(*this, this[1], v3);
  v4 = *this;
  v5 = (char *)this[1] - (char *)*this;
  if ( v4 )
    operator delete(v4);
  result = v8;
  v8[2] = &v3[16 * a2];
  result[1] = &v3[v5 & 0xFFFFFFF0];
  *result = v3;
  return result;
}
// 43903C: using guessed type void __cdecl std::_Xbad_alloc();

//----- (00406920) --------------------------------------------------------
unsigned int __thiscall sub_406920(int this, unsigned int a2)
{
  int v2; // esi
  unsigned int result; // eax
  int v4; // esi
  unsigned int v5; // esi
  unsigned int v6; // edx
  unsigned int v7; // edx

  v2 = *(_DWORD *)(this + 4);
  result = (*(_DWORD *)(this + 8) - v2) >> 4;
  if ( result < a2 )
  {
    v4 = (v2 - *(_DWORD *)this) >> 4;
    if ( 0xFFFFFFF - v4 < a2 )
      std::_Xlength_error("vector<T> too long");
    v5 = a2 + v4;
    v6 = (*(_DWORD *)(this + 8) - *(_DWORD *)this) >> 4;
    if ( 0xFFFFFFF - (v6 >> 1) >= v6 )
    {
      v7 = (v6 >> 1) + v6;
      if ( v7 < v5 )
        v7 = v5;
    }
    else
    {
      v7 = 0;
      if ( v5 )
        v7 = v5;
    }
    return (unsigned int)sub_406840((_QWORD **)this, v7);
  }
  return result;
}
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (004069A0) --------------------------------------------------------
int __thiscall sub_4069A0(_DWORD *this, unsigned int a2)
{
  int result; // eax
  unsigned int v4; // ecx
  _OWORD *v5; // edx
  _DWORD v6[9]; // [esp+0h] [ebp-24h] BYREF

  v6[5] = v6;
  v6[4] = this;
  result = this[1];
  v4 = (result - *this) >> 4;
  if ( v4 <= a2 )
  {
    if ( v4 < a2 )
    {
      sub_406920((int)this, a2 - v4);
      v5 = (_OWORD *)this[1];
      v6[8] = 0;
      sub_405DC0(v5, a2 - (((int)v5 - *this) >> 4));
      result = (this[1] - *this) >> 4;
      this[1] += 16 * (a2 - result);
    }
  }
  else
  {
    this[1] = result + 16 * (a2 - v4);
  }
  return result;
}

//----- (00406A70) --------------------------------------------------------
double __thiscall sub_406A70(
        int this,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  double v9; // xmm7_8
  double v10; // xmm5_8
  double v11; // xmm4_8
  double v12; // xmm3_8
  int v14; // esi
  double v15; // xmm6_8
  int v16; // edx
  double v17; // xmm1_8
  unsigned int v18; // esi
  double *v19; // ecx
  double v20; // xmm2_8
  double v21; // st7
  double v22; // xmm2_8
  double v24; // [esp+10h] [ebp-18h]
  double v25; // [esp+20h] [ebp-8h]
  int v26; // [esp+24h] [ebp-4h]

  v9 = a8;
  v10 = a7;
  v11 = a6;
  v12 = a4;
  v14 = 1;
  v26 = 1;
  v15 = *(double *)(this + 168);
  v24 = v15;
  while ( 1 )
  {
    v16 = *(_DWORD *)(this + 160);
    v17 = 0.0;
    if ( v16 >= 0 )
    {
      if ( v16 + 1 >= 4 )
      {
        v18 = (unsigned int)(v16 + 1) >> 2;
        v19 = (double *)(this - 16 + 8 * v16);
        v16 -= 4 * v18;
        do
        {
          v20 = (v12 * v11 - v10) * *(double *)(this + 168);
          v17 = (((v17 * v20 + v19[2]) * v20 + v19[1]) * v20 + *v19) * v20 + *(v19 - 1);
          v19 -= 4;
          --v18;
        }
        while ( v18 );
      }
      for ( ; v16 >= 0; --v16 )
        v17 = v17 * ((v12 * v11 - v10) * *(double *)(this + 168)) + *(double *)(this + 8 * v16);
      v14 = v26;
    }
    v25 = v17 / v15 - (v12 * v9 - a9);
    v21 = sub_4060D0((_DWORD *)this, (v12 * v11 - v10) * v15);
    v11 = a6;
    v9 = a8;
    v22 = v25 / (v21 * a6 - a8);
    a4 = a4 - v22;
    v12 = a4;
    if ( (a2 - a4) * (a4 - a3) < 0.0 )
      break;
    if ( a5 <= fabs(v22) )
    {
      v10 = a7;
      ++v14;
      v15 = v24;
      v26 = v14;
      if ( v14 <= 4000 )
        continue;
    }
    return a4;
  }
  return -50.0;
}

//----- (00406C30) --------------------------------------------------------
#error "406CDC: call analysis failed (funcsize=118)"

//----- (00406E50) --------------------------------------------------------
double *__cdecl sub_406E50(double *a1, double *a2, double *a3)
{
  double *result; // eax
  double v4; // xmm0_8
  double v5; // xmm0_8
  double v6; // xmm0_8
  double v7; // xmm5_8
  double v8; // xmm6_8
  double v9; // xmm4_8
  double v10; // xmm7_8
  int v11; // [esp+0h] [ebp-30h]
  int v12; // [esp+0h] [ebp-30h]
  int v13; // [esp+4h] [ebp-2Ch]
  int v14; // [esp+4h] [ebp-2Ch]
  int v15; // [esp+8h] [ebp-28h]
  double v16; // [esp+8h] [ebp-28h]
  int v17; // [esp+Ch] [ebp-24h]
  double v18; // [esp+10h] [ebp-20h]
  double v19; // [esp+18h] [ebp-18h]
  double v20; // [esp+20h] [ebp-10h]

  v20 = a3[1] * a3[1];
  v19 = a3[2] * a3[2];
  v16 = *(double *)libm_sse2_sqrt_precise(v11, v13, v15, v17).m128_u64;
  if ( v16 >= 0.001 )
  {
    v18 = *(double *)libm_sse2_sin_precise().m128_u64;
    v6 = *(double *)libm_sse2_cos_precise(v12, v14).m128_u64;
    v7 = *a3;
    result = a2;
    v8 = (1.0 - v6) / (v16 * v16);
    v9 = (v6 * v7 - v18 * v7 / v16) / (v16 * v16);
    v10 = (v18 * v7 * v16 - (1.0 - v6) * 2.0 * v7) / (v16 * v16 * v16 * v16);
    *a2 = -((v19 + v20) * v10);
    a2[1] = a3[1] * v8 - v9 * a3[2] + a3[1] * *a3 * v10;
    a2[2] = a3[2] * v8 + v9 * a3[1] + a3[2] * *a3 * v10;
    a2[3] = a3[1] * v8 + v9 * a3[2] + a3[1] * *a3 * v10;
    a2[4] = *a3 * -2.0 * v8 - (a3[2] * a3[2] + *a3 * *a3) * v10;
    a2[5] = a3[2] * a3[1] * v10 - (*a3 * v9 + v18 / v16);
    a2[6] = a3[2] * v8 - v9 * a3[1] + a3[2] * *a3 * v10;
    a2[7] = *a3 * v9 + v18 / v16 + a3[2] * a3[1] * v10;
    a2[8] = *a3 * -2.0 * v8 - (a3[1] * a3[1] + *a3 * *a3) * v10;
  }
  else
  {
    result = a1;
    *a2 = 0.0;
    a2[1] = a1[2];
    v4 = -a1[1];
    a2[3] = 0.0;
    a2[2] = v4;
    a2[4] = a1[5];
    v5 = -a1[4];
    a2[6] = 0.0;
    a2[5] = v5;
    a2[7] = a1[8];
    a2[8] = -a1[7];
  }
  return result;
}
// 406E8B: variable 'v11' is possibly undefined
// 406E8B: variable 'v13' is possibly undefined
// 406E8B: variable 'v15' is possibly undefined
// 406E8B: variable 'v17' is possibly undefined
// 406F2D: variable 'v12' is possibly undefined
// 406F2D: variable 'v14' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);
// 436A62: using guessed type __m128 __stdcall libm_sse2_cos_precise(_DWORD, _DWORD);
// 436A68: using guessed type __m128 libm_sse2_sin_precise(void);

//----- (00407120) --------------------------------------------------------
double *__cdecl sub_407120(double *a1, double *a2, double *a3)
{
  double *result; // eax
  double v4; // xmm0_8
  double v5; // xmm0_8
  double v6; // xmm0_8
  double v7; // xmm0_8
  double v8; // xmm6_8
  double v9; // xmm5_8
  double v10; // xmm7_8
  int v11; // [esp+0h] [ebp-38h]
  int v12; // [esp+0h] [ebp-38h]
  int v13; // [esp+4h] [ebp-34h]
  int v14; // [esp+4h] [ebp-34h]
  int v15; // [esp+8h] [ebp-30h]
  double v16; // [esp+8h] [ebp-30h]
  int v17; // [esp+Ch] [ebp-2Ch]
  double v18; // [esp+10h] [ebp-28h]
  double v19; // [esp+18h] [ebp-20h]
  double v20; // [esp+20h] [ebp-18h]

  v19 = a3[1];
  v20 = a3[2] * a3[2];
  v16 = *(double *)libm_sse2_sqrt_precise(v11, v13, v15, v17).m128_u64;
  if ( v16 >= 0.001 )
  {
    v18 = *(double *)libm_sse2_sin_precise().m128_u64;
    v7 = *(double *)libm_sse2_cos_precise(v12, v14).m128_u64;
    result = a2;
    v8 = (1.0 - v7) / (v16 * v16);
    v9 = (v7 * v19 - v18 * v19 / v16) / (v16 * v16);
    v10 = (v18 * v19 * v16 - (1.0 - v7) * 2.0 * v19) / (v16 * v16 * v16 * v16);
    *a2 = v19 * -2.0 * v8 - (v20 + v19 * v19) * v10;
    a2[1] = *a3 * v8 - v9 * a3[2] + *a3 * a3[1] * v10;
    a2[2] = *a3 * a3[2] * v10 + v9 * a3[1] + v18 / v16;
    a2[3] = *a3 * v8 + v9 * a3[2] + *a3 * a3[1] * v10;
    a2[4] = -((*a3 * *a3 + a3[2] * a3[2]) * v10);
    a2[5] = a3[2] * v8 - *a3 * v9 + a3[2] * a3[1] * v10;
    a2[6] = *a3 * a3[2] * v10 - (v9 * a3[1] + v18 / v16);
    a2[7] = a3[2] * v8 + *a3 * v9 + a3[2] * a3[1] * v10;
    a2[8] = a3[1] * -2.0 * v8 - (*a3 * *a3 + a3[1] * a3[1]) * v10;
  }
  else
  {
    result = a2;
    v4 = -a1[2];
    a2[1] = 0.0;
    *a2 = v4;
    a2[2] = *a1;
    v5 = -a1[5];
    a2[4] = 0.0;
    a2[3] = v5;
    a2[5] = a1[3];
    v6 = -a1[8];
    a2[7] = 0.0;
    a2[6] = v6;
    a2[8] = a1[6];
  }
  return result;
}
// 407165: variable 'v11' is possibly undefined
// 407165: variable 'v13' is possibly undefined
// 407165: variable 'v15' is possibly undefined
// 407165: variable 'v17' is possibly undefined
// 407206: variable 'v12' is possibly undefined
// 407206: variable 'v14' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);
// 436A62: using guessed type __m128 __stdcall libm_sse2_cos_precise(_DWORD, _DWORD);
// 436A68: using guessed type __m128 libm_sse2_sin_precise(void);

//----- (00407400) --------------------------------------------------------
double *__cdecl sub_407400(double *a1, double *a2, double *a3)
{
  double *result; // eax
  double v4; // xmm0_8
  double v5; // xmm0_8
  double v6; // xmm0_8
  double v7; // xmm0_8
  double v8; // xmm5_8
  double v9; // xmm6_8
  double v10; // xmm7_8
  int v11; // [esp+0h] [ebp-38h]
  int v12; // [esp+0h] [ebp-38h]
  int v13; // [esp+4h] [ebp-34h]
  int v14; // [esp+4h] [ebp-34h]
  int v15; // [esp+8h] [ebp-30h]
  double v16; // [esp+8h] [ebp-30h]
  int v17; // [esp+Ch] [ebp-2Ch]
  double v18; // [esp+10h] [ebp-28h]
  double v19; // [esp+18h] [ebp-20h]
  double v20; // [esp+28h] [ebp-10h]

  v20 = a3[1] * a3[1];
  v19 = a3[2];
  v16 = *(double *)libm_sse2_sqrt_precise(v11, v13, v15, v17).m128_u64;
  if ( v16 >= 0.001 )
  {
    v18 = *(double *)libm_sse2_sin_precise().m128_u64;
    v7 = *(double *)libm_sse2_cos_precise(v12, v14).m128_u64;
    result = a2;
    v8 = (1.0 - v7) / (v16 * v16);
    v9 = (v7 * v19 - v18 * v19 / v16) / (v16 * v16);
    v10 = (v18 * v19 * v16 - (1.0 - v7) * 2.0 * v19) / (v16 * v16 * v16 * v16);
    *a2 = v19 * -2.0 * v8 - (v19 * v19 + v20) * v10;
    a2[1] = *a3 * a3[1] * v10 - (v9 * a3[2] + v18 / v16);
    a2[2] = *a3 * v8 + v9 * a3[1] + *a3 * a3[2] * v10;
    a2[3] = *a3 * a3[1] * v10 + v9 * a3[2] + v18 / v16;
    a2[4] = a3[2] * -2.0 * v8 - (*a3 * *a3 + a3[2] * a3[2]) * v10;
    a2[5] = a3[1] * v8 - *a3 * v9 + a3[1] * a3[2] * v10;
    a2[6] = *a3 * v8 - v9 * a3[1] + *a3 * a3[2] * v10;
    a2[7] = a3[1] * v8 + *a3 * v9 + a3[1] * a3[2] * v10;
    a2[8] = -((*a3 * *a3 + a3[1] * a3[1]) * v10);
  }
  else
  {
    result = a1;
    *a2 = a1[1];
    v4 = -*a1;
    a2[2] = 0.0;
    a2[1] = v4;
    a2[3] = a1[4];
    v5 = -a1[3];
    a2[5] = 0.0;
    a2[4] = v5;
    a2[6] = a1[7];
    v6 = -a1[6];
    a2[8] = 0.0;
    a2[7] = v6;
  }
  return result;
}
// 407445: variable 'v11' is possibly undefined
// 407445: variable 'v13' is possibly undefined
// 407445: variable 'v15' is possibly undefined
// 407445: variable 'v17' is possibly undefined
// 4074E6: variable 'v12' is possibly undefined
// 4074E6: variable 'v14' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);
// 436A62: using guessed type __m128 __stdcall libm_sse2_cos_precise(_DWORD, _DWORD);
// 436A68: using guessed type __m128 libm_sse2_sin_precise(void);

//----- (004076E0) --------------------------------------------------------
char *__thiscall sub_4076E0(int this, unsigned int a2)
{
  char *v2; // esi
  char *result; // eax
  int v5; // [esp+Ch] [ebp-4h]

  v2 = 0;
  if ( a2 )
  {
    if ( a2 > 0x1FFFFFFF || (v2 = (char *)operator new(8 * a2)) == 0 )
      std::_Xbad_alloc();
  }
  memmove(v2, *(const void **)this, (*(_DWORD *)(this + 4) - *(_DWORD *)this) & 0xFFFFFFF8);
  v5 = (*(_DWORD *)(this + 4) - *(_DWORD *)this) >> 3;
  if ( *(_DWORD *)this )
    operator delete(*(void **)this);
  *(_DWORD *)this = v2;
  *(_DWORD *)(this + 8) = &v2[8 * a2];
  result = &v2[8 * v5];
  *(_DWORD *)(this + 4) = result;
  return result;
}
// 43903C: using guessed type void __cdecl std::_Xbad_alloc();

//----- (00407760) --------------------------------------------------------
unsigned int __thiscall sub_407760(_DWORD *this, unsigned int a2)
{
  int v2; // esi
  unsigned int result; // eax
  int v4; // esi
  unsigned int v5; // esi
  unsigned int v6; // edx
  unsigned int v7; // edx

  v2 = this[1];
  result = (this[2] - v2) >> 3;
  if ( result < a2 )
  {
    v4 = (v2 - *this) >> 3;
    if ( 0x1FFFFFFF - v4 < a2 )
      std::_Xlength_error("vector<T> too long");
    v5 = a2 + v4;
    v6 = (this[2] - *this) >> 3;
    if ( 0x1FFFFFFF - (v6 >> 1) >= v6 )
    {
      v7 = (v6 >> 1) + v6;
      if ( v7 < v5 )
        v7 = v5;
    }
    else
    {
      v7 = 0;
      if ( v5 )
        v7 = v5;
    }
    return (unsigned int)sub_4076E0((int)this, v7);
  }
  return result;
}
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (004077E0) --------------------------------------------------------
int __thiscall sub_4077E0(_DWORD *this, unsigned int a2)
{
  int result; // eax
  unsigned int v4; // edx
  int v5; // eax

  result = this[1];
  v4 = (result - *this) >> 3;
  if ( v4 <= a2 )
  {
    if ( v4 < a2 )
    {
      sub_407760(this, a2 - v4);
      v5 = (this[1] - *this) >> 3;
      if ( a2 != v5 )
        memset((void *)this[1], 0, 8 * (a2 - v5));
      result = this[1] + 8 * (a2 - ((this[1] - *this) >> 3));
      this[1] = result;
    }
  }
  else
  {
    result += 8 * (a2 - v4);
    this[1] = result;
  }
  return result;
}

//----- (00407850) --------------------------------------------------------
_DWORD *__thiscall sub_407850(_DWORD *this, int a2, int a3, int a4)
{
  void *v5; // eax

  this[8] = a4;
  this[6] = a2;
  *this = &CLevmarForGCM_LineGap_LS::`vftable';
  this[7] = a3;
  this[1] = operator new[](8 * a2);
  v5 = operator new[](8 * a3);
  this[2] = v5;
  memset(v5, 0, 8 * a3);
  return this;
}
// 439424: using guessed type void *CLevmarForGCM_LineGap_LS::`vftable';

//----- (004078C0) --------------------------------------------------------
void __thiscall sub_4078C0(void *this)
{
  void *v2; // [esp-4h] [ebp-8h]

  v2 = (void *)*((_DWORD *)this + 1);
  *(_DWORD *)this = &CLevmarForGCM_LineGap_LS::`vftable';
  operator delete[](v2);
  operator delete[](*((void **)this + 2));
}
// 439424: using guessed type void *CLevmarForGCM_LineGap_LS::`vftable';

//----- (004078E0) --------------------------------------------------------
void *__thiscall sub_4078E0(void *this, char a2)
{
  void *v4; // [esp-4h] [ebp-8h]

  v4 = (void *)*((_DWORD *)this + 1);
  *(_DWORD *)this = &CLevmarForGCM_LineGap_LS::`vftable';
  operator delete[](v4);
  operator delete[](*((void **)this + 2));
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 439424: using guessed type void *CLevmarForGCM_LineGap_LS::`vftable';

//----- (00407920) --------------------------------------------------------
int __usercall sub_407920@<eax>(int a1@<edi>, int a2@<esi>, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // esi
  int v8; // edi
  double v9; // xmm6_8
  double v10; // xmm7_8
  int *v11; // edx
  double v12; // xmm2_8
  double v13; // xmm0_8
  int v14; // eax
  double v15; // xmm4_8
  double v16; // xmm5_8
  double v17; // xmm6_8
  double v18; // xmm7_8
  double *v19; // esi
  double v20; // st7
  double v21; // xmm3_8
  double v22; // xmm1_8
  double v23; // xmm0_8
  double v24; // xmm1_8
  int v25; // edi
  int v26; // esi
  double *v27; // edx
  double v28; // xmm1_8
  double v29; // xmm0_8
  int v30; // eax
  int v31; // edx
  int v32; // edi
  double v33; // xmm0_8
  double v34; // xmm1_8
  double v35; // xmm6_8
  double v36; // xmm5_8
  double v37; // xmm4_8
  int v38; // edi
  double *v39; // esi
  double v40; // xmm2_8
  double v41; // st7
  double v42; // xmm7_8
  __int128 v43; // xmm6
  double v44; // xmm5_8
  int v45; // ecx
  double *v46; // esi
  __int128 v47; // xmm1
  __int128 v48; // xmm2
  unsigned int v49; // eax
  double v50; // xmm1_8
  __int128 v51; // xmm0
  double v52; // xmm2_8
  int v53; // edx
  unsigned int v54; // eax
  double v55; // xmm3_8
  double v56; // xmm0_8
  __int128 v57; // xmm2
  double v58; // xmm1_8
  __int128 v59; // xmm0
  double v60; // xmm2_8
  unsigned int v61; // eax
  double v62; // xmm0_8
  __int128 v63; // xmm2
  double v64; // xmm1_8
  __int128 v65; // xmm0
  double v66; // xmm0_8
  double v67; // xmm0_8
  int v68; // esi
  double v69; // xmm3_8
  double v70; // xmm2_8
  double v71; // xmm3_8
  double v72; // st7
  double v73; // xmm0_8
  double v74; // xmm7_8
  double v75; // xmm6_8
  double v76; // xmm3_8
  __int128 v77; // xmm5
  int v78; // ecx
  double *v79; // esi
  __int128 v80; // xmm1
  __int128 v81; // xmm2
  unsigned int v82; // eax
  double v83; // xmm1_8
  __int128 v84; // xmm0
  double v85; // xmm2_8
  int v86; // edx
  unsigned int v87; // eax
  double v88; // xmm3_8
  double v89; // xmm0_8
  __int128 v90; // xmm2
  double v91; // xmm1_8
  __int128 v92; // xmm0
  double v93; // xmm2_8
  unsigned int v94; // eax
  double v95; // xmm0_8
  __int128 v96; // xmm2
  double v97; // xmm1_8
  __int128 v98; // xmm0
  double v99; // xmm0_8
  double v100; // xmm0_8
  double *v101; // esi
  double v102; // xmm2_8
  double v103; // xmm3_8
  double v104; // st7
  double v105; // xmm0_8
  double v106; // xmm4_8
  double v107; // xmm3_8
  double v108; // xmm5_8
  double v109; // xmm7_8
  double v110; // xmm6_8
  int v111; // ecx
  __int128 v112; // xmm2
  double *v113; // esi
  unsigned int v114; // eax
  double v115; // xmm1_8
  __int128 v116; // xmm0
  double v117; // xmm0_8
  __int128 v118; // xmm2
  int v119; // edx
  unsigned int v120; // eax
  double v121; // xmm3_8
  double v122; // xmm1_8
  __int128 v123; // xmm0
  double v124; // xmm0_8
  __int128 v125; // xmm2
  unsigned int v126; // eax
  double v127; // xmm1_8
  __int128 v128; // xmm0
  double v129; // xmm0_8
  double v130; // xmm0_8
  double v131; // xmm0_8
  int v132; // edx
  int v133; // eax
  double v134; // xmm0_8
  double v135; // xmm0_8
  double *v136; // ecx
  double *v137; // eax
  double v138; // xmm1_8
  int result; // eax
  double v140; // xmm1_8
  int v141; // [esp+40h] [ebp-1C8h]
  int v142; // [esp+40h] [ebp-1C8h]
  int v143; // [esp+40h] [ebp-1C8h]
  int v144; // [esp+40h] [ebp-1C8h]
  int v145; // [esp+40h] [ebp-1C8h]
  int v146; // [esp+40h] [ebp-1C8h]
  int v147; // [esp+40h] [ebp-1C8h]
  int v148; // [esp+40h] [ebp-1C8h]
  int v149; // [esp+40h] [ebp-1C8h]
  int v150; // [esp+40h] [ebp-1C8h]
  int v151; // [esp+44h] [ebp-1C4h]
  int v152; // [esp+44h] [ebp-1C4h]
  int v153; // [esp+44h] [ebp-1C4h]
  int v154; // [esp+44h] [ebp-1C4h]
  int v155; // [esp+44h] [ebp-1C4h]
  int v156; // [esp+44h] [ebp-1C4h]
  int v157; // [esp+44h] [ebp-1C4h]
  int v158; // [esp+44h] [ebp-1C4h]
  int v159; // [esp+44h] [ebp-1C4h]
  int v160; // [esp+44h] [ebp-1C4h]
  int v161; // [esp+48h] [ebp-1C0h]
  unsigned int v162; // [esp+48h] [ebp-1C0h]
  int v163; // [esp+48h] [ebp-1C0h]
  int v164; // [esp+48h] [ebp-1C0h]
  int v165; // [esp+48h] [ebp-1C0h]
  int v166; // [esp+48h] [ebp-1C0h]
  int v167; // [esp+48h] [ebp-1C0h]
  int v168; // [esp+48h] [ebp-1C0h]
  int v169; // [esp+48h] [ebp-1C0h]
  int v170; // [esp+48h] [ebp-1C0h]
  int v171; // [esp+48h] [ebp-1C0h]
  int v172; // [esp+48h] [ebp-1C0h]
  int v173; // [esp+48h] [ebp-1C0h]
  int v174; // [esp+4Ch] [ebp-1BCh]
  int v175; // [esp+4Ch] [ebp-1BCh]
  int v176; // [esp+4Ch] [ebp-1BCh]
  int v177; // [esp+4Ch] [ebp-1BCh]
  int v178; // [esp+4Ch] [ebp-1BCh]
  int v179; // [esp+4Ch] [ebp-1BCh]
  int v180; // [esp+4Ch] [ebp-1BCh]
  int v181; // [esp+4Ch] [ebp-1BCh]
  int v182; // [esp+4Ch] [ebp-1BCh]
  int v183; // [esp+4Ch] [ebp-1BCh]
  int v184; // [esp+4Ch] [ebp-1BCh]
  int v185; // [esp+4Ch] [ebp-1BCh]
  int v186; // [esp+4Ch] [ebp-1BCh]
  double v187; // [esp+50h] [ebp-1B8h]
  double v188; // [esp+50h] [ebp-1B8h]
  double v189; // [esp+50h] [ebp-1B8h]
  int v190; // [esp+5Ch] [ebp-1ACh]
  double v191; // [esp+60h] [ebp-1A8h]
  int v192; // [esp+6Ch] [ebp-19Ch]
  int v193; // [esp+70h] [ebp-198h]
  int v194; // [esp+70h] [ebp-198h]
  double v195; // [esp+70h] [ebp-198h]
  double v196; // [esp+70h] [ebp-198h]
  double v197; // [esp+70h] [ebp-198h]
  double v198; // [esp+80h] [ebp-188h]
  double v199; // [esp+80h] [ebp-188h]
  double v200; // [esp+80h] [ebp-188h]
  double v201; // [esp+80h] [ebp-188h]
  double v202; // [esp+88h] [ebp-180h]
  double v203; // [esp+88h] [ebp-180h]
  double v204; // [esp+90h] [ebp-178h]
  double v205; // [esp+90h] [ebp-178h]
  int v206; // [esp+9Ch] [ebp-16Ch]
  double v207; // [esp+A0h] [ebp-168h]
  double v208; // [esp+A0h] [ebp-168h]
  double v209; // [esp+A8h] [ebp-160h]
  double v210; // [esp+A8h] [ebp-160h]
  double v211; // [esp+A8h] [ebp-160h]
  double v212; // [esp+B0h] [ebp-158h]
  double v213; // [esp+B0h] [ebp-158h]
  double v214; // [esp+B8h] [ebp-150h]
  double v215; // [esp+C0h] [ebp-148h]
  double v216; // [esp+C8h] [ebp-140h]
  double v217; // [esp+C8h] [ebp-140h]
  int v218; // [esp+D4h] [ebp-134h]
  double v219; // [esp+D8h] [ebp-130h]
  double v220; // [esp+E0h] [ebp-128h]
  double v221; // [esp+E0h] [ebp-128h]
  double v222; // [esp+E8h] [ebp-120h]
  double v223; // [esp+E8h] [ebp-120h]
  double *v224; // [esp+F4h] [ebp-114h]
  double v225; // [esp+F8h] [ebp-110h] BYREF
  double v226; // [esp+100h] [ebp-108h]
  double v227; // [esp+108h] [ebp-100h]
  double v228; // [esp+110h] [ebp-F8h]
  double v229; // [esp+118h] [ebp-F0h]
  double v230; // [esp+120h] [ebp-E8h]
  double v231; // [esp+128h] [ebp-E0h]
  double v232; // [esp+130h] [ebp-D8h]
  double v233; // [esp+138h] [ebp-D0h]
  double v234; // [esp+140h] [ebp-C8h] BYREF
  double v235; // [esp+148h] [ebp-C0h] BYREF
  char v236[180]; // [esp+150h] [ebp-B8h] BYREF

  v151 = a2;
  v141 = a1;
  *(_QWORD *)(a3 + 24) = 0i64;
  v206 = *(_DWORD *)(a7 + 32);
  sub_405EB0((int)v236, v206, a3 + 24, qword_43E0E8);
  v7 = *(_DWORD *)(a7 + 20);
  v192 = v7;
  v212 = *(double *)(v7 + 56);
  v8 = a3 + 8 * *(_DWORD *)(v7 + 204);
  v174 = v8;
  sub_406C30(*(_QWORD *)a3, *(double *)(a3 + 8), *(double *)(a3 + 16), &v225);
  v9 = v233;
  v10 = v227;
  v11 = (int *)(v7 + 48);
  v224 = (double *)(a3 + 64);
  if ( *(_DWORD *)(v7 + 48) < *(_DWORD *)(v7 + 52) )
    v11 = (int *)(v7 + 52);
  v161 = 0;
  v218 = *(_DWORD *)(v7 + 24);
  v12 = (double)*v11 * *(double *)(a3 + 64);
  v190 = *(_DWORD *)(v7 + 16);
  if ( v190 <= 0 )
  {
    v21 = v212;
  }
  else
  {
    v13 = -v12;
    v14 = 0;
    v15 = -v12 * v227;
    v193 = 0;
    v16 = v233 * -v12;
    v17 = v233 * v12;
    v18 = v227 * v12;
    v220 = v15;
    v204 = v16;
    v216 = v233 * v12;
    v222 = v227 * v12;
    v191 = v230 * v12;
    do
    {
      v19 = (double *)(v14 + *(_DWORD *)(v7 + 108));
      v19[2] = v13;
      v20 = sub_406A70(
              (int)v236,
              -4.0,
              0.0,
              -1.0,
              1.0e-10,
              *v19 * v225 + v19[1] * v226 + v15,
              v18,
              *v19 * v231 + v19[1] * v232 + v16,
              v17);
      v21 = v212;
      v15 = v220;
      v16 = v204;
      v22 = *v19 * v228 + v19[1] * v229;
      v17 = v216;
      v23 = v19[2] * v230;
      v7 = v192;
      v18 = v222;
      v24 = (v22 + v23) * v20 - v191 - *(double *)(v8 + 8 * *(_DWORD *)(*(_DWORD *)(v192 + 120) + 4 * v161)) * v212;
      v13 = -v12;
      *(double *)(a4 + 8 * v161) = v24;
      v14 = v193 + 32;
      ++v161;
      v193 += 32;
    }
    while ( v161 < v190 );
    v9 = v233;
    v10 = v227;
  }
  v25 = *(_DWORD *)(v7 + 132);
  v162 = 0;
  if ( (*(_DWORD *)(v7 + 136) - v25) / 24 )
  {
    v26 = 0;
    v27 = (double *)(a4 + 8 * v190);
    do
    {
      ++v162;
      v28 = *(double *)(v174 + 8 * *(_DWORD *)(v26 + v25))
          - *(double *)(v174 + 8 * *(_DWORD *)(v26 + v25 + 4)) * 2.0
          + *(double *)(v174 + 8 * *(_DWORD *)(v26 + v25 + 8));
      *v27 = v28;
      v29 = *(double *)(v26 + *(_DWORD *)(v192 + 132) + 16);
      v26 += 24;
      *v27 = v29 * v21 * v28;
      v25 = *(_DWORD *)(v192 + 132);
      ++v27;
    }
    while ( v162 < (*(_DWORD *)(v192 + 136) - v25) / 24 );
    v7 = v192;
  }
  v30 = v190;
  v31 = 0;
  v175 = 0;
  v32 = v190 + v218 + (*(_DWORD *)(v7 + 136) - *(_DWORD *)(v7 + 132)) / 24;
  v163 = v32;
  if ( v218 > 0 )
  {
    v33 = v9;
    v34 = -v12;
    v35 = v9 * v12;
    v36 = -v12 * v10;
    v37 = v10 * v12;
    v219 = v33 * -v12;
    v215 = -v12;
    v213 = v36;
    v221 = v35;
    v214 = v10 * v12;
    v223 = v230 * v12;
    do
    {
      v194 = v31 + v30 + 2 * v31;
      v38 = 32 * v194;
      v39 = (double *)(32 * v194 + *(_DWORD *)(v7 + 108));
      v40 = *v39;
      v39[2] = v34;
      v41 = sub_406A70(
              (int)v236,
              -4.0,
              0.0,
              -1.0,
              1.0e-10,
              v40 * v225 + v39[1] * v226 + v36,
              v37,
              v40 * v231 + v39[1] * v232 + v219,
              v35);
      v42 = 0.0;
      v43 = *(unsigned __int64 *)v39;
      v198 = 0.0;
      *(double *)&v43 = (*(double *)&v43 * v225 + v39[1] * v226 + v39[2] * v227) * v41 - v214;
      v202 = *(double *)&v43;
      v217 = (v228 * *v39 + v229 * v39[1] + v230 * v39[2]) * v41 - v223;
      v44 = 0.0;
      if ( v206 >= 1 )
      {
        v45 = 0;
        v47 = (unsigned __int64)qword_43E0E8;
        *(double *)&v43 = *(double *)&v43 * *(double *)&qword_43E0E8;
        v46 = (double *)(a3 + 32);
        *(double *)&v47 = *(double *)&qword_43E0E8 * 0.0;
        do
        {
          v48 = v47;
          v49 = v45;
          if ( v45 < 0 )
            v49 = -v45;
          v50 = 1.0;
          while ( 1 )
          {
            if ( (v49 & 1) != 0 )
              v50 = v50 * *(double *)&v48;
            v49 >>= 1;
            if ( !v49 )
              break;
            *((_QWORD *)&v51 + 1) = *((_QWORD *)&v48 + 1);
            *(double *)&v51 = *(double *)&v48 * *(double *)&v48;
            v48 = v51;
          }
          if ( v45 >= 0 )
            v52 = v50;
          else
            v52 = 1.0 / v50;
          v53 = v45 + 1;
          v54 = v45;
          v55 = (double)(v45 + 1) * *v46;
          v56 = v55 * v52;
          v57 = COERCE_UNSIGNED_INT64(*(double *)&v43 * 0.5);
          v198 = v56 + v198;
          if ( v45 < 0 )
            v54 = -v45;
          v58 = 1.0;
          while ( 1 )
          {
            if ( (v54 & 1) != 0 )
              v58 = v58 * *(double *)&v57;
            v54 >>= 1;
            if ( !v54 )
              break;
            *((_QWORD *)&v59 + 1) = *((_QWORD *)&v57 + 1);
            *(double *)&v59 = *(double *)&v57 * *(double *)&v57;
            v57 = v59;
          }
          if ( v45 >= 0 )
            v60 = v58;
          else
            v60 = 1.0 / v58;
          v61 = v45;
          v62 = v55 * v60;
          v63 = v43;
          v42 = v62 + v42;
          if ( v45 < 0 )
            v61 = -v45;
          v64 = 1.0;
          while ( 1 )
          {
            if ( (v61 & 1) != 0 )
              v64 = v64 * *(double *)&v63;
            v61 >>= 1;
            if ( !v61 )
              break;
            *((_QWORD *)&v65 + 1) = *((_QWORD *)&v63 + 1);
            *(double *)&v65 = *(double *)&v63 * *(double *)&v63;
            v63 = v65;
          }
          if ( v45 >= 0 )
            v66 = v64;
          else
            v66 = 1.0 / v64;
          v47 = COERCE_UNSIGNED_INT64(*(double *)&qword_43E0E8 * 0.0);
          ++v45;
          ++v46;
          v44 = v55 * v66 + v44;
        }
        while ( v53 + 1 <= v206 );
      }
      v209 = *(double *)libm_sse2_sqrt_precise(v141, v151, v163, v175).m128_u64 * 4.0;
      v210 = v209 + *(double *)libm_sse2_sqrt_precise(v142, v152, v164, v176).m128_u64;
      v67 = *(double *)libm_sse2_sqrt_precise(v143, v153, v165, v177).m128_u64;
      v68 = *(_DWORD *)(v192 + 108);
      v69 = *(double *)(v38 + v68 + 32);
      v70 = v69 * v231;
      v71 = v69 * v225;
      *(double *)(v38 + v68 + 48) = v215;
      v211 = (v210 + v67) * (v202 / 6.0);
      v72 = sub_406A70(
              (int)v236,
              -4.0,
              0.0,
              -1.0,
              1.0e-10,
              v71 + *(double *)(v38 + v68 + 40) * v226 + v213,
              v214,
              v70 + *(double *)(v38 + v68 + 40) * v232 + v219,
              v221);
      v73 = *(double *)(v38 + v68 + 48);
      v203 = 0.0;
      v74 = 0.0;
      v75 = 0.0;
      v76 = (*(double *)(v38 + v68 + 32) * v225 + *(double *)(v38 + v68 + 40) * v226 + v73 * v227) * v72 - v214;
      v207 = v76;
      v205 = (*(double *)(v38 + v68 + 32) * v228 + *(double *)(v38 + v68 + 40) * v229 + v73 * v230) * v72 - v223;
      if ( v206 >= 1 )
      {
        *((_QWORD *)&v77 + 1) = 0i64;
        v80 = (unsigned __int64)qword_43E0E8;
        *(double *)&v77 = v76 * *(double *)&qword_43E0E8;
        v78 = 0;
        v79 = (double *)(a3 + 32);
        *(double *)&v80 = *(double *)&qword_43E0E8 * 0.0;
        v187 = v76 * *(double *)&qword_43E0E8 * 0.5;
        do
        {
          v81 = v80;
          v82 = v78;
          if ( v78 < 0 )
            v82 = -v78;
          v83 = 1.0;
          while ( 1 )
          {
            if ( (v82 & 1) != 0 )
              v83 = v83 * *(double *)&v81;
            v82 >>= 1;
            if ( !v82 )
              break;
            *((_QWORD *)&v84 + 1) = *((_QWORD *)&v81 + 1);
            *(double *)&v84 = *(double *)&v81 * *(double *)&v81;
            v81 = v84;
          }
          if ( v78 >= 0 )
            v85 = v83;
          else
            v85 = 1.0 / v83;
          v86 = v78 + 1;
          v87 = v78;
          v88 = (double)(v78 + 1) * *v79;
          v89 = v88 * v85;
          v90 = *(unsigned __int64 *)&v187;
          v203 = v89 + v203;
          if ( v78 < 0 )
            v87 = -v78;
          v91 = 1.0;
          while ( 1 )
          {
            if ( (v87 & 1) != 0 )
              v91 = v91 * *(double *)&v90;
            v87 >>= 1;
            if ( !v87 )
              break;
            *((_QWORD *)&v92 + 1) = *((_QWORD *)&v90 + 1);
            *(double *)&v92 = *(double *)&v90 * *(double *)&v90;
            v90 = v92;
          }
          if ( v78 >= 0 )
            v93 = v91;
          else
            v93 = 1.0 / v91;
          v94 = v78;
          v95 = v88 * v93;
          v96 = v77;
          v74 = v95 + v74;
          if ( v78 < 0 )
            v94 = -v78;
          v97 = 1.0;
          while ( 1 )
          {
            if ( (v94 & 1) != 0 )
              v97 = v97 * *(double *)&v96;
            v94 >>= 1;
            if ( !v94 )
              break;
            *((_QWORD *)&v98 + 1) = *((_QWORD *)&v96 + 1);
            *(double *)&v98 = *(double *)&v96 * *(double *)&v96;
            v96 = v98;
          }
          if ( v78 >= 0 )
            v99 = v97;
          else
            v99 = 1.0 / v97;
          v80 = COERCE_UNSIGNED_INT64(*(double *)&qword_43E0E8 * 0.0);
          ++v78;
          ++v79;
          v75 = v88 * v99 + v75;
        }
        while ( v86 + 1 <= v206 );
      }
      v199 = *(double *)libm_sse2_sqrt_precise(v144, v154, v166, v178).m128_u64 * 4.0;
      v200 = v199 + *(double *)libm_sse2_sqrt_precise(v145, v155, v167, v179).m128_u64;
      v100 = *(double *)libm_sse2_sqrt_precise(v146, v156, v168, v180).m128_u64;
      v101 = (double *)(*(_DWORD *)(v192 + 108) + 32 * (v194 + 2));
      v102 = *v101 * v231;
      v103 = *v101 * v225;
      v101[2] = v215;
      v201 = (v200 + v100) * (v207 / 6.0);
      v104 = sub_406A70(
               (int)v236,
               -4.0,
               0.0,
               -1.0,
               1.0e-10,
               v103 + v101[1] * v226 + v213,
               v214,
               v102 + v101[1] * v232 + v219,
               v221);
      v105 = v101[2];
      v106 = *v101 * v228 + v101[1] * v229;
      v107 = (*v101 * v225 + v101[1] * v226 + v105 * v227) * v104 - v214;
      v234 = v107;
      v235 = (v106 + v105 * v230) * v104 - v223;
      v108 = 0.0;
      v109 = 0.0;
      v110 = 0.0;
      if ( v206 >= 1 )
      {
        v111 = 0;
        v112 = (unsigned __int64)qword_43E0E8;
        *(double *)&v112 = *(double *)&qword_43E0E8 * 0.0;
        v113 = (double *)(a3 + 32);
        v188 = v107 * *(double *)&qword_43E0E8;
        v208 = v107 * *(double *)&qword_43E0E8 * 0.5;
        do
        {
          v114 = v111;
          if ( v111 < 0 )
            v114 = -v111;
          v115 = 1.0;
          while ( 1 )
          {
            if ( (v114 & 1) != 0 )
              v115 = v115 * *(double *)&v112;
            v114 >>= 1;
            if ( !v114 )
              break;
            *((_QWORD *)&v116 + 1) = *((_QWORD *)&v112 + 1);
            *(double *)&v116 = *(double *)&v112 * *(double *)&v112;
            v112 = v116;
          }
          if ( v111 >= 0 )
            v117 = v115;
          else
            v117 = 1.0 / v115;
          v118 = *(unsigned __int64 *)&v208;
          v119 = v111 + 1;
          v120 = v111;
          v121 = (double)(v111 + 1) * *v113;
          v109 = v117 * v121 + v109;
          if ( v111 < 0 )
            v120 = -v111;
          v122 = 1.0;
          while ( 1 )
          {
            if ( (v120 & 1) != 0 )
              v122 = v122 * *(double *)&v118;
            v120 >>= 1;
            if ( !v120 )
              break;
            *((_QWORD *)&v123 + 1) = *((_QWORD *)&v118 + 1);
            *(double *)&v123 = *(double *)&v118 * *(double *)&v118;
            v118 = v123;
          }
          if ( v111 >= 0 )
            v124 = v122;
          else
            v124 = 1.0 / v122;
          v125 = *(unsigned __int64 *)&v188;
          v126 = v111;
          v110 = v124 * v121 + v110;
          if ( v111 < 0 )
            v126 = -v111;
          v127 = 1.0;
          while ( 1 )
          {
            if ( (v126 & 1) != 0 )
              v127 = v127 * *(double *)&v125;
            v126 >>= 1;
            if ( !v126 )
              break;
            *((_QWORD *)&v128 + 1) = *((_QWORD *)&v125 + 1);
            *(double *)&v128 = *(double *)&v125 * *(double *)&v125;
            v125 = v128;
          }
          if ( v111 >= 0 )
            v129 = v127;
          else
            v129 = 1.0 / v127;
          v112 = COERCE_UNSIGNED_INT64(*(double *)&qword_43E0E8 * 0.0);
          ++v111;
          ++v113;
          v108 = v129 * v121 + v108;
        }
        while ( v119 + 1 <= v206 );
      }
      v195 = *(double *)libm_sse2_sqrt_precise(v147, v157, v169, v181).m128_u64 * 4.0;
      v196 = v195 + *(double *)libm_sse2_sqrt_precise(v148, v158, v170, v182).m128_u64;
      v130 = *(double *)libm_sse2_sqrt_precise(v149, v159, v171, v183).m128_u64;
      v197 = (v196 + v130) * (v234 / 6.0) * (v205 - v217) + (v211 - v201) * v235 + v201 * v217 - v205 * v211;
      v131 = *(double *)libm_sse2_sqrt_precise(v150, v160, v172, v184).m128_u64;
      v7 = v192;
      *(double *)(a4 + 8 * (v190 + v185 + (*(_DWORD *)(v192 + 136) - *(_DWORD *)(v192 + 132)) / 24)) = v197 / v131;
      v132 = v185;
      v133 = v190 + v185 + (*(_DWORD *)(v7 + 136) - *(_DWORD *)(v7 + 132)) / 24;
      *(double *)(a4 + 8 * v133) = *(double *)(a4 + 8 * v133) * *(double *)(v192 + 80);
      if ( *(_BYTE *)(*(_DWORD *)(v192 + 192) + 40 * v185 + 32) == 1 )
      {
        if ( fabs(v211 - v201) <= fabs(v217 - v205) )
          v134 = v211 - v201;
        else
          v134 = v217 - v205;
        v189 = v134;
        v135 = *(double *)libm_sse2_sqrt_precise(v141, v151, v163, v185).m128_u64;
        v132 = v186;
        *(double *)(a4 + 8 * v173) = v189 / v135;
        *(double *)(a4 + 8 * v173) = *(double *)(v192 + 72) * (v189 / v135);
        v32 = v173 + 1;
        v163 = v173 + 1;
      }
      else
      {
        v32 = v163;
      }
      v35 = v221;
      v31 = v132 + 1;
      v37 = v214;
      v34 = v215;
      v36 = v213;
      v30 = v190;
      v175 = v31;
    }
    while ( v31 < v218 );
  }
  v136 = &v235;
  v137 = &v234;
  v235 = 1.0;
  v234 = 1.0;
  if ( *v224 > 1.0 )
    v136 = (double *)(a3 + 64);
  if ( *v224 < 1.0 )
    v137 = (double *)(a3 + 64);
  v138 = *v136 / *v137;
  result = a4;
  v140 = v138 - 1.0;
  *(double *)(a4 + 8 * v32) = v140;
  *(double *)(a4 + 8 * v32) = *(double *)(v7 + 88) * v140;
  return result;
}
// 407920: could not find valid save-restore pair for edi
// 407920: could not find valid save-restore pair for esi
// 408042: variable 'v141' is possibly undefined
// 408042: variable 'v151' is possibly undefined
// 408042: variable 'v163' is possibly undefined
// 408067: variable 'v142' is possibly undefined
// 408067: variable 'v152' is possibly undefined
// 408067: variable 'v164' is possibly undefined
// 408067: variable 'v176' is possibly undefined
// 40808E: variable 'v143' is possibly undefined
// 40808E: variable 'v153' is possibly undefined
// 40808E: variable 'v165' is possibly undefined
// 40808E: variable 'v177' is possibly undefined
// 408390: variable 'v144' is possibly undefined
// 408390: variable 'v154' is possibly undefined
// 408390: variable 'v166' is possibly undefined
// 408390: variable 'v178' is possibly undefined
// 4083B5: variable 'v145' is possibly undefined
// 4083B5: variable 'v155' is possibly undefined
// 4083B5: variable 'v167' is possibly undefined
// 4083B5: variable 'v179' is possibly undefined
// 4083DC: variable 'v146' is possibly undefined
// 4083DC: variable 'v156' is possibly undefined
// 4083DC: variable 'v168' is possibly undefined
// 4083DC: variable 'v180' is possibly undefined
// 40870D: variable 'v147' is possibly undefined
// 40870D: variable 'v157' is possibly undefined
// 40870D: variable 'v169' is possibly undefined
// 40870D: variable 'v181' is possibly undefined
// 408732: variable 'v148' is possibly undefined
// 408732: variable 'v158' is possibly undefined
// 408732: variable 'v170' is possibly undefined
// 408732: variable 'v182' is possibly undefined
// 408759: variable 'v149' is possibly undefined
// 408759: variable 'v159' is possibly undefined
// 408759: variable 'v171' is possibly undefined
// 408759: variable 'v183' is possibly undefined
// 4087D5: variable 'v150' is possibly undefined
// 4087D5: variable 'v160' is possibly undefined
// 4087D5: variable 'v172' is possibly undefined
// 4087D5: variable 'v184' is possibly undefined
// 408809: variable 'v185' is possibly undefined
// 4088C5: variable 'v186' is possibly undefined
// 4088C9: variable 'v173' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);
// 43E0E8: using guessed type __int64 qword_43E0E8;

//----- (004089A0) --------------------------------------------------------
void __thiscall sub_4089A0(int *this, int a2, _DWORD **a3, _DWORD *a4, double a5, double a6)
{
  _DWORD *v7; // edi
  char *v8; // ebx
  _DWORD *v9; // esi
  int v10; // edx
  _DWORD *v11; // ecx
  _DWORD *v12; // edx
  int v13; // ebx
  unsigned int v14; // esi
  _DWORD *v15; // edi
  int v16; // ebx
  double v17; // xmm0_8
  const __m128i *v18; // esi
  const __m128i *v19; // eax
  int v20; // edx
  __int64 v21; // xmm0_8
  double *v22; // esi
  int v23; // edi
  int v24; // edx
  int v25; // ecx
  double v26; // xmm0_8
  unsigned int v27; // [esp-4h] [ebp-58h]
  int v28; // [esp+10h] [ebp-44h]
  int v30; // [esp+1Ch] [ebp-38h]
  unsigned int v31; // [esp+20h] [ebp-34h]
  unsigned int v32; // [esp+24h] [ebp-30h]
  int v33; // [esp+28h] [ebp-2Ch]
  int v34; // [esp+2Ch] [ebp-28h]
  int v35; // [esp+30h] [ebp-24h]
  void *v36[2]; // [esp+38h] [ebp-1Ch] BYREF
  int v37; // [esp+40h] [ebp-14h]
  int v38; // [esp+50h] [ebp-4h]

  v7 = (_DWORD *)a2;
  v36[0] = 0;
  v36[1] = 0;
  v37 = 0;
  v27 = this[7];
  v38 = 0;
  sub_4077E0(v36, v27);
  v8 = (char *)v36[0];
  sub_407920(a2, (int)this, this[1], (int)v36[0], this[6], this[7], (int)this);
  v9 = (_DWORD *)this[5];
  v33 = 0;
  v30 = v9[4];
  v10 = v9[6];
  v28 = (v9[34] - v9[33]) / 24;
  v34 = v10;
  v11 = *a3;
  if ( *a3 != a3[1] )
  {
    do
    {
      v31 = 0;
      v12 = (_DWORD *)(v7[2] + 8 + 56 * *v11);
      if ( (v12[1] - *v12) >> 5 )
      {
        v13 = 0;
        v35 = 0;
        do
        {
          v14 = 0;
          v15 = (_DWORD *)(v13 + *v12 + 8);
          v32 = 0;
          if ( (v15[1] - *v15) / 40 )
          {
            v16 = 0;
            do
            {
              v17 = *((double *)v36[0] + v33) * *((double *)v36[0] + v33);
              ++v33;
              if ( v17 > a5 )
              {
                v18 = (const __m128i *)v15[1];
                v19 = (const __m128i *)(v16 + *v15 + 40);
                if ( v19 != v18 )
                {
                  v20 = v16 + *v15;
                  do
                  {
                    v20 += 40;
                    *(__m128i *)(v20 - 40) = _mm_loadu_si128(v19);
                    *(__m128i *)(v20 - 24) = _mm_loadu_si128(v19 + 1);
                    v21 = v19[2].m128i_i64[0];
                    v19 = (const __m128i *)((char *)v19 + 40);
                    *(_QWORD *)(v20 - 8) = v21;
                  }
                  while ( v19 != v18 );
                }
                v15[1] -= 40;
                v14 = v32 - 1;
                v16 -= 40;
              }
              ++v14;
              v16 += 40;
              v32 = v14;
              v15 = (_DWORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 8) + 56 * *v11 + 8) + v35 + 8);
            }
            while ( v14 < (v15[1] - *v15) / 40 );
            v13 = v35;
          }
          v13 += 32;
          v7 = (_DWORD *)a2;
          v35 = v13;
          ++v31;
          v12 = (_DWORD *)(*(_DWORD *)(a2 + 8) + 8 + 56 * *v11);
        }
        while ( v31 < (v12[1] - *v12) >> 5 );
      }
      ++v11;
    }
    while ( v11 != a3[1] );
    v8 = (char *)v36[0];
    v10 = v34;
  }
  if ( v10 > 0 )
  {
    v22 = (double *)&v8[8 * v30 + 8 * v10 + 8 * v28];
    v23 = v34;
    v24 = 0;
    do
    {
      v25 = this[5];
      if ( *(_BYTE *)(*(_DWORD *)(v25 + 192) + v24 + 32) == 1 )
      {
        v26 = *v22++;
        if ( v26 / *(double *)(v25 + 72) * (v26 / *(double *)(v25 + 72)) > a6 )
          *(_BYTE *)(v24 + *a4 + 32) = 0;
      }
      v24 += 40;
      --v23;
    }
    while ( v23 );
    v8 = (char *)v36[0];
    v7 = (_DWORD *)a2;
  }
  sub_4057B0(v7);
  if ( v8 )
    operator delete(v8);
}

//----- (00408C60) --------------------------------------------------------
char *__usercall sub_408C60@<eax>(int a1@<edi>, int a2@<esi>, int a3, char *a4, int a5, int a6, int a7)
{
  int v7; // esi
  int *v8; // edx
  int v9; // ecx
  double v10; // xmm7_8
  double v11; // xmm1_8
  int v12; // eax
  double *v13; // edi
  double v14; // xmm5_8
  double v15; // xmm4_8
  double v16; // xmm7_8
  double v17; // xmm6_8
  double *v18; // esi
  double v19; // xmm0_8
  double v20; // xmm3_8
  double v21; // xmm3_8
  double v22; // xmm0_8
  double v23; // xmm3_8
  double v24; // xmm4_8
  double v25; // st7
  double v26; // xmm6_8
  double v27; // xmm4_8
  double v28; // xmm5_8
  double v29; // xmm7_8
  double v30; // xmm2_8
  double v31; // xmm1_8
  double v32; // xmm0_8
  double v33; // xmm6_8
  double v34; // xmm2_8
  double v35; // xmm1_8
  double v36; // xmm0_8
  double v37; // xmm5_8
  int v38; // ecx
  double v39; // xmm5_8
  double v40; // xmm7_8
  double v41; // xmm0_8
  double v42; // xmm1_8
  double v43; // xmm3_8
  double v44; // xmm5_8
  double v45; // xmm1_8
  double v46; // xmm0_8
  double v47; // xmm5_8
  double *v48; // edx
  __int128 v49; // xmm6
  __int128 v50; // xmm2
  unsigned int v51; // eax
  double v52; // xmm1_8
  __int128 v53; // xmm0
  double v54; // xmm0_8
  double v55; // xmm1_8
  double v56; // xmm0_8
  double v57; // xmm1_8
  double v58; // xmm0_8
  int v59; // eax
  int v60; // edi
  double v61; // xmm0_8
  int v62; // esi
  double v63; // xmm1_8
  double v64; // xmm2_8
  int v65; // eax
  int v66; // edx
  int v67; // ecx
  double v68; // xmm0_8
  double v69; // xmm2_8
  double v70; // xmm6_8
  double v71; // xmm4_8
  double v72; // xmm1_8
  double v73; // xmm7_8
  int v74; // edi
  double *v75; // esi
  double v76; // xmm3_8
  double v77; // xmm0_8
  double v78; // xmm1_8
  double v79; // st7
  double v80; // xmm7_8
  double v81; // xmm1_8
  double v82; // xmm5_8
  double v83; // xmm2_8
  int v84; // ecx
  double v85; // xmm3_8
  double v86; // xmm4_8
  double v87; // xmm1_8
  double v88; // xmm4_8
  double v89; // xmm0_8
  double v90; // xmm2_8
  double v91; // xmm3_8
  double v92; // xmm4_8
  double v93; // xmm5_8
  double v94; // xmm6_8
  double v95; // xmm2_8
  double v96; // xmm3_8
  double v97; // xmm0_8
  int v98; // esi
  double v99; // xmm3_8
  double v100; // xmm5_8
  double v101; // xmm6_8
  double v102; // xmm4_8
  __int128 v103; // xmm0
  __int128 v104; // xmm7
  int v105; // ecx
  double *v106; // esi
  __int128 v107; // xmm1
  __int128 v108; // xmm2
  unsigned int v109; // eax
  double v110; // xmm1_8
  __int128 v111; // xmm0
  double v112; // xmm0_8
  __int128 v113; // xmm2
  int v114; // edx
  unsigned int v115; // eax
  double v116; // xmm3_8
  double v117; // xmm1_8
  __int128 v118; // xmm0
  double v119; // xmm0_8
  __int128 v120; // xmm2
  unsigned int v121; // eax
  double v122; // xmm1_8
  __int128 v123; // xmm0
  double v124; // xmm0_8
  double v125; // xmm0_8
  double v126; // xmm3_8
  double v127; // xmm1_8
  int v128; // ecx
  double *v129; // edx
  double v130; // xmm2_8
  unsigned int v131; // eax
  double v132; // xmm1_8
  double v133; // xmm2_8
  double v134; // xmm0_8
  double v135; // xmm2_8
  double v136; // xmm3_8
  double v137; // xmm2_8
  double v138; // xmm1_8
  double v139; // xmm7_8
  double v140; // xmm6_8
  int v141; // ecx
  double v142; // xmm2_8
  double v143; // xmm0_8
  double v144; // xmm3_8
  double v145; // xmm4_8
  double v146; // xmm5_8
  double v147; // xmm1_8
  double v148; // xmm1_8
  int v149; // esi
  __int128 v150; // xmm2
  double v151; // xmm0_8
  double v152; // xmm6_8
  double v153; // xmm5_8
  double v154; // xmm4_8
  __int128 v155; // xmm7
  int v156; // ecx
  double *v157; // esi
  __int128 v158; // xmm0
  __int128 v159; // xmm2
  unsigned int v160; // eax
  double v161; // xmm1_8
  __int128 v162; // xmm0
  double v163; // xmm0_8
  __int128 v164; // xmm2
  int v165; // edx
  unsigned int v166; // eax
  double v167; // xmm3_8
  double v168; // xmm1_8
  __int128 v169; // xmm0
  double v170; // xmm0_8
  __int128 v171; // xmm2
  unsigned int v172; // eax
  double v173; // xmm1_8
  __int128 v174; // xmm0
  double v175; // xmm0_8
  double v176; // xmm3_8
  int v177; // ecx
  double *v178; // edx
  double v179; // xmm2_8
  unsigned int v180; // eax
  double v181; // xmm1_8
  double v182; // xmm2_8
  double v183; // xmm0_8
  double v184; // xmm0_8
  double *v185; // esi
  double v186; // xmm3_8
  double v187; // xmm4_8
  double v188; // xmm1_8
  double v189; // xmm0_8
  double v190; // st7
  double v191; // xmm6_8
  double v192; // xmm7_8
  double v193; // xmm1_8
  double v194; // xmm3_8
  int v195; // ecx
  double v196; // xmm4_8
  double v197; // xmm5_8
  double v198; // xmm1_8
  double v199; // xmm0_8
  double v200; // xmm2_8
  double v201; // xmm0_8
  double v202; // xmm1_8
  double v203; // xmm1_8
  double v204; // xmm3_8
  double v205; // xmm1_8
  double v206; // xmm4_8
  double v207; // xmm5_8
  double v208; // xmm6_8
  double v209; // xmm2_8
  double v210; // xmm2_8
  __int128 v211; // xmm7
  double v212; // xmm6_8
  double v213; // xmm5_8
  double v214; // xmm4_8
  int v215; // ecx
  double *v216; // esi
  __int128 v217; // xmm0
  __int128 v218; // xmm2
  unsigned int v219; // eax
  double v220; // xmm1_8
  __int128 v221; // xmm0
  double v222; // xmm0_8
  __int128 v223; // xmm2
  int v224; // edx
  unsigned int v225; // eax
  double v226; // xmm3_8
  double v227; // xmm1_8
  __int128 v228; // xmm0
  double v229; // xmm0_8
  __int128 v230; // xmm2
  unsigned int v231; // eax
  double v232; // xmm1_8
  __int128 v233; // xmm0
  double v234; // xmm0_8
  double v235; // xmm3_8
  double v236; // xmm1_8
  int v237; // ecx
  double *v238; // edx
  double v239; // xmm2_8
  unsigned int v240; // eax
  double v241; // xmm1_8
  double v242; // xmm2_8
  double v243; // xmm0_8
  double v244; // xmm0_8
  double v245; // xmm4_8
  double v246; // xmm3_8
  double v247; // xmm1_8
  double v248; // xmm7_8
  double v249; // xmm2_8
  char *v250; // edx
  int v251; // ecx
  double v252; // xmm6_8
  double v253; // xmm5_8
  double v254; // xmm1_8
  double v255; // xmm1_8
  double v256; // xmm6_8
  int v257; // eax
  double v258; // xmm4_8
  double v259; // xmm1_8
  double v260; // xmm7_8
  double v261; // xmm1_8
  double *v262; // edx
  unsigned int v263; // ecx
  __int128 v264; // xmm3
  __int128 v265; // xmm2
  double v266; // xmm1_8
  __int128 v267; // xmm0
  double v268; // xmm2_8
  unsigned int v269; // ecx
  double v270; // xmm2_8
  double v271; // xmm1_8
  __int128 v272; // xmm0
  double v273; // xmm0_8
  unsigned int v274; // ecx
  double v275; // xmm3_8
  double v276; // xmm0_8
  double v277; // xmm2_8
  double v278; // xmm1_8
  double v279; // xmm2_8
  unsigned int v280; // ecx
  double v281; // xmm2_8
  double v282; // xmm1_8
  double v283; // xmm6_8
  unsigned int v284; // ecx
  double v285; // xmm3_8
  double v286; // xmm7_8
  double v287; // xmm2_8
  double v288; // xmm6_8
  double v289; // xmm1_8
  double v290; // xmm4_8
  unsigned int v291; // ecx
  double v292; // xmm4_8
  double v293; // xmm1_8
  double v294; // xmm5_8
  double v295; // xmm3_8
  double v296; // xmm1_8
  double v297; // xmm4_8
  double v298; // xmm2_8
  double v299; // xmm0_8
  int v300; // edx
  double v301; // xmm4_8
  double v302; // xmm7_8
  double v303; // xmm5_8
  int v304; // ecx
  char *v305; // edx
  double v306; // xmm1_8
  int v307; // eax
  double *v308; // edx
  unsigned int v309; // ecx
  double v310; // xmm2_8
  double v311; // xmm3_8
  double v312; // xmm1_8
  double v313; // xmm3_8
  unsigned int v314; // ecx
  double v315; // xmm3_8
  double v316; // xmm1_8
  double v317; // xmm5_8
  unsigned int v318; // ecx
  double v319; // xmm1_8
  double v320; // xmm3_8
  double v321; // xmm4_8
  double v322; // xmm5_8
  double v323; // xmm2_8
  double v324; // xmm4_8
  unsigned int v325; // ecx
  double v326; // xmm4_8
  double v327; // xmm2_8
  double v328; // xmm3_8
  double v329; // xmm0_8
  double v330; // xmm1_8
  double v331; // xmm1_8
  double v332; // xmm0_8
  double v333; // xmm0_8
  double v334; // xmm1_8
  double v335; // xmm0_8
  char *result; // eax
  int v337; // [esp+40h] [ebp-458h]
  int v338; // [esp+40h] [ebp-458h]
  int v339; // [esp+40h] [ebp-458h]
  int v340; // [esp+40h] [ebp-458h]
  int v341; // [esp+40h] [ebp-458h]
  int v342; // [esp+40h] [ebp-458h]
  int v343; // [esp+40h] [ebp-458h]
  int v344; // [esp+40h] [ebp-458h]
  int v345; // [esp+40h] [ebp-458h]
  int v346; // [esp+40h] [ebp-458h]
  int v347; // [esp+40h] [ebp-458h]
  int v348; // [esp+40h] [ebp-458h]
  int v349; // [esp+40h] [ebp-458h]
  int v350; // [esp+44h] [ebp-454h]
  int v351; // [esp+44h] [ebp-454h]
  int v352; // [esp+44h] [ebp-454h]
  int v353; // [esp+44h] [ebp-454h]
  int v354; // [esp+44h] [ebp-454h]
  int v355; // [esp+44h] [ebp-454h]
  int v356; // [esp+44h] [ebp-454h]
  int v357; // [esp+44h] [ebp-454h]
  int v358; // [esp+44h] [ebp-454h]
  int v359; // [esp+44h] [ebp-454h]
  int v360; // [esp+44h] [ebp-454h]
  int v361; // [esp+44h] [ebp-454h]
  int v362; // [esp+44h] [ebp-454h]
  double v363; // [esp+48h] [ebp-450h]
  int v364; // [esp+48h] [ebp-450h]
  int v365; // [esp+48h] [ebp-450h]
  int v366; // [esp+48h] [ebp-450h]
  double v367; // [esp+48h] [ebp-450h]
  int v368; // [esp+48h] [ebp-450h]
  int v369; // [esp+48h] [ebp-450h]
  int v370; // [esp+48h] [ebp-450h]
  double v371; // [esp+48h] [ebp-450h]
  int v372; // [esp+48h] [ebp-450h]
  int v373; // [esp+48h] [ebp-450h]
  int v374; // [esp+48h] [ebp-450h]
  int v375; // [esp+48h] [ebp-450h]
  double v376; // [esp+48h] [ebp-450h]
  int v377; // [esp+4Ch] [ebp-44Ch]
  int v378; // [esp+4Ch] [ebp-44Ch]
  int v379; // [esp+4Ch] [ebp-44Ch]
  int v380; // [esp+4Ch] [ebp-44Ch]
  int v381; // [esp+4Ch] [ebp-44Ch]
  int v382; // [esp+4Ch] [ebp-44Ch]
  int v383; // [esp+4Ch] [ebp-44Ch]
  int v384; // [esp+4Ch] [ebp-44Ch]
  int v385; // [esp+4Ch] [ebp-44Ch]
  int v386; // [esp+4Ch] [ebp-44Ch]
  int v387; // [esp+5Ch] [ebp-43Ch]
  double v388; // [esp+60h] [ebp-438h]
  double v389; // [esp+60h] [ebp-438h]
  double v390; // [esp+60h] [ebp-438h]
  int v391; // [esp+68h] [ebp-430h]
  unsigned int v392; // [esp+6Ch] [ebp-42Ch]
  int v393; // [esp+6Ch] [ebp-42Ch]
  unsigned __int64 v394; // [esp+70h] [ebp-428h]
  double v395; // [esp+70h] [ebp-428h]
  double v396; // [esp+70h] [ebp-428h]
  double v397; // [esp+70h] [ebp-428h]
  double v398; // [esp+70h] [ebp-428h]
  double v399; // [esp+78h] [ebp-420h]
  double v400; // [esp+78h] [ebp-420h]
  double v401; // [esp+78h] [ebp-420h]
  double v402; // [esp+80h] [ebp-418h]
  double v403; // [esp+80h] [ebp-418h]
  double v404; // [esp+80h] [ebp-418h]
  double v405; // [esp+80h] [ebp-418h]
  double v406; // [esp+88h] [ebp-410h]
  double v407; // [esp+88h] [ebp-410h]
  double v408; // [esp+88h] [ebp-410h]
  double v409; // [esp+88h] [ebp-410h]
  double v410; // [esp+90h] [ebp-408h]
  double v411; // [esp+90h] [ebp-408h]
  double v412; // [esp+98h] [ebp-400h]
  double v413; // [esp+98h] [ebp-400h]
  double v414; // [esp+98h] [ebp-400h]
  double v415; // [esp+98h] [ebp-400h]
  double v416; // [esp+A0h] [ebp-3F8h]
  int v417; // [esp+A8h] [ebp-3F0h]
  double v418; // [esp+A8h] [ebp-3F0h]
  double v419; // [esp+B0h] [ebp-3E8h]
  double v420; // [esp+B0h] [ebp-3E8h]
  double v421; // [esp+B0h] [ebp-3E8h]
  double v422; // [esp+B8h] [ebp-3E0h]
  double v423; // [esp+B8h] [ebp-3E0h]
  double v424; // [esp+B8h] [ebp-3E0h]
  double v425; // [esp+B8h] [ebp-3E0h]
  double v426; // [esp+B8h] [ebp-3E0h]
  double v427; // [esp+C0h] [ebp-3D8h]
  double v428; // [esp+C0h] [ebp-3D8h]
  double v429; // [esp+C0h] [ebp-3D8h]
  double v430; // [esp+C0h] [ebp-3D8h]
  double v431; // [esp+C0h] [ebp-3D8h]
  double v432; // [esp+C0h] [ebp-3D8h]
  double v433; // [esp+C0h] [ebp-3D8h]
  int v434; // [esp+CCh] [ebp-3CCh]
  double v435; // [esp+D0h] [ebp-3C8h]
  double v436; // [esp+D0h] [ebp-3C8h]
  double v437; // [esp+D0h] [ebp-3C8h]
  double v438; // [esp+D0h] [ebp-3C8h]
  __int64 v439; // [esp+D0h] [ebp-3C8h]
  int v440; // [esp+DCh] [ebp-3BCh]
  int v441; // [esp+DCh] [ebp-3BCh]
  double v442; // [esp+E0h] [ebp-3B8h]
  double v443; // [esp+E0h] [ebp-3B8h]
  double v444; // [esp+E8h] [ebp-3B0h]
  double v445; // [esp+E8h] [ebp-3B0h]
  double v446; // [esp+E8h] [ebp-3B0h]
  double v447; // [esp+E8h] [ebp-3B0h]
  double v448; // [esp+F0h] [ebp-3A8h]
  double v449; // [esp+F0h] [ebp-3A8h]
  double v450; // [esp+F0h] [ebp-3A8h]
  double v451; // [esp+F0h] [ebp-3A8h]
  double v452; // [esp+F0h] [ebp-3A8h]
  int v453; // [esp+F8h] [ebp-3A0h]
  int v454; // [esp+F8h] [ebp-3A0h]
  double v455; // [esp+F8h] [ebp-3A0h]
  double v456; // [esp+100h] [ebp-398h]
  double v457; // [esp+100h] [ebp-398h]
  double v458; // [esp+100h] [ebp-398h]
  double v459; // [esp+100h] [ebp-398h]
  double v460; // [esp+108h] [ebp-390h]
  double v461; // [esp+108h] [ebp-390h]
  double v462; // [esp+110h] [ebp-388h]
  double v463; // [esp+110h] [ebp-388h]
  double v464; // [esp+110h] [ebp-388h]
  double v465; // [esp+118h] [ebp-380h]
  double v466; // [esp+118h] [ebp-380h]
  double v467; // [esp+120h] [ebp-378h]
  double v468; // [esp+120h] [ebp-378h]
  double v469; // [esp+120h] [ebp-378h]
  double v470; // [esp+128h] [ebp-370h]
  double v471; // [esp+128h] [ebp-370h]
  double v472; // [esp+128h] [ebp-370h]
  double v473; // [esp+130h] [ebp-368h]
  double v474; // [esp+130h] [ebp-368h]
  double v475; // [esp+130h] [ebp-368h]
  double v476; // [esp+130h] [ebp-368h]
  double v477; // [esp+138h] [ebp-360h]
  double v478; // [esp+138h] [ebp-360h]
  double v479; // [esp+138h] [ebp-360h]
  double v480; // [esp+138h] [ebp-360h]
  double v481; // [esp+138h] [ebp-360h]
  int v482; // [esp+140h] [ebp-358h]
  double *v483; // [esp+140h] [ebp-358h]
  double v484; // [esp+140h] [ebp-358h]
  double v485; // [esp+148h] [ebp-350h]
  double v486; // [esp+150h] [ebp-348h]
  double v487; // [esp+158h] [ebp-340h]
  double v488; // [esp+158h] [ebp-340h]
  double v489; // [esp+160h] [ebp-338h]
  double v490; // [esp+160h] [ebp-338h]
  double v491; // [esp+160h] [ebp-338h]
  double v492; // [esp+168h] [ebp-330h] BYREF
  double v493; // [esp+170h] [ebp-328h]
  double v494; // [esp+178h] [ebp-320h]
  double v495; // [esp+180h] [ebp-318h]
  double v496; // [esp+188h] [ebp-310h]
  double v497; // [esp+190h] [ebp-308h]
  double v498; // [esp+198h] [ebp-300h]
  double v499; // [esp+1A0h] [ebp-2F8h]
  double v500; // [esp+1A8h] [ebp-2F0h]
  double v501; // [esp+1B0h] [ebp-2E8h]
  double v502; // [esp+1B8h] [ebp-2E0h]
  double v503; // [esp+1C0h] [ebp-2D8h]
  double v504; // [esp+1C8h] [ebp-2D0h]
  double v505; // [esp+1D0h] [ebp-2C8h]
  double v506; // [esp+1D8h] [ebp-2C0h]
  double v507; // [esp+1E0h] [ebp-2B8h]
  double v508; // [esp+1E8h] [ebp-2B0h]
  double v509; // [esp+1F0h] [ebp-2A8h]
  double v510; // [esp+1F8h] [ebp-2A0h]
  double v511; // [esp+200h] [ebp-298h]
  double v512; // [esp+208h] [ebp-290h]
  double v513; // [esp+210h] [ebp-288h]
  double v514; // [esp+218h] [ebp-280h]
  double v515; // [esp+220h] [ebp-278h]
  double v516; // [esp+228h] [ebp-270h]
  int v517; // [esp+234h] [ebp-264h]
  double v518; // [esp+238h] [ebp-260h]
  double v519; // [esp+240h] [ebp-258h]
  int v520; // [esp+24Ch] [ebp-24Ch]
  double v521; // [esp+250h] [ebp-248h]
  unsigned __int64 v522; // [esp+258h] [ebp-240h]
  double v523; // [esp+260h] [ebp-238h]
  double v524; // [esp+268h] [ebp-230h]
  double v525; // [esp+270h] [ebp-228h]
  double v526; // [esp+278h] [ebp-220h]
  double v527; // [esp+280h] [ebp-218h] BYREF
  double v528; // [esp+288h] [ebp-210h]
  double v529; // [esp+290h] [ebp-208h]
  double v530; // [esp+298h] [ebp-200h]
  double v531; // [esp+2A0h] [ebp-1F8h]
  double v532; // [esp+2A8h] [ebp-1F0h]
  double v533; // [esp+2B0h] [ebp-1E8h]
  double v534; // [esp+2B8h] [ebp-1E0h]
  double v535; // [esp+2C0h] [ebp-1D8h]
  double v536; // [esp+2C8h] [ebp-1D0h] BYREF
  double v537; // [esp+2D0h] [ebp-1C8h]
  double v538; // [esp+2D8h] [ebp-1C0h]
  double v539; // [esp+2E0h] [ebp-1B8h]
  double v540; // [esp+2E8h] [ebp-1B0h]
  double v541; // [esp+2F0h] [ebp-1A8h]
  double v542; // [esp+2F8h] [ebp-1A0h]
  double v543; // [esp+300h] [ebp-198h]
  double v544; // [esp+308h] [ebp-190h]
  double v545; // [esp+310h] [ebp-188h] BYREF
  double v546; // [esp+318h] [ebp-180h]
  double v547; // [esp+320h] [ebp-178h]
  double v548; // [esp+328h] [ebp-170h]
  double v549; // [esp+330h] [ebp-168h]
  double v550; // [esp+338h] [ebp-160h]
  double v551; // [esp+340h] [ebp-158h]
  double v552; // [esp+348h] [ebp-150h]
  double v553; // [esp+350h] [ebp-148h]
  double v554; // [esp+358h] [ebp-140h]
  double v555; // [esp+360h] [ebp-138h]
  double v556; // [esp+368h] [ebp-130h]
  double v557; // [esp+370h] [ebp-128h]
  double v558; // [esp+378h] [ebp-120h]
  double v559; // [esp+380h] [ebp-118h]
  double v560; // [esp+388h] [ebp-110h]
  double v561; // [esp+390h] [ebp-108h]
  double v562; // [esp+398h] [ebp-100h]
  double v563; // [esp+3A0h] [ebp-F8h]
  double v564; // [esp+3A8h] [ebp-F0h]
  double v565; // [esp+3B0h] [ebp-E8h]
  double v566; // [esp+3B8h] [ebp-E0h]
  double v567; // [esp+3C0h] [ebp-D8h]
  double v568; // [esp+3C8h] [ebp-D0h]
  double v569; // [esp+3D0h] [ebp-C8h]
  double v570; // [esp+3D8h] [ebp-C0h]
  _DWORD v571[40]; // [esp+3E0h] [ebp-B8h] BYREF
  int v572; // [esp+480h] [ebp-18h]
  double v573; // [esp+488h] [ebp-10h]

  v350 = a2;
  v337 = a1;
  *(_QWORD *)(a3 + 24) = 0i64;
  v391 = *(_DWORD *)(a7 + 32);
  sub_405EB0((int)v571, v391, a3 + 24, qword_43E0E8);
  v7 = *(_DWORD *)(a7 + 20);
  v434 = v7;
  v489 = *(double *)(v7 + 56);
  sub_406C30(*(_QWORD *)a3, *(double *)(a3 + 8), *(double *)(a3 + 16), &v492);
  v8 = (int *)(v7 + 48);
  if ( *(_DWORD *)(v7 + 48) < *(_DWORD *)(v7 + 52) )
    v8 = (int *)(v7 + 52);
  v416 = (double)*v8;
  v510 = *(double *)(a3 + 64) * v416;
  sub_406E50(&v492, &v527, (double *)a3);
  sub_407120(&v492, &v545, (double *)a3);
  sub_407400(&v492, &v536, (double *)a3);
  memset(a4, 0, 8 * a6 * a5);
  v9 = *(_DWORD *)(v7 + 24);
  v482 = *(_DWORD *)(v7 + 204);
  v387 = 0;
  v520 = *(_DWORD *)(v7 + 16);
  v517 = v9;
  v440 = 0;
  v10 = v494;
  if ( v520 > 0 )
  {
    v11 = -v510;
    v12 = 0;
    v13 = (double *)(a4 + 16);
    v14 = v494 * v510;
    v453 = 0;
    v15 = v494 * -v510;
    v410 = v553 * v510;
    v16 = v500 * v510;
    v17 = v500 * -v510;
    v412 = v547 * v510;
    v402 = -v510;
    v477 = v15;
    v514 = v494 * v510;
    v509 = v544 * v510;
    v519 = v17;
    v518 = v500 * v510;
    v422 = v538 * v510;
    v427 = v500 * v416;
    v448 = v494 * v416;
    v435 = v535 * v510;
    v456 = v529 * v510;
    v505 = v532 * v510;
    v506 = v550 * v510;
    v523 = v541 * v510;
    v419 = v497 * v416;
    do
    {
      v18 = (double *)(v12 + *(_DWORD *)(v7 + 108));
      v19 = v493 * v18[1];
      v20 = v492 * *v18;
      v18[2] = v11;
      v21 = v20 + v19;
      v22 = v499 * v18[1];
      v23 = v21 + v15;
      v24 = v498 * *v18;
      v501 = v23;
      v444 = v24 + v22 + v17;
      v388 = sub_406A70((int)v571, -4.0, 0.0, -1.0, 1.0e-10, v23, v14, v444, v16);
      v502 = v388 * v501 - v514;
      v25 = sub_4060D0(v571, v573 * v502);
      v26 = v18[1];
      v27 = *v18;
      v28 = v18[2];
      v445 = v444 - v25 * v501;
      v29 = -(((v551 * v27 + v552 * v26 + v553 * v28) * v388
             - v410
             - ((v545 * v27 + v546 * v26 + v547 * v28) * v388 - v412) * v25)
            / v445);
      v406 = -(((v542 * v27 + v543 * v26 + v544 * v28) * v388
              - v509
              - ((v536 * v27 + v537 * v26 + v538 * v28) * v388 - v422) * v25)
             / v445);
      v501 = -((-(v500 * v388 * v416) - v427 - (-(v494 * v388 * v416) - v448) * v25) / v445);
      v30 = -(((v533 * v27 + v534 * v26 + v535 * v28) * v388
             - v435
             - ((v527 * v27 + v528 * v26 + v529 * v28) * v388 - v456) * v25)
            / v445);
      v31 = v495 * v27 + v496 * v26 + v497 * v28;
      v32 = v531 * v26;
      v33 = v388;
      v34 = v30 * v31;
      v35 = v530 * v27 + v32;
      v36 = v532 * v28;
      v37 = v495;
      *(v13 - 2) = v34 + (v35 + v36) * v388 - v505;
      v38 = 1;
      v39 = (v37 * *v18 + v496 * v18[1] + v497 * v18[2]) * v29;
      v40 = v497;
      v41 = v496;
      v42 = v539;
      *(v13 - 1) = v39 + (v548 * *v18 + v549 * v18[1] + v550 * v18[2]) * v388 - v506;
      v43 = v18[2];
      v44 = (v495 * *v18 + v41 * v18[1] + v40 * v43) * v406;
      v45 = v42 * *v18 + v540 * v18[1] + v541 * v43;
      v13[1] = 0.0;
      v46 = v496;
      *v13 = v44 + v45 * v388 - v523;
      v47 = v495 * *v18 + v46 * v18[1] + v18[2] * v40;
      if ( v391 >= 1 )
      {
        v48 = v13 + 2;
        v49 = *(unsigned __int64 *)&v502;
        do
        {
          *((_QWORD *)&v50 + 1) = *((_QWORD *)&v49 + 1);
          *(double *)&v50 = *(double *)&v49 * *(double *)&qword_43E0E8;
          v51 = v38;
          if ( v38 < 0 )
            v51 = -v38;
          v52 = 1.0;
          while ( 1 )
          {
            if ( (v51 & 1) != 0 )
              v52 = v52 * *(double *)&v50;
            v51 >>= 1;
            if ( !v51 )
              break;
            *((_QWORD *)&v53 + 1) = *((_QWORD *)&v50 + 1);
            *(double *)&v53 = *(double *)&v50 * *(double *)&v50;
            v50 = v53;
          }
          if ( v38 >= 0 )
            v54 = v52;
          else
            v54 = 1.0 / v52;
          ++v38;
          *v48++ = v54 / *(double *)&qword_43E0E8 / v445 * v47;
        }
        while ( v38 <= v391 );
        v33 = v388;
      }
      v14 = v514;
      v15 = v477;
      v55 = v495 * *v18 + v496 * v18[1];
      v56 = v18[2] * v40;
      v7 = v434;
      v57 = v55 + v56;
      v58 = v40 * v33;
      v17 = v519;
      v16 = v518;
      v13[6] = v57 * v501 - v58 * v416 - v419;
      v11 = v402;
      v59 = *(_DWORD *)(*(_DWORD *)(v434 + 120) + 4 * v440++);
      *(double *)&a4[8 * v387 + 8 * v482 + 8 * v59] = v489 * -1.0;
      v387 += a5;
      v13 += a5;
      v12 = v453 + 32;
      v453 += 32;
    }
    while ( v440 < v520 );
    v10 = v494;
  }
  v60 = *(_DWORD *)(v7 + 132);
  v392 = 0;
  if ( (*(_DWORD *)(v7 + 136) - v60) / 24 )
  {
    v61 = v489;
    v62 = 0;
    do
    {
      v63 = *(double *)(v60 + v62 + 16);
      v62 += 24;
      v64 = v63 * v61;
      ++v392;
      *(double *)&a4[8 * v387 + 8 * v482 + 8 * *(_DWORD *)(v60 + v62 - 24)] = v63 * v61;
      *(double *)&a4[8 * v387 + 8 * v482 + 8 * *(_DWORD *)(v62 + *(_DWORD *)(v434 + 132) - 20)] = v489 * -2.0 * v63;
      v61 = v489;
      v65 = v387 + v482 + *(_DWORD *)(v62 + *(_DWORD *)(v434 + 132) - 16);
      v387 += a5;
      *(double *)&a4[8 * v65] = v64;
      v60 = *(_DWORD *)(v434 + 132);
    }
    while ( v392 < (*(_DWORD *)(v434 + 136) - v60) / 24 );
    v7 = v434;
  }
  v66 = 0;
  v441 = 0;
  v67 = v387 + a5 * v517;
  v393 = v67;
  if ( v517 > 0 )
  {
    v68 = v510;
    v69 = -v510;
    v70 = v10 * -v510;
    v71 = v10 * v510;
    v72 = v500 * v510;
    v73 = v500 * -v510;
    v510 = v69;
    v554 = v72;
    v514 = v70;
    v486 = v71;
    v501 = v500 * v69;
    v508 = v529 * v68;
    v558 = v535 * v68;
    v507 = v547 * v68;
    v557 = v553 * v68;
    v513 = v538 * v68;
    v559 = v544 * v68;
    v515 = v494 * v416;
    v561 = v500 * v416;
    v556 = v532 * v68;
    v555 = v550 * v68;
    v560 = v541 * v68;
    v518 = v497 * v416;
    v519 = v497 * v68;
    do
    {
      v74 = v66 + v520 + 2 * v66;
      v75 = (double *)(32 * v74 + *(_DWORD *)(v7 + 108));
      v454 = 32 * v74;
      v483 = v75;
      v76 = *v75;
      v77 = v75[1] * v493;
      v78 = v75[1] * v499;
      v75[2] = v69;
      v420 = v76 * v492 + v77 + v70;
      v490 = v76 * v498 + v78 + v73;
      v79 = sub_406A70((int)v571, -4.0, 0.0, -1.0, 1.0e-10, v420, v71, v490, v554);
      v80 = v75[1];
      v81 = *v75;
      v82 = v75[2];
      v502 = v80;
      v423 = (v527 * v81 + v528 * v80 + v529 * v82) * v79;
      v83 = (v81 * v533 + v80 * v534 + v82 * v535) * v79 - v558;
      v428 = (v545 * v81 + v546 * v80 + v547 * v82) * v79;
      v84 = v572 - 1;
      v85 = (v81 * v551 + v80 * v552 + v82 * v553) * v79 - v557;
      v449 = (v536 * v81 + v537 * v80 + v538 * v82) * v79;
      v86 = v81;
      v87 = 0.0;
      v88 = (v86 * v542 + v80 * v543 + v82 * v544) * v79 - v559;
      v509 = -(v494 * v79 * v416) - v515;
      v89 = v79 * v420 - v486;
      *(double *)&v522 = v89;
      if ( v572 - 1 >= 0 )
      {
        if ( v572 >= 4 )
        {
          do
          {
            v87 = (((v87 * (v573 * *(double *)&v522) + *(double *)&v571[2 * v84 + 20]) * (v573 * *(double *)&v522)
                  + *(double *)&v571[2 * v84 + 18])
                 * (v573
                  * *(double *)&v522)
                 + *(double *)&v571[2 * v84 + 16])
                * (v573
                 * *(double *)&v522)
                + *(double *)&v571[2 * v84 + 14];
            v84 -= 4;
          }
          while ( v84 >= 3 );
          v89 = *(double *)&v522;
        }
        for ( ; v84 >= 0; --v84 )
          v87 = v87 * (v573 * v89) + *(double *)&v571[2 * v84 + 20];
        v80 = v502;
      }
      v491 = v490 - v87 * v420;
      v90 = -((v83 - v87 * (v423 - v508)) / v491);
      v91 = -((v85 - v87 * (v428 - v507)) / v491);
      v92 = -((v88 - v87 * (v449 - v513)) / v491);
      v93 = -((-(v500 * v79 * v416) - v561 - v87 * v509) / v491);
      *(double *)&v394 = *v75 * v492 + v80 * v493 + v75[2] * v494;
      v413 = *(double *)&v394 * v90 + v423 - v508;
      v424 = *(double *)&v394 * v91 + v428 - v507;
      v94 = *(double *)&v394 * v92 + v449 - v513;
      v450 = *(double *)&v394 * v93 - v494 * v79 * v416 - v515;
      v429 = v94;
      v399 = v495 * *v75 + v496 * v80 + v497 * v75[2];
      v465 = (v530 * *v75 + v531 * v80 + v532 * v75[2]) * v79 + v399 * v90 - v556;
      v442 = (v548 * *v75 + v549 * v80 + v550 * v75[2]) * v79 + v399 * v91 - v555;
      v95 = v399 * v93;
      v96 = v539 * *v75 + v540 * v75[1];
      v97 = v541 * v75[2];
      v98 = v391;
      v99 = (v96 + v97) * v79 + v399 * v92;
      v400 = v399 * v79 - v519;
      v446 = v99 - v560;
      v363 = 0.0;
      v103 = v394;
      v100 = 0.0;
      v101 = 0.0;
      v102 = 0.0;
      *(double *)&v103 = *(double *)&v394 * v79 - v486;
      v502 = v95 - v497 * v79 * v416 - v518;
      v395 = *(double *)&v103;
      if ( v391 >= 1 )
      {
        *((_QWORD *)&v104 + 1) = *((_QWORD *)&v103 + 1);
        *(double *)&v104 = *(double *)&v103 * *(double *)&qword_43E0E8;
        *((_QWORD *)&v107 + 1) = 0i64;
        v105 = 0;
        v106 = (double *)(a3 + 32);
        *(double *)&v107 = *(double *)&qword_43E0E8 * 0.0;
        v407 = *(double *)&v103 * *(double *)&qword_43E0E8 * 0.5;
        do
        {
          v108 = v107;
          v109 = v105;
          if ( v105 < 0 )
            v109 = -v105;
          v110 = 1.0;
          while ( 1 )
          {
            if ( (v109 & 1) != 0 )
              v110 = v110 * *(double *)&v108;
            v109 >>= 1;
            if ( !v109 )
              break;
            *((_QWORD *)&v111 + 1) = *((_QWORD *)&v108 + 1);
            *(double *)&v111 = *(double *)&v108 * *(double *)&v108;
            v108 = v111;
          }
          if ( v105 >= 0 )
            v112 = v110;
          else
            v112 = 1.0 / v110;
          v113 = *(unsigned __int64 *)&v407;
          v114 = v105 + 1;
          v115 = v105;
          v116 = (double)(v105 + 1) * *v106;
          v101 = v112 * v116 + v101;
          if ( v105 < 0 )
            v115 = -v105;
          v117 = 1.0;
          while ( 1 )
          {
            if ( (v115 & 1) != 0 )
              v117 = v117 * *(double *)&v113;
            v115 >>= 1;
            if ( !v115 )
              break;
            *((_QWORD *)&v118 + 1) = *((_QWORD *)&v113 + 1);
            *(double *)&v118 = *(double *)&v113 * *(double *)&v113;
            v113 = v118;
          }
          if ( v105 >= 0 )
            v119 = v117;
          else
            v119 = 1.0 / v117;
          v120 = v104;
          v121 = v105;
          v100 = v119 * v116 + v100;
          if ( v105 < 0 )
            v121 = -v105;
          v122 = 1.0;
          while ( 1 )
          {
            if ( (v121 & 1) != 0 )
              v122 = v122 * *(double *)&v120;
            v121 >>= 1;
            if ( !v121 )
              break;
            *((_QWORD *)&v123 + 1) = *((_QWORD *)&v120 + 1);
            *(double *)&v123 = *(double *)&v120 * *(double *)&v120;
            v120 = v123;
          }
          if ( v105 >= 0 )
            v124 = v122;
          else
            v124 = 1.0 / v122;
          v107 = COERCE_UNSIGNED_INT64(*(double *)&qword_43E0E8 * 0.0);
          ++v105;
          ++v106;
          v125 = v124 * v116 + v102;
          v102 = v125;
        }
        while ( v114 + 1 <= v391 );
        v98 = v391;
        v363 = v125;
      }
      v462 = *(double *)libm_sse2_sqrt_precise(v337, v350, LODWORD(v363), HIDWORD(v363)).m128_u64 * 4.0;
      v463 = v462 + *(double *)libm_sse2_sqrt_precise(v338, v351, v364, v377).m128_u64;
      v126 = 0.0;
      v464 = (v463 + *(double *)libm_sse2_sqrt_precise(v339, v352, v365, v378).m128_u64) * (v395 / 6.0);
      if ( v98 >= 1 )
      {
        v127 = v395 * *(double *)&qword_43E0E8;
        v128 = 0;
        v129 = (double *)(a3 + 32);
        v396 = v395 * *(double *)&qword_43E0E8;
        do
        {
          v130 = v127;
          v131 = v128;
          if ( v128 < 0 )
            v131 = -v128;
          v132 = 1.0;
          while ( 1 )
          {
            if ( (v131 & 1) != 0 )
              v132 = v132 * v130;
            v131 >>= 1;
            if ( !v131 )
              break;
            v130 = v130 * v130;
          }
          if ( v128 >= 0 )
            v133 = v132;
          else
            v133 = 1.0 / v132;
          v127 = v396;
          v134 = (double)++v128 * *v129++;
          v126 = v126 + v134 * v133;
        }
        while ( v128 + 1 <= v98 );
      }
      v509 = *(double *)libm_sse2_sqrt_precise(v340, v353, v366, v379).m128_u64;
      v417 = *(_DWORD *)(v434 + 108);
      v523 = v509 * v413;
      v135 = *(double *)(v454 + v417 + 32);
      v136 = v135 * v498;
      v506 = v509 * v424;
      v137 = v135 * v492;
      v505 = v509 * v429;
      v138 = *(double *)(v454 + v417 + 40);
      v451 = v509 * v450;
      *(double *)(v454 + v417 + 48) = v510;
      v403 = v137 + v138 * v493 + v514;
      v397 = v136 + v138 * v499 + v501;
      v460 = sub_406A70((int)v571, -4.0, 0.0, -1.0, 1.0e-10, v403, v486, v397, v554);
      v139 = *(double *)(v454 + v417 + 40);
      v140 = *(double *)(v454 + v417 + 48);
      v389 = *(double *)(v454 + v417 + 32);
      v478 = (v389 * v527 + v139 * v528 + v140 * v529) * v460;
      v141 = v572 - 1;
      v430 = (v389 * v545 + v139 * v546 + v140 * v547) * v460;
      v436 = (v389 * v536 + v139 * v537 + v140 * v538) * v460;
      v142 = 0.0;
      v143 = v460 * v403 - v486;
      v421 = v143;
      if ( v572 - 1 >= 0 )
      {
        if ( v572 >= 4 )
        {
          do
          {
            v142 = (((v142 * (v573 * v143) + *(double *)&v571[2 * v141 + 20]) * (v573 * v143)
                   + *(double *)&v571[2 * v141 + 18])
                  * (v573
                   * v143)
                  + *(double *)&v571[2 * v141 + 16])
                 * (v573
                  * v143)
                 + *(double *)&v571[2 * v141 + 14];
            v141 -= 4;
          }
          while ( v141 >= 3 );
          v143 = v460 * v403 - v486;
        }
        for ( ; v141 >= 0; --v141 )
          v142 = v142 * (v573 * v143) + *(double *)&v571[2 * v141 + 20];
      }
      v398 = v397 - v142 * v403;
      v144 = -(((v389 * v533 + v139 * v534 + v140 * v535) * v460 - v558 - v142 * (v478 - v508)) / v398);
      v145 = -(((v389 * v551 + v139 * v552 + v140 * v553) * v460 - v557 - v142 * (v430 - v507)) / v398);
      v146 = -(((v389 * v542 + v139 * v543 + v140 * v544) * v460 - v559 - v142 * (v436 - v513)) / v398);
      v147 = -(v500 * v460 * v416) - v561 - v142 * (-(v494 * v460 * v416) - v515);
      v150 = *(unsigned __int64 *)&v389;
      v487 = -(v147 / v398);
      v425 = (v389 * v492 + v139 * v493 + v140 * v494) * v144 + v478 - v508;
      v431 = (v389 * v492 + v139 * v493 + v140 * v494) * v145 + v430 - v507;
      v437 = (v389 * v492 + v139 * v493 + v140 * v494) * v146 + v436 - v513;
      v457 = (v389 * v492 + v139 * v493 + v140 * v494) * v487 - v494 * v460 * v416 - v515;
      v148 = v389 * v495 + v139 * v496 + v140 * v497;
      v149 = v391;
      v504 = (v389 * v530 + v139 * v531 + v140 * v532) * v460 + v144 * v148 - v556;
      v521 = v389 * v548 + v139 * v549 + v140 * v550;
      *(double *)&v150 = (v389 * v492 + v139 * v493 + v140 * v494) * v460 - v486;
      v414 = *(double *)&v150;
      v521 = v521 * v460 + v145 * v148 - v555;
      v390 = (v389 * v539 + v139 * v540 + v140 * v541) * v460 + v146 * v148 - v560;
      v151 = v460 * v497 * v416;
      v461 = v460 * v148 - v519;
      v152 = 0.0;
      v153 = 0.0;
      v367 = 0.0;
      v488 = v487 * v148 - v151 - v518;
      v154 = 0.0;
      if ( v391 >= 1 )
      {
        *((_QWORD *)&v155 + 1) = *((_QWORD *)&v150 + 1);
        *(double *)&v155 = *(double *)&v150 * *(double *)&qword_43E0E8;
        *((_QWORD *)&v158 + 1) = 0i64;
        v156 = 0;
        v157 = (double *)(a3 + 32);
        *(double *)&v158 = *(double *)&qword_43E0E8 * 0.0;
        v408 = *(double *)&v150 * *(double *)&qword_43E0E8 * 0.5;
        do
        {
          v159 = v158;
          v160 = v156;
          if ( v156 < 0 )
            v160 = -v156;
          v161 = 1.0;
          while ( 1 )
          {
            if ( (v160 & 1) != 0 )
              v161 = v161 * *(double *)&v159;
            v160 >>= 1;
            if ( !v160 )
              break;
            *((_QWORD *)&v162 + 1) = *((_QWORD *)&v159 + 1);
            *(double *)&v162 = *(double *)&v159 * *(double *)&v159;
            v159 = v162;
          }
          if ( v156 >= 0 )
            v163 = v161;
          else
            v163 = 1.0 / v161;
          v164 = *(unsigned __int64 *)&v408;
          v165 = v156 + 1;
          v166 = v156;
          v167 = (double)(v156 + 1) * *v157;
          v152 = v163 * v167 + v152;
          if ( v156 < 0 )
            v166 = -v156;
          v168 = 1.0;
          while ( 1 )
          {
            if ( (v166 & 1) != 0 )
              v168 = v168 * *(double *)&v164;
            v166 >>= 1;
            if ( !v166 )
              break;
            *((_QWORD *)&v169 + 1) = *((_QWORD *)&v164 + 1);
            *(double *)&v169 = *(double *)&v164 * *(double *)&v164;
            v164 = v169;
          }
          if ( v156 >= 0 )
            v170 = v168;
          else
            v170 = 1.0 / v168;
          v171 = v155;
          v172 = v156;
          v153 = v170 * v167 + v153;
          if ( v156 < 0 )
            v172 = -v156;
          v173 = 1.0;
          while ( 1 )
          {
            if ( (v172 & 1) != 0 )
              v173 = v173 * *(double *)&v171;
            v172 >>= 1;
            if ( !v172 )
              break;
            *((_QWORD *)&v174 + 1) = *((_QWORD *)&v171 + 1);
            *(double *)&v174 = *(double *)&v171 * *(double *)&v171;
            v171 = v174;
          }
          if ( v156 >= 0 )
            v175 = v173;
          else
            v175 = 1.0 / v173;
          ++v156;
          ++v157;
          v154 = v154 + v175 * v167;
          v158 = COERCE_UNSIGNED_INT64(*(double *)&qword_43E0E8 * 0.0);
        }
        while ( v165 + 1 <= v391 );
        v149 = v391;
        v367 = v152;
      }
      v470 = *(double *)libm_sse2_sqrt_precise(v341, v354, LODWORD(v367), HIDWORD(v367)).m128_u64 * 4.0;
      v471 = v470 + *(double *)libm_sse2_sqrt_precise(v342, v355, v368, v380).m128_u64;
      v176 = 0.0;
      v472 = (v471 + *(double *)libm_sse2_sqrt_precise(v343, v356, v369, v381).m128_u64) * (v414 / 6.0);
      if ( v149 >= 1 )
      {
        v177 = 0;
        v178 = (double *)(a3 + 32);
        do
        {
          v179 = v414 * *(double *)&qword_43E0E8;
          v180 = v177;
          if ( v177 < 0 )
            v180 = -v177;
          v181 = 1.0;
          while ( 1 )
          {
            if ( (v180 & 1) != 0 )
              v181 = v181 * v179;
            v180 >>= 1;
            if ( !v180 )
              break;
            v179 = v179 * v179;
          }
          if ( v177 >= 0 )
            v182 = v181;
          else
            v182 = 1.0 / v181;
          v183 = (double)++v177 * *v178++;
          v176 = v176 + v183 * v182;
        }
        while ( v177 + 1 <= v149 );
      }
      v184 = *(double *)libm_sse2_sqrt_precise(v344, v357, v370, v382).m128_u64;
      v185 = (double *)(*(_DWORD *)(v434 + 108) + 32 * (v74 + 2));
      v409 = v184;
      v564 = v184 * v425;
      v186 = v492 * *v185;
      v187 = v498 * *v185;
      v563 = v184 * v431;
      v188 = v184 * v437;
      v516 = v184 * v457;
      v185[2] = v510;
      v189 = v493 * v185[1];
      v565 = v188;
      v404 = v186 + v189 + v514;
      v503 = v187 + v499 * v185[1] + v501;
      v190 = sub_406A70((int)v571, -4.0, 0.0, -1.0, 1.0e-10, v404, v486, v503, v554);
      v191 = v185[1];
      v192 = *v185;
      v193 = v185[2];
      v432 = (v527 * *v185 + v528 * v191 + v529 * v193) * v190;
      v194 = (v533 * *v185 + v534 * v191 + v535 * v193) * v190 - v558;
      v195 = v572 - 1;
      v479 = (v546 * v191 + v545 * *v185 + v547 * v193) * v190;
      v196 = (v551 * *v185 + v552 * v191 + v553 * v193) * v190 - v557;
      v473 = (v536 * *v185 + v537 * v191 + v538 * v193) * v190;
      v197 = (v542 * *v185 + v543 * v191 + v544 * v193) * v190 - v559;
      v198 = v190 * v404 - v486;
      v511 = v190 * v494 * v416;
      v199 = -v511 - v515;
      v512 = -(v190 * v500 * v416) - v561;
      v200 = 0.0;
      v458 = v198;
      if ( v572 - 1 >= 0 )
      {
        v201 = v573;
        if ( v572 >= 4 )
        {
          v202 = v198 * v573;
          do
          {
            v200 = (((v200 * v202 + *(double *)&v571[2 * v195 + 20]) * v202 + *(double *)&v571[2 * v195 + 18]) * v202
                  + *(double *)&v571[2 * v195 + 16])
                 * v202
                 + *(double *)&v571[2 * v195 + 14];
            v195 -= 4;
          }
          while ( v195 >= 3 );
          v201 = v573;
          v198 = v190 * v404 - v486;
        }
        if ( v195 >= 0 )
        {
          v203 = v198 * v201;
          do
            v200 = v200 * v203 + *(double *)&v571[2 * v195-- + 20];
          while ( v195 >= 0 );
        }
        v199 = -(v190 * v494 * v416) - v515;
      }
      v503 = v503 - v404 * v200;
      v204 = -((v194 - (v432 - v508) * v200) / v503);
      v205 = v185[2];
      v206 = -((v196 - (v479 - v507) * v200) / v503);
      v512 = -((v512 - v199 * v200) / v503);
      v207 = -((v197 - (v473 - v513) * v200) / v503);
      v208 = v185[1];
      v209 = v492 * v192 + v493 * v208 + v494 * v205;
      v438 = v209;
      v567 = v204 * v209 + v432 - v508;
      v562 = v206 * v209 + v479 - v507;
      v566 = v207 * v209 + v473 - v513;
      v480 = v512 * v209 - v511 - v515;
      v526 = v495 * v192 + v496 * v208 + v497 * v205;
      v569 = (v530 * v192 + v531 * v208 + v532 * v205) * v190 + v204 * v526 - v556;
      v568 = (v548 * v192 + v549 * v208 + v550 * v205) * v190 + v206 * v526 - v555;
      v210 = v539 * v192;
      v211 = *(unsigned __int64 *)&v190;
      v485 = v190 * v526 - v519;
      v570 = (v210 + v540 * v208 + v541 * v205) * v190 + v207 * v526 - v560;
      v512 = v512 * v526 - v190 * v497 * v416 - v518;
      v212 = 0.0;
      v371 = 0.0;
      v213 = 0.0;
      v214 = 0.0;
      if ( v391 >= 1 )
      {
        *((_QWORD *)&v217 + 1) = 0i64;
        *(double *)&v211 = (v190 * v438 - v486) * *(double *)&qword_43E0E8;
        v215 = 0;
        v216 = (double *)(a3 + 32);
        *(double *)&v217 = *(double *)&qword_43E0E8 * 0.0;
        do
        {
          v218 = v217;
          v219 = v215;
          if ( v215 < 0 )
            v219 = -v215;
          v220 = 1.0;
          while ( 1 )
          {
            if ( (v219 & 1) != 0 )
              v220 = v220 * *(double *)&v218;
            v219 >>= 1;
            if ( !v219 )
              break;
            *((_QWORD *)&v221 + 1) = *((_QWORD *)&v218 + 1);
            *(double *)&v221 = *(double *)&v218 * *(double *)&v218;
            v218 = v221;
          }
          if ( v215 >= 0 )
            v222 = v220;
          else
            v222 = 1.0 / v220;
          v223 = COERCE_UNSIGNED_INT64(*(double *)&v211 * 0.5);
          v224 = v215 + 1;
          v225 = v215;
          v226 = (double)(v215 + 1) * *v216;
          v212 = v222 * v226 + v212;
          if ( v215 < 0 )
            v225 = -v215;
          v227 = 1.0;
          while ( 1 )
          {
            if ( (v225 & 1) != 0 )
              v227 = v227 * *(double *)&v223;
            v225 >>= 1;
            if ( !v225 )
              break;
            *((_QWORD *)&v228 + 1) = *((_QWORD *)&v223 + 1);
            *(double *)&v228 = *(double *)&v223 * *(double *)&v223;
            v223 = v228;
          }
          if ( v215 >= 0 )
            v229 = v227;
          else
            v229 = 1.0 / v227;
          v230 = v211;
          v231 = v215;
          v213 = v229 * v226 + v213;
          if ( v215 < 0 )
            v231 = -v215;
          v232 = 1.0;
          while ( 1 )
          {
            if ( (v231 & 1) != 0 )
              v232 = v232 * *(double *)&v230;
            v231 >>= 1;
            if ( !v231 )
              break;
            *((_QWORD *)&v233 + 1) = *((_QWORD *)&v230 + 1);
            *(double *)&v233 = *(double *)&v230 * *(double *)&v230;
            v230 = v233;
          }
          if ( v215 >= 0 )
            v234 = v232;
          else
            v234 = 1.0 / v232;
          ++v215;
          ++v216;
          v214 = v214 + v234 * v226;
          v217 = COERCE_UNSIGNED_INT64(*(double *)&qword_43E0E8 * 0.0);
        }
        while ( v224 + 1 <= v391 );
        v371 = v212;
      }
      v467 = *(double *)libm_sse2_sqrt_precise(v345, v358, LODWORD(v371), HIDWORD(v371)).m128_u64 * 4.0;
      v468 = v467 + *(double *)libm_sse2_sqrt_precise(v346, v359, v372, v383).m128_u64;
      v235 = 0.0;
      v474 = v190 * v438 - v486;
      v469 = (v468 + *(double *)libm_sse2_sqrt_precise(v347, v360, v373, v384).m128_u64) * (v474 / 6.0);
      if ( v391 >= 1 )
      {
        v236 = v474 * *(double *)&qword_43E0E8;
        v237 = 0;
        v238 = (double *)(a3 + 32);
        v475 = v474 * *(double *)&qword_43E0E8;
        do
        {
          v239 = v236;
          v240 = v237;
          if ( v237 < 0 )
            v240 = -v237;
          v241 = 1.0;
          while ( 1 )
          {
            if ( (v240 & 1) != 0 )
              v241 = v241 * v239;
            v240 >>= 1;
            if ( !v240 )
              break;
            v239 = v239 * v239;
          }
          if ( v237 >= 0 )
            v242 = v241;
          else
            v242 = 1.0 / v241;
          v236 = v475;
          v243 = (double)++v237 * *v238++;
          v235 = v235 + v243 * v242;
        }
        while ( v237 + 1 <= v391 );
      }
      v244 = *(double *)libm_sse2_sqrt_precise(v348, v361, v374, v385).m128_u64;
      v245 = *v483 * v492;
      v525 = v244;
      v481 = v480 * v244;
      v433 = v245 + v483[1] * v493 + v483[2] * v494;
      v246 = *(double *)(v454 + v417 + 32);
      v247 = *(double *)(v454 + v417 + 48);
      v426 = v495 * *v483 + v496 * v483[1] + v497 * v483[2];
      v415 = v246 * v492 + *(double *)(v454 + v417 + 40) * v493 + v247 * v494;
      v411 = v246 * v495 + *(double *)(v454 + v417 + 40) * v496 + v247 * v497;
      v524 = v461 - v400;
      v418 = v464 - v472;
      v511 = v472 * v400 - v461 * v464 + (v461 - v400) * v469 + (v464 - v472) * v485;
      v455 = *(double *)libm_sse2_sqrt_precise(v349, v362, v375, v386).m128_u64;
      v476 = v523 - v564;
      v248 = v565;
      v7 = v434;
      v249 = v521 - v442;
      v405 = v506 - v563;
      v250 = a4;
      v251 = v387;
      v252 = v563 * v400;
      v376 = v505 - v565;
      v484 = v455 * v455;
      v253 = v524;
      v254 = v562 * v525 * v524 + (v521 - v442) * v469;
      *(double *)&a4[8 * v387] = ((v567 * v525 * v524
                                 + (v504 - v465) * v469
                                 + (v523 - v564) * v485
                                 + v569 * (v464 - v472)
                                 + v564 * v400
                                 + v472 * v465
                                 - v461 * v523
                                 - v504 * v464)
                                * v455
                                - ((v523 - v564) * (v464 - v472) + (v504 - v465) * v524) / v455 * v511)
                               * *(double *)(v434 + 80)
                               / (v455
                                * v455);
      v255 = v254 + v405 * v485 + v568 * (v464 - v472) + v252 + v472 * v442 - v461 * v506 - v521 * v464;
      v256 = v455;
      v257 = 1;
      v258 = v511;
      *(double *)&a4[8 * v387 + 8] = (v255 * v455 - (v405 * (v464 - v472) + v249 * v253) / v455 * v511)
                                   * *(double *)(v434 + 80)
                                   / (v455
                                    * v455);
      v259 = v566 * v525 * v253
           + (v390 - v446) * v469
           + v376 * v485
           + v570 * (v464 - v472)
           + v248 * v400
           + v472 * v446
           - v461 * v505
           - v390 * v464;
      v260 = v464 - v472;
      v261 = (v259 * v256 - (v376 * (v464 - v472) + (v390 - v446) * v253) / v256 * v258) * *(double *)(v434 + 80);
      *(_QWORD *)&a4[8 * v387 + 24] = 0i64;
      *(double *)&a4[8 * v387 + 16] = v261 / (v455 * v455);
      if ( v391 >= 1 )
      {
        v262 = (double *)&a4[8 * v387 + 32];
        do
        {
          v264 = v522;
          v263 = v257;
          *(double *)&v264 = *(double *)&v522 * *(double *)&qword_43E0E8;
          v265 = v264;
          if ( v257 < 0 )
            v263 = -v257;
          v266 = 1.0;
          while ( 1 )
          {
            if ( (v263 & 1) != 0 )
              v266 = v266 * *(double *)&v265;
            v263 >>= 1;
            if ( !v263 )
              break;
            *((_QWORD *)&v267 + 1) = *((_QWORD *)&v265 + 1);
            *(double *)&v267 = *(double *)&v265 * *(double *)&v265;
            v265 = v267;
          }
          if ( v257 >= 0 )
            v268 = v266;
          else
            v268 = 1.0 / v266;
          v269 = v257;
          v270 = v268 / *(double *)&qword_43E0E8 / v491 * v433;
          if ( v257 < 0 )
            v269 = -v257;
          v271 = 1.0;
          while ( 1 )
          {
            if ( (v269 & 1) != 0 )
              v271 = v271 * *(double *)&v264;
            v269 >>= 1;
            if ( !v269 )
              break;
            *((_QWORD *)&v272 + 1) = *((_QWORD *)&v264 + 1);
            *(double *)&v272 = *(double *)&v264 * *(double *)&v264;
            v264 = v272;
          }
          if ( v257 >= 0 )
            v273 = v271;
          else
            v273 = 1.0 / v271;
          v274 = v257;
          v275 = v421 * *(double *)&qword_43E0E8;
          v505 = v273 / *(double *)&qword_43E0E8 / v491 * v426;
          v276 = v509 * v270;
          v277 = v421 * *(double *)&qword_43E0E8;
          v506 = v276;
          if ( v257 < 0 )
            v274 = -v257;
          v278 = 1.0;
          while ( 1 )
          {
            if ( (v274 & 1) != 0 )
              v278 = v278 * v277;
            v274 >>= 1;
            if ( !v274 )
              break;
            v277 = v277 * v277;
          }
          if ( v257 >= 0 )
            v279 = v278;
          else
            v279 = 1.0 / v278;
          v280 = v257;
          v281 = v279 / *(double *)&qword_43E0E8 / v398 * v415;
          if ( v257 < 0 )
            v280 = -v257;
          v282 = 1.0;
          while ( 1 )
          {
            if ( (v280 & 1) != 0 )
              v282 = v282 * v275;
            v280 >>= 1;
            if ( !v280 )
              break;
            v275 = v275 * v275;
          }
          if ( v257 >= 0 )
            v283 = v282;
          else
            v283 = 1.0 / v282;
          v284 = v257;
          v285 = v458 * *(double *)&qword_43E0E8;
          v286 = v409 * v281;
          v287 = v458 * *(double *)&qword_43E0E8;
          v288 = v283 / *(double *)&qword_43E0E8 / v398 * v411;
          if ( v257 < 0 )
            v284 = -v257;
          v289 = 1.0;
          while ( 1 )
          {
            if ( (v284 & 1) != 0 )
              v289 = v289 * v287;
            v284 >>= 1;
            if ( !v284 )
              break;
            v287 = v287 * v287;
          }
          if ( v257 >= 0 )
            v290 = v289;
          else
            v290 = 1.0 / v289;
          v291 = v257;
          v292 = v290 / *(double *)&qword_43E0E8 / v503 * v438;
          if ( v257 < 0 )
            v291 = -v257;
          v293 = 1.0;
          while ( 1 )
          {
            if ( (v291 & 1) != 0 )
              v293 = v293 * v285;
            v291 >>= 1;
            if ( !v291 )
              break;
            v285 = v285 * v285;
          }
          if ( v257 >= 0 )
            v294 = v293;
          else
            v294 = 1.0 / v293;
          ++v257;
          v295 = v506 - v286;
          v296 = v400 * v286;
          v260 = v464 - v472;
          v297 = v292 * v525 * v524
               + (v288 - v505) * v469
               + v295 * v485
               + v294 / *(double *)&qword_43E0E8 / v503 * v526 * v418;
          v253 = v524;
          v298 = (v288 - v505) * v524;
          v299 = v464 * v288;
          v256 = v455;
          *v262++ = ((v297 + v296 + v472 * v505 - v461 * v506 - v299) * v455 - (v295 * v418 + v298) / v455 * v511)
                  * *(double *)(v434 + 80)
                  / v484;
        }
        while ( v257 <= v391 );
        v258 = v511;
        v250 = a4;
        v251 = v387;
      }
      v459 = v451 - v516;
      v516 = v516 * v400 + v472 * v502 - v461 * v451 - v488 * v464;
      v516 = v516 + (v488 - v502) * v469 + v253 * v481 + v459 * v485 + v512 * v260;
      *(double *)&v250[8 * v251 + 64] = (v516 * v256 - (v459 * v260 + (v488 - v502) * v253) / v256 * v258)
                                      * *(double *)(v434 + 80)
                                      / v484;
      v300 = v441;
      v387 = a5 + v251;
      if ( *(_BYTE *)(*(_DWORD *)(v434 + 192) + 40 * v441 + 32) == 1 )
      {
        v466 = v465 - v504;
        v452 = fabs(v260);
        v401 = v400 - v461;
        v443 = v442 - v521;
        v447 = v446 - v390;
        v439 = *(_QWORD *)&v401 & 0x7FFFFFFFFFFFFFFFi64;
        if ( v452 <= COERCE_DOUBLE(*(_QWORD *)&v401 & 0x7FFFFFFFFFFFFFFFi64) )
        {
          v303 = v401;
          v302 = *(double *)libm_sse2_pow_precise().m128_u64;
          v301 = v464 - v472;
          v304 = v393;
          v305 = a4;
          *(double *)&a4[8 * v393] = (v476 * v401 - v466 * v418) * (v401 * *(double *)(v434 + 72)) / v302;
          *(double *)&a4[8 * v393 + 8] = (v405 * v401 - v443 * v418) * (v401 * *(double *)(v434 + 72)) / v302;
          v306 = (v376 * v303 - v447 * v418) * (v303 * *(double *)(v434 + 72));
        }
        else
        {
          v301 = v464 - v472;
          v302 = *(double *)libm_sse2_pow_precise().m128_u64;
          v303 = v401;
          v304 = v393;
          v305 = a4;
          *(double *)&a4[8 * v393] = (v476 * v401 - v466 * v418) * (v418 * *(double *)(v434 + 72)) * -1.0 / v302;
          *(double *)&a4[8 * v393 + 8] = (v405 * v401 - v443 * v418) * (v418 * *(double *)(v434 + 72)) * -1.0 / v302;
          v306 = (v376 * v401 - v447 * v418) * (v418 * *(double *)(v434 + 72)) * -1.0;
        }
        v307 = 1;
        *(double *)&v305[8 * v304 + 16] = v306 / v302;
        *(_QWORD *)&v305[8 * v304 + 24] = 0i64;
        if ( v391 >= 1 )
        {
          v308 = (double *)&v305[8 * v304 + 32];
          do
          {
            v309 = v307;
            v310 = *(double *)&v522 * *(double *)&qword_43E0E8;
            v311 = *(double *)&v522 * *(double *)&qword_43E0E8;
            if ( v307 < 0 )
              v309 = -v307;
            v312 = 1.0;
            while ( 1 )
            {
              if ( (v309 & 1) != 0 )
                v312 = v312 * v311;
              v309 >>= 1;
              if ( !v309 )
                break;
              v311 = v311 * v311;
            }
            if ( v307 >= 0 )
              v313 = v312;
            else
              v313 = 1.0 / v312;
            v314 = v307;
            v315 = v313 / *(double *)&qword_43E0E8 / v491 * v433;
            if ( v307 < 0 )
              v314 = -v307;
            v316 = 1.0;
            while ( 1 )
            {
              if ( (v314 & 1) != 0 )
                v316 = v316 * v310;
              v314 >>= 1;
              if ( !v314 )
                break;
              v310 = v310 * v310;
            }
            if ( v307 >= 0 )
              v317 = v316;
            else
              v317 = 1.0 / v316;
            v318 = v307;
            v319 = v509 * v315;
            v320 = v421 * *(double *)&qword_43E0E8;
            v321 = v421 * *(double *)&qword_43E0E8;
            v322 = v317 / *(double *)&qword_43E0E8 / v491 * v426;
            if ( v307 < 0 )
              v318 = -v307;
            v323 = 1.0;
            while ( 1 )
            {
              if ( (v318 & 1) != 0 )
                v323 = v323 * v321;
              v318 >>= 1;
              if ( !v318 )
                break;
              v321 = v321 * v321;
            }
            if ( v307 >= 0 )
              v324 = v323;
            else
              v324 = 1.0 / v323;
            v325 = v307;
            v326 = v324 / *(double *)&qword_43E0E8 / v398 * v415;
            if ( v307 < 0 )
              v325 = -v307;
            v327 = 1.0;
            while ( 1 )
            {
              if ( (v325 & 1) != 0 )
                v327 = v327 * v320;
              v325 >>= 1;
              if ( !v325 )
                break;
              v320 = v320 * v320;
            }
            if ( v307 >= 0 )
              v328 = v327;
            else
              v328 = 1.0 / v327;
            v329 = v409 * v326;
            v301 = v464 - v472;
            v330 = (v319 - v329) * v401 - (v322 - v328 / *(double *)&qword_43E0E8 / v398 * v411) * v418;
            v303 = v401;
            if ( v452 <= *(double *)&v439 )
              v331 = v330 * (v401 * *(double *)(v434 + 72));
            else
              v331 = v330 * (v418 * *(double *)(v434 + 72)) * -1.0;
            ++v307;
            *v308++ = v331 / v302;
          }
          while ( v307 <= v391 );
          v304 = v393;
          v305 = a4;
        }
        v332 = v459 * v303 - (v502 - v488) * v301;
        if ( v452 <= *(double *)&v439 )
          v333 = v332 * (v303 * *(double *)(v434 + 72));
        else
          v333 = v332 * (v301 * *(double *)(v434 + 72)) * -1.0;
        *(double *)&v305[8 * v304 + 64] = v333 / v302;
        v67 = a5 + v304;
        v300 = v441;
        v393 = v67;
      }
      else
      {
        v67 = v393;
      }
      v71 = v486;
      v66 = v300 + 1;
      v69 = v510;
      v70 = v514;
      v73 = v501;
      v441 = v66;
    }
    while ( v66 < v517 );
  }
  v334 = 1.0;
  v335 = *(double *)(a3 + 64);
  result = a4;
  if ( v335 <= 1.0 )
  {
    if ( v335 >= 1.0 )
    {
      *(_QWORD *)&a4[8 * v67 + 64] = 0i64;
      goto LABEL_316;
    }
    v334 = -1.0 / (v335 * v335);
  }
  *(double *)&a4[8 * v67 + 64] = v334;
LABEL_316:
  *(double *)&a4[8 * v67 + 64] = *(double *)(v7 + 88) * *(double *)&a4[8 * v67 + 64];
  return result;
}
// 408C60: could not find valid save-restore pair for edi
// 408C60: could not find valid save-restore pair for esi
// 40A119: variable 'v337' is possibly undefined
// 40A119: variable 'v350' is possibly undefined
// 40A141: variable 'v338' is possibly undefined
// 40A141: variable 'v351' is possibly undefined
// 40A141: variable 'v364' is possibly undefined
// 40A141: variable 'v377' is possibly undefined
// 40A16E: variable 'v339' is possibly undefined
// 40A16E: variable 'v352' is possibly undefined
// 40A16E: variable 'v365' is possibly undefined
// 40A16E: variable 'v378' is possibly undefined
// 40A237: variable 'v340' is possibly undefined
// 40A237: variable 'v353' is possibly undefined
// 40A237: variable 'v366' is possibly undefined
// 40A237: variable 'v379' is possibly undefined
// 40AB01: variable 'v341' is possibly undefined
// 40AB01: variable 'v354' is possibly undefined
// 40AB29: variable 'v342' is possibly undefined
// 40AB29: variable 'v355' is possibly undefined
// 40AB29: variable 'v368' is possibly undefined
// 40AB29: variable 'v380' is possibly undefined
// 40AB56: variable 'v343' is possibly undefined
// 40AB56: variable 'v356' is possibly undefined
// 40AB56: variable 'v369' is possibly undefined
// 40AB56: variable 'v381' is possibly undefined
// 40AC13: variable 'v344' is possibly undefined
// 40AC13: variable 'v357' is possibly undefined
// 40AC13: variable 'v370' is possibly undefined
// 40AC13: variable 'v382' is possibly undefined
// 40B4CF: variable 'v345' is possibly undefined
// 40B4CF: variable 'v358' is possibly undefined
// 40B4F7: variable 'v346' is possibly undefined
// 40B4F7: variable 'v359' is possibly undefined
// 40B4F7: variable 'v372' is possibly undefined
// 40B4F7: variable 'v383' is possibly undefined
// 40B524: variable 'v347' is possibly undefined
// 40B524: variable 'v360' is possibly undefined
// 40B524: variable 'v373' is possibly undefined
// 40B524: variable 'v384' is possibly undefined
// 40B5F8: variable 'v348' is possibly undefined
// 40B5F8: variable 'v361' is possibly undefined
// 40B5F8: variable 'v374' is possibly undefined
// 40B5F8: variable 'v385' is possibly undefined
// 40B797: variable 'v349' is possibly undefined
// 40B797: variable 'v362' is possibly undefined
// 40B797: variable 'v375' is possibly undefined
// 40B797: variable 'v386' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);
// 436A6E: using guessed type __m128 libm_sse2_pow_precise(void);
// 43E0E8: using guessed type __int64 qword_43E0E8;

//----- (0040C4E0) --------------------------------------------------------
double __thiscall sub_40C4E0(int *this)
{
  int v2; // edi
  unsigned int v3; // esi
  double *v4; // esi
  int v5; // ecx
  int i; // eax
  double v7; // xmm0_8
  int v9; // [esp+0h] [ebp-94h]
  int v10; // [esp+4h] [ebp-90h]
  int v11; // [esp+8h] [ebp-8Ch]
  int v12; // [esp+Ch] [ebp-88h]
  double v13; // [esp+14h] [ebp-80h]
  double v14; // [esp+14h] [ebp-80h]
  void *v15[2]; // [esp+20h] [ebp-74h] BYREF
  int v16; // [esp+28h] [ebp-6Ch]
  int v17[26]; // [esp+2Ch] [ebp-68h] BYREF

  v2 = this[6];
  v3 = this[7];
  v15[0] = 0;
  v15[1] = 0;
  v16 = 0;
  v17[25] = 0;
  sub_4077E0(v15, v3);
  sub_407920(v2, v3, this[1], (int)v15[0], this[6], this[7], (int)this);
  v13 = 0.0;
  sub_401000(
    (void (__cdecl *)(int, double *, int, int, int))sub_407920,
    (void (__cdecl *)(int, int, int, int, int))sub_408C60,
    this[1],
    this[2],
    v2,
    v3,
    1000,
    0,
    (double *)v17,
    0,
    0,
    (int)this);
  v4 = (double *)v15[0];
  sub_407920(v2, (int)v15[0], this[1], (int)v15[0], this[6], this[7], (int)this);
  v5 = this[7];
  for ( i = 0; i < v5; v13 = v7 * v7 + v13 )
    v7 = v4[i++];
  *(_QWORD *)&v14 = libm_sse2_sqrt_precise(v9, v10, v11, v12).m128_u64[0];
  if ( v4 )
    operator delete(v4);
  return v14;
}
// 40C5FB: variable 'v9' is possibly undefined
// 40C5FB: variable 'v10' is possibly undefined
// 40C5FB: variable 'v11' is possibly undefined
// 40C5FB: variable 'v12' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0040C640) --------------------------------------------------------
_DWORD *__thiscall sub_40C640(_DWORD *this, int a2, int a3, int a4)
{
  void *v5; // eax
  size_t v7; // [esp-Ch] [ebp-14h]

  this[8] = a4;
  this[6] = a2;
  this[7] = a3;
  *this = &CLevmarForGCM_LS::`vftable';
  this[1] = operator new[](8 * a2);
  v5 = operator new[](8 * this[7]);
  v7 = 8 * this[7];
  this[2] = v5;
  memset(v5, 0, v7);
  return this;
}
// 43943C: using guessed type void *CLevmarForGCM_LS::`vftable';

//----- (0040C6B0) --------------------------------------------------------
void __thiscall sub_40C6B0(void *this)
{
  void *v2; // [esp-4h] [ebp-8h]

  v2 = (void *)*((_DWORD *)this + 1);
  *(_DWORD *)this = &CLevmarForGCM_LS::`vftable';
  operator delete[](v2);
  operator delete[](*((void **)this + 2));
}
// 43943C: using guessed type void *CLevmarForGCM_LS::`vftable';

//----- (0040C6D0) --------------------------------------------------------
void *__thiscall sub_40C6D0(void *this, char a2)
{
  void *v4; // [esp-4h] [ebp-8h]

  v4 = (void *)*((_DWORD *)this + 1);
  *(_DWORD *)this = &CLevmarForGCM_LS::`vftable';
  operator delete[](v4);
  operator delete[](*((void **)this + 2));
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 43943C: using guessed type void *CLevmarForGCM_LS::`vftable';

//----- (0040C710) --------------------------------------------------------
int __usercall sub_40C710@<eax>(int a1@<edi>, int a2@<esi>, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // esi
  double v8; // xmm6_8
  double v9; // xmm3_8
  double v10; // xmm7_8
  unsigned int *v11; // edx
  __m128i v12; // xmm0
  int v13; // edx
  int v14; // eax
  int v15; // ecx
  double v16; // xmm0_8
  int v17; // edi
  double v18; // xmm1_8
  double v19; // xmm7_8
  int v20; // eax
  double v21; // xmm4_8
  double v22; // xmm5_8
  double v23; // xmm6_8
  double *v24; // esi
  double v25; // st7
  int v26; // esi
  int v27; // edi
  double v28; // xmm1_8
  double v29; // xmm5_8
  double v30; // xmm2_8
  double v31; // xmm6_8
  double v32; // xmm4_8
  int v33; // eax
  int v34; // edi
  double *v35; // esi
  double v36; // xmm2_8
  double v37; // st7
  double v38; // xmm7_8
  __int128 v39; // xmm6
  double v40; // xmm5_8
  int v41; // ecx
  double *v42; // esi
  __int128 v43; // xmm1
  __int128 v44; // xmm2
  unsigned int v45; // eax
  double v46; // xmm1_8
  __int128 v47; // xmm0
  double v48; // xmm2_8
  int v49; // edx
  unsigned int v50; // eax
  double v51; // xmm3_8
  double v52; // xmm0_8
  __int128 v53; // xmm2
  double v54; // xmm1_8
  __int128 v55; // xmm0
  double v56; // xmm2_8
  unsigned int v57; // eax
  double v58; // xmm0_8
  __int128 v59; // xmm2
  double v60; // xmm1_8
  __int128 v61; // xmm0
  double v62; // xmm0_8
  double v63; // xmm0_8
  int v64; // esi
  double v65; // xmm3_8
  double v66; // xmm2_8
  double v67; // xmm3_8
  double v68; // st7
  double v69; // xmm0_8
  double v70; // xmm7_8
  double v71; // xmm6_8
  double v72; // xmm3_8
  __int128 v73; // xmm5
  int v74; // ecx
  double *v75; // esi
  __int128 v76; // xmm1
  __int128 v77; // xmm2
  unsigned int v78; // eax
  double v79; // xmm1_8
  __int128 v80; // xmm0
  double v81; // xmm2_8
  int v82; // edx
  unsigned int v83; // eax
  double v84; // xmm3_8
  double v85; // xmm0_8
  __int128 v86; // xmm2
  double v87; // xmm1_8
  __int128 v88; // xmm0
  double v89; // xmm2_8
  unsigned int v90; // eax
  double v91; // xmm0_8
  __int128 v92; // xmm2
  double v93; // xmm1_8
  __int128 v94; // xmm0
  double v95; // xmm0_8
  double v96; // xmm0_8
  double *v97; // esi
  double v98; // xmm2_8
  double v99; // xmm3_8
  double v100; // st7
  double v101; // xmm0_8
  double v102; // xmm4_8
  double v103; // xmm3_8
  double v104; // xmm5_8
  double v105; // xmm7_8
  double v106; // xmm6_8
  int v107; // ecx
  __int128 v108; // xmm2
  double *v109; // esi
  unsigned int v110; // eax
  double v111; // xmm1_8
  __int128 v112; // xmm0
  double v113; // xmm2_8
  int v114; // edx
  unsigned int v115; // eax
  double v116; // xmm3_8
  double v117; // xmm0_8
  __int128 v118; // xmm2
  double v119; // xmm1_8
  __int128 v120; // xmm0
  double v121; // xmm2_8
  unsigned int v122; // eax
  double v123; // xmm0_8
  __int128 v124; // xmm2
  double v125; // xmm1_8
  __int128 v126; // xmm0
  double v127; // xmm0_8
  double v128; // xmm0_8
  double v129; // xmm0_8
  int v130; // eax
  double v131; // xmm0_8
  double v132; // xmm0_8
  double *v133; // ecx
  double *v134; // eax
  double v135; // xmm1_8
  int result; // eax
  double v137; // xmm1_8
  int v138; // [esp+40h] [ebp-1C8h]
  int v139; // [esp+40h] [ebp-1C8h]
  int v140; // [esp+40h] [ebp-1C8h]
  int v141; // [esp+40h] [ebp-1C8h]
  int v142; // [esp+40h] [ebp-1C8h]
  int v143; // [esp+40h] [ebp-1C8h]
  int v144; // [esp+40h] [ebp-1C8h]
  int v145; // [esp+40h] [ebp-1C8h]
  int v146; // [esp+40h] [ebp-1C8h]
  int v147; // [esp+40h] [ebp-1C8h]
  int v148; // [esp+44h] [ebp-1C4h]
  int v149; // [esp+44h] [ebp-1C4h]
  int v150; // [esp+44h] [ebp-1C4h]
  int v151; // [esp+44h] [ebp-1C4h]
  int v152; // [esp+44h] [ebp-1C4h]
  int v153; // [esp+44h] [ebp-1C4h]
  int v154; // [esp+44h] [ebp-1C4h]
  int v155; // [esp+44h] [ebp-1C4h]
  int v156; // [esp+44h] [ebp-1C4h]
  int v157; // [esp+44h] [ebp-1C4h]
  double v158; // [esp+48h] [ebp-1C0h]
  int v159; // [esp+48h] [ebp-1C0h]
  int v160; // [esp+48h] [ebp-1C0h]
  double v161; // [esp+48h] [ebp-1C0h]
  int v162; // [esp+48h] [ebp-1C0h]
  int v163; // [esp+48h] [ebp-1C0h]
  double v164; // [esp+48h] [ebp-1C0h]
  int v165; // [esp+48h] [ebp-1C0h]
  int v166; // [esp+48h] [ebp-1C0h]
  double v167; // [esp+48h] [ebp-1C0h]
  double v168; // [esp+48h] [ebp-1C0h]
  double v169; // [esp+48h] [ebp-1C0h]
  int v170; // [esp+4Ch] [ebp-1BCh]
  int v171; // [esp+4Ch] [ebp-1BCh]
  int v172; // [esp+4Ch] [ebp-1BCh]
  int v173; // [esp+4Ch] [ebp-1BCh]
  int v174; // [esp+4Ch] [ebp-1BCh]
  int v175; // [esp+4Ch] [ebp-1BCh]
  int v176; // [esp+50h] [ebp-1B8h]
  int v177; // [esp+50h] [ebp-1B8h]
  int v178; // [esp+54h] [ebp-1B4h]
  double v179; // [esp+58h] [ebp-1B0h]
  double v180; // [esp+60h] [ebp-1A8h]
  double v181; // [esp+60h] [ebp-1A8h]
  double v182; // [esp+60h] [ebp-1A8h]
  double v183; // [esp+60h] [ebp-1A8h]
  int v184; // [esp+6Ch] [ebp-19Ch]
  int v185; // [esp+6Ch] [ebp-19Ch]
  int v186; // [esp+74h] [ebp-194h]
  double v187; // [esp+78h] [ebp-190h]
  double v188; // [esp+78h] [ebp-190h]
  double v189; // [esp+80h] [ebp-188h]
  double v190; // [esp+80h] [ebp-188h]
  double v191; // [esp+88h] [ebp-180h]
  double v192; // [esp+88h] [ebp-180h]
  int v193; // [esp+98h] [ebp-170h]
  double v194; // [esp+98h] [ebp-170h]
  double v195; // [esp+98h] [ebp-170h]
  double v196; // [esp+98h] [ebp-170h]
  int v197; // [esp+A4h] [ebp-164h]
  double v198; // [esp+A8h] [ebp-160h]
  double v199; // [esp+B0h] [ebp-158h]
  double v200; // [esp+B0h] [ebp-158h]
  double v201; // [esp+B0h] [ebp-158h]
  double v202; // [esp+B8h] [ebp-150h]
  double v203; // [esp+B8h] [ebp-150h]
  double v204; // [esp+C0h] [ebp-148h]
  double v205; // [esp+C0h] [ebp-148h]
  double v206; // [esp+C8h] [ebp-140h]
  double v207; // [esp+D0h] [ebp-138h]
  double v208; // [esp+D0h] [ebp-138h]
  double v209; // [esp+D8h] [ebp-130h]
  double v210; // [esp+E0h] [ebp-128h]
  double v211; // [esp+E0h] [ebp-128h]
  int v212; // [esp+ECh] [ebp-11Ch]
  double v213; // [esp+F0h] [ebp-118h] BYREF
  double v214; // [esp+F8h] [ebp-110h]
  double v215; // [esp+100h] [ebp-108h]
  double v216; // [esp+108h] [ebp-100h]
  double v217; // [esp+110h] [ebp-F8h]
  double v218; // [esp+118h] [ebp-F0h]
  double v219; // [esp+120h] [ebp-E8h]
  double v220; // [esp+128h] [ebp-E0h]
  double v221; // [esp+130h] [ebp-D8h]
  double v222; // [esp+138h] [ebp-D0h] BYREF
  double *v223; // [esp+144h] [ebp-C4h]
  double v224; // [esp+148h] [ebp-C0h] BYREF
  char v225[180]; // [esp+150h] [ebp-B8h] BYREF

  v148 = a2;
  v138 = a1;
  *(_QWORD *)(a3 + 24) = 0i64;
  v197 = *(_DWORD *)(a7 + 32);
  sub_405EB0((int)v225, v197, a3 + 24, qword_43E0E8);
  v7 = *(_DWORD *)(a7 + 20);
  v178 = v7;
  v210 = *(double *)(v7 + 56);
  v184 = a3 + 8 * *(_DWORD *)(v7 + 204);
  sub_406C30(*(_QWORD *)a3, *(double *)(a3 + 8), *(double *)(a3 + 16), &v213);
  v8 = v221;
  v9 = v218;
  v10 = v215;
  v11 = (unsigned int *)(v7 + 48);
  v223 = (double *)(a3 + 64);
  if ( *(_DWORD *)(v7 + 48) < *(_DWORD *)(v7 + 52) )
    v11 = (unsigned int *)(v7 + 52);
  v12 = _mm_cvtsi32_si128(*v11);
  v13 = v7;
  v14 = *(_DWORD *)(v7 + 16);
  v15 = *(_DWORD *)(v7 + 24);
  v186 = v14;
  v212 = v15;
  v16 = _mm_cvtepi32_pd(v12).m128d_f64[0] * *(double *)(a3 + 64);
  v17 = 0;
  if ( v14 > 0 )
  {
    v18 = -v16;
    v19 = v215 * v16;
    v20 = 0;
    v21 = v215 * -v16;
    v176 = 0;
    v22 = v221 * -v16;
    v23 = v221 * v16;
    v202 = v21;
    v189 = v22;
    v207 = v221 * v16;
    v204 = v215 * v16;
    v179 = v218 * v16;
    do
    {
      v24 = (double *)(v20 + *(_DWORD *)(v13 + 108));
      v24[2] = v18;
      v25 = sub_406A70(
              (int)v225,
              -4.0,
              0.0,
              -1.0,
              1.0e-10,
              *v24 * v213 + v24[1] * v214 + v21,
              v19,
              *v24 * v219 + v24[1] * v220 + v22,
              v23);
      v13 = v178;
      v9 = v218;
      v21 = v202;
      v22 = v189;
      v23 = v207;
      v19 = v204;
      *(double *)(a4 + 8 * v17) = (v24[1] * v217 + *v24 * v216 + v218 * v24[2]) * v25
                                - v179
                                - *(double *)(v184 + 8 * *(_DWORD *)(*(_DWORD *)(v178 + 120) + 4 * v17)) * v210;
      ++v17;
      v18 = -v16;
      v20 = v176 + 32;
      v176 += 32;
    }
    while ( v17 < v186 );
    v8 = v221;
    v10 = v215;
    v14 = v186;
    v15 = v212;
  }
  v26 = 0;
  v27 = v15 + v14;
  v177 = v15 + v14;
  v185 = 0;
  if ( v15 > 0 )
  {
    v28 = -v16;
    v29 = v10 * -v16;
    v30 = v8 * -v16;
    v31 = v8 * v16;
    v32 = v10 * v16;
    v206 = v30;
    v209 = -v16;
    v211 = v29;
    v203 = v31;
    v198 = v10 * v16;
    v205 = v9 * v16;
    do
    {
      v33 = v26 + v14 + 2 * v26;
      v34 = 32 * v33;
      v35 = (double *)(32 * v33 + *(_DWORD *)(v13 + 108));
      v193 = v33;
      v36 = *v35;
      v35[2] = v28;
      v37 = sub_406A70(
              (int)v225,
              -4.0,
              0.0,
              -1.0,
              1.0e-10,
              v36 * v213 + v35[1] * v214 + v29,
              v32,
              v36 * v219 + v35[1] * v220 + v206,
              v31);
      v38 = 0.0;
      v39 = *(unsigned __int64 *)v35;
      v180 = 0.0;
      v158 = v37;
      *(double *)&v39 = (*(double *)&v39 * v213 + v35[1] * v214 + v35[2] * v215) * v37 - v198;
      v187 = *(double *)&v39;
      v208 = (v216 * *v35 + v217 * v35[1] + v218 * v35[2]) * v37 - v205;
      v40 = 0.0;
      if ( v197 >= 1 )
      {
        v41 = 0;
        v43 = (unsigned __int64)qword_43E0E8;
        *(double *)&v39 = *(double *)&v39 * *(double *)&qword_43E0E8;
        v42 = (double *)(a3 + 32);
        *(double *)&v43 = *(double *)&qword_43E0E8 * 0.0;
        v158 = *(double *)&v39 * 0.5;
        do
        {
          v44 = v43;
          v45 = v41;
          if ( v41 < 0 )
            v45 = -v41;
          v46 = 1.0;
          while ( 1 )
          {
            if ( (v45 & 1) != 0 )
              v46 = v46 * *(double *)&v44;
            v45 >>= 1;
            if ( !v45 )
              break;
            *((_QWORD *)&v47 + 1) = *((_QWORD *)&v44 + 1);
            *(double *)&v47 = *(double *)&v44 * *(double *)&v44;
            v44 = v47;
          }
          if ( v41 >= 0 )
            v48 = v46;
          else
            v48 = 1.0 / v46;
          v49 = v41 + 1;
          v50 = v41;
          v51 = (double)(v41 + 1) * *v42;
          v52 = v51 * v48;
          v53 = *(unsigned __int64 *)&v158;
          v180 = v52 + v180;
          if ( v41 < 0 )
            v50 = -v41;
          v54 = 1.0;
          while ( 1 )
          {
            if ( (v50 & 1) != 0 )
              v54 = v54 * *(double *)&v53;
            v50 >>= 1;
            if ( !v50 )
              break;
            *((_QWORD *)&v55 + 1) = *((_QWORD *)&v53 + 1);
            *(double *)&v55 = *(double *)&v53 * *(double *)&v53;
            v53 = v55;
          }
          if ( v41 >= 0 )
            v56 = v54;
          else
            v56 = 1.0 / v54;
          v57 = v41;
          v58 = v51 * v56;
          v59 = v39;
          v38 = v58 + v38;
          if ( v41 < 0 )
            v57 = -v41;
          v60 = 1.0;
          while ( 1 )
          {
            if ( (v57 & 1) != 0 )
              v60 = v60 * *(double *)&v59;
            v57 >>= 1;
            if ( !v57 )
              break;
            *((_QWORD *)&v61 + 1) = *((_QWORD *)&v59 + 1);
            *(double *)&v61 = *(double *)&v59 * *(double *)&v59;
            v59 = v61;
          }
          if ( v41 >= 0 )
            v62 = v60;
          else
            v62 = 1.0 / v60;
          v43 = COERCE_UNSIGNED_INT64(*(double *)&qword_43E0E8 * 0.0);
          ++v41;
          ++v42;
          v40 = v51 * v62 + v40;
        }
        while ( v49 + 1 <= v197 );
      }
      v199 = *(double *)libm_sse2_sqrt_precise(v138, v148, LODWORD(v158), HIDWORD(v158)).m128_u64 * 4.0;
      v200 = v199 + *(double *)libm_sse2_sqrt_precise(v139, v149, v159, v170).m128_u64;
      v63 = *(double *)libm_sse2_sqrt_precise(v140, v150, v160, v171).m128_u64;
      v64 = *(_DWORD *)(v178 + 108);
      v65 = *(double *)(v34 + v64 + 32);
      v66 = v65 * v219;
      v67 = v65 * v213;
      *(double *)(v34 + v64 + 48) = v209;
      v201 = (v200 + v63) * (v187 / 6.0);
      v68 = sub_406A70(
              (int)v225,
              -4.0,
              0.0,
              -1.0,
              1.0e-10,
              v67 + *(double *)(v34 + v64 + 40) * v214 + v211,
              v198,
              v66 + *(double *)(v34 + v64 + 40) * v220 + v206,
              v203);
      v69 = *(double *)(v34 + v64 + 48);
      v161 = v68;
      v188 = 0.0;
      v70 = 0.0;
      v71 = 0.0;
      v72 = (*(double *)(v34 + v64 + 32) * v213 + *(double *)(v34 + v64 + 40) * v214 + v69 * v215) * v68 - v198;
      v191 = v72;
      v190 = (*(double *)(v34 + v64 + 32) * v216 + *(double *)(v34 + v64 + 40) * v217 + v69 * v218) * v68 - v205;
      if ( v197 >= 1 )
      {
        *((_QWORD *)&v73 + 1) = 0i64;
        v76 = (unsigned __int64)qword_43E0E8;
        *(double *)&v73 = v72 * *(double *)&qword_43E0E8;
        v74 = 0;
        v75 = (double *)(a3 + 32);
        *(double *)&v76 = *(double *)&qword_43E0E8 * 0.0;
        v161 = v72 * *(double *)&qword_43E0E8 * 0.5;
        do
        {
          v77 = v76;
          v78 = v74;
          if ( v74 < 0 )
            v78 = -v74;
          v79 = 1.0;
          while ( 1 )
          {
            if ( (v78 & 1) != 0 )
              v79 = v79 * *(double *)&v77;
            v78 >>= 1;
            if ( !v78 )
              break;
            *((_QWORD *)&v80 + 1) = *((_QWORD *)&v77 + 1);
            *(double *)&v80 = *(double *)&v77 * *(double *)&v77;
            v77 = v80;
          }
          if ( v74 >= 0 )
            v81 = v79;
          else
            v81 = 1.0 / v79;
          v82 = v74 + 1;
          v83 = v74;
          v84 = (double)(v74 + 1) * *v75;
          v85 = v84 * v81;
          v86 = *(unsigned __int64 *)&v161;
          v188 = v85 + v188;
          if ( v74 < 0 )
            v83 = -v74;
          v87 = 1.0;
          while ( 1 )
          {
            if ( (v83 & 1) != 0 )
              v87 = v87 * *(double *)&v86;
            v83 >>= 1;
            if ( !v83 )
              break;
            *((_QWORD *)&v88 + 1) = *((_QWORD *)&v86 + 1);
            *(double *)&v88 = *(double *)&v86 * *(double *)&v86;
            v86 = v88;
          }
          if ( v74 >= 0 )
            v89 = v87;
          else
            v89 = 1.0 / v87;
          v90 = v74;
          v91 = v84 * v89;
          v92 = v73;
          v70 = v91 + v70;
          if ( v74 < 0 )
            v90 = -v74;
          v93 = 1.0;
          while ( 1 )
          {
            if ( (v90 & 1) != 0 )
              v93 = v93 * *(double *)&v92;
            v90 >>= 1;
            if ( !v90 )
              break;
            *((_QWORD *)&v94 + 1) = *((_QWORD *)&v92 + 1);
            *(double *)&v94 = *(double *)&v92 * *(double *)&v92;
            v92 = v94;
          }
          if ( v74 >= 0 )
            v95 = v93;
          else
            v95 = 1.0 / v93;
          v76 = COERCE_UNSIGNED_INT64(*(double *)&qword_43E0E8 * 0.0);
          ++v74;
          ++v75;
          v71 = v84 * v95 + v71;
        }
        while ( v82 + 1 <= v197 );
      }
      v181 = *(double *)libm_sse2_sqrt_precise(v141, v151, LODWORD(v161), HIDWORD(v161)).m128_u64 * 4.0;
      v182 = v181 + *(double *)libm_sse2_sqrt_precise(v142, v152, v162, v172).m128_u64;
      v96 = *(double *)libm_sse2_sqrt_precise(v143, v153, v163, v173).m128_u64;
      v97 = (double *)(*(_DWORD *)(v178 + 108) + 32 * (v193 + 2));
      v98 = *v97 * v219;
      v99 = *v97 * v213;
      v97[2] = v209;
      v183 = (v182 + v96) * (v191 / 6.0);
      v100 = sub_406A70(
               (int)v225,
               -4.0,
               0.0,
               -1.0,
               1.0e-10,
               v99 + v97[1] * v214 + v211,
               v198,
               v98 + v97[1] * v220 + v206,
               v203);
      v101 = v97[2];
      v102 = *v97 * v216 + v97[1] * v217;
      v103 = (*v97 * v213 + v97[1] * v214 + v101 * v215) * v100 - v198;
      v222 = v103;
      v224 = (v102 + v101 * v218) * v100 - v205;
      v104 = 0.0;
      v105 = 0.0;
      v106 = 0.0;
      if ( v197 >= 1 )
      {
        v107 = 0;
        v108 = (unsigned __int64)qword_43E0E8;
        *(double *)&v108 = *(double *)&qword_43E0E8 * 0.0;
        v109 = (double *)(a3 + 32);
        v164 = v103 * *(double *)&qword_43E0E8;
        v192 = v103 * *(double *)&qword_43E0E8 * 0.5;
        do
        {
          v110 = v107;
          if ( v107 < 0 )
            v110 = -v107;
          v111 = 1.0;
          while ( 1 )
          {
            if ( (v110 & 1) != 0 )
              v111 = v111 * *(double *)&v108;
            v110 >>= 1;
            if ( !v110 )
              break;
            *((_QWORD *)&v112 + 1) = *((_QWORD *)&v108 + 1);
            *(double *)&v112 = *(double *)&v108 * *(double *)&v108;
            v108 = v112;
          }
          if ( v107 >= 0 )
            v113 = v111;
          else
            v113 = 1.0 / v111;
          v114 = v107 + 1;
          v115 = v107;
          v116 = (double)(v107 + 1) * *v109;
          v117 = v116 * v113;
          v118 = *(unsigned __int64 *)&v192;
          v105 = v117 + v105;
          if ( v107 < 0 )
            v115 = -v107;
          v119 = 1.0;
          while ( 1 )
          {
            if ( (v115 & 1) != 0 )
              v119 = v119 * *(double *)&v118;
            v115 >>= 1;
            if ( !v115 )
              break;
            *((_QWORD *)&v120 + 1) = *((_QWORD *)&v118 + 1);
            *(double *)&v120 = *(double *)&v118 * *(double *)&v118;
            v118 = v120;
          }
          if ( v107 >= 0 )
            v121 = v119;
          else
            v121 = 1.0 / v119;
          v122 = v107;
          v123 = v116 * v121;
          v124 = *(unsigned __int64 *)&v164;
          v106 = v123 + v106;
          if ( v107 < 0 )
            v122 = -v107;
          v125 = 1.0;
          while ( 1 )
          {
            if ( (v122 & 1) != 0 )
              v125 = v125 * *(double *)&v124;
            v122 >>= 1;
            if ( !v122 )
              break;
            *((_QWORD *)&v126 + 1) = *((_QWORD *)&v124 + 1);
            *(double *)&v126 = *(double *)&v124 * *(double *)&v124;
            v124 = v126;
          }
          if ( v107 >= 0 )
            v127 = v125;
          else
            v127 = 1.0 / v125;
          v108 = COERCE_UNSIGNED_INT64(*(double *)&qword_43E0E8 * 0.0);
          ++v107;
          ++v109;
          v104 = v104 + v116 * v127;
        }
        while ( v114 + 1 <= v197 );
      }
      v194 = *(double *)libm_sse2_sqrt_precise(
                          v144,
                          v154,
                          COERCE_UNSIGNED_INT64(v201 - v183),
                          HIDWORD(COERCE_UNSIGNED_INT64(v201 - v183))).m128_u64
           * 4.0;
      v195 = v194 + *(double *)libm_sse2_sqrt_precise(v145, v155, v165, v174).m128_u64;
      v128 = *(double *)libm_sse2_sqrt_precise(v146, v156, v166, v175).m128_u64;
      v196 = (v195 + v128) * (v222 / 6.0) * (v190 - v208) + v167 * v224 + v183 * v208 - v190 * v201;
      v129 = *(double *)libm_sse2_sqrt_precise(v147, v157, LODWORD(v167), HIDWORD(v167)).m128_u64;
      v130 = v185 + v186;
      v13 = v178;
      *(double *)(a4 + 8 * v130) = v196 / v129;
      *(double *)(a4 + 8 * v130) = *(double *)(v178 + 80) * (v196 / v129);
      if ( *(_BYTE *)(*(_DWORD *)(v178 + 192) + 40 * v185 + 32) == 1 )
      {
        if ( fabs(v168) <= fabs(v208 - v190) )
          v131 = v168;
        else
          v131 = v208 - v190;
        v132 = *(double *)libm_sse2_sqrt_precise(v138, v148, LODWORD(v131), HIDWORD(v131)).m128_u64;
        v13 = v178;
        *(double *)(a4 + 8 * v177) = v169 / v132;
        *(double *)(a4 + 8 * v177) = *(double *)(v178 + 72) * (v169 / v132);
        v27 = ++v177;
      }
      else
      {
        v27 = v177;
      }
      v31 = v203;
      v26 = v185 + 1;
      v32 = v198;
      v28 = v209;
      v29 = v211;
      v14 = v186;
      v185 = v26;
    }
    while ( v26 < v212 );
  }
  v133 = &v224;
  v134 = &v222;
  v224 = 1.0;
  v222 = 1.0;
  if ( *v223 > 1.0 )
    v133 = v223;
  if ( *v223 < 1.0 )
    v134 = v223;
  v135 = *v133 / *v134;
  result = a4;
  v137 = v135 - 1.0;
  *(double *)(a4 + 8 * v27) = v137;
  *(double *)(a4 + 8 * v27) = *(double *)(v13 + 88) * v137;
  return result;
}
// 40C710: could not find valid save-restore pair for edi
// 40C710: could not find valid save-restore pair for esi
// 40CD22: variable 'v138' is possibly undefined
// 40CD22: variable 'v148' is possibly undefined
// 40CD47: variable 'v139' is possibly undefined
// 40CD47: variable 'v149' is possibly undefined
// 40CD47: variable 'v159' is possibly undefined
// 40CD47: variable 'v170' is possibly undefined
// 40CD6E: variable 'v140' is possibly undefined
// 40CD6E: variable 'v150' is possibly undefined
// 40CD6E: variable 'v160' is possibly undefined
// 40CD6E: variable 'v171' is possibly undefined
// 40D070: variable 'v141' is possibly undefined
// 40D070: variable 'v151' is possibly undefined
// 40D095: variable 'v142' is possibly undefined
// 40D095: variable 'v152' is possibly undefined
// 40D095: variable 'v162' is possibly undefined
// 40D095: variable 'v172' is possibly undefined
// 40D0BC: variable 'v143' is possibly undefined
// 40D0BC: variable 'v153' is possibly undefined
// 40D0BC: variable 'v163' is possibly undefined
// 40D0BC: variable 'v173' is possibly undefined
// 40D3E9: variable 'v144' is possibly undefined
// 40D3E9: variable 'v154' is possibly undefined
// 40D40E: variable 'v145' is possibly undefined
// 40D40E: variable 'v155' is possibly undefined
// 40D40E: variable 'v165' is possibly undefined
// 40D40E: variable 'v174' is possibly undefined
// 40D435: variable 'v146' is possibly undefined
// 40D435: variable 'v156' is possibly undefined
// 40D435: variable 'v166' is possibly undefined
// 40D435: variable 'v175' is possibly undefined
// 40D477: variable 'v167' is possibly undefined
// 40D4B1: variable 'v147' is possibly undefined
// 40D4B1: variable 'v157' is possibly undefined
// 40D511: variable 'v168' is possibly undefined
// 40D552: variable 'v169' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);
// 43E0E8: using guessed type __int64 qword_43E0E8;

//----- (0040D630) --------------------------------------------------------
int *__thiscall sub_40D630(int this, char *a2, int a3)
{
  int v4; // edx
  int *result; // eax
  double *v6; // esi
  int v7; // ecx

  memcpy(a2, *(const void **)(this + 4), 8 * *(_DWORD *)(this + 24));
  v4 = *(_DWORD *)(this + 20);
  result = *(int **)(v4 + 96);
  if ( result != *(int **)(v4 + 100) )
  {
    v6 = (double *)&a2[8 * a3];
    do
    {
      ++v6;
      v7 = *result++;
      *(double *)(v7 + 24) = *(double *)(v4 + 56) * *(v6 - 1);
      v4 = *(_DWORD *)(this + 20);
    }
    while ( result != *(int **)(v4 + 100) );
  }
  return result;
}

//----- (0040D690) --------------------------------------------------------
char *__usercall sub_40D690@<eax>(int a1@<edi>, int a2@<esi>, int a3, char *a4, int a5, int a6, int a7)
{
  int v7; // esi
  int *v8; // edx
  int v9; // edx
  int v10; // ecx
  int v11; // eax
  double v12; // xmm7_8
  double v13; // xmm1_8
  double v14; // xmm5_8
  int v15; // eax
  double *v16; // edi
  double v17; // xmm7_8
  double v18; // xmm4_8
  double v19; // xmm6_8
  double *v20; // esi
  double v21; // xmm0_8
  double v22; // xmm3_8
  double v23; // xmm3_8
  double v24; // xmm0_8
  double v25; // xmm3_8
  double v26; // xmm4_8
  double v27; // st7
  double v28; // xmm6_8
  double v29; // xmm4_8
  double v30; // xmm5_8
  double v31; // xmm7_8
  double v32; // xmm2_8
  double v33; // xmm1_8
  double v34; // xmm0_8
  double v35; // xmm6_8
  double v36; // xmm2_8
  double v37; // xmm1_8
  double v38; // xmm0_8
  double v39; // xmm5_8
  int v40; // ecx
  double v41; // xmm5_8
  double v42; // xmm7_8
  double v43; // xmm0_8
  double v44; // xmm1_8
  double v45; // xmm3_8
  double v46; // xmm5_8
  double v47; // xmm1_8
  double v48; // xmm0_8
  double v49; // xmm5_8
  double *v50; // edx
  __int128 v51; // xmm2
  unsigned int v52; // eax
  double v53; // xmm1_8
  __int128 v54; // xmm0
  double v55; // xmm0_8
  double v56; // xmm1_8
  double v57; // xmm0_8
  double v58; // xmm1_8
  double v59; // xmm0_8
  int v60; // eax
  int v61; // ecx
  int v62; // edx
  double v63; // xmm0_8
  double v64; // xmm4_8
  double v65; // xmm3_8
  double v66; // xmm6_8
  double v67; // xmm7_8
  double v68; // xmm1_8
  int v69; // edi
  double *v70; // esi
  double v71; // xmm1_8
  double v72; // xmm3_8
  double v73; // st7
  double v74; // xmm7_8
  double v75; // xmm5_8
  double v76; // xmm2_8
  int v77; // ecx
  double v78; // xmm3_8
  double v79; // xmm1_8
  double v80; // xmm4_8
  double v81; // xmm0_8
  double v82; // xmm2_8
  double v83; // xmm3_8
  double v84; // xmm4_8
  double v85; // xmm5_8
  double v86; // xmm6_8
  double v87; // xmm2_8
  double v88; // xmm3_8
  double v89; // xmm0_8
  int v90; // esi
  double v91; // xmm3_8
  double v92; // xmm5_8
  double v93; // xmm6_8
  double v94; // xmm4_8
  __int128 v95; // xmm0
  __int128 v96; // xmm7
  int v97; // ecx
  double *v98; // esi
  __int128 v99; // xmm1
  __int128 v100; // xmm2
  unsigned int v101; // eax
  double v102; // xmm1_8
  __int128 v103; // xmm0
  double v104; // xmm0_8
  __int128 v105; // xmm2
  int v106; // edx
  unsigned int v107; // eax
  double v108; // xmm3_8
  double v109; // xmm1_8
  __int128 v110; // xmm0
  double v111; // xmm0_8
  __int128 v112; // xmm2
  unsigned int v113; // eax
  double v114; // xmm1_8
  __int128 v115; // xmm0
  double v116; // xmm0_8
  double v117; // xmm3_8
  double v118; // xmm1_8
  int v119; // ecx
  double *v120; // edx
  double v121; // xmm2_8
  unsigned int v122; // eax
  double v123; // xmm1_8
  double v124; // xmm2_8
  double v125; // xmm0_8
  double v126; // xmm2_8
  double v127; // xmm3_8
  double v128; // xmm2_8
  double v129; // xmm1_8
  double v130; // st7
  double v131; // xmm3_8
  int v132; // ecx
  double v133; // xmm2_8
  double v134; // xmm0_8
  double v135; // xmm4_8
  double v136; // xmm5_8
  double v137; // xmm6_8
  double v138; // xmm7_8
  double v139; // xmm2_8
  int v140; // esi
  double v141; // xmm0_8
  double v142; // xmm6_8
  double v143; // xmm5_8
  double v144; // xmm2_8
  double v145; // xmm4_8
  double v146; // xmm5_8
  __int128 v147; // xmm2
  __int128 v148; // xmm7
  int v149; // ecx
  double *v150; // esi
  __int128 v151; // xmm0
  __int128 v152; // xmm2
  unsigned int v153; // eax
  double v154; // xmm1_8
  __int128 v155; // xmm0
  double v156; // xmm2_8
  int v157; // edx
  unsigned int v158; // eax
  double v159; // xmm3_8
  double v160; // xmm0_8
  __int128 v161; // xmm2
  double v162; // xmm1_8
  __int128 v163; // xmm0
  double v164; // xmm2_8
  unsigned int v165; // eax
  double v166; // xmm0_8
  __int128 v167; // xmm2
  double v168; // xmm1_8
  __int128 v169; // xmm0
  double v170; // xmm0_8
  double v171; // xmm3_8
  double v172; // xmm3_8
  double v173; // xmm1_8
  int v174; // ecx
  double *v175; // edx
  double v176; // xmm2_8
  unsigned int v177; // eax
  double v178; // xmm1_8
  double v179; // xmm2_8
  double v180; // xmm0_8
  double v181; // xmm0_8
  double *v182; // esi
  double v183; // xmm3_8
  double v184; // xmm4_8
  double v185; // xmm1_8
  double v186; // xmm0_8
  double v187; // st7
  double v188; // xmm6_8
  double v189; // xmm7_8
  double v190; // xmm1_8
  double v191; // xmm3_8
  int v192; // ecx
  double v193; // xmm4_8
  double v194; // xmm5_8
  double v195; // xmm1_8
  double v196; // xmm0_8
  double v197; // xmm2_8
  double v198; // xmm0_8
  double v199; // xmm1_8
  double v200; // xmm1_8
  double v201; // xmm3_8
  double v202; // xmm1_8
  double v203; // xmm4_8
  double v204; // xmm5_8
  double v205; // xmm6_8
  double v206; // xmm2_8
  double v207; // xmm2_8
  __int128 v208; // xmm7
  double v209; // xmm6_8
  double v210; // xmm5_8
  double v211; // xmm4_8
  int v212; // ecx
  double *v213; // esi
  __int128 v214; // xmm0
  __int128 v215; // xmm2
  unsigned int v216; // eax
  double v217; // xmm1_8
  __int128 v218; // xmm0
  double v219; // xmm0_8
  __int128 v220; // xmm2
  int v221; // edx
  unsigned int v222; // eax
  double v223; // xmm3_8
  double v224; // xmm1_8
  __int128 v225; // xmm0
  double v226; // xmm0_8
  __int128 v227; // xmm2
  unsigned int v228; // eax
  double v229; // xmm1_8
  __int128 v230; // xmm0
  double v231; // xmm0_8
  double v232; // xmm3_8
  double v233; // xmm1_8
  int v234; // ecx
  double *v235; // edx
  double v236; // xmm2_8
  unsigned int v237; // eax
  double v238; // xmm1_8
  double v239; // xmm2_8
  double v240; // xmm0_8
  double v241; // xmm0_8
  double v242; // xmm4_8
  double v243; // xmm3_8
  double v244; // xmm1_8
  double v245; // xmm7_8
  double v246; // xmm2_8
  char *v247; // edx
  int v248; // ecx
  double v249; // xmm6_8
  double v250; // xmm3_8
  double v251; // xmm5_8
  double v252; // xmm1_8
  double v253; // xmm1_8
  double v254; // xmm6_8
  int v255; // eax
  double v256; // xmm4_8
  double v257; // xmm1_8
  double v258; // xmm7_8
  double v259; // xmm1_8
  double *v260; // edx
  unsigned int v261; // ecx
  __int128 v262; // xmm3
  __int128 v263; // xmm2
  double v264; // xmm1_8
  __int128 v265; // xmm0
  double v266; // xmm2_8
  unsigned int v267; // ecx
  double v268; // xmm2_8
  double v269; // xmm1_8
  __int128 v270; // xmm0
  double v271; // xmm0_8
  unsigned int v272; // ecx
  double v273; // xmm3_8
  double v274; // xmm0_8
  double v275; // xmm2_8
  double v276; // xmm1_8
  double v277; // xmm2_8
  unsigned int v278; // ecx
  double v279; // xmm2_8
  double v280; // xmm1_8
  double v281; // xmm6_8
  unsigned int v282; // ecx
  double v283; // xmm3_8
  double v284; // xmm7_8
  double v285; // xmm2_8
  double v286; // xmm6_8
  double v287; // xmm1_8
  double v288; // xmm4_8
  unsigned int v289; // ecx
  double v290; // xmm4_8
  double v291; // xmm1_8
  double v292; // xmm5_8
  double v293; // xmm3_8
  double v294; // xmm1_8
  double v295; // xmm4_8
  double v296; // xmm2_8
  double v297; // xmm0_8
  int v298; // edx
  double v299; // xmm4_8
  double v300; // xmm7_8
  double v301; // xmm5_8
  int v302; // ecx
  char *v303; // edx
  double v304; // xmm0_8
  double v305; // xmm1_8
  double v306; // xmm0_8
  int v307; // eax
  double *v308; // edx
  unsigned int v309; // ecx
  double v310; // xmm2_8
  double v311; // xmm3_8
  double v312; // xmm1_8
  double v313; // xmm3_8
  unsigned int v314; // ecx
  double v315; // xmm3_8
  double v316; // xmm1_8
  double v317; // xmm5_8
  unsigned int v318; // ecx
  double v319; // xmm1_8
  double v320; // xmm3_8
  double v321; // xmm4_8
  double v322; // xmm5_8
  double v323; // xmm2_8
  double v324; // xmm4_8
  unsigned int v325; // ecx
  double v326; // xmm4_8
  double v327; // xmm2_8
  double v328; // xmm3_8
  double v329; // xmm0_8
  double v330; // xmm1_8
  double v331; // xmm0_8
  double v332; // xmm1_8
  double v333; // xmm1_8
  double v334; // xmm0_8
  double v335; // xmm1_8
  double v336; // xmm1_8
  double v337; // xmm1_8
  double v338; // xmm0_8
  char *result; // eax
  int v340; // [esp+40h] [ebp-460h]
  int v341; // [esp+40h] [ebp-460h]
  int v342; // [esp+40h] [ebp-460h]
  int v343; // [esp+40h] [ebp-460h]
  int v344; // [esp+40h] [ebp-460h]
  int v345; // [esp+40h] [ebp-460h]
  int v346; // [esp+40h] [ebp-460h]
  int v347; // [esp+40h] [ebp-460h]
  int v348; // [esp+40h] [ebp-460h]
  int v349; // [esp+40h] [ebp-460h]
  int v350; // [esp+40h] [ebp-460h]
  int v351; // [esp+40h] [ebp-460h]
  int v352; // [esp+40h] [ebp-460h]
  int v353; // [esp+44h] [ebp-45Ch]
  int v354; // [esp+44h] [ebp-45Ch]
  int v355; // [esp+44h] [ebp-45Ch]
  int v356; // [esp+44h] [ebp-45Ch]
  int v357; // [esp+44h] [ebp-45Ch]
  int v358; // [esp+44h] [ebp-45Ch]
  int v359; // [esp+44h] [ebp-45Ch]
  int v360; // [esp+44h] [ebp-45Ch]
  int v361; // [esp+44h] [ebp-45Ch]
  int v362; // [esp+44h] [ebp-45Ch]
  int v363; // [esp+44h] [ebp-45Ch]
  int v364; // [esp+44h] [ebp-45Ch]
  int v365; // [esp+44h] [ebp-45Ch]
  double v366; // [esp+48h] [ebp-458h]
  double v367; // [esp+48h] [ebp-458h]
  int v368; // [esp+48h] [ebp-458h]
  int v369; // [esp+48h] [ebp-458h]
  int v370; // [esp+48h] [ebp-458h]
  int v371; // [esp+48h] [ebp-458h]
  int v372; // [esp+48h] [ebp-458h]
  int v373; // [esp+48h] [ebp-458h]
  int v374; // [esp+48h] [ebp-458h]
  int v375; // [esp+48h] [ebp-458h]
  int v376; // [esp+48h] [ebp-458h]
  int v377; // [esp+48h] [ebp-458h]
  int v378; // [esp+48h] [ebp-458h]
  int v379; // [esp+48h] [ebp-458h]
  double v380; // [esp+48h] [ebp-458h]
  double v381; // [esp+48h] [ebp-458h]
  int v382; // [esp+4Ch] [ebp-454h]
  int v383; // [esp+4Ch] [ebp-454h]
  int v384; // [esp+4Ch] [ebp-454h]
  int v385; // [esp+4Ch] [ebp-454h]
  int v386; // [esp+4Ch] [ebp-454h]
  int v387; // [esp+4Ch] [ebp-454h]
  int v388; // [esp+4Ch] [ebp-454h]
  int v389; // [esp+4Ch] [ebp-454h]
  int v390; // [esp+4Ch] [ebp-454h]
  int v391; // [esp+4Ch] [ebp-454h]
  int v392; // [esp+4Ch] [ebp-454h]
  int v393; // [esp+4Ch] [ebp-454h]
  double v394; // [esp+58h] [ebp-448h]
  double v395; // [esp+58h] [ebp-448h]
  double v396; // [esp+58h] [ebp-448h]
  int v397; // [esp+64h] [ebp-43Ch]
  unsigned __int64 v398; // [esp+68h] [ebp-438h]
  double v399; // [esp+68h] [ebp-438h]
  double v400; // [esp+68h] [ebp-438h]
  double v401; // [esp+68h] [ebp-438h]
  unsigned __int64 v402; // [esp+70h] [ebp-430h]
  double v403; // [esp+70h] [ebp-430h]
  double v404; // [esp+70h] [ebp-430h]
  double v405; // [esp+70h] [ebp-430h]
  double v406; // [esp+70h] [ebp-430h]
  double v407; // [esp+78h] [ebp-428h]
  double v408; // [esp+78h] [ebp-428h]
  double v409; // [esp+78h] [ebp-428h]
  double v410; // [esp+80h] [ebp-420h]
  double v411; // [esp+80h] [ebp-420h]
  double v412; // [esp+80h] [ebp-420h]
  double v413; // [esp+80h] [ebp-420h]
  double v414; // [esp+88h] [ebp-418h]
  double v415; // [esp+88h] [ebp-418h]
  double v416; // [esp+90h] [ebp-410h]
  double v417; // [esp+90h] [ebp-410h]
  double v418; // [esp+90h] [ebp-410h]
  double v419; // [esp+90h] [ebp-410h]
  int v420; // [esp+9Ch] [ebp-404h]
  int v421; // [esp+9Ch] [ebp-404h]
  double v422; // [esp+A0h] [ebp-400h]
  double v423; // [esp+A0h] [ebp-400h]
  double v424; // [esp+A0h] [ebp-400h]
  double v425; // [esp+A0h] [ebp-400h]
  double v426; // [esp+A8h] [ebp-3F8h]
  double v427; // [esp+A8h] [ebp-3F8h]
  double v428; // [esp+A8h] [ebp-3F8h]
  double v429; // [esp+A8h] [ebp-3F8h]
  double v430; // [esp+B0h] [ebp-3F0h]
  double v431; // [esp+B0h] [ebp-3F0h]
  double v432; // [esp+B0h] [ebp-3F0h]
  double v433; // [esp+B0h] [ebp-3F0h]
  double v434; // [esp+B0h] [ebp-3F0h]
  int v435; // [esp+B8h] [ebp-3E8h]
  double v436; // [esp+B8h] [ebp-3E8h]
  double v437; // [esp+C0h] [ebp-3E0h]
  double v438; // [esp+C8h] [ebp-3D8h]
  double v439; // [esp+C8h] [ebp-3D8h]
  double v440; // [esp+C8h] [ebp-3D8h]
  double v441; // [esp+C8h] [ebp-3D8h]
  double v442; // [esp+C8h] [ebp-3D8h]
  double v443; // [esp+C8h] [ebp-3D8h]
  double v444; // [esp+C8h] [ebp-3D8h]
  double v445; // [esp+D0h] [ebp-3D0h]
  double v446; // [esp+D0h] [ebp-3D0h]
  int v447; // [esp+DCh] [ebp-3C4h]
  double v448; // [esp+E0h] [ebp-3C0h]
  double v449; // [esp+E0h] [ebp-3C0h]
  double v450; // [esp+E0h] [ebp-3C0h]
  double v451; // [esp+E0h] [ebp-3C0h]
  __int64 v452; // [esp+E0h] [ebp-3C0h]
  int v453; // [esp+ECh] [ebp-3B4h]
  int v454; // [esp+ECh] [ebp-3B4h]
  double v455; // [esp+F0h] [ebp-3B0h]
  double v456; // [esp+F0h] [ebp-3B0h]
  double v457; // [esp+F0h] [ebp-3B0h]
  double v458; // [esp+F0h] [ebp-3B0h]
  double v459; // [esp+F8h] [ebp-3A8h]
  double v460; // [esp+F8h] [ebp-3A8h]
  double v461; // [esp+F8h] [ebp-3A8h]
  double v462; // [esp+F8h] [ebp-3A8h]
  double v463; // [esp+F8h] [ebp-3A8h]
  double v464; // [esp+100h] [ebp-3A0h]
  double v465; // [esp+100h] [ebp-3A0h]
  int v466; // [esp+10Ch] [ebp-394h]
  int v467; // [esp+110h] [ebp-390h]
  int v468; // [esp+110h] [ebp-390h]
  double v469; // [esp+110h] [ebp-390h]
  double v470; // [esp+118h] [ebp-388h]
  double v471; // [esp+118h] [ebp-388h]
  double v472; // [esp+120h] [ebp-380h]
  double v473; // [esp+120h] [ebp-380h]
  double v474; // [esp+120h] [ebp-380h]
  double v475; // [esp+128h] [ebp-378h]
  double v476; // [esp+128h] [ebp-378h]
  double v477; // [esp+128h] [ebp-378h]
  double v478; // [esp+130h] [ebp-370h]
  double v479; // [esp+130h] [ebp-370h]
  double v480; // [esp+138h] [ebp-368h]
  double v481; // [esp+138h] [ebp-368h]
  double v482; // [esp+138h] [ebp-368h]
  double v483; // [esp+140h] [ebp-360h]
  double v484; // [esp+148h] [ebp-358h]
  double v485; // [esp+148h] [ebp-358h]
  double v486; // [esp+148h] [ebp-358h]
  double v487; // [esp+148h] [ebp-358h]
  double v488; // [esp+150h] [ebp-350h]
  double v489; // [esp+150h] [ebp-350h]
  double v490; // [esp+150h] [ebp-350h]
  double v491; // [esp+150h] [ebp-350h]
  double v492; // [esp+158h] [ebp-348h] BYREF
  double v493; // [esp+160h] [ebp-340h]
  double v494; // [esp+168h] [ebp-338h]
  double v495; // [esp+170h] [ebp-330h]
  double v496; // [esp+178h] [ebp-328h]
  double v497; // [esp+180h] [ebp-320h]
  double v498; // [esp+188h] [ebp-318h]
  double v499; // [esp+190h] [ebp-310h]
  double v500; // [esp+198h] [ebp-308h]
  double v501; // [esp+1A0h] [ebp-300h]
  double v502; // [esp+1A8h] [ebp-2F8h]
  double v503; // [esp+1B0h] [ebp-2F0h]
  int v504; // [esp+1BCh] [ebp-2E4h]
  double v505; // [esp+1C0h] [ebp-2E0h]
  int v506; // [esp+1CCh] [ebp-2D4h]
  double v507; // [esp+1D0h] [ebp-2D0h]
  double v508; // [esp+1D8h] [ebp-2C8h]
  double v509; // [esp+1E0h] [ebp-2C0h]
  double v510; // [esp+1E8h] [ebp-2B8h]
  double v511; // [esp+1F0h] [ebp-2B0h]
  double v512; // [esp+1F8h] [ebp-2A8h]
  double v513; // [esp+200h] [ebp-2A0h]
  double v514; // [esp+208h] [ebp-298h]
  double v515; // [esp+210h] [ebp-290h]
  double v516; // [esp+218h] [ebp-288h]
  double v517; // [esp+220h] [ebp-280h]
  double v518; // [esp+228h] [ebp-278h]
  double v519; // [esp+230h] [ebp-270h]
  double v520; // [esp+238h] [ebp-268h]
  double v521; // [esp+240h] [ebp-260h]
  double v522; // [esp+248h] [ebp-258h]
  double v523; // [esp+250h] [ebp-250h]
  double v524; // [esp+258h] [ebp-248h]
  unsigned __int64 v525; // [esp+260h] [ebp-240h]
  double v526; // [esp+268h] [ebp-238h]
  double v527; // [esp+270h] [ebp-230h]
  double v528; // [esp+278h] [ebp-228h] BYREF
  double v529; // [esp+280h] [ebp-220h]
  double v530; // [esp+288h] [ebp-218h]
  double v531; // [esp+290h] [ebp-210h]
  double v532; // [esp+298h] [ebp-208h]
  double v533; // [esp+2A0h] [ebp-200h]
  double v534; // [esp+2A8h] [ebp-1F8h]
  double v535; // [esp+2B0h] [ebp-1F0h]
  double v536; // [esp+2B8h] [ebp-1E8h]
  double v537; // [esp+2C0h] [ebp-1E0h] BYREF
  double v538; // [esp+2C8h] [ebp-1D8h]
  double v539; // [esp+2D0h] [ebp-1D0h]
  double v540; // [esp+2D8h] [ebp-1C8h]
  double v541; // [esp+2E0h] [ebp-1C0h]
  double v542; // [esp+2E8h] [ebp-1B8h]
  double v543; // [esp+2F0h] [ebp-1B0h]
  double v544; // [esp+2F8h] [ebp-1A8h]
  double v545; // [esp+300h] [ebp-1A0h]
  double v546; // [esp+308h] [ebp-198h] BYREF
  double v547; // [esp+310h] [ebp-190h]
  double v548; // [esp+318h] [ebp-188h]
  double v549; // [esp+320h] [ebp-180h]
  double v550; // [esp+328h] [ebp-178h]
  double v551; // [esp+330h] [ebp-170h]
  double v552; // [esp+338h] [ebp-168h]
  double v553; // [esp+340h] [ebp-160h]
  double v554; // [esp+348h] [ebp-158h]
  double v555; // [esp+350h] [ebp-150h]
  double v556; // [esp+358h] [ebp-148h]
  double v557; // [esp+360h] [ebp-140h]
  double v558; // [esp+368h] [ebp-138h]
  double v559; // [esp+370h] [ebp-130h]
  double v560; // [esp+378h] [ebp-128h]
  double v561; // [esp+380h] [ebp-120h]
  double v562; // [esp+388h] [ebp-118h]
  double v563; // [esp+390h] [ebp-110h]
  double v564; // [esp+398h] [ebp-108h]
  double v565; // [esp+3A0h] [ebp-100h]
  double v566; // [esp+3A8h] [ebp-F8h]
  double v567; // [esp+3B0h] [ebp-F0h]
  double v568; // [esp+3B8h] [ebp-E8h]
  double v569; // [esp+3C0h] [ebp-E0h]
  double v570; // [esp+3C8h] [ebp-D8h]
  double v571; // [esp+3D0h] [ebp-D0h]
  double v572; // [esp+3D8h] [ebp-C8h]
  double v573; // [esp+3E0h] [ebp-C0h]
  _DWORD v574[40]; // [esp+3E8h] [ebp-B8h] BYREF
  int v575; // [esp+488h] [ebp-18h]
  double v576; // [esp+490h] [ebp-10h]

  v353 = a2;
  v340 = a1;
  *(_QWORD *)(a3 + 24) = 0i64;
  v397 = *(_DWORD *)(a7 + 32);
  sub_405EB0((int)v574, v397, a3 + 24, qword_43E0E8);
  v7 = *(_DWORD *)(a7 + 20);
  v466 = v7;
  v502 = *(double *)(v7 + 56);
  sub_406C30(*(_QWORD *)a3, *(double *)(a3 + 8), *(double *)(a3 + 16), &v492);
  v8 = (int *)(v7 + 48);
  if ( *(_DWORD *)(v7 + 48) < *(_DWORD *)(v7 + 52) )
    v8 = (int *)(v7 + 52);
  v437 = (double)*v8;
  v519 = *(double *)(a3 + 64) * v437;
  sub_406E50(&v492, &v537, (double *)a3);
  sub_407120(&v492, &v546, (double *)a3);
  sub_407400(&v492, &v528, (double *)a3);
  memset(a4, 0, 8 * a6 * a5);
  v9 = 0;
  v10 = *(_DWORD *)(v7 + 24);
  v420 = *(_DWORD *)(v7 + 204);
  v504 = *(_DWORD *)(v7 + 16);
  v11 = v504;
  v506 = v10;
  v447 = 0;
  v453 = 0;
  v12 = v494;
  if ( v504 > 0 )
  {
    v13 = -v519;
    v14 = v494 * v519;
    v15 = 0;
    v16 = (double *)(a4 + 16);
    v467 = 0;
    v17 = v500 * v519;
    v18 = v494 * -v519;
    v414 = v554 * v519;
    v19 = v500 * -v519;
    v464 = -v519;
    v410 = v548 * v519;
    v394 = v18;
    v512 = v494 * v519;
    v416 = v19;
    v514 = v536 * v519;
    v488 = v500 * v519;
    v430 = v530 * v519;
    v438 = v500 * v437;
    v459 = v494 * v437;
    v448 = v545 * v519;
    v484 = v539 * v519;
    v509 = v542 * v519;
    v507 = v551 * v519;
    v526 = v533 * v519;
    v501 = v497 * v437;
    v502 = v502 * -1.0;
    do
    {
      v20 = (double *)(v15 + *(_DWORD *)(v7 + 108));
      v21 = v493 * v20[1];
      v22 = v492 * *v20;
      v20[2] = v13;
      v23 = v22 + v21;
      v24 = v499 * v20[1];
      v25 = v23 + v18;
      v26 = v498 * *v20;
      v503 = v25;
      v455 = v26 + v24 + v19;
      v366 = sub_406A70((int)v574, -4.0, 0.0, -1.0, 1.0e-10, v25, v14, v455, v17);
      v445 = v366 * v503 - v512;
      v27 = sub_4060D0(v574, v576 * v445);
      v28 = v20[1];
      v29 = *v20;
      v30 = v20[2];
      v456 = v455 - v27 * v503;
      v31 = -(((v552 * v29 + v553 * v28 + v554 * v30) * v366
             - v414
             - ((v546 * v29 + v547 * v28 + v548 * v30) * v366 - v410) * v27)
            / v456);
      v422 = -(((v534 * v29 + v535 * v28 + v536 * v30) * v366
              - v514
              - ((v528 * v29 + v529 * v28 + v530 * v30) * v366 - v430) * v27)
             / v456);
      v503 = -((-(v500 * v366 * v437) - v438 - (-(v494 * v366 * v437) - v459) * v27) / v456);
      v32 = -(((v543 * v29 + v544 * v28 + v545 * v30) * v366
             - v448
             - ((v537 * v29 + v538 * v28 + v539 * v30) * v366 - v484) * v27)
            / v456);
      v33 = v495 * v29 + v496 * v28 + v497 * v30;
      v34 = v541 * v28;
      v35 = v366;
      v36 = v32 * v33;
      v37 = v540 * v29 + v34;
      v38 = v542 * v30;
      v39 = v495;
      *(v16 - 2) = v36 + (v37 + v38) * v366 - v509;
      v40 = 1;
      v41 = (v39 * *v20 + v496 * v20[1] + v497 * v20[2]) * v31;
      v42 = v497;
      v43 = v496;
      v44 = v531;
      *(v16 - 1) = v41 + (v549 * *v20 + v550 * v20[1] + v551 * v20[2]) * v366 - v507;
      v45 = v20[2];
      v46 = (v495 * *v20 + v43 * v20[1] + v42 * v45) * v422;
      v47 = v44 * *v20 + v532 * v20[1] + v533 * v45;
      v16[1] = 0.0;
      v48 = v496;
      *v16 = v46 + v47 * v366 - v526;
      v49 = v495 * *v20 + v48 * v20[1] + v20[2] * v42;
      if ( v397 >= 1 )
      {
        v50 = v16 + 2;
        do
        {
          *((_QWORD *)&v51 + 1) = 0i64;
          *(double *)&v51 = v445 * *(double *)&qword_43E0E8;
          v52 = v40;
          if ( v40 < 0 )
            v52 = -v40;
          v53 = 1.0;
          while ( 1 )
          {
            if ( (v52 & 1) != 0 )
              v53 = v53 * *(double *)&v51;
            v52 >>= 1;
            if ( !v52 )
              break;
            *((_QWORD *)&v54 + 1) = *((_QWORD *)&v51 + 1);
            *(double *)&v54 = *(double *)&v51 * *(double *)&v51;
            v51 = v54;
          }
          if ( v40 >= 0 )
            v55 = v53;
          else
            v55 = 1.0 / v53;
          ++v40;
          *v50++ = v55 / *(double *)&qword_43E0E8 / v456 * v49;
        }
        while ( v40 <= v397 );
        v35 = v366;
      }
      v14 = v512;
      v18 = v394;
      v56 = v495 * *v20 + v496 * v20[1] + v20[2] * v42;
      v57 = v42 * v35;
      v19 = v416;
      v17 = v488;
      v58 = v56 * v503 - v57 * v437;
      v59 = v502;
      v16[6] = v58 - v501;
      v13 = v464;
      v60 = *(_DWORD *)(*(_DWORD *)(v466 + 120) + 4 * v453++);
      *(double *)&a4[8 * v420 + 8 * v447 + 8 * v60] = v59;
      v16 += a5;
      v9 = a5 + v447;
      v15 = v467 + 32;
      v7 = v466;
      v447 += a5;
      v467 += 32;
    }
    while ( v453 < v504 );
    v12 = v494;
    v11 = v504;
    v10 = v506;
  }
  v61 = v9 + a5 * v10;
  v62 = 0;
  v421 = v61;
  v454 = 0;
  if ( v506 > 0 )
  {
    v63 = v519;
    v64 = v12 * v519;
    v65 = -v519;
    v66 = v12 * -v519;
    v559 = v500 * v519;
    v67 = v500 * -v519;
    v513 = v539 * v519;
    v68 = v545 * v519;
    v519 = v65;
    v512 = v66;
    v483 = v64;
    v555 = v68;
    v503 = v500 * v65;
    v518 = v548 * v63;
    v563 = v554 * v63;
    v511 = v530 * v63;
    v556 = v536 * v63;
    v517 = v494 * v437;
    v560 = v500 * v437;
    v562 = v542 * v63;
    v564 = v551 * v63;
    v557 = v533 * v63;
    v558 = v497 * v437;
    v561 = v497 * v63;
    do
    {
      v69 = v62 + v11 + 2 * v62;
      v70 = (double *)(32 * v69 + *(_DWORD *)(v7 + 108));
      v468 = 32 * v69;
      LODWORD(v505) = v70;
      v71 = v70[1];
      v70[2] = v65;
      v72 = *v70;
      v501 = *v70 * v492 + v71 * v493 + v66;
      v502 = v72 * v498 + v71 * v499 + v67;
      v73 = sub_406A70((int)v574, -4.0, 0.0, -1.0, 1.0e-10, v501, v64, v502, v559);
      v74 = v70[1];
      v75 = v70[2];
      v431 = (v537 * *v70 + v538 * v74 + v539 * v75) * v73;
      v76 = (*v70 * v543 + v74 * v544 + v75 * v545) * v73 - v555;
      v439 = (v546 * *v70 + v547 * v74 + v548 * v75) * v73;
      v77 = v575 - 1;
      v78 = (*v70 * v552 + v74 * v553 + v75 * v554) * v73 - v563;
      v460 = (v528 * *v70 + v529 * v74 + v530 * v75) * v73;
      v79 = 0.0;
      v80 = (*v70 * v534 + v74 * v535 + v75 * v536) * v73 - v556;
      v514 = -(v494 * v73 * v437) - v517;
      v81 = v73 * v501 - v483;
      *(double *)&v525 = v81;
      if ( v575 - 1 >= 0 )
      {
        if ( v575 >= 4 )
        {
          do
          {
            v79 = (((v79 * (v576 * *(double *)&v525) + *(double *)&v574[2 * v77 + 20]) * (v576 * *(double *)&v525)
                  + *(double *)&v574[2 * v77 + 18])
                 * (v576
                  * *(double *)&v525)
                 + *(double *)&v574[2 * v77 + 16])
                * (v576
                 * *(double *)&v525)
                + *(double *)&v574[2 * v77 + 14];
            v77 -= 4;
          }
          while ( v77 >= 3 );
          v81 = *(double *)&v525;
        }
        for ( ; v77 >= 0; --v77 )
          v79 = v79 * (v576 * v81) + *(double *)&v574[2 * v77 + 20];
      }
      v502 = v502 - v79 * v501;
      v82 = -((v76 - v79 * (v431 - v513)) / v502);
      v83 = -((v78 - v79 * (v439 - v518)) / v502);
      v84 = -((v80 - v79 * (v460 - v511)) / v502);
      v85 = -((-(v500 * v73 * v437) - v560 - v79 * v514) / v502);
      *(double *)&v402 = *v70 * v492 + v74 * v493 + v70[2] * v494;
      v411 = *(double *)&v402 * v82 + v431 - v513;
      v432 = *(double *)&v402 * v83 + v439 - v518;
      v86 = *(double *)&v402 * v84 + v460 - v511;
      v461 = *(double *)&v402 * v85 - v494 * v73 * v437 - v517;
      v440 = v86;
      v407 = v495 * *v70 + v496 * v74 + v497 * v70[2];
      v478 = (v540 * *v70 + v541 * v74 + v542 * v70[2]) * v73 + v407 * v82 - v562;
      v367 = (v549 * *v70 + v550 * v74 + v551 * v70[2]) * v73 + v407 * v83 - v564;
      v87 = v407 * v85;
      v88 = v531 * *v70 + v532 * v70[1];
      v89 = v533 * v70[2];
      v90 = v397;
      v91 = (v88 + v89) * v73 + v407 * v84;
      v408 = v407 * v73 - v561;
      v516 = v91 - v557;
      v95 = v402;
      v92 = 0.0;
      v93 = 0.0;
      v94 = 0.0;
      *(double *)&v95 = *(double *)&v402 * v73 - v483;
      v501 = v87 - v497 * v73 * v437 - v558;
      v403 = *(double *)&v95;
      if ( v397 >= 1 )
      {
        *((_QWORD *)&v96 + 1) = *((_QWORD *)&v95 + 1);
        *(double *)&v96 = *(double *)&v95 * *(double *)&qword_43E0E8;
        *((_QWORD *)&v99 + 1) = 0i64;
        v97 = 0;
        v98 = (double *)(a3 + 32);
        *(double *)&v99 = *(double *)&qword_43E0E8 * 0.0;
        v423 = *(double *)&v95 * *(double *)&qword_43E0E8 * 0.5;
        do
        {
          v100 = v99;
          v101 = v97;
          if ( v97 < 0 )
            v101 = -v97;
          v102 = 1.0;
          while ( 1 )
          {
            if ( (v101 & 1) != 0 )
              v102 = v102 * *(double *)&v100;
            v101 >>= 1;
            if ( !v101 )
              break;
            *((_QWORD *)&v103 + 1) = *((_QWORD *)&v100 + 1);
            *(double *)&v103 = *(double *)&v100 * *(double *)&v100;
            v100 = v103;
          }
          if ( v97 >= 0 )
            v104 = v102;
          else
            v104 = 1.0 / v102;
          v105 = *(unsigned __int64 *)&v423;
          v106 = v97 + 1;
          v107 = v97;
          v108 = (double)(v97 + 1) * *v98;
          v93 = v104 * v108 + v93;
          if ( v97 < 0 )
            v107 = -v97;
          v109 = 1.0;
          while ( 1 )
          {
            if ( (v107 & 1) != 0 )
              v109 = v109 * *(double *)&v105;
            v107 >>= 1;
            if ( !v107 )
              break;
            *((_QWORD *)&v110 + 1) = *((_QWORD *)&v105 + 1);
            *(double *)&v110 = *(double *)&v105 * *(double *)&v105;
            v105 = v110;
          }
          if ( v97 >= 0 )
            v111 = v109;
          else
            v111 = 1.0 / v109;
          v112 = v96;
          v113 = v97;
          v92 = v111 * v108 + v92;
          if ( v97 < 0 )
            v113 = -v97;
          v114 = 1.0;
          while ( 1 )
          {
            if ( (v113 & 1) != 0 )
              v114 = v114 * *(double *)&v112;
            v113 >>= 1;
            if ( !v113 )
              break;
            *((_QWORD *)&v115 + 1) = *((_QWORD *)&v112 + 1);
            *(double *)&v115 = *(double *)&v112 * *(double *)&v112;
            v112 = v115;
          }
          if ( v97 >= 0 )
            v116 = v114;
          else
            v116 = 1.0 / v114;
          v99 = COERCE_UNSIGNED_INT64(*(double *)&qword_43E0E8 * 0.0);
          ++v97;
          ++v98;
          v94 = v116 * v108 + v94;
        }
        while ( v106 + 1 <= v397 );
        v90 = v397;
      }
      v472 = *(double *)libm_sse2_sqrt_precise(v340, v353, LODWORD(v367), HIDWORD(v367)).m128_u64 * 4.0;
      v473 = v472 + *(double *)libm_sse2_sqrt_precise(v341, v354, v368, v382).m128_u64;
      v117 = 0.0;
      v474 = (v473 + *(double *)libm_sse2_sqrt_precise(v342, v355, v369, v383).m128_u64) * (v403 / 6.0);
      if ( v90 >= 1 )
      {
        v118 = v403 * *(double *)&qword_43E0E8;
        v119 = 0;
        v120 = (double *)(a3 + 32);
        v404 = v403 * *(double *)&qword_43E0E8;
        do
        {
          v121 = v118;
          v122 = v119;
          if ( v119 < 0 )
            v122 = -v119;
          v123 = 1.0;
          while ( 1 )
          {
            if ( (v122 & 1) != 0 )
              v123 = v123 * v121;
            v122 >>= 1;
            if ( !v122 )
              break;
            v121 = v121 * v121;
          }
          if ( v119 >= 0 )
            v124 = v123;
          else
            v124 = 1.0 / v123;
          v118 = v404;
          v125 = (double)++v119 * *v120++;
          v117 = v117 + v125 * v124;
        }
        while ( v119 + 1 <= v90 );
      }
      v514 = *(double *)libm_sse2_sqrt_precise(v343, v356, v370, v384).m128_u64;
      v435 = *(_DWORD *)(v466 + 108);
      v526 = v514 * v411;
      v126 = *(double *)(v468 + v435 + 32);
      v127 = v126 * v498;
      v507 = v514 * v432;
      v128 = v126 * v492;
      v509 = v514 * v440;
      v129 = *(double *)(v468 + v435 + 40);
      v462 = v514 * v461;
      *(double *)(v468 + v435 + 48) = v519;
      v395 = v128 + v129 * v493 + v512;
      v457 = v127 + v129 * v499 + v503;
      v130 = sub_406A70((int)v574, -4.0, 0.0, -1.0, 1.0e-10, v395, v483, v457, v559);
      v131 = *(double *)(v468 + v435 + 40);
      v405 = *(double *)(v468 + v435 + 32);
      v441 = *(double *)(v468 + v435 + 48);
      v449 = (v405 * v537 + v131 * v538 + v441 * v539) * v130;
      v132 = v575 - 1;
      v485 = (v405 * v546 + v131 * v547 + v441 * v548) * v130;
      v417 = (v405 * v528 + v131 * v529 + v441 * v530) * v130;
      v133 = 0.0;
      v134 = v130 * v395 - v483;
      v465 = v134;
      if ( v575 - 1 >= 0 )
      {
        if ( v575 >= 4 )
        {
          do
          {
            v133 = (((v133 * (v576 * v134) + *(double *)&v574[2 * v132 + 20]) * (v576 * v134)
                   + *(double *)&v574[2 * v132 + 18])
                  * (v576
                   * v134)
                  + *(double *)&v574[2 * v132 + 16])
                 * (v576
                  * v134)
                 + *(double *)&v574[2 * v132 + 14];
            v132 -= 4;
          }
          while ( v132 >= 3 );
          v134 = v130 * v395 - v483;
        }
        for ( ; v132 >= 0; --v132 )
          v133 = v133 * (v576 * v134) + *(double *)&v574[2 * v132 + 20];
      }
      v458 = v457 - v133 * v395;
      v135 = -(((v405 * v543 + v131 * v544 + v441 * v545) * v130 - v555 - v133 * (v449 - v513)) / v458);
      v136 = -(((v405 * v552 + v131 * v553 + v441 * v554) * v130 - v563 - v133 * (v485 - v518)) / v458);
      v137 = -(((v405 * v534 + v131 * v535 + v441 * v536) * v130 - v556 - v133 * (v417 - v511)) / v458);
      v138 = -((-(v500 * v130 * v437) - v560 - v133 * (-(v494 * v130 * v437) - v517)) / v458);
      v139 = *(double *)(v468 + v435 + 48);
      *(double *)&v398 = v405 * v492 + v131 * v493 + v441 * v494;
      v412 = *(double *)&v398 * v135 + v449 - v513;
      v433 = *(double *)&v398 * v136 + v485 - v518;
      v450 = *(double *)&v398 * v138 - v494 * v130 * v437 - v517;
      v442 = *(double *)&v398 * v137 + v417 - v511;
      v470 = v405 * v495 + v131 * v496 + v139 * v497;
      v140 = v397;
      v510 = (v405 * v540 + v131 * v541 + v139 * v542) * v130 + v470 * v135 - v562;
      v522 = (v405 * v549 + v131 * v550 + v139 * v551) * v130;
      v141 = v470 * v137;
      v522 = v522 + v470 * v136 - v564;
      v142 = 0.0;
      v143 = v405 * v531 + v131 * v532 + v139 * v533;
      v144 = v470 * v138;
      v471 = v470 * v130 - v561;
      v145 = 0.0;
      v406 = v143 * v130 + v141 - v557;
      v146 = 0.0;
      v446 = v144 - v130 * v497 * v437 - v558;
      v147 = v398;
      *(double *)&v147 = *(double *)&v398 * v130 - v483;
      v399 = *(double *)&v147;
      if ( v397 >= 1 )
      {
        *((_QWORD *)&v148 + 1) = *((_QWORD *)&v147 + 1);
        *(double *)&v148 = *(double *)&v147 * *(double *)&qword_43E0E8;
        *((_QWORD *)&v151 + 1) = 0i64;
        v149 = 0;
        v150 = (double *)(a3 + 32);
        *(double *)&v151 = *(double *)&qword_43E0E8 * 0.0;
        v424 = *(double *)&v147 * *(double *)&qword_43E0E8 * 0.5;
        do
        {
          v152 = v151;
          v153 = v149;
          if ( v149 < 0 )
            v153 = -v149;
          v154 = 1.0;
          while ( 1 )
          {
            if ( (v153 & 1) != 0 )
              v154 = v154 * *(double *)&v152;
            v153 >>= 1;
            if ( !v153 )
              break;
            *((_QWORD *)&v155 + 1) = *((_QWORD *)&v152 + 1);
            *(double *)&v155 = *(double *)&v152 * *(double *)&v152;
            v152 = v155;
          }
          if ( v149 >= 0 )
            v156 = v154;
          else
            v156 = 1.0 / v154;
          v157 = v149 + 1;
          v158 = v149;
          v159 = (double)(v149 + 1) * *v150;
          v160 = v159 * v156;
          v161 = *(unsigned __int64 *)&v424;
          v142 = v160 + v142;
          if ( v149 < 0 )
            v158 = -v149;
          v162 = 1.0;
          while ( 1 )
          {
            if ( (v158 & 1) != 0 )
              v162 = v162 * *(double *)&v161;
            v158 >>= 1;
            if ( !v158 )
              break;
            *((_QWORD *)&v163 + 1) = *((_QWORD *)&v161 + 1);
            *(double *)&v163 = *(double *)&v161 * *(double *)&v161;
            v161 = v163;
          }
          if ( v149 >= 0 )
            v164 = v162;
          else
            v164 = 1.0 / v162;
          v165 = v149;
          v166 = v159 * v164;
          v167 = v148;
          v146 = v166 + v146;
          if ( v149 < 0 )
            v165 = -v149;
          v168 = 1.0;
          while ( 1 )
          {
            if ( (v165 & 1) != 0 )
              v168 = v168 * *(double *)&v167;
            v165 >>= 1;
            if ( !v165 )
              break;
            *((_QWORD *)&v169 + 1) = *((_QWORD *)&v167 + 1);
            *(double *)&v169 = *(double *)&v167 * *(double *)&v167;
            v167 = v169;
          }
          if ( v149 >= 0 )
            v170 = v168;
          else
            v170 = 1.0 / v168;
          ++v149;
          v171 = v159 * v170;
          ++v150;
          v151 = COERCE_UNSIGNED_INT64(*(double *)&qword_43E0E8 * 0.0);
          v145 = v145 + v171;
        }
        while ( v157 + 1 <= v397 );
        v140 = v397;
      }
      v480 = *(double *)libm_sse2_sqrt_precise(v344, v357, v371, v385).m128_u64 * 4.0;
      v481 = v480 + *(double *)libm_sse2_sqrt_precise(v345, v358, v372, v386).m128_u64;
      v172 = 0.0;
      v482 = (v481 + *(double *)libm_sse2_sqrt_precise(v346, v359, v373, v387).m128_u64) * (v399 / 6.0);
      if ( v140 >= 1 )
      {
        v173 = v399 * *(double *)&qword_43E0E8;
        v174 = 0;
        v175 = (double *)(a3 + 32);
        v400 = v399 * *(double *)&qword_43E0E8;
        do
        {
          v176 = v173;
          v177 = v174;
          if ( v174 < 0 )
            v177 = -v174;
          v178 = 1.0;
          while ( 1 )
          {
            if ( (v177 & 1) != 0 )
              v178 = v178 * v176;
            v177 >>= 1;
            if ( !v177 )
              break;
            v176 = v176 * v176;
          }
          if ( v174 >= 0 )
            v179 = v178;
          else
            v179 = 1.0 / v178;
          v173 = v400;
          v180 = (double)++v174 * *v175++;
          v172 = v172 + v180 * v179;
        }
        while ( v174 + 1 <= v140 );
      }
      v181 = *(double *)libm_sse2_sqrt_precise(v347, v360, v374, v388).m128_u64;
      v182 = (double *)(*(_DWORD *)(v466 + 108) + 32 * (v69 + 2));
      v425 = v181;
      v572 = v181 * v412;
      v183 = v492 * *v182;
      v184 = v498 * *v182;
      v566 = v181 * v433;
      v185 = v181 * v442;
      v521 = v181 * v450;
      v182[2] = v519;
      v186 = v493 * v182[1];
      v568 = v185;
      v418 = v183 + v186 + v512;
      v508 = v184 + v499 * v182[1] + v503;
      v187 = sub_406A70((int)v574, -4.0, 0.0, -1.0, 1.0e-10, v418, v483, v508, v559);
      v188 = v182[1];
      v189 = *v182;
      v190 = v182[2];
      v443 = (v537 * *v182 + v538 * v188 + v539 * v190) * v187;
      v191 = (v543 * *v182 + v544 * v188 + v545 * v190) * v187 - v555;
      v192 = v575 - 1;
      v489 = (v546 * *v182 + v547 * v188 + v548 * v190) * v187;
      v193 = (v552 * *v182 + v553 * v188 + v554 * v190) * v187 - v563;
      v426 = (v528 * *v182 + v529 * v188 + v530 * v190) * v187;
      v194 = (v534 * *v182 + v535 * v188 + v536 * v190) * v187 - v556;
      v195 = v187 * v418 - v483;
      v520 = v187 * v494 * v437;
      v196 = -v520 - v517;
      v515 = -(v187 * v500 * v437) - v560;
      v197 = 0.0;
      v486 = v195;
      if ( v575 - 1 >= 0 )
      {
        v198 = v576;
        if ( v575 >= 4 )
        {
          v199 = v195 * v576;
          do
          {
            v197 = (((v197 * v199 + *(double *)&v574[2 * v192 + 20]) * v199 + *(double *)&v574[2 * v192 + 18]) * v199
                  + *(double *)&v574[2 * v192 + 16])
                 * v199
                 + *(double *)&v574[2 * v192 + 14];
            v192 -= 4;
          }
          while ( v192 >= 3 );
          v198 = v576;
          v195 = v187 * v418 - v483;
        }
        if ( v192 >= 0 )
        {
          v200 = v195 * v198;
          do
            v197 = v197 * v200 + *(double *)&v574[2 * v192-- + 20];
          while ( v192 >= 0 );
        }
        v196 = -(v187 * v494 * v437) - v517;
      }
      v508 = v508 - v418 * v197;
      v201 = -((v191 - (v443 - v513) * v197) / v508);
      v202 = v182[2];
      v203 = -((v193 - (v489 - v518) * v197) / v508);
      v515 = -((v515 - v196 * v197) / v508);
      v204 = -((v194 - (v426 - v511) * v197) / v508);
      v205 = v182[1];
      v206 = v492 * v189 + v493 * v205 + v494 * v202;
      v451 = v206;
      v570 = v201 * v206 + v443 - v513;
      v567 = v203 * v206 + v489 - v518;
      v569 = v204 * v206 + v426 - v511;
      v490 = v515 * v206 - v520 - v517;
      v527 = v495 * v189 + v496 * v205 + v497 * v202;
      v565 = (v540 * v189 + v541 * v205 + v542 * v202) * v187 + v201 * v527 - v562;
      v571 = (v549 * v189 + v550 * v205 + v551 * v202) * v187 + v203 * v527 - v564;
      v207 = v531 * v189;
      v208 = *(unsigned __int64 *)&v187;
      v401 = v187 * v527 - v561;
      v573 = (v207 + v532 * v205 + v533 * v202) * v187 + v204 * v527 - v557;
      v515 = v515 * v527 - v187 * v497 * v437 - v558;
      v209 = 0.0;
      v210 = 0.0;
      v211 = 0.0;
      if ( v397 >= 1 )
      {
        *((_QWORD *)&v214 + 1) = 0i64;
        *(double *)&v208 = (v187 * v451 - v483) * *(double *)&qword_43E0E8;
        v212 = 0;
        v213 = (double *)(a3 + 32);
        *(double *)&v214 = *(double *)&qword_43E0E8 * 0.0;
        do
        {
          v215 = v214;
          v216 = v212;
          if ( v212 < 0 )
            v216 = -v212;
          v217 = 1.0;
          while ( 1 )
          {
            if ( (v216 & 1) != 0 )
              v217 = v217 * *(double *)&v215;
            v216 >>= 1;
            if ( !v216 )
              break;
            *((_QWORD *)&v218 + 1) = *((_QWORD *)&v215 + 1);
            *(double *)&v218 = *(double *)&v215 * *(double *)&v215;
            v215 = v218;
          }
          if ( v212 >= 0 )
            v219 = v217;
          else
            v219 = 1.0 / v217;
          v220 = COERCE_UNSIGNED_INT64(*(double *)&v208 * 0.5);
          v221 = v212 + 1;
          v222 = v212;
          v223 = (double)(v212 + 1) * *v213;
          v209 = v219 * v223 + v209;
          if ( v212 < 0 )
            v222 = -v212;
          v224 = 1.0;
          while ( 1 )
          {
            if ( (v222 & 1) != 0 )
              v224 = v224 * *(double *)&v220;
            v222 >>= 1;
            if ( !v222 )
              break;
            *((_QWORD *)&v225 + 1) = *((_QWORD *)&v220 + 1);
            *(double *)&v225 = *(double *)&v220 * *(double *)&v220;
            v220 = v225;
          }
          if ( v212 >= 0 )
            v226 = v224;
          else
            v226 = 1.0 / v224;
          v227 = v208;
          v228 = v212;
          v210 = v226 * v223 + v210;
          if ( v212 < 0 )
            v228 = -v212;
          v229 = 1.0;
          while ( 1 )
          {
            if ( (v228 & 1) != 0 )
              v229 = v229 * *(double *)&v227;
            v228 >>= 1;
            if ( !v228 )
              break;
            *((_QWORD *)&v230 + 1) = *((_QWORD *)&v227 + 1);
            *(double *)&v230 = *(double *)&v227 * *(double *)&v227;
            v227 = v230;
          }
          if ( v212 >= 0 )
            v231 = v229;
          else
            v231 = 1.0 / v229;
          ++v212;
          ++v213;
          v211 = v211 + v231 * v223;
          v214 = COERCE_UNSIGNED_INT64(*(double *)&qword_43E0E8 * 0.0);
        }
        while ( v221 + 1 <= v397 );
      }
      v475 = *(double *)libm_sse2_sqrt_precise(v348, v361, v375, v389).m128_u64 * 4.0;
      v476 = v475 + *(double *)libm_sse2_sqrt_precise(v349, v362, v376, v390).m128_u64;
      v232 = 0.0;
      v427 = v187 * v451 - v483;
      v477 = (v476 + *(double *)libm_sse2_sqrt_precise(v350, v363, v377, v391).m128_u64) * (v427 / 6.0);
      if ( v397 >= 1 )
      {
        v233 = v427 * *(double *)&qword_43E0E8;
        v234 = 0;
        v235 = (double *)(a3 + 32);
        v428 = v427 * *(double *)&qword_43E0E8;
        do
        {
          v236 = v233;
          v237 = v234;
          if ( v234 < 0 )
            v237 = -v234;
          v238 = 1.0;
          while ( 1 )
          {
            if ( (v237 & 1) != 0 )
              v238 = v238 * v236;
            v237 >>= 1;
            if ( !v237 )
              break;
            v236 = v236 * v236;
          }
          if ( v234 >= 0 )
            v239 = v238;
          else
            v239 = 1.0 / v238;
          v233 = v428;
          v240 = (double)++v234 * *v235++;
          v232 = v232 + v240 * v239;
        }
        while ( v234 + 1 <= v397 );
      }
      v241 = *(double *)libm_sse2_sqrt_precise(v351, v364, v378, v392).m128_u64;
      v242 = *(double *)LODWORD(v505) * v492;
      v523 = v241;
      v491 = v490 * v241;
      v444 = v242 + *(double *)(LODWORD(v505) + 8) * v493 + *(double *)(LODWORD(v505) + 16) * v494;
      v243 = *(double *)(v468 + v435 + 32);
      v244 = *(double *)(v468 + v435 + 48);
      v434 = v495 * *(double *)LODWORD(v505)
           + v496 * *(double *)(LODWORD(v505) + 8)
           + v497 * *(double *)(LODWORD(v505) + 16);
      v413 = v243 * v492 + *(double *)(v468 + v435 + 40) * v493 + v244 * v494;
      v415 = v243 * v495 + *(double *)(v468 + v435 + 40) * v496 + v244 * v497;
      v524 = v471 - v408;
      v436 = v474 - v482;
      v520 = v482 * v408 - v471 * v474 + (v471 - v408) * v477 + v401 * (v474 - v482);
      v469 = *(double *)libm_sse2_sqrt_precise(v352, v365, v379, v393).m128_u64;
      v429 = v526 - v572;
      v245 = v568;
      v7 = v466;
      v246 = v522 - v380;
      v419 = v507 - v566;
      v247 = a4;
      v248 = v447;
      v249 = v566 * v408;
      v396 = v509 - v568;
      v505 = v469 * v469;
      v250 = v406 - v516;
      v251 = v524;
      v252 = v567 * v523 * v524 + (v522 - v380) * v477;
      *(double *)&a4[8 * v447] = ((v570 * v523 * v524
                                 + (v510 - v478) * v477
                                 + v401 * (v526 - v572)
                                 + v565 * (v474 - v482)
                                 + v572 * v408
                                 + v482 * v478
                                 - v471 * v526
                                 - v510 * v474)
                                * v469
                                - ((v526 - v572) * (v474 - v482) + (v510 - v478) * v524) / v469 * v520)
                               * *(double *)(v466 + 80)
                               / (v469
                                * v469);
      v253 = v252 + v401 * v419 + v571 * (v474 - v482) + v249 + v482 * v380 - v471 * v507 - v522 * v474;
      v254 = v469;
      v255 = 1;
      v256 = v520;
      *(double *)&a4[8 * v447 + 8] = (v253 * v469 - (v419 * (v474 - v482) + v246 * v251) / v469 * v520)
                                   * *(double *)(v466 + 80)
                                   / v505;
      v257 = v569 * v523 * v251
           + v250 * v477
           + v401 * v396
           + v573 * (v474 - v482)
           + v245 * v408
           + v482 * v516
           - v471 * v509
           - v406 * v474;
      v258 = v474 - v482;
      v259 = (v257 * v254 - (v396 * (v474 - v482) + v250 * v251) / v254 * v256) * *(double *)(v466 + 80);
      *(_QWORD *)&a4[8 * v447 + 24] = 0i64;
      *(double *)&a4[8 * v447 + 16] = v259 / v505;
      if ( v397 >= 1 )
      {
        v260 = (double *)&a4[8 * v447 + 32];
        do
        {
          v262 = v525;
          v261 = v255;
          *(double *)&v262 = *(double *)&v525 * *(double *)&qword_43E0E8;
          v263 = v262;
          if ( v255 < 0 )
            v261 = -v255;
          v264 = 1.0;
          while ( 1 )
          {
            if ( (v261 & 1) != 0 )
              v264 = v264 * *(double *)&v263;
            v261 >>= 1;
            if ( !v261 )
              break;
            *((_QWORD *)&v265 + 1) = *((_QWORD *)&v263 + 1);
            *(double *)&v265 = *(double *)&v263 * *(double *)&v263;
            v263 = v265;
          }
          if ( v255 >= 0 )
            v266 = v264;
          else
            v266 = 1.0 / v264;
          v267 = v255;
          v268 = v266 / *(double *)&qword_43E0E8 / v502 * v444;
          if ( v255 < 0 )
            v267 = -v255;
          v269 = 1.0;
          while ( 1 )
          {
            if ( (v267 & 1) != 0 )
              v269 = v269 * *(double *)&v262;
            v267 >>= 1;
            if ( !v267 )
              break;
            *((_QWORD *)&v270 + 1) = *((_QWORD *)&v262 + 1);
            *(double *)&v270 = *(double *)&v262 * *(double *)&v262;
            v262 = v270;
          }
          if ( v255 >= 0 )
            v271 = v269;
          else
            v271 = 1.0 / v269;
          v272 = v255;
          v273 = v465 * *(double *)&qword_43E0E8;
          v509 = v271 / *(double *)&qword_43E0E8 / v502 * v434;
          v274 = v514 * v268;
          v275 = v465 * *(double *)&qword_43E0E8;
          v507 = v274;
          if ( v255 < 0 )
            v272 = -v255;
          v276 = 1.0;
          while ( 1 )
          {
            if ( (v272 & 1) != 0 )
              v276 = v276 * v275;
            v272 >>= 1;
            if ( !v272 )
              break;
            v275 = v275 * v275;
          }
          if ( v255 >= 0 )
            v277 = v276;
          else
            v277 = 1.0 / v276;
          v278 = v255;
          v279 = v277 / *(double *)&qword_43E0E8 / v458 * v413;
          if ( v255 < 0 )
            v278 = -v255;
          v280 = 1.0;
          while ( 1 )
          {
            if ( (v278 & 1) != 0 )
              v280 = v280 * v273;
            v278 >>= 1;
            if ( !v278 )
              break;
            v273 = v273 * v273;
          }
          if ( v255 >= 0 )
            v281 = v280;
          else
            v281 = 1.0 / v280;
          v282 = v255;
          v283 = v486 * *(double *)&qword_43E0E8;
          v284 = v425 * v279;
          v285 = v486 * *(double *)&qword_43E0E8;
          v286 = v281 / *(double *)&qword_43E0E8 / v458 * v415;
          if ( v255 < 0 )
            v282 = -v255;
          v287 = 1.0;
          while ( 1 )
          {
            if ( (v282 & 1) != 0 )
              v287 = v287 * v285;
            v282 >>= 1;
            if ( !v282 )
              break;
            v285 = v285 * v285;
          }
          if ( v255 >= 0 )
            v288 = v287;
          else
            v288 = 1.0 / v287;
          v289 = v255;
          v290 = v288 / *(double *)&qword_43E0E8 / v508 * v451;
          if ( v255 < 0 )
            v289 = -v255;
          v291 = 1.0;
          while ( 1 )
          {
            if ( (v289 & 1) != 0 )
              v291 = v291 * v283;
            v289 >>= 1;
            if ( !v289 )
              break;
            v283 = v283 * v283;
          }
          if ( v255 >= 0 )
            v292 = v291;
          else
            v292 = 1.0 / v291;
          ++v255;
          v293 = v507 - v284;
          v294 = v408 * v284;
          v258 = v474 - v482;
          v295 = v290 * v523 * v524
               + (v286 - v509) * v477
               + v401 * v293
               + v292 / *(double *)&qword_43E0E8 / v508 * v527 * v436;
          v251 = v524;
          v296 = (v286 - v509) * v524;
          v297 = v474 * v286;
          v254 = v469;
          *v260++ = ((v295 + v294 + v482 * v509 - v471 * v507 - v297) * v469 - (v293 * v436 + v296) / v469 * v520)
                  * *(double *)(v466 + 80)
                  / v505;
        }
        while ( v255 <= v397 );
        v256 = v520;
        v247 = a4;
        v248 = v447;
      }
      v487 = v462 - v521;
      v521 = v521 * v408 + v482 * v501 - v471 * v462 - v446 * v474;
      v521 = v521 + (v446 - v501) * v477 + v251 * v491 + v401 * v487 + v515 * v258;
      *(double *)&v247[8 * v248 + 64] = (v521 * v254 - (v487 * v258 + (v446 - v501) * v251) / v254 * v256)
                                      * *(double *)(v466 + 80)
                                      / v505;
      v298 = v454;
      v447 = a5 + v248;
      if ( *(_BYTE *)(*(_DWORD *)(v466 + 192) + 40 * v454 + 32) == 1 )
      {
        v479 = v478 - v510;
        v463 = fabs(v258);
        v409 = v408 - v471;
        v381 = v380 - v522;
        v516 = v516 - v406;
        v452 = *(_QWORD *)&v409 & 0x7FFFFFFFFFFFFFFFi64;
        if ( v463 <= COERCE_DOUBLE(*(_QWORD *)&v409 & 0x7FFFFFFFFFFFFFFFi64) )
        {
          v301 = v409;
          v300 = *(double *)libm_sse2_pow_precise().m128_u64;
          v299 = v474 - v482;
          v302 = v421;
          v303 = a4;
          *(double *)&a4[8 * v421] = (v429 * v409 - v479 * v436) * (*(double *)(v466 + 72) * v409) / v300;
          v306 = v516 * v436;
          *(double *)&a4[8 * v421 + 8] = (v419 * v409 - v381 * v436) * (*(double *)(v466 + 72) * v409) / v300;
          v305 = (v396 * v301 - v306) * (*(double *)(v466 + 72) * v301);
        }
        else
        {
          v299 = v474 - v482;
          v300 = *(double *)libm_sse2_pow_precise().m128_u64;
          v301 = v409;
          v302 = v421;
          v303 = a4;
          *(double *)&a4[8 * v421] = (v429 * v409 - v479 * v436) * (*(double *)(v466 + 72) * v436) * -1.0 / v300;
          v304 = v516 * v436;
          *(double *)&a4[8 * v421 + 8] = (v419 * v409 - v381 * v436) * (*(double *)(v466 + 72) * v436) * -1.0 / v300;
          v305 = (v396 * v409 - v304) * (*(double *)(v466 + 72) * v436) * -1.0;
        }
        v307 = 1;
        *(double *)&v303[8 * v302 + 16] = v305 / v300;
        *(_QWORD *)&v303[8 * v302 + 24] = 0i64;
        if ( v397 >= 1 )
        {
          v308 = (double *)&v303[8 * v302 + 32];
          do
          {
            v309 = v307;
            v310 = *(double *)&v525 * *(double *)&qword_43E0E8;
            v311 = *(double *)&v525 * *(double *)&qword_43E0E8;
            if ( v307 < 0 )
              v309 = -v307;
            v312 = 1.0;
            while ( 1 )
            {
              if ( (v309 & 1) != 0 )
                v312 = v312 * v311;
              v309 >>= 1;
              if ( !v309 )
                break;
              v311 = v311 * v311;
            }
            if ( v307 >= 0 )
              v313 = v312;
            else
              v313 = 1.0 / v312;
            v314 = v307;
            v315 = v313 / *(double *)&qword_43E0E8 / v502 * v444;
            if ( v307 < 0 )
              v314 = -v307;
            v316 = 1.0;
            while ( 1 )
            {
              if ( (v314 & 1) != 0 )
                v316 = v316 * v310;
              v314 >>= 1;
              if ( !v314 )
                break;
              v310 = v310 * v310;
            }
            if ( v307 >= 0 )
              v317 = v316;
            else
              v317 = 1.0 / v316;
            v318 = v307;
            v319 = v514 * v315;
            v320 = v465 * *(double *)&qword_43E0E8;
            v321 = v465 * *(double *)&qword_43E0E8;
            v322 = v317 / *(double *)&qword_43E0E8 / v502 * v434;
            if ( v307 < 0 )
              v318 = -v307;
            v323 = 1.0;
            while ( 1 )
            {
              if ( (v318 & 1) != 0 )
                v323 = v323 * v321;
              v318 >>= 1;
              if ( !v318 )
                break;
              v321 = v321 * v321;
            }
            if ( v307 >= 0 )
              v324 = v323;
            else
              v324 = 1.0 / v323;
            v325 = v307;
            v326 = v324 / *(double *)&qword_43E0E8 / v458 * v413;
            if ( v307 < 0 )
              v325 = -v307;
            v327 = 1.0;
            while ( 1 )
            {
              if ( (v325 & 1) != 0 )
                v327 = v327 * v320;
              v325 >>= 1;
              if ( !v325 )
                break;
              v320 = v320 * v320;
            }
            if ( v307 >= 0 )
              v328 = v327;
            else
              v328 = 1.0 / v327;
            v329 = v425 * v326;
            v299 = v474 - v482;
            v330 = v319 - v329;
            v331 = *(double *)(v466 + 72);
            v332 = v330 * v409 - (v322 - v328 / *(double *)&qword_43E0E8 / v458 * v415) * v436;
            v301 = v409;
            if ( v463 <= *(double *)&v452 )
              v333 = v332 * (v331 * v409);
            else
              v333 = v332 * (v331 * v436) * -1.0;
            ++v307;
            *v308++ = v333 / v300;
          }
          while ( v307 <= v397 );
          v302 = v421;
          v303 = a4;
        }
        v334 = *(double *)(v466 + 72);
        v335 = v487 * v301 - (v501 - v446) * v299;
        if ( v463 <= *(double *)&v452 )
          v336 = v335 * (v334 * v301);
        else
          v336 = v335 * (v334 * v299) * -1.0;
        *(double *)&v303[8 * v302 + 64] = v336 / v300;
        v61 = a5 + v302;
        v298 = v454;
        v421 = v61;
      }
      else
      {
        v61 = v421;
      }
      v64 = v483;
      v62 = v298 + 1;
      v65 = v519;
      v66 = v512;
      v67 = v503;
      v11 = v504;
      v454 = v62;
    }
    while ( v62 < v506 );
  }
  v337 = 1.0;
  v338 = *(double *)(a3 + 64);
  result = a4;
  if ( v338 <= 1.0 )
  {
    if ( v338 >= 1.0 )
    {
      *(_QWORD *)&a4[8 * v61 + 64] = 0i64;
      goto LABEL_310;
    }
    v337 = -1.0 / (v338 * v338);
  }
  *(double *)&a4[8 * v61 + 64] = v337;
LABEL_310:
  *(double *)&a4[8 * v61 + 64] = *(double *)(v7 + 88) * *(double *)&a4[8 * v61 + 64];
  return result;
}
// 40D690: could not find valid save-restore pair for edi
// 40D690: could not find valid save-restore pair for esi
// 40EA8F: variable 'v340' is possibly undefined
// 40EA8F: variable 'v353' is possibly undefined
// 40EABA: variable 'v341' is possibly undefined
// 40EABA: variable 'v354' is possibly undefined
// 40EABA: variable 'v368' is possibly undefined
// 40EABA: variable 'v382' is possibly undefined
// 40EAEA: variable 'v342' is possibly undefined
// 40EAEA: variable 'v355' is possibly undefined
// 40EAEA: variable 'v369' is possibly undefined
// 40EAEA: variable 'v383' is possibly undefined
// 40EBB5: variable 'v343' is possibly undefined
// 40EBB5: variable 'v356' is possibly undefined
// 40EBB5: variable 'v370' is possibly undefined
// 40EBB5: variable 'v384' is possibly undefined
// 40F4A4: variable 'v344' is possibly undefined
// 40F4A4: variable 'v357' is possibly undefined
// 40F4A4: variable 'v371' is possibly undefined
// 40F4A4: variable 'v385' is possibly undefined
// 40F4CC: variable 'v345' is possibly undefined
// 40F4CC: variable 'v358' is possibly undefined
// 40F4CC: variable 'v372' is possibly undefined
// 40F4CC: variable 'v386' is possibly undefined
// 40F4F9: variable 'v346' is possibly undefined
// 40F4F9: variable 'v359' is possibly undefined
// 40F4F9: variable 'v373' is possibly undefined
// 40F4F9: variable 'v387' is possibly undefined
// 40F5C5: variable 'v347' is possibly undefined
// 40F5C5: variable 'v360' is possibly undefined
// 40F5C5: variable 'v374' is possibly undefined
// 40F5C5: variable 'v388' is possibly undefined
// 40FE70: variable 'v348' is possibly undefined
// 40FE70: variable 'v361' is possibly undefined
// 40FE70: variable 'v375' is possibly undefined
// 40FE70: variable 'v389' is possibly undefined
// 40FE98: variable 'v349' is possibly undefined
// 40FE98: variable 'v362' is possibly undefined
// 40FE98: variable 'v376' is possibly undefined
// 40FE98: variable 'v390' is possibly undefined
// 40FEC5: variable 'v350' is possibly undefined
// 40FEC5: variable 'v363' is possibly undefined
// 40FEC5: variable 'v377' is possibly undefined
// 40FEC5: variable 'v391' is possibly undefined
// 40FF95: variable 'v351' is possibly undefined
// 40FF95: variable 'v364' is possibly undefined
// 40FF95: variable 'v378' is possibly undefined
// 40FF95: variable 'v392' is possibly undefined
// 410132: variable 'v352' is possibly undefined
// 410132: variable 'v365' is possibly undefined
// 410132: variable 'v379' is possibly undefined
// 410132: variable 'v393' is possibly undefined
// 4101A7: variable 'v380' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);
// 436A6E: using guessed type __m128 libm_sse2_pow_precise(void);
// 43E0E8: using guessed type __int64 qword_43E0E8;

//----- (00410E70) --------------------------------------------------------
double __thiscall sub_410E70(int *this)
{
  int v2; // edi
  unsigned int v3; // esi
  double *v4; // esi
  int v5; // ecx
  int i; // eax
  double v7; // xmm0_8
  int v9; // [esp+0h] [ebp-BCh]
  int v10; // [esp+4h] [ebp-B8h]
  int v11; // [esp+8h] [ebp-B4h]
  int v12; // [esp+Ch] [ebp-B0h]
  double v13; // [esp+14h] [ebp-A8h]
  double v14; // [esp+14h] [ebp-A8h]
  void *v15[2]; // [esp+20h] [ebp-9Ch] BYREF
  int v16; // [esp+28h] [ebp-94h]
  int v17[4]; // [esp+2Ch] [ebp-90h] BYREF
  __int128 v18; // [esp+3Ch] [ebp-80h]
  __int64 v19; // [esp+4Ch] [ebp-70h]
  int v20[26]; // [esp+54h] [ebp-68h] BYREF

  v2 = this[6];
  v3 = this[7];
  *(_OWORD *)v17 = xmmword_439410;
  v18 = xmmword_439410;
  v16 = 0;
  v19 = 0x3EB0C6F7A0B5ED8Di64;
  v15[0] = 0;
  v15[1] = 0;
  v20[25] = 0;
  sub_4077E0(v15, v3);
  sub_40C710(v2, v3, this[1], (int)v15[0], this[6], this[7], (int)this);
  v13 = 0.0;
  sub_401000(
    (void (__cdecl *)(int, double *, int, int, int))sub_40C710,
    (void (__cdecl *)(int, int, int, int, int))sub_40D690,
    this[1],
    this[2],
    v2,
    v3,
    1000,
    (double *)v17,
    (double *)v20,
    0,
    0,
    (int)this);
  v4 = (double *)v15[0];
  sub_40C710(v2, (int)v15[0], this[1], (int)v15[0], this[6], this[7], (int)this);
  v5 = this[7];
  for ( i = 0; i < v5; v13 = v7 * v7 + v13 )
    v7 = v4[i++];
  *(_QWORD *)&v14 = libm_sse2_sqrt_precise(v9, v10, v11, v12).m128_u64[0];
  if ( v4 )
    operator delete(v4);
  return v14;
}
// 410FBB: variable 'v9' is possibly undefined
// 410FBB: variable 'v10' is possibly undefined
// 410FBB: variable 'v11' is possibly undefined
// 410FBB: variable 'v12' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);
// 439410: using guessed type __int128 xmmword_439410;

//----- (00411000) --------------------------------------------------------
_DWORD *__thiscall sub_411000(_DWORD *this, int a2, int a3, int a4)
{
  void *v5; // eax

  this[8] = a4;
  this[6] = a2;
  *this = &CLevmarForGCM_VerticalLine_LS::`vftable';
  this[7] = a3;
  this[1] = operator new[](8 * a2);
  v5 = operator new[](8 * a3);
  this[2] = v5;
  memset(v5, 0, 8 * a3);
  return this;
}
// 439444: using guessed type void *CLevmarForGCM_VerticalLine_LS::`vftable';

//----- (00411070) --------------------------------------------------------
void __thiscall sub_411070(void *this)
{
  void *v2; // [esp-4h] [ebp-8h]

  v2 = (void *)*((_DWORD *)this + 1);
  *(_DWORD *)this = &CLevmarForGCM_VerticalLine_LS::`vftable';
  operator delete[](v2);
  operator delete[](*((void **)this + 2));
}
// 439444: using guessed type void *CLevmarForGCM_VerticalLine_LS::`vftable';

//----- (00411090) --------------------------------------------------------
void *__thiscall sub_411090(void *this, char a2)
{
  void *v4; // [esp-4h] [ebp-8h]

  v4 = (void *)*((_DWORD *)this + 1);
  *(_DWORD *)this = &CLevmarForGCM_VerticalLine_LS::`vftable';
  operator delete[](v4);
  operator delete[](*((void **)this + 2));
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 439444: using guessed type void *CLevmarForGCM_VerticalLine_LS::`vftable';

//----- (004110D0) --------------------------------------------------------
int __usercall sub_4110D0@<eax>(int a1@<edi>, int a2@<esi>, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // esi
  double v8; // xmm3_8
  double v9; // xmm4_8
  int *v10; // edx
  double v11; // xmm2_8
  int v12; // edi
  double v13; // xmm0_8
  double v14; // xmm5_8
  int v15; // eax
  double v16; // xmm6_8
  double v17; // xmm7_8
  double *v18; // esi
  double v19; // xmm4_8
  double v20; // xmm2_8
  double v21; // st7
  int v22; // ecx
  double v23; // xmm1_8
  double v24; // xmm0_8
  double v25; // xmm1_8
  int v26; // edi
  int v27; // eax
  int v28; // edi
  unsigned int v29; // esi
  double v30; // xmm7_8
  int v31; // edi
  double v32; // xmm6_8
  double v33; // xmm1_8
  double v34; // xmm5_8
  double v35; // xmm3_8
  double v36; // xmm2_8
  double v37; // st7
  double v38; // xmm1_8
  double v39; // xmm0_8
  int v40; // edx
  double v41; // xmm2_8
  double v42; // xmm6_8
  double v43; // xmm7_8
  double v44; // xmm4_8
  double v45; // xmm5_8
  double v46; // xmm1_8
  int v47; // edi
  double *v48; // esi
  double v49; // xmm1_8
  double v50; // st7
  double v51; // xmm7_8
  __int128 v52; // xmm6
  double v53; // xmm5_8
  int v54; // ecx
  double *v55; // esi
  __int128 v56; // xmm1
  __int128 v57; // xmm2
  unsigned int v58; // eax
  double v59; // xmm1_8
  __int128 v60; // xmm0
  double v61; // xmm2_8
  int v62; // edx
  unsigned int v63; // eax
  double v64; // xmm3_8
  double v65; // xmm0_8
  __int128 v66; // xmm2
  double v67; // xmm1_8
  __int128 v68; // xmm0
  double v69; // xmm2_8
  unsigned int v70; // eax
  double v71; // xmm0_8
  __int128 v72; // xmm2
  double v73; // xmm1_8
  __int128 v74; // xmm0
  double v75; // xmm0_8
  double v76; // xmm0_8
  int v77; // esi
  double v78; // xmm3_8
  double v79; // xmm2_8
  double v80; // xmm3_8
  double v81; // st7
  double v82; // xmm0_8
  double v83; // xmm1_8
  double v84; // xmm7_8
  double v85; // xmm3_8
  double v86; // xmm6_8
  __int128 v87; // xmm5
  int v88; // ecx
  double *v89; // esi
  __int128 v90; // xmm1
  __int128 v91; // xmm2
  unsigned int v92; // eax
  double v93; // xmm1_8
  __int128 v94; // xmm0
  double v95; // xmm0_8
  __int128 v96; // xmm2
  int v97; // edx
  unsigned int v98; // eax
  double v99; // xmm3_8
  double v100; // xmm1_8
  __int128 v101; // xmm0
  double v102; // xmm0_8
  __int128 v103; // xmm2
  unsigned int v104; // eax
  double v105; // xmm1_8
  __int128 v106; // xmm0
  double v107; // xmm0_8
  double v108; // xmm0_8
  double *v109; // esi
  double v110; // xmm2_8
  double v111; // xmm3_8
  double v112; // st7
  double v113; // xmm0_8
  double v114; // xmm4_8
  double v115; // xmm3_8
  double v116; // xmm5_8
  double v117; // xmm7_8
  double v118; // xmm6_8
  int v119; // ecx
  __int128 v120; // xmm2
  double *v121; // esi
  unsigned int v122; // eax
  double v123; // xmm1_8
  __int128 v124; // xmm0
  double v125; // xmm0_8
  __int128 v126; // xmm2
  int v127; // edx
  unsigned int v128; // eax
  double v129; // xmm3_8
  double v130; // xmm1_8
  __int128 v131; // xmm0
  double v132; // xmm0_8
  __int128 v133; // xmm2
  unsigned int v134; // eax
  double v135; // xmm1_8
  __int128 v136; // xmm0
  double v137; // xmm0_8
  double v138; // xmm0_8
  double v139; // xmm0_8
  int v140; // edi
  int v141; // edx
  double v142; // xmm0_8
  double v143; // xmm0_8
  double *v144; // ecx
  double *v145; // eax
  double v146; // xmm1_8
  int result; // eax
  double v148; // xmm1_8
  int v149; // [esp+40h] [ebp-1D0h]
  int v150; // [esp+40h] [ebp-1D0h]
  int v151; // [esp+40h] [ebp-1D0h]
  int v152; // [esp+40h] [ebp-1D0h]
  int v153; // [esp+40h] [ebp-1D0h]
  int v154; // [esp+40h] [ebp-1D0h]
  int v155; // [esp+40h] [ebp-1D0h]
  int v156; // [esp+40h] [ebp-1D0h]
  int v157; // [esp+40h] [ebp-1D0h]
  int v158; // [esp+40h] [ebp-1D0h]
  int v159; // [esp+44h] [ebp-1CCh]
  int v160; // [esp+44h] [ebp-1CCh]
  int v161; // [esp+44h] [ebp-1CCh]
  int v162; // [esp+44h] [ebp-1CCh]
  int v163; // [esp+44h] [ebp-1CCh]
  int v164; // [esp+44h] [ebp-1CCh]
  int v165; // [esp+44h] [ebp-1CCh]
  int v166; // [esp+44h] [ebp-1CCh]
  int v167; // [esp+44h] [ebp-1CCh]
  int v168; // [esp+44h] [ebp-1CCh]
  int v169; // [esp+48h] [ebp-1C8h]
  int v170; // [esp+48h] [ebp-1C8h]
  int v171; // [esp+48h] [ebp-1C8h]
  int v172; // [esp+48h] [ebp-1C8h]
  int v173; // [esp+48h] [ebp-1C8h]
  int v174; // [esp+48h] [ebp-1C8h]
  int v175; // [esp+48h] [ebp-1C8h]
  int v176; // [esp+48h] [ebp-1C8h]
  int v177; // [esp+48h] [ebp-1C8h]
  int v178; // [esp+48h] [ebp-1C8h]
  int v179; // [esp+48h] [ebp-1C8h]
  int v180; // [esp+48h] [ebp-1C8h]
  int v181; // [esp+48h] [ebp-1C8h]
  int v182; // [esp+48h] [ebp-1C8h]
  int v183; // [esp+4Ch] [ebp-1C4h]
  double *v184; // [esp+4Ch] [ebp-1C4h]
  int v185; // [esp+4Ch] [ebp-1C4h]
  int v186; // [esp+4Ch] [ebp-1C4h]
  int v187; // [esp+4Ch] [ebp-1C4h]
  int v188; // [esp+4Ch] [ebp-1C4h]
  int v189; // [esp+4Ch] [ebp-1C4h]
  int v190; // [esp+4Ch] [ebp-1C4h]
  int v191; // [esp+4Ch] [ebp-1C4h]
  int v192; // [esp+4Ch] [ebp-1C4h]
  int v193; // [esp+4Ch] [ebp-1C4h]
  int v194; // [esp+4Ch] [ebp-1C4h]
  int v195; // [esp+4Ch] [ebp-1C4h]
  double v196; // [esp+50h] [ebp-1C0h]
  double v197; // [esp+50h] [ebp-1C0h]
  double v198; // [esp+50h] [ebp-1C0h]
  double v199; // [esp+50h] [ebp-1C0h]
  double v200; // [esp+50h] [ebp-1C0h]
  int v201; // [esp+5Ch] [ebp-1B4h]
  unsigned int v202; // [esp+68h] [ebp-1A8h]
  double v203; // [esp+68h] [ebp-1A8h]
  double v204; // [esp+68h] [ebp-1A8h]
  double v205; // [esp+68h] [ebp-1A8h]
  double v206; // [esp+68h] [ebp-1A8h]
  int v207; // [esp+74h] [ebp-19Ch]
  int v208; // [esp+78h] [ebp-198h]
  int v209; // [esp+78h] [ebp-198h]
  double v210; // [esp+78h] [ebp-198h]
  double v211; // [esp+78h] [ebp-198h]
  double v212; // [esp+78h] [ebp-198h]
  double v213; // [esp+80h] [ebp-190h]
  double v214; // [esp+80h] [ebp-190h]
  double v215; // [esp+88h] [ebp-188h]
  double v216; // [esp+88h] [ebp-188h]
  double v217; // [esp+88h] [ebp-188h]
  _DWORD *v218; // [esp+90h] [ebp-180h]
  double v219; // [esp+90h] [ebp-180h]
  double v220; // [esp+90h] [ebp-180h]
  double v221; // [esp+90h] [ebp-180h]
  double v222; // [esp+A0h] [ebp-170h]
  double v223; // [esp+A0h] [ebp-170h]
  double v224; // [esp+A8h] [ebp-168h]
  double v225; // [esp+A8h] [ebp-168h]
  double v226; // [esp+A8h] [ebp-168h]
  double v227; // [esp+B0h] [ebp-160h]
  double v228; // [esp+B0h] [ebp-160h]
  double v229; // [esp+B0h] [ebp-160h]
  double v230; // [esp+B8h] [ebp-158h]
  double v231; // [esp+B8h] [ebp-158h]
  double v232; // [esp+B8h] [ebp-158h]
  int v233; // [esp+C4h] [ebp-14Ch]
  double v234; // [esp+C8h] [ebp-148h]
  double v235; // [esp+C8h] [ebp-148h]
  int v236; // [esp+D4h] [ebp-13Ch]
  double v237; // [esp+D8h] [ebp-138h]
  double v238; // [esp+D8h] [ebp-138h]
  double v239; // [esp+E0h] [ebp-130h]
  double v240; // [esp+E0h] [ebp-130h]
  int v241; // [esp+ECh] [ebp-124h]
  double v242; // [esp+F0h] [ebp-120h] BYREF
  double v243; // [esp+F8h] [ebp-118h]
  double v244; // [esp+100h] [ebp-110h]
  double v245; // [esp+108h] [ebp-108h]
  double v246; // [esp+110h] [ebp-100h]
  double v247; // [esp+118h] [ebp-F8h]
  double v248; // [esp+120h] [ebp-F0h]
  double v249; // [esp+128h] [ebp-E8h]
  double v250; // [esp+130h] [ebp-E0h]
  double v251; // [esp+138h] [ebp-D8h] BYREF
  double v252; // [esp+140h] [ebp-D0h] BYREF
  double v253; // [esp+148h] [ebp-C8h]
  double *v254; // [esp+154h] [ebp-BCh]
  char v255[180]; // [esp+158h] [ebp-B8h] BYREF

  v159 = a2;
  v149 = a1;
  *(_QWORD *)(a3 + 24) = 0i64;
  v236 = *(_DWORD *)(a7 + 32);
  sub_405EB0((int)v255, v236, a3 + 24, qword_43E0E8);
  v7 = *(_DWORD *)(a7 + 20);
  v201 = v7;
  v237 = *(double *)(v7 + 56);
  v183 = a3 + 8 * *(_DWORD *)(v7 + 204);
  sub_406C30(*(_QWORD *)a3, *(double *)(a3 + 8), *(double *)(a3 + 16), &v242);
  v8 = v250;
  v9 = v244;
  v10 = (int *)(v7 + 48);
  v254 = (double *)(a3 + 64);
  if ( *(_DWORD *)(v7 + 48) < *(_DWORD *)(v7 + 52) )
    v10 = (int *)(v7 + 52);
  v241 = *(_DWORD *)(v7 + 24);
  v233 = *(_DWORD *)(v7 + 16);
  v11 = (double)*v10 * *(double *)(a3 + 64);
  v12 = 0;
  v213 = v11;
  if ( v233 <= 0 )
  {
    v22 = v183;
  }
  else
  {
    v13 = -v11;
    v14 = v244 * -v11;
    v15 = 0;
    v169 = 0;
    v16 = v250 * -v11;
    v17 = v250 * v11;
    v196 = v244 * v11;
    v230 = -v11;
    v227 = v14;
    v215 = v16;
    v239 = v250 * v11;
    v224 = v247 * v11;
    do
    {
      v18 = (double *)(v15 + *(_DWORD *)(v7 + 108));
      v19 = v242 * *v18;
      v20 = v248 * *v18;
      v18[2] = v13;
      v21 = sub_406A70(
              (int)v255,
              -4.0,
              0.0,
              -1.0,
              1.0e-10,
              v19 + v243 * v18[1] + v14,
              v196,
              v20 + v249 * v18[1] + v16,
              v17);
      v22 = v183;
      v14 = v227;
      v16 = v215;
      v17 = v239;
      v23 = v246 * v18[1] + v245 * *v18;
      v24 = v247 * v18[2];
      v7 = v201;
      v25 = (v23 + v24) * v21 - v224 - *(double *)(v183 + 8 * *(_DWORD *)(*(_DWORD *)(v201 + 120) + 4 * v12)) * v237;
      v13 = v230;
      *(double *)(a4 + 8 * v12++) = v25;
      v15 = v169 + 32;
      v169 += 32;
    }
    while ( v12 < v233 );
    v11 = v213;
    v8 = v250;
    v9 = v244;
  }
  v26 = v233;
  v207 = v233;
  v202 = 0;
  v184 = (double *)(v22 + 8 * *(_DWORD *)(v7 + 8));
  if ( (*(_DWORD *)(v7 + 160) - *(_DWORD *)(v7 + 156)) / 12 )
  {
    v27 = *(_DWORD *)(v7 + 156);
    v28 = 0;
    v208 = v27;
    v170 = 0;
    do
    {
      v218 = (_DWORD *)(v28 + v27);
      v29 = 0;
      if ( (*(_DWORD *)(v27 + v28 + 4) - *(_DWORD *)(v28 + v27)) / 40 )
      {
        v30 = v8 * v11;
        v31 = 0;
        v32 = v8 * -v11;
        v33 = v9 * -v11;
        v34 = v9 * v11;
        v216 = v8 * v11;
        v231 = v32;
        v228 = v33;
        v225 = v9 * v11;
        do
        {
          v35 = *(double *)(*v218 + v31 + 8) - *(double *)(v201 + 32);
          v36 = *(double *)(*v218 + v31 + 16) - *(double *)(v201 + 40);
          v197 = v243 * v36 + v242 * v35 + v33;
          v37 = sub_406A70((int)v255, -4.0, 0.0, -1.0, 1.0e-10, v197, v34, v249 * v36 + v248 * v35 + v32, v30);
          ++v29;
          v31 += 40;
          v34 = v225;
          v32 = v231;
          v30 = v216;
          v38 = v197 * v37 - v225 - *v184 * v237;
          *(double *)(a4 + 8 * v207) = v38;
          v39 = *(double *)(v201 + 64) * v38;
          v33 = v228;
          *(double *)(a4 + 8 * v207++) = v39;
          v208 = *(_DWORD *)(v201 + 156);
          v218 = (_DWORD *)(v208 + v170);
        }
        while ( v29 < (*(_DWORD *)(v208 + v170 + 4) - *(_DWORD *)(v208 + v170)) / 40 );
        v28 = v170;
      }
      v28 += 12;
      ++v184;
      v11 = v213;
      v8 = v250;
      v9 = v244;
      ++v202;
      v170 = v28;
      v27 = v208;
    }
    while ( v202 < (*(_DWORD *)(v201 + 160) - *(_DWORD *)(v201 + 156)) / 12 );
    v7 = v201;
    v26 = v207;
  }
  v40 = 0;
  v171 = 0;
  v185 = v26 + v241;
  if ( v241 <= 0 )
  {
    v140 = a4;
  }
  else
  {
    v41 = -v213;
    v42 = v244 * -v213;
    v43 = v250 * -v213;
    v44 = v250 * v213;
    v45 = v244 * v213;
    v46 = v247 * v213;
    v232 = -v213;
    v226 = v42;
    v238 = v43;
    v229 = v250 * v213;
    v214 = v244 * v213;
    v253 = v46;
    do
    {
      v209 = v40 + v233 + 2 * v40;
      v47 = 32 * v209;
      v48 = (double *)(32 * v209 + *(_DWORD *)(v7 + 108));
      v49 = v48[1];
      v48[2] = v41;
      v50 = sub_406A70(
              (int)v255,
              -4.0,
              0.0,
              -1.0,
              1.0e-10,
              *v48 * v242 + v49 * v243 + v42,
              v45,
              *v48 * v248 + v49 * v249 + v43,
              v44);
      v51 = 0.0;
      v52 = *(unsigned __int64 *)v48;
      v203 = 0.0;
      *(double *)&v52 = (*(double *)&v52 * v242 + v48[1] * v243 + v48[2] * v244) * v50 - v214;
      v222 = *(double *)&v52;
      v240 = (v245 * *v48 + v246 * v48[1] + v247 * v48[2]) * v50 - v253;
      v53 = 0.0;
      if ( v236 >= 1 )
      {
        v54 = 0;
        v56 = (unsigned __int64)qword_43E0E8;
        *(double *)&v52 = *(double *)&v52 * *(double *)&qword_43E0E8;
        v55 = (double *)(a3 + 32);
        *(double *)&v56 = *(double *)&qword_43E0E8 * 0.0;
        do
        {
          v57 = v56;
          v58 = v54;
          if ( v54 < 0 )
            v58 = -v54;
          v59 = 1.0;
          while ( 1 )
          {
            if ( (v58 & 1) != 0 )
              v59 = v59 * *(double *)&v57;
            v58 >>= 1;
            if ( !v58 )
              break;
            *((_QWORD *)&v60 + 1) = *((_QWORD *)&v57 + 1);
            *(double *)&v60 = *(double *)&v57 * *(double *)&v57;
            v57 = v60;
          }
          if ( v54 >= 0 )
            v61 = v59;
          else
            v61 = 1.0 / v59;
          v62 = v54 + 1;
          v63 = v54;
          v64 = (double)(v54 + 1) * *v55;
          v65 = v64 * v61;
          v66 = COERCE_UNSIGNED_INT64(*(double *)&v52 * 0.5);
          v203 = v65 + v203;
          if ( v54 < 0 )
            v63 = -v54;
          v67 = 1.0;
          while ( 1 )
          {
            if ( (v63 & 1) != 0 )
              v67 = v67 * *(double *)&v66;
            v63 >>= 1;
            if ( !v63 )
              break;
            *((_QWORD *)&v68 + 1) = *((_QWORD *)&v66 + 1);
            *(double *)&v68 = *(double *)&v66 * *(double *)&v66;
            v66 = v68;
          }
          if ( v54 >= 0 )
            v69 = v67;
          else
            v69 = 1.0 / v67;
          v70 = v54;
          v71 = v64 * v69;
          v72 = v52;
          v51 = v71 + v51;
          if ( v54 < 0 )
            v70 = -v54;
          v73 = 1.0;
          while ( 1 )
          {
            if ( (v70 & 1) != 0 )
              v73 = v73 * *(double *)&v72;
            v70 >>= 1;
            if ( !v70 )
              break;
            *((_QWORD *)&v74 + 1) = *((_QWORD *)&v72 + 1);
            *(double *)&v74 = *(double *)&v72 * *(double *)&v72;
            v72 = v74;
          }
          if ( v54 >= 0 )
            v75 = v73;
          else
            v75 = 1.0 / v73;
          v56 = COERCE_UNSIGNED_INT64(*(double *)&qword_43E0E8 * 0.0);
          ++v54;
          ++v55;
          v53 = v64 * v75 + v53;
        }
        while ( v62 + 1 <= v236 );
      }
      v219 = *(double *)libm_sse2_sqrt_precise(v149, v159, v171, v185).m128_u64 * 4.0;
      v220 = v219 + *(double *)libm_sse2_sqrt_precise(v150, v160, v172, v186).m128_u64;
      v76 = *(double *)libm_sse2_sqrt_precise(v151, v161, v173, v187).m128_u64;
      v77 = *(_DWORD *)(v201 + 108);
      v78 = *(double *)(v47 + v77 + 32);
      v79 = v78 * v248;
      v80 = v78 * v242;
      *(double *)(v47 + v77 + 48) = v232;
      v221 = (v220 + v76) * (v222 / 6.0);
      v81 = sub_406A70(
              (int)v255,
              -4.0,
              0.0,
              -1.0,
              1.0e-10,
              v80 + *(double *)(v47 + v77 + 40) * v243 + v226,
              v214,
              v79 + *(double *)(v47 + v77 + 40) * v249 + v238,
              v229);
      v82 = *(double *)(v47 + v77 + 40);
      v83 = *(double *)(v47 + v77 + 48);
      v223 = 0.0;
      v84 = 0.0;
      v85 = (*(double *)(v47 + v77 + 32) * v242 + v82 * v243 + v83 * v244) * v81 - v214;
      v234 = v85;
      v217 = (*(double *)(v47 + v77 + 32) * v245 + v82 * v246 + v83 * v247) * v81 - v253;
      v86 = 0.0;
      if ( v236 >= 1 )
      {
        *((_QWORD *)&v87 + 1) = 0i64;
        v90 = (unsigned __int64)qword_43E0E8;
        *(double *)&v87 = v85 * *(double *)&qword_43E0E8;
        v88 = 0;
        v89 = (double *)(a3 + 32);
        *(double *)&v90 = *(double *)&qword_43E0E8 * 0.0;
        v198 = v85 * *(double *)&qword_43E0E8 * 0.5;
        do
        {
          v91 = v90;
          v92 = v88;
          if ( v88 < 0 )
            v92 = -v88;
          v93 = 1.0;
          while ( 1 )
          {
            if ( (v92 & 1) != 0 )
              v93 = v93 * *(double *)&v91;
            v92 >>= 1;
            if ( !v92 )
              break;
            *((_QWORD *)&v94 + 1) = *((_QWORD *)&v91 + 1);
            *(double *)&v94 = *(double *)&v91 * *(double *)&v91;
            v91 = v94;
          }
          if ( v88 >= 0 )
            v95 = v93;
          else
            v95 = 1.0 / v93;
          v96 = *(unsigned __int64 *)&v198;
          v97 = v88 + 1;
          v98 = v88;
          v99 = (double)(v88 + 1) * *v89;
          v223 = v95 * v99 + v223;
          if ( v88 < 0 )
            v98 = -v88;
          v100 = 1.0;
          while ( 1 )
          {
            if ( (v98 & 1) != 0 )
              v100 = v100 * *(double *)&v96;
            v98 >>= 1;
            if ( !v98 )
              break;
            *((_QWORD *)&v101 + 1) = *((_QWORD *)&v96 + 1);
            *(double *)&v101 = *(double *)&v96 * *(double *)&v96;
            v96 = v101;
          }
          if ( v88 >= 0 )
            v102 = v100;
          else
            v102 = 1.0 / v100;
          v103 = v87;
          v104 = v88;
          v84 = v102 * v99 + v84;
          if ( v88 < 0 )
            v104 = -v88;
          v105 = 1.0;
          while ( 1 )
          {
            if ( (v104 & 1) != 0 )
              v105 = v105 * *(double *)&v103;
            v104 >>= 1;
            if ( !v104 )
              break;
            *((_QWORD *)&v106 + 1) = *((_QWORD *)&v103 + 1);
            *(double *)&v106 = *(double *)&v103 * *(double *)&v103;
            v103 = v106;
          }
          if ( v88 >= 0 )
            v107 = v105;
          else
            v107 = 1.0 / v105;
          v90 = COERCE_UNSIGNED_INT64(*(double *)&qword_43E0E8 * 0.0);
          ++v88;
          ++v89;
          v86 = v107 * v99 + v86;
        }
        while ( v97 + 1 <= v236 );
      }
      v204 = *(double *)libm_sse2_sqrt_precise(v152, v162, v174, v188).m128_u64 * 4.0;
      v205 = v204 + *(double *)libm_sse2_sqrt_precise(v153, v163, v175, v189).m128_u64;
      v108 = *(double *)libm_sse2_sqrt_precise(v154, v164, v176, v190).m128_u64;
      v109 = (double *)(*(_DWORD *)(v201 + 108) + 32 * (v209 + 2));
      v110 = *v109 * v248;
      v111 = *v109 * v242;
      v109[2] = v232;
      v206 = (v205 + v108) * (v234 / 6.0);
      v112 = sub_406A70(
               (int)v255,
               -4.0,
               0.0,
               -1.0,
               1.0e-10,
               v111 + v109[1] * v243 + v226,
               v214,
               v110 + v109[1] * v249 + v238,
               v229);
      v113 = v109[2];
      v114 = *v109 * v245 + v109[1] * v246;
      v115 = (*v109 * v242 + v109[1] * v243 + v113 * v244) * v112 - v214;
      v251 = v115;
      v252 = (v114 + v113 * v247) * v112 - v253;
      v116 = 0.0;
      v117 = 0.0;
      v118 = 0.0;
      if ( v236 >= 1 )
      {
        v119 = 0;
        v120 = (unsigned __int64)qword_43E0E8;
        *(double *)&v120 = *(double *)&qword_43E0E8 * 0.0;
        v121 = (double *)(a3 + 32);
        v199 = v115 * *(double *)&qword_43E0E8;
        v235 = v115 * *(double *)&qword_43E0E8 * 0.5;
        do
        {
          v122 = v119;
          if ( v119 < 0 )
            v122 = -v119;
          v123 = 1.0;
          while ( 1 )
          {
            if ( (v122 & 1) != 0 )
              v123 = v123 * *(double *)&v120;
            v122 >>= 1;
            if ( !v122 )
              break;
            *((_QWORD *)&v124 + 1) = *((_QWORD *)&v120 + 1);
            *(double *)&v124 = *(double *)&v120 * *(double *)&v120;
            v120 = v124;
          }
          if ( v119 >= 0 )
            v125 = v123;
          else
            v125 = 1.0 / v123;
          v126 = *(unsigned __int64 *)&v235;
          v127 = v119 + 1;
          v128 = v119;
          v129 = (double)(v119 + 1) * *v121;
          v117 = v125 * v129 + v117;
          if ( v119 < 0 )
            v128 = -v119;
          v130 = 1.0;
          while ( 1 )
          {
            if ( (v128 & 1) != 0 )
              v130 = v130 * *(double *)&v126;
            v128 >>= 1;
            if ( !v128 )
              break;
            *((_QWORD *)&v131 + 1) = *((_QWORD *)&v126 + 1);
            *(double *)&v131 = *(double *)&v126 * *(double *)&v126;
            v126 = v131;
          }
          if ( v119 >= 0 )
            v132 = v130;
          else
            v132 = 1.0 / v130;
          v133 = *(unsigned __int64 *)&v199;
          v134 = v119;
          v118 = v132 * v129 + v118;
          if ( v119 < 0 )
            v134 = -v119;
          v135 = 1.0;
          while ( 1 )
          {
            if ( (v134 & 1) != 0 )
              v135 = v135 * *(double *)&v133;
            v134 >>= 1;
            if ( !v134 )
              break;
            *((_QWORD *)&v136 + 1) = *((_QWORD *)&v133 + 1);
            *(double *)&v136 = *(double *)&v133 * *(double *)&v133;
            v133 = v136;
          }
          if ( v119 >= 0 )
            v137 = v135;
          else
            v137 = 1.0 / v135;
          v120 = COERCE_UNSIGNED_INT64(*(double *)&qword_43E0E8 * 0.0);
          ++v119;
          ++v121;
          v116 = v137 * v129 + v116;
        }
        while ( v127 + 1 <= v236 );
      }
      v210 = *(double *)libm_sse2_sqrt_precise(v155, v165, v177, v191).m128_u64 * 4.0;
      v211 = v210 + *(double *)libm_sse2_sqrt_precise(v156, v166, v178, v192).m128_u64;
      v138 = *(double *)libm_sse2_sqrt_precise(v157, v167, v179, v193).m128_u64;
      v212 = (v211 + v138) * (v251 / 6.0) * (v217 - v240) + (v221 - v206) * v252 + v206 * v240 - v217 * v221;
      v139 = *(double *)libm_sse2_sqrt_precise(v158, v168, v180, v194).m128_u64;
      v140 = a4;
      v7 = v201;
      v141 = v181;
      *(double *)(a4 + 8 * v207) = v212 / v139;
      *(double *)(a4 + 8 * v207++) = v212 / v139 * *(double *)(v201 + 80);
      if ( *(_BYTE *)(*(_DWORD *)(v201 + 192) + 40 * v181 + 32) == 1 )
      {
        if ( fabs(v221 - v206) <= fabs(v240 - v217) )
          v142 = v221 - v206;
        else
          v142 = v240 - v217;
        v200 = v142;
        v143 = *(double *)libm_sse2_sqrt_precise(v149, v159, v181, v185).m128_u64;
        v141 = v182;
        *(double *)(a4 + 8 * v195) = v200 / v143;
        *(double *)(a4 + 8 * v195) = *(double *)(v201 + 72) * (v200 / v143);
        v185 = v195 + 1;
      }
      v44 = v229;
      v40 = v141 + 1;
      v45 = v214;
      v41 = v232;
      v42 = v226;
      v43 = v238;
      v171 = v40;
    }
    while ( v40 < v241 );
  }
  v144 = &v252;
  v145 = &v251;
  v252 = 1.0;
  v251 = 1.0;
  if ( *v254 > 1.0 )
    v144 = v254;
  if ( *v254 < 1.0 )
    v145 = v254;
  v146 = *v144 / *v145;
  result = v185;
  v148 = v146 - 1.0;
  *(double *)(v140 + 8 * v185) = v148;
  *(double *)(v140 + 8 * v185) = *(double *)(v7 + 88) * v148;
  return result;
}
// 4110D0: could not find valid save-restore pair for edi
// 4110D0: could not find valid save-restore pair for esi
// 411975: variable 'v149' is possibly undefined
// 411975: variable 'v159' is possibly undefined
// 411975: variable 'v185' is possibly undefined
// 41199A: variable 'v150' is possibly undefined
// 41199A: variable 'v160' is possibly undefined
// 41199A: variable 'v172' is possibly undefined
// 41199A: variable 'v186' is possibly undefined
// 4119C1: variable 'v151' is possibly undefined
// 4119C1: variable 'v161' is possibly undefined
// 4119C1: variable 'v173' is possibly undefined
// 4119C1: variable 'v187' is possibly undefined
// 411CC8: variable 'v152' is possibly undefined
// 411CC8: variable 'v162' is possibly undefined
// 411CC8: variable 'v174' is possibly undefined
// 411CC8: variable 'v188' is possibly undefined
// 411CED: variable 'v153' is possibly undefined
// 411CED: variable 'v163' is possibly undefined
// 411CED: variable 'v175' is possibly undefined
// 411CED: variable 'v189' is possibly undefined
// 411D14: variable 'v154' is possibly undefined
// 411D14: variable 'v164' is possibly undefined
// 411D14: variable 'v176' is possibly undefined
// 411D14: variable 'v190' is possibly undefined
// 412060: variable 'v155' is possibly undefined
// 412060: variable 'v165' is possibly undefined
// 412060: variable 'v177' is possibly undefined
// 412060: variable 'v191' is possibly undefined
// 412085: variable 'v156' is possibly undefined
// 412085: variable 'v166' is possibly undefined
// 412085: variable 'v178' is possibly undefined
// 412085: variable 'v192' is possibly undefined
// 4120AC: variable 'v157' is possibly undefined
// 4120AC: variable 'v167' is possibly undefined
// 4120AC: variable 'v179' is possibly undefined
// 4120AC: variable 'v193' is possibly undefined
// 41212B: variable 'v158' is possibly undefined
// 41212B: variable 'v168' is possibly undefined
// 41212B: variable 'v180' is possibly undefined
// 41212B: variable 'v194' is possibly undefined
// 412146: variable 'v181' is possibly undefined
// 4121D4: variable 'v182' is possibly undefined
// 4121D8: variable 'v195' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);
// 43E0E8: using guessed type __int64 qword_43E0E8;

//----- (004122B0) --------------------------------------------------------
void __userpurge sub_4122B0(int *a1@<ecx>, int a2@<edi>, _DWORD *a3, _DWORD **a4, _DWORD *a5, double a6, double a7)
{
  int *v7; // esi
  _DWORD *v8; // ebx
  _DWORD *v9; // ecx
  _DWORD *v10; // edx
  int v11; // ebx
  unsigned int v12; // esi
  _DWORD *v13; // edi
  int v14; // ebx
  double v15; // xmm0_8
  const __m128i *v16; // esi
  const __m128i *v17; // eax
  int v18; // edx
  __int64 v19; // xmm0_8
  _DWORD *v20; // esi
  int v21; // ebx
  int v22; // edi
  int v23; // ebx
  int v24; // eax
  _DWORD *v25; // ecx
  unsigned int v26; // esi
  int v27; // edi
  int v28; // edx
  double *v29; // esi
  int v30; // ecx
  double v31; // xmm0_8
  unsigned int v32; // [esp-4h] [ebp-50h]
  int v33; // [esp+10h] [ebp-3Ch]
  int v35; // [esp+1Ch] [ebp-30h]
  unsigned int v36; // [esp+1Ch] [ebp-30h]
  int v37; // [esp+24h] [ebp-28h]
  int v38; // [esp+24h] [ebp-28h]
  unsigned int v39; // [esp+28h] [ebp-24h]
  unsigned int v40; // [esp+28h] [ebp-24h]
  unsigned int v41; // [esp+2Ch] [ebp-20h]
  int v42; // [esp+2Ch] [ebp-20h]
  void *v43[2]; // [esp+30h] [ebp-1Ch] BYREF
  int v44; // [esp+38h] [ebp-14h]
  int v45; // [esp+48h] [ebp-4h]

  v7 = a1;
  v8 = a3;
  v43[0] = 0;
  v43[1] = 0;
  v44 = 0;
  v32 = a1[7];
  v45 = 0;
  sub_4077E0(v43, v32);
  sub_4110D0(a2, (int)v7, v7[1], (int)v43[0], v7[6], v7[7], (int)v7);
  v35 = 0;
  v9 = *a4;
  if ( *a4 != a4[1] )
  {
    do
    {
      v39 = 0;
      v10 = (_DWORD *)(v8[2] + 8 + 56 * *v9);
      if ( (v10[1] - *v10) >> 5 )
      {
        v11 = 0;
        v37 = 0;
        do
        {
          v12 = 0;
          v13 = (_DWORD *)(v11 + *v10 + 8);
          v41 = 0;
          if ( (v13[1] - *v13) / 40 )
          {
            v14 = 0;
            do
            {
              v15 = *((double *)v43[0] + v35) * *((double *)v43[0] + v35);
              ++v35;
              if ( v15 > a6 )
              {
                v16 = (const __m128i *)v13[1];
                v17 = (const __m128i *)(v14 + *v13 + 40);
                if ( v17 != v16 )
                {
                  v18 = v14 + *v13;
                  do
                  {
                    v18 += 40;
                    *(__m128i *)(v18 - 40) = _mm_loadu_si128(v17);
                    *(__m128i *)(v18 - 24) = _mm_loadu_si128(v17 + 1);
                    v19 = v17[2].m128i_i64[0];
                    v17 = (const __m128i *)((char *)v17 + 40);
                    *(_QWORD *)(v18 - 8) = v19;
                  }
                  while ( v17 != v16 );
                }
                v13[1] -= 40;
                v12 = v41 - 1;
                v14 -= 40;
              }
              ++v12;
              v14 += 40;
              v41 = v12;
              v13 = (_DWORD *)(*(_DWORD *)(a3[2] + 56 * *v9 + 8) + v37 + 8);
            }
            while ( v12 < (v13[1] - *v13) / 40 );
            v11 = v37;
          }
          v11 += 32;
          v37 = v11;
          ++v39;
          v10 = (_DWORD *)(a3[2] + 8 + 56 * *v9);
        }
        while ( v39 < (v10[1] - *v10) >> 5 );
        v8 = a3;
      }
      ++v9;
    }
    while ( v9 != a4[1] );
    v7 = a1;
  }
  v20 = (_DWORD *)v7[5];
  v40 = 0;
  v21 = v20[6];
  v22 = v20[4];
  v33 = v21;
  if ( (v20[40] - v20[39]) / 12 )
  {
    v38 = v20[39];
    v23 = 0;
    v36 = (v20[40] - v38) / 12;
    v24 = v38;
    v25 = (_DWORD *)(v38 + 4);
    v42 = v38 + 4;
    do
    {
      v26 = 0;
      if ( (*v25 - *(_DWORD *)(v24 + v23)) / 40 )
      {
        do
        {
          ++v26;
          ++v22;
        }
        while ( v26 < (*(_DWORD *)(*(_DWORD *)(a1[5] + 156) + v23 + 4) - *(_DWORD *)(*(_DWORD *)(a1[5] + 156) + v23))
                    / 40 );
      }
      v23 += 12;
      v25 = (_DWORD *)(v42 + 12);
      ++v40;
      v24 = v38;
      v42 += 12;
    }
    while ( v40 < v36 );
    v21 = v33;
  }
  v27 = v21 + v22;
  if ( v21 > 0 )
  {
    v28 = 0;
    v29 = (double *)((char *)v43[0] + 8 * v27);
    do
    {
      v30 = a1[5];
      if ( *(_BYTE *)(*(_DWORD *)(v30 + 192) + v28 + 32) == 1 )
      {
        v31 = *v29++;
        if ( v31 / *(double *)(v30 + 72) * (v31 / *(double *)(v30 + 72)) > a7 )
          *(_BYTE *)(*a5 + v28 + 32) = 0;
      }
      v28 += 40;
      --v21;
    }
    while ( v21 );
  }
  sub_4057B0(a3);
  if ( v43[0] )
    operator delete(v43[0]);
}

//----- (00412610) --------------------------------------------------------
char *__usercall sub_412610@<eax>(int a1@<edi>, int a2@<esi>, int a3, char *a4, int a5, int a6, int a7)
{
  int v7; // esi
  int *v8; // edx
  int v9; // ecx
  double v10; // xmm7_8
  double v11; // xmm4_8
  int v12; // eax
  double v13; // xmm1_8
  double *v14; // edi
  double v15; // xmm4_8
  double v16; // xmm6_8
  double v17; // xmm5_8
  double v18; // xmm7_8
  double *v19; // esi
  double v20; // xmm0_8
  double v21; // xmm3_8
  double v22; // st7
  double v23; // xmm5_8
  double v24; // xmm6_8
  double v25; // xmm4_8
  double v26; // xmm7_8
  int v27; // ecx
  double v28; // xmm6_8
  double v29; // xmm4_8
  double v30; // xmm7_8
  double v31; // xmm3_8
  double v32; // xmm5_8
  double v33; // xmm4_8
  double v34; // xmm5_8
  double *v35; // edx
  __int128 v36; // xmm2
  unsigned int v37; // eax
  double v38; // xmm1_8
  __int128 v39; // xmm0
  double v40; // xmm0_8
  double v41; // xmm0_8
  double v42; // xmm1_8
  double v43; // xmm0_8
  double v44; // xmm1_8
  double v45; // xmm0_8
  int v46; // eax
  unsigned int v47; // edi
  int v48; // esi
  _DWORD *v49; // esi
  double v50; // xmm5_8
  double v51; // xmm6_8
  char *v52; // edi
  double v53; // xmm4_8
  double v54; // xmm5_8
  double v55; // xmm7_8
  double v56; // xmm7_8
  int v57; // ecx
  double v58; // xmm1_8
  double v59; // xmm5_8
  double v60; // xmm6_8
  double v61; // xmm0_8
  int v62; // ecx
  double v63; // xmm2_8
  double v64; // xmm3_8
  double v65; // xmm0_8
  double v66; // xmm1_8
  double v67; // xmm4_8
  double v68; // xmm3_8
  double v69; // xmm7_8
  double v70; // xmm5_8
  double v71; // xmm4_8
  double v72; // xmm4_8
  __int128 v73; // xmm6
  double *v74; // edx
  double v75; // xmm4_8
  __int128 v76; // xmm2
  unsigned int v77; // eax
  double v78; // xmm1_8
  __int128 v79; // xmm0
  double v80; // xmm0_8
  double v81; // xmm7_8
  int v82; // esi
  int v83; // ecx
  double v84; // xmm2_8
  double v85; // xmm6_8
  double v86; // xmm4_8
  double v87; // xmm5_8
  double v88; // xmm7_8
  int v89; // edi
  double *v90; // esi
  double v91; // st7
  double v92; // xmm7_8
  double v93; // xmm5_8
  double v94; // xmm2_8
  int v95; // ecx
  double v96; // xmm3_8
  double v97; // xmm1_8
  double v98; // xmm4_8
  double v99; // xmm0_8
  double v100; // xmm2_8
  double v101; // xmm3_8
  double v102; // xmm4_8
  double v103; // xmm5_8
  double v104; // xmm2_8
  double v105; // xmm3_8
  double v106; // xmm0_8
  int v107; // esi
  double v108; // xmm3_8
  double v109; // xmm5_8
  double v110; // xmm6_8
  double v111; // xmm4_8
  __int128 v112; // xmm0
  __int128 v113; // xmm7
  int v114; // ecx
  double *v115; // esi
  __int128 v116; // xmm1
  __int128 v117; // xmm2
  unsigned int v118; // eax
  double v119; // xmm1_8
  __int128 v120; // xmm0
  double v121; // xmm2_8
  int v122; // edx
  unsigned int v123; // eax
  double v124; // xmm3_8
  double v125; // xmm0_8
  __int128 v126; // xmm2
  double v127; // xmm1_8
  __int128 v128; // xmm0
  double v129; // xmm2_8
  unsigned int v130; // eax
  double v131; // xmm0_8
  __int128 v132; // xmm2
  double v133; // xmm1_8
  __int128 v134; // xmm0
  double v135; // xmm0_8
  double v136; // xmm3_8
  double v137; // xmm1_8
  int v138; // ecx
  double *v139; // edx
  double v140; // xmm2_8
  unsigned int v141; // eax
  double v142; // xmm1_8
  double v143; // xmm2_8
  double v144; // xmm0_8
  double v145; // xmm2_8
  double v146; // xmm3_8
  double v147; // xmm2_8
  double v148; // xmm1_8
  double v149; // xmm7_8
  double v150; // xmm6_8
  int v151; // ecx
  double v152; // xmm1_8
  double v153; // xmm2_8
  double v154; // xmm0_8
  double v155; // xmm3_8
  double v156; // xmm4_8
  double v157; // xmm5_8
  double v158; // xmm1_8
  int v159; // esi
  __int128 v160; // xmm2
  double v161; // xmm0_8
  double v162; // xmm6_8
  double v163; // xmm5_8
  double v164; // xmm4_8
  __int128 v165; // xmm7
  int v166; // ecx
  double *v167; // esi
  __int128 v168; // xmm0
  __int128 v169; // xmm2
  unsigned int v170; // eax
  double v171; // xmm1_8
  __int128 v172; // xmm0
  double v173; // xmm2_8
  int v174; // edx
  unsigned int v175; // eax
  double v176; // xmm3_8
  double v177; // xmm0_8
  __int128 v178; // xmm2
  double v179; // xmm1_8
  __int128 v180; // xmm0
  double v181; // xmm2_8
  unsigned int v182; // eax
  double v183; // xmm0_8
  __int128 v184; // xmm2
  double v185; // xmm1_8
  __int128 v186; // xmm0
  double v187; // xmm0_8
  double v188; // xmm3_8
  double v189; // xmm3_8
  int v190; // ecx
  double *v191; // edx
  double v192; // xmm2_8
  unsigned int v193; // eax
  double v194; // xmm1_8
  double v195; // xmm2_8
  double v196; // xmm0_8
  double v197; // xmm2_8
  double *v198; // esi
  double v199; // xmm3_8
  double v200; // xmm4_8
  double v201; // xmm0_8
  double v202; // xmm3_8
  double v203; // xmm0_8
  double v204; // st7
  double v205; // xmm7_8
  double v206; // xmm1_8
  double v207; // xmm3_8
  int v208; // ecx
  double v209; // xmm4_8
  double v210; // xmm5_8
  double v211; // xmm0_8
  double v212; // xmm1_8
  double v213; // xmm3_8
  double v214; // xmm4_8
  double v215; // xmm5_8
  double v216; // xmm6_8
  double v217; // xmm1_8
  double v218; // xmm0_8
  double v219; // xmm3_8
  __int128 v220; // xmm7
  double v221; // xmm3_8
  double v222; // xmm6_8
  double v223; // xmm5_8
  double v224; // xmm4_8
  int v225; // ecx
  double *v226; // esi
  __int128 v227; // xmm0
  __int128 v228; // xmm2
  unsigned int v229; // eax
  double v230; // xmm1_8
  __int128 v231; // xmm0
  double v232; // xmm0_8
  __int128 v233; // xmm2
  int v234; // edx
  unsigned int v235; // eax
  double v236; // xmm3_8
  double v237; // xmm1_8
  __int128 v238; // xmm0
  double v239; // xmm0_8
  __int128 v240; // xmm2
  unsigned int v241; // eax
  double v242; // xmm1_8
  __int128 v243; // xmm0
  double v244; // xmm0_8
  double v245; // xmm3_8
  double v246; // xmm1_8
  int v247; // ecx
  double *v248; // edx
  double v249; // xmm2_8
  unsigned int v250; // eax
  double v251; // xmm1_8
  double v252; // xmm2_8
  double v253; // xmm0_8
  double v254; // xmm4_8
  double v255; // xmm3_8
  double v256; // xmm1_8
  double v257; // xmm7_8
  char *v258; // edx
  int v259; // ecx
  double v260; // xmm6_8
  double v261; // xmm1_8
  double v262; // xmm1_8
  double v263; // xmm6_8
  int v264; // eax
  double v265; // xmm1_8
  double *v266; // edx
  unsigned int v267; // ecx
  __int128 v268; // xmm3
  __int128 v269; // xmm2
  double v270; // xmm1_8
  __int128 v271; // xmm0
  double v272; // xmm2_8
  unsigned int v273; // ecx
  double v274; // xmm2_8
  double v275; // xmm1_8
  __int128 v276; // xmm0
  double v277; // xmm0_8
  unsigned int v278; // ecx
  double v279; // xmm3_8
  double v280; // xmm0_8
  double v281; // xmm2_8
  double v282; // xmm1_8
  double v283; // xmm2_8
  unsigned int v284; // ecx
  double v285; // xmm2_8
  double v286; // xmm1_8
  double v287; // xmm6_8
  unsigned int v288; // ecx
  double v289; // xmm3_8
  double v290; // xmm7_8
  double v291; // xmm2_8
  double v292; // xmm6_8
  double v293; // xmm1_8
  double v294; // xmm4_8
  unsigned int v295; // ecx
  double v296; // xmm4_8
  double v297; // xmm1_8
  double v298; // xmm5_8
  double v299; // xmm2_8
  double v300; // xmm4_8
  double v301; // xmm5_8
  double v302; // xmm0_8
  int v303; // esi
  double v304; // xmm4_8
  double v305; // xmm7_8
  double v306; // xmm5_8
  int v307; // ecx
  char *v308; // edx
  double v309; // xmm1_8
  int v310; // eax
  double *v311; // edx
  unsigned int v312; // ecx
  double v313; // xmm2_8
  double v314; // xmm3_8
  double v315; // xmm1_8
  double v316; // xmm3_8
  unsigned int v317; // ecx
  double v318; // xmm3_8
  double v319; // xmm1_8
  double v320; // xmm5_8
  unsigned int v321; // ecx
  double v322; // xmm1_8
  double v323; // xmm3_8
  double v324; // xmm4_8
  double v325; // xmm5_8
  double v326; // xmm2_8
  double v327; // xmm4_8
  unsigned int v328; // ecx
  double v329; // xmm4_8
  double v330; // xmm2_8
  double v331; // xmm3_8
  double v332; // xmm0_8
  double v333; // xmm1_8
  double v334; // xmm0_8
  double v335; // xmm1_8
  double v336; // xmm1_8
  double v337; // xmm0_8
  double v338; // xmm1_8
  double v339; // xmm1_8
  double v340; // xmm1_8
  double v341; // xmm0_8
  char *result; // eax
  int v343; // [esp+40h] [ebp-450h]
  int v344; // [esp+40h] [ebp-450h]
  int v345; // [esp+40h] [ebp-450h]
  int v346; // [esp+40h] [ebp-450h]
  int v347; // [esp+40h] [ebp-450h]
  int v348; // [esp+40h] [ebp-450h]
  int v349; // [esp+40h] [ebp-450h]
  int v350; // [esp+40h] [ebp-450h]
  int v351; // [esp+40h] [ebp-450h]
  int v352; // [esp+40h] [ebp-450h]
  int v353; // [esp+40h] [ebp-450h]
  int v354; // [esp+40h] [ebp-450h]
  int v355; // [esp+40h] [ebp-450h]
  int v356; // [esp+44h] [ebp-44Ch]
  int v357; // [esp+44h] [ebp-44Ch]
  int v358; // [esp+44h] [ebp-44Ch]
  int v359; // [esp+44h] [ebp-44Ch]
  int v360; // [esp+44h] [ebp-44Ch]
  int v361; // [esp+44h] [ebp-44Ch]
  int v362; // [esp+44h] [ebp-44Ch]
  int v363; // [esp+44h] [ebp-44Ch]
  int v364; // [esp+44h] [ebp-44Ch]
  int v365; // [esp+44h] [ebp-44Ch]
  int v366; // [esp+44h] [ebp-44Ch]
  int v367; // [esp+44h] [ebp-44Ch]
  int v368; // [esp+44h] [ebp-44Ch]
  int v369; // [esp+48h] [ebp-448h]
  int v370; // [esp+48h] [ebp-448h]
  int v371; // [esp+48h] [ebp-448h]
  int v372; // [esp+48h] [ebp-448h]
  int v373; // [esp+48h] [ebp-448h]
  int v374; // [esp+48h] [ebp-448h]
  int v375; // [esp+48h] [ebp-448h]
  int v376; // [esp+48h] [ebp-448h]
  int v377; // [esp+48h] [ebp-448h]
  int v378; // [esp+48h] [ebp-448h]
  int v379; // [esp+48h] [ebp-448h]
  int v380; // [esp+48h] [ebp-448h]
  int v381; // [esp+48h] [ebp-448h]
  char *v382; // [esp+4Ch] [ebp-444h]
  int v383; // [esp+4Ch] [ebp-444h]
  int v384; // [esp+4Ch] [ebp-444h]
  int v385; // [esp+4Ch] [ebp-444h]
  int v386; // [esp+4Ch] [ebp-444h]
  int v387; // [esp+4Ch] [ebp-444h]
  int v388; // [esp+4Ch] [ebp-444h]
  int v389; // [esp+4Ch] [ebp-444h]
  int v390; // [esp+4Ch] [ebp-444h]
  int v391; // [esp+4Ch] [ebp-444h]
  int v392; // [esp+4Ch] [ebp-444h]
  int v393; // [esp+4Ch] [ebp-444h]
  int v394; // [esp+4Ch] [ebp-444h]
  double v395; // [esp+50h] [ebp-440h]
  double v396; // [esp+50h] [ebp-440h]
  double v397; // [esp+50h] [ebp-440h]
  double v398; // [esp+50h] [ebp-440h]
  int v399; // [esp+5Ch] [ebp-434h]
  int v400; // [esp+64h] [ebp-42Ch]
  double v401; // [esp+68h] [ebp-428h]
  double v402; // [esp+68h] [ebp-428h]
  double v403; // [esp+68h] [ebp-428h]
  double v404; // [esp+68h] [ebp-428h]
  double v405; // [esp+68h] [ebp-428h]
  int v406; // [esp+74h] [ebp-41Ch]
  unsigned int v407; // [esp+74h] [ebp-41Ch]
  int v408; // [esp+74h] [ebp-41Ch]
  double v409; // [esp+78h] [ebp-418h]
  double v410; // [esp+78h] [ebp-418h]
  double v411; // [esp+78h] [ebp-418h]
  double v412; // [esp+80h] [ebp-410h]
  double v413; // [esp+80h] [ebp-410h]
  double v414; // [esp+80h] [ebp-410h]
  double v415; // [esp+88h] [ebp-408h]
  double v416; // [esp+88h] [ebp-408h]
  double v417; // [esp+88h] [ebp-408h]
  double v418; // [esp+88h] [ebp-408h]
  unsigned int v419; // [esp+94h] [ebp-3FCh]
  int v420; // [esp+94h] [ebp-3FCh]
  double v421; // [esp+98h] [ebp-3F8h]
  double v422; // [esp+98h] [ebp-3F8h]
  double v423; // [esp+98h] [ebp-3F8h]
  double v424; // [esp+98h] [ebp-3F8h]
  double v425; // [esp+98h] [ebp-3F8h]
  double v426; // [esp+A0h] [ebp-3F0h]
  double v427; // [esp+A0h] [ebp-3F0h]
  double v428; // [esp+A0h] [ebp-3F0h]
  double v429; // [esp+A0h] [ebp-3F0h]
  double v430; // [esp+A0h] [ebp-3F0h]
  double v431; // [esp+A8h] [ebp-3E8h]
  double v432; // [esp+A8h] [ebp-3E8h]
  double v433; // [esp+A8h] [ebp-3E8h]
  int v434; // [esp+B0h] [ebp-3E0h]
  double *v435; // [esp+B0h] [ebp-3E0h]
  double v436; // [esp+B0h] [ebp-3E0h]
  unsigned __int64 v437; // [esp+B8h] [ebp-3D8h]
  double v438; // [esp+B8h] [ebp-3D8h]
  double v439; // [esp+B8h] [ebp-3D8h]
  double v440; // [esp+B8h] [ebp-3D8h]
  double v441; // [esp+B8h] [ebp-3D8h]
  double v442; // [esp+C0h] [ebp-3D0h]
  double v443; // [esp+C0h] [ebp-3D0h]
  double v444; // [esp+C0h] [ebp-3D0h]
  double v445; // [esp+C0h] [ebp-3D0h]
  double v446; // [esp+C0h] [ebp-3D0h]
  double v447; // [esp+C0h] [ebp-3D0h]
  double v448; // [esp+C0h] [ebp-3D0h]
  int v449; // [esp+C8h] [ebp-3C8h]
  int v450; // [esp+C8h] [ebp-3C8h]
  int v451; // [esp+C8h] [ebp-3C8h]
  double v452; // [esp+C8h] [ebp-3C8h]
  double v453; // [esp+D0h] [ebp-3C0h]
  double v454; // [esp+D0h] [ebp-3C0h]
  double v455; // [esp+D0h] [ebp-3C0h]
  double v456; // [esp+D0h] [ebp-3C0h]
  double v457; // [esp+D0h] [ebp-3C0h]
  double v458; // [esp+D0h] [ebp-3C0h]
  double v459; // [esp+D0h] [ebp-3C0h]
  double v460; // [esp+D8h] [ebp-3B8h]
  double v461; // [esp+E0h] [ebp-3B0h]
  double v462; // [esp+E0h] [ebp-3B0h]
  double v463; // [esp+E0h] [ebp-3B0h]
  double v464; // [esp+E0h] [ebp-3B0h]
  double v465; // [esp+E8h] [ebp-3A8h]
  double v466; // [esp+E8h] [ebp-3A8h]
  double v467; // [esp+E8h] [ebp-3A8h]
  double v468; // [esp+E8h] [ebp-3A8h]
  double v469; // [esp+E8h] [ebp-3A8h]
  double v470; // [esp+E8h] [ebp-3A8h]
  double v471; // [esp+F0h] [ebp-3A0h]
  double v472; // [esp+F0h] [ebp-3A0h]
  double v473; // [esp+F0h] [ebp-3A0h]
  double v474; // [esp+F0h] [ebp-3A0h]
  __int64 v475; // [esp+F0h] [ebp-3A0h]
  double v476; // [esp+F8h] [ebp-398h]
  double v477; // [esp+F8h] [ebp-398h]
  double v478; // [esp+F8h] [ebp-398h]
  double v479; // [esp+F8h] [ebp-398h]
  double v480; // [esp+F8h] [ebp-398h]
  double v481; // [esp+F8h] [ebp-398h]
  double v482; // [esp+100h] [ebp-390h]
  double v483; // [esp+100h] [ebp-390h]
  double v484; // [esp+100h] [ebp-390h]
  double v485; // [esp+100h] [ebp-390h]
  double v486; // [esp+100h] [ebp-390h]
  double v487; // [esp+108h] [ebp-388h]
  double v488; // [esp+108h] [ebp-388h]
  double v489; // [esp+110h] [ebp-380h]
  double v490; // [esp+110h] [ebp-380h]
  double v491; // [esp+110h] [ebp-380h]
  double v492; // [esp+118h] [ebp-378h]
  double v493; // [esp+118h] [ebp-378h]
  double v494; // [esp+118h] [ebp-378h]
  double v495; // [esp+118h] [ebp-378h]
  int v496; // [esp+120h] [ebp-370h]
  int v497; // [esp+120h] [ebp-370h]
  double v498; // [esp+120h] [ebp-370h]
  double v499; // [esp+128h] [ebp-368h]
  double v500; // [esp+128h] [ebp-368h]
  double v501; // [esp+130h] [ebp-360h]
  double v502; // [esp+138h] [ebp-358h]
  double v503; // [esp+138h] [ebp-358h]
  double v504; // [esp+138h] [ebp-358h]
  double v505; // [esp+140h] [ebp-350h]
  double v506; // [esp+140h] [ebp-350h]
  double v507; // [esp+148h] [ebp-348h]
  double v508; // [esp+148h] [ebp-348h]
  double v509; // [esp+148h] [ebp-348h]
  double v510; // [esp+148h] [ebp-348h]
  double v511; // [esp+148h] [ebp-348h]
  double v512; // [esp+150h] [ebp-340h]
  double v513; // [esp+150h] [ebp-340h]
  double v514; // [esp+150h] [ebp-340h]
  double v515; // [esp+158h] [ebp-338h]
  double v516; // [esp+158h] [ebp-338h]
  double v517; // [esp+158h] [ebp-338h]
  double v518; // [esp+160h] [ebp-330h]
  double v519; // [esp+160h] [ebp-330h]
  double v520; // [esp+160h] [ebp-330h]
  double v521; // [esp+160h] [ebp-330h]
  double v522; // [esp+168h] [ebp-328h] BYREF
  double v523; // [esp+170h] [ebp-320h]
  double v524; // [esp+178h] [ebp-318h]
  double v525; // [esp+180h] [ebp-310h]
  double v526; // [esp+188h] [ebp-308h]
  double v527; // [esp+190h] [ebp-300h]
  double v528; // [esp+198h] [ebp-2F8h]
  double v529; // [esp+1A0h] [ebp-2F0h]
  double v530; // [esp+1A8h] [ebp-2E8h]
  double v531; // [esp+1B0h] [ebp-2E0h]
  double v532; // [esp+1B8h] [ebp-2D8h]
  double v533; // [esp+1C0h] [ebp-2D0h]
  unsigned __int64 v534; // [esp+1C8h] [ebp-2C8h]
  double v535; // [esp+1D0h] [ebp-2C0h]
  double v536; // [esp+1D8h] [ebp-2B8h]
  double v537; // [esp+1E0h] [ebp-2B0h]
  double v538; // [esp+1E8h] [ebp-2A8h]
  double v539; // [esp+1F0h] [ebp-2A0h]
  double v540; // [esp+1F8h] [ebp-298h]
  double v541; // [esp+200h] [ebp-290h]
  double v542; // [esp+208h] [ebp-288h]
  double v543; // [esp+210h] [ebp-280h]
  double v544; // [esp+218h] [ebp-278h]
  double v545; // [esp+220h] [ebp-270h]
  double v546; // [esp+228h] [ebp-268h]
  double v547; // [esp+230h] [ebp-260h]
  double v548; // [esp+238h] [ebp-258h]
  double v549; // [esp+240h] [ebp-250h]
  double v550; // [esp+248h] [ebp-248h]
  double v551; // [esp+250h] [ebp-240h]
  double v552; // [esp+258h] [ebp-238h]
  double v553; // [esp+260h] [ebp-230h]
  double v554; // [esp+268h] [ebp-228h]
  double v555; // [esp+270h] [ebp-220h]
  double v556; // [esp+278h] [ebp-218h]
  double v557; // [esp+280h] [ebp-210h]
  double v558; // [esp+288h] [ebp-208h]
  int v559; // [esp+290h] [ebp-200h]
  int v560; // [esp+294h] [ebp-1FCh]
  double v561; // [esp+298h] [ebp-1F8h]
  double v562; // [esp+2A0h] [ebp-1F0h]
  double v563; // [esp+2A8h] [ebp-1E8h] BYREF
  double v564; // [esp+2B0h] [ebp-1E0h]
  double v565; // [esp+2B8h] [ebp-1D8h]
  double v566; // [esp+2C0h] [ebp-1D0h]
  double v567; // [esp+2C8h] [ebp-1C8h]
  double v568; // [esp+2D0h] [ebp-1C0h]
  double v569; // [esp+2D8h] [ebp-1B8h]
  double v570; // [esp+2E0h] [ebp-1B0h]
  double v571; // [esp+2E8h] [ebp-1A8h]
  double v572; // [esp+2F0h] [ebp-1A0h] BYREF
  double v573; // [esp+2F8h] [ebp-198h]
  double v574; // [esp+300h] [ebp-190h]
  double v575; // [esp+308h] [ebp-188h]
  double v576; // [esp+310h] [ebp-180h]
  double v577; // [esp+318h] [ebp-178h]
  double v578; // [esp+320h] [ebp-170h]
  double v579; // [esp+328h] [ebp-168h]
  double v580; // [esp+330h] [ebp-160h]
  double v581; // [esp+338h] [ebp-158h] BYREF
  double v582; // [esp+340h] [ebp-150h]
  double v583; // [esp+348h] [ebp-148h]
  double v584; // [esp+350h] [ebp-140h]
  double v585; // [esp+358h] [ebp-138h]
  double v586; // [esp+360h] [ebp-130h]
  double v587; // [esp+368h] [ebp-128h]
  double v588; // [esp+370h] [ebp-120h]
  double v589; // [esp+378h] [ebp-118h]
  double v590; // [esp+380h] [ebp-110h]
  double v591; // [esp+388h] [ebp-108h]
  double v592; // [esp+390h] [ebp-100h]
  double v593; // [esp+398h] [ebp-F8h]
  double v594; // [esp+3A0h] [ebp-F0h]
  double v595; // [esp+3A8h] [ebp-E8h]
  double v596; // [esp+3B0h] [ebp-E0h]
  double v597; // [esp+3B8h] [ebp-D8h]
  double v598; // [esp+3C0h] [ebp-D0h]
  double v599; // [esp+3C8h] [ebp-C8h]
  double v600; // [esp+3D0h] [ebp-C0h]
  _DWORD v601[40]; // [esp+3D8h] [ebp-B8h] BYREF
  int v602; // [esp+478h] [ebp-18h]
  double v603; // [esp+480h] [ebp-10h]

  v356 = a2;
  v343 = a1;
  v382 = a4;
  *(_QWORD *)(a3 + 24) = 0i64;
  v400 = *(_DWORD *)(a7 + 32);
  sub_405EB0((int)v601, v400, a3 + 24, qword_43E0E8);
  v7 = *(_DWORD *)(a7 + 20);
  v369 = v7;
  v552 = *(double *)(v7 + 56);
  sub_406C30(*(_QWORD *)a3, *(double *)(a3 + 8), *(double *)(a3 + 16), &v522);
  v8 = (int *)(v7 + 48);
  if ( *(_DWORD *)(v7 + 48) < *(_DWORD *)(v7 + 52) )
    v8 = (int *)(v7 + 52);
  v460 = (double)*v8;
  *(double *)&v534 = *(double *)(a3 + 64) * v460;
  sub_406E50(&v522, &v563, (double *)a3);
  sub_407120(&v522, &v581, (double *)a3);
  sub_407400(&v522, &v572, (double *)a3);
  memset(a4, 0, 8 * a6 * a5);
  v9 = *(_DWORD *)(v7 + 24);
  v10 = v530;
  v496 = *(_DWORD *)(v7 + 204);
  v399 = 0;
  v560 = *(_DWORD *)(v7 + 16);
  v559 = v9;
  v449 = 0;
  v11 = v524;
  if ( v560 > 0 )
  {
    v12 = 0;
    v13 = -*(double *)&v534;
    v406 = 0;
    v14 = (double *)(a4 + 16);
    v15 = -*(double *)&v534 * v524;
    v412 = v589 * *(double *)&v534;
    v16 = -*(double *)&v534 * v530;
    v17 = v524 * *(double *)&v534;
    v421 = v583 * *(double *)&v534;
    v18 = v530 * *(double *)&v534;
    v476 = -*(double *)&v534;
    v536 = v580 * *(double *)&v534;
    v482 = v15;
    v532 = v524 * *(double *)&v534;
    v545 = v16;
    v442 = v574 * *(double *)&v534;
    v543 = v530 * *(double *)&v534;
    v453 = v530 * v460;
    v465 = v524 * v460;
    v471 = v571 * *(double *)&v534;
    v531 = v565 * *(double *)&v534;
    v507 = v568 * *(double *)&v534;
    v537 = v586 * *(double *)&v534;
    v489 = v577 * *(double *)&v534;
    v395 = v527 * v460;
    v415 = v552 * -1.0;
    do
    {
      v19 = (double *)(v12 + *(_DWORD *)(v7 + 108));
      v20 = v523 * v19[1];
      v21 = v522 * *v19;
      v19[2] = v13;
      v492 = v21 + v20 + v15;
      v426 = v528 * *v19 + v529 * v19[1] + v16;
      v409 = sub_406A70((int)v601, -4.0, 0.0, -1.0, 1.0e-10, v492, v17, v426, v18);
      v461 = v409 * v492 - v532;
      v22 = sub_4060D0(v601, v603 * v461);
      v23 = v19[1];
      v24 = *v19;
      v25 = v19[2];
      v427 = v426 - v22 * v492;
      v26 = -(((v587 * v24 + v588 * v23 + v25 * v589) * v409
             - v412
             - ((v581 * v24 + v582 * v23 + v25 * v583) * v409 - v421) * v22)
            / v427);
      v401 = -(((v578 * v24 + v579 * v23 + v25 * v580) * v409
              - v536
              - ((v572 * v24 + v573 * v23 + v25 * v574) * v409 - v442) * v22)
             / v427);
      v493 = -((-(v409 * v530 * v460) - v453 - (-(v409 * v524 * v460) - v465) * v22) / v427);
      *(v14 - 2) = -(((v569 * *v19 + v570 * v23 + v25 * v571) * v409
                    - v471
                    - ((*v19 * v563 + v23 * v564 + v565 * v25) * v409 - v531) * v22)
                   / v427)
                 * (*v19 * v525 + v23 * v526 + v527 * v25)
                 + (*v19 * v566 + v23 * v567 + v568 * v25) * v409
                 - v507;
      v27 = 1;
      v28 = v527;
      v29 = (*v19 * v525 + v19[1] * v526 + v527 * v19[2]) * v26;
      v30 = v526;
      *(v14 - 1) = (*v19 * v584 + v19[1] * v585 + v586 * v19[2]) * v409 + v29 - v537;
      v31 = (*v19 * v575 + v19[1] * v576 + v577 * v19[2]) * v409;
      v32 = v525;
      v33 = *v19 * v525 + v19[1] * v30 + v28 * v19[2];
      v14[1] = 0.0;
      *v14 = v31 + v33 * v401 - v489;
      v34 = v32 * *v19 + v30 * v19[1] + v28 * v19[2];
      if ( v400 >= 1 )
      {
        v35 = v14 + 2;
        do
        {
          *((_QWORD *)&v36 + 1) = 0i64;
          *(double *)&v36 = v461 * *(double *)&qword_43E0E8;
          v37 = v27;
          if ( v27 < 0 )
            v37 = -v27;
          v38 = 1.0;
          while ( 1 )
          {
            if ( (v37 & 1) != 0 )
              v38 = v38 * *(double *)&v36;
            v37 >>= 1;
            if ( !v37 )
              break;
            *((_QWORD *)&v39 + 1) = *((_QWORD *)&v36 + 1);
            *(double *)&v39 = *(double *)&v36 * *(double *)&v36;
            v36 = v39;
          }
          if ( v27 >= 0 )
            v40 = v38;
          else
            v40 = 1.0 / v38;
          ++v27;
          *v35++ = v40 / *(double *)&qword_43E0E8 / v427 * v34;
        }
        while ( v27 <= v400 );
        v28 = v527;
      }
      v41 = v30 * v19[1];
      v17 = v532;
      v15 = v482;
      v18 = v543;
      v42 = v525 * *v19 + v41;
      v43 = v28 * v19[2];
      v7 = v369;
      v44 = v42 + v43;
      v45 = v28 * v409;
      v16 = v545;
      v14[6] = v44 * v493 - v45 * v460 - v395;
      v13 = v476;
      v46 = *(_DWORD *)(*(_DWORD *)(v369 + 120) + 4 * v449++);
      *(double *)&a4[8 * v399 + 8 * v496 + 8 * v46] = v415;
      v399 += a5;
      v14 += a5;
      v12 = v406 + 32;
      v406 += 32;
    }
    while ( v449 < v560 );
    v11 = v524;
    v10 = v530;
  }
  v47 = 0;
  v407 = 0;
  if ( (*(_DWORD *)(v7 + 160) - *(_DWORD *)(v7 + 156)) / 12 )
  {
    v48 = 0;
    v450 = 0;
    while ( 1 )
    {
      v419 = 0;
      v49 = (_DWORD *)(*(_DWORD *)(v369 + 156) + v48);
      if ( (v49[1] - *v49) / 40 )
      {
        v50 = v11;
        v51 = v10 * COERCE_DOUBLE(v534 ^ 0x8000000000000000ui64);
        v434 = 0;
        v536 = v571 * COERCE_DOUBLE(v534 ^ 0x8000000000000000ui64);
        v52 = &a4[8 * v399 + 16];
        v53 = v11 * COERCE_DOUBLE(v534 ^ 0x8000000000000000ui64);
        v54 = v50 * *(double *)&v534;
        v443 = v571 * *(double *)&v534;
        v55 = v10 * *(double *)&v534;
        v477 = v54;
        v466 = v589 * COERCE_DOUBLE(v534 ^ 0x8000000000000000ui64);
        v553 = v51;
        v555 = v55;
        v554 = v53;
        v472 = v589 * *(double *)&v534;
        v508 = v580 * COERCE_DOUBLE(v534 ^ 0x8000000000000000ui64);
        v483 = v580 * *(double *)&v534;
        v545 = v530 * v460;
        v422 = v565 * COERCE_DOUBLE(v534 ^ 0x8000000000000000ui64);
        v532 = v565 * *(double *)&v534;
        v454 = v583 * COERCE_DOUBLE(v534 ^ 0x8000000000000000ui64);
        v537 = v583 * *(double *)&v534;
        v531 = v574 * COERCE_DOUBLE(v534 ^ 0x8000000000000000ui64);
        v416 = v524 * v460;
        v490 = v574 * *(double *)&v534;
        v557 = v552 * -1.0;
        do
        {
          v396 = *(double *)(v369 + 64);
          v413 = *(double *)(*v49 + v434 + 8) - *(double *)(v369 + 32);
          v402 = *(double *)(*v49 + v434 + 16) - *(double *)(v369 + 40);
          v462 = v523 * v402 + v522 * v413 + v53;
          v499 = v529 * v402 + v528 * v413 + v51;
          v494 = sub_406A70((int)v601, -4.0, 0.0, -1.0, 1.0e-10, v462, v54, v499, v55);
          v56 = (v564 * v402 + v563 * v413 + v422) * v494;
          v561 = (v582 * v402 + v581 * v413 + v454) * v494;
          v543 = v561 - v537;
          v57 = v602 - 1;
          v558 = (v573 * v402 + v572 * v413 + v531) * v494;
          v58 = 0.0;
          v556 = v558 - v490;
          v562 = v494 * v524 * v460;
          v59 = (v579 * v402 + v578 * v413 + v508) * v494 - v483;
          v60 = v462;
          v61 = v494 * v462 - v477;
          v538 = v61;
          if ( v602 - 1 >= 0 )
          {
            if ( v602 >= 4 )
            {
              do
              {
                v58 = (((v58 * (v603 * v538) + *(double *)&v601[2 * v57 + 20]) * (v603 * v538)
                      + *(double *)&v601[2 * v57 + 18])
                     * (v603
                      * v538)
                     + *(double *)&v601[2 * v57 + 16])
                    * (v603
                     * v538)
                    + *(double *)&v601[2 * v57 + 14];
                v57 -= 4;
              }
              while ( v57 >= 3 );
              v61 = v538;
            }
            for ( ; v57 >= 0; --v57 )
              v58 = v58 * (v603 * v61) + *(double *)&v601[2 * v57 + 20];
          }
          v62 = 1;
          v63 = v499 - v58 * v462;
          v428 = -((-(v494 * v530 * v460) - v545 - v58 * (-(v494 * v524 * v460) - v416)) / v63);
          v64 = (v570 * v402 + v569 * v413 + v536) * v494 - v443 - v58 * (v56 - v532);
          v65 = v58;
          v66 = v58 * v556;
          v67 = (v588 * v402 + v587 * v413 + v466) * v494 - v472 - v65 * v543;
          *((_QWORD *)v52 + 1) = 0i64;
          v68 = -(v64 / v63) * v462 + v56;
          v69 = v396;
          v70 = -((v59 - v66) / v63) * v462 + v558;
          v71 = -(v67 / v63) * v462 + v561;
          *((double *)v52 - 2) = (v68 - v532) * v396;
          v72 = (v71 - v537) * v396;
          *(double *)v52 = (v70 - v490) * v396;
          *((double *)v52 - 1) = v72;
          if ( v400 >= 1 )
          {
            v73 = *(unsigned __int64 *)&v538;
            v74 = (double *)(v52 + 16);
            v75 = v63;
            do
            {
              *((_QWORD *)&v76 + 1) = *((_QWORD *)&v73 + 1);
              *(double *)&v76 = *(double *)&v73 * *(double *)&qword_43E0E8;
              v77 = v62;
              if ( v62 < 0 )
                v77 = -v62;
              v78 = 1.0;
              while ( 1 )
              {
                if ( (v77 & 1) != 0 )
                  v78 = v78 * *(double *)&v76;
                v77 >>= 1;
                if ( !v77 )
                  break;
                *((_QWORD *)&v79 + 1) = *((_QWORD *)&v76 + 1);
                *(double *)&v79 = *(double *)&v76 * *(double *)&v76;
                v76 = v79;
              }
              if ( v62 >= 0 )
                v80 = v78;
              else
                v80 = 1.0 / v78;
              ++v62;
              *v74++ = v80 / *(double *)&qword_43E0E8 / v75 * (v462 * v396);
            }
            while ( v62 <= v400 );
            v60 = v462;
            v69 = v396;
          }
          v81 = v69 * v557;
          ++v419;
          v54 = v477;
          v53 = v554;
          v434 += 40;
          *((double *)v52 + 6) = v60 * v428 - v562 - v416;
          v51 = v553;
          *(double *)&a4[8 * v399 + 8 * v496 + 8 * v407 + 8 * *(_DWORD *)(v369 + 8)] = v81;
          v49 = (_DWORD *)(*(_DWORD *)(v369 + 156) + v450);
          v399 += a5;
          v55 = v555;
          v52 += 8 * a5;
        }
        while ( v419 < (v49[1] - *v49) / 40 );
        v47 = v407;
      }
      ++v47;
      v48 = v450 + 12;
      v407 = v47;
      v450 += 12;
      if ( v47 >= (*(_DWORD *)(v369 + 160) - *(_DWORD *)(v369 + 156)) / 12 )
        break;
      v11 = v524;
      v10 = v530;
    }
  }
  v82 = 0;
  v408 = 0;
  v83 = v399 + a5 * v559;
  v420 = v83;
  if ( v559 > 0 )
  {
    v84 = -*(double *)&v534;
    v85 = -*(double *)&v534 * v530;
    v86 = -*(double *)&v534 * v524;
    v87 = v524 * *(double *)&v534;
    v547 = v565 * *(double *)&v534;
    v88 = v530 * *(double *)&v534;
    v537 = -*(double *)&v534;
    v555 = v571 * *(double *)&v534;
    v552 = v86;
    v533 = v524 * *(double *)&v534;
    v532 = v85;
    v550 = v583 * *(double *)&v534;
    v495 = v530 * *(double *)&v534;
    v554 = v589 * *(double *)&v534;
    v551 = v574 * *(double *)&v534;
    v553 = v580 * *(double *)&v534;
    v546 = v524 * v460;
    v557 = v530 * v460;
    v562 = v568 * *(double *)&v534;
    v558 = v586 * *(double *)&v534;
    v556 = v577 * *(double *)&v534;
    v561 = v527 * v460;
    v543 = v527 * *(double *)&v534;
    do
    {
      v89 = v82 + v560 + 2 * v82;
      v451 = 32 * v89;
      v90 = (double *)(32 * v89 + *(_DWORD *)(v369 + 108));
      v435 = v90;
      v90[2] = v84;
      v463 = *v90 * v522 + v90[1] * v523 + v86;
      v538 = v528 * *v90 + v529 * v90[1] + v85;
      v91 = sub_406A70((int)v601, -4.0, 0.0, -1.0, 1.0e-10, v463, v87, v538, v88);
      v92 = v90[1];
      v93 = v90[2];
      v444 = (v563 * *v90 + v564 * v92 + v565 * v93) * v91;
      v94 = (v569 * *v90 + v570 * v92 + v571 * v93) * v91 - v555;
      v455 = (v581 * *v90 + v582 * v92 + v583 * v93) * v91;
      v95 = v602 - 1;
      v96 = (v587 * *v90 + v588 * v92 + v589 * v93) * v91 - v554;
      v467 = (v572 * *v90 + v573 * v92 + v574 * v93) * v91;
      v97 = 0.0;
      v98 = (v578 * *v90 + v579 * v92 + v580 * v93) * v91 - v553;
      v536 = -(v91 * v524 * v460) - v546;
      v99 = v91 * v463 - v533;
      *(double *)&v534 = v99;
      if ( v602 - 1 >= 0 )
      {
        if ( v602 >= 4 )
        {
          do
          {
            v97 = (((v97 * (v603 * *(double *)&v534) + *(double *)&v601[2 * v95 + 20]) * (v603 * *(double *)&v534)
                  + *(double *)&v601[2 * v95 + 18])
                 * (v603
                  * *(double *)&v534)
                 + *(double *)&v601[2 * v95 + 16])
                * (v603
                 * *(double *)&v534)
                + *(double *)&v601[2 * v95 + 14];
            v95 -= 4;
          }
          while ( v95 >= 3 );
          v99 = *(double *)&v534;
        }
        for ( ; v95 >= 0; --v95 )
          v97 = v97 * (v603 * v99) + *(double *)&v601[2 * v95 + 20];
      }
      v538 = v538 - v97 * v463;
      v100 = -((v94 - v97 * (v444 - v547)) / v538);
      v101 = -((v96 - v97 * (v455 - v550)) / v538);
      v102 = -((v98 - v97 * (v467 - v551)) / v538);
      v103 = -((-(v91 * v530 * v460) - v557 - v97 * v536) / v538);
      *(double *)&v437 = *v90 * v522 + v92 * v523 + v90[2] * v524;
      v423 = *(double *)&v437 * v100 + v444 - v547;
      v445 = *(double *)&v437 * v101 + v455 - v550;
      v509 = *(double *)&v437 * v103 - v91 * v524 * v460 - v546;
      v456 = *(double *)&v437 * v102 + v467 - v551;
      v431 = v525 * *v90 + v526 * v92 + v527 * v90[2];
      v410 = (v566 * *v90 + v567 * v92 + v568 * v90[2]) * v91 + v431 * v100 - v562;
      v487 = (v584 * *v90 + v585 * v92 + v586 * v90[2]) * v91 + v431 * v101 - v558;
      v104 = v431 * v103;
      v105 = v575 * *v90 + v576 * v90[1];
      v106 = v577 * v90[2];
      v107 = v400;
      v108 = (v105 + v106) * v91 + v431 * v102;
      v432 = v431 * v91 - v543;
      v429 = v108 - v556;
      v112 = v437;
      v109 = 0.0;
      v110 = 0.0;
      v111 = 0.0;
      *(double *)&v112 = *(double *)&v437 * v91 - v533;
      v491 = v104 - v527 * v91 * v460 - v561;
      v438 = *(double *)&v112;
      if ( v400 >= 1 )
      {
        *((_QWORD *)&v113 + 1) = *((_QWORD *)&v112 + 1);
        *(double *)&v113 = *(double *)&v112 * *(double *)&qword_43E0E8;
        *((_QWORD *)&v116 + 1) = 0i64;
        v114 = 0;
        v115 = (double *)(a3 + 32);
        *(double *)&v116 = *(double *)&qword_43E0E8 * 0.0;
        v403 = *(double *)&v112 * *(double *)&qword_43E0E8 * 0.5;
        do
        {
          v117 = v116;
          v118 = v114;
          if ( v114 < 0 )
            v118 = -v114;
          v119 = 1.0;
          while ( 1 )
          {
            if ( (v118 & 1) != 0 )
              v119 = v119 * *(double *)&v117;
            v118 >>= 1;
            if ( !v118 )
              break;
            *((_QWORD *)&v120 + 1) = *((_QWORD *)&v117 + 1);
            *(double *)&v120 = *(double *)&v117 * *(double *)&v117;
            v117 = v120;
          }
          if ( v114 >= 0 )
            v121 = v119;
          else
            v121 = 1.0 / v119;
          v122 = v114 + 1;
          v123 = v114;
          v124 = (double)(v114 + 1) * *v115;
          v125 = v124 * v121;
          v126 = *(unsigned __int64 *)&v403;
          v110 = v125 + v110;
          if ( v114 < 0 )
            v123 = -v114;
          v127 = 1.0;
          while ( 1 )
          {
            if ( (v123 & 1) != 0 )
              v127 = v127 * *(double *)&v126;
            v123 >>= 1;
            if ( !v123 )
              break;
            *((_QWORD *)&v128 + 1) = *((_QWORD *)&v126 + 1);
            *(double *)&v128 = *(double *)&v126 * *(double *)&v126;
            v126 = v128;
          }
          if ( v114 >= 0 )
            v129 = v127;
          else
            v129 = 1.0 / v127;
          v130 = v114;
          v131 = v124 * v129;
          v132 = v113;
          v109 = v131 + v109;
          if ( v114 < 0 )
            v130 = -v114;
          v133 = 1.0;
          while ( 1 )
          {
            if ( (v130 & 1) != 0 )
              v133 = v133 * *(double *)&v132;
            v130 >>= 1;
            if ( !v130 )
              break;
            *((_QWORD *)&v134 + 1) = *((_QWORD *)&v132 + 1);
            *(double *)&v134 = *(double *)&v132 * *(double *)&v132;
            v132 = v134;
          }
          if ( v114 >= 0 )
            v135 = v133;
          else
            v135 = 1.0 / v133;
          v116 = COERCE_UNSIGNED_INT64(*(double *)&qword_43E0E8 * 0.0);
          ++v114;
          ++v115;
          v111 = v111 + v124 * v135;
        }
        while ( v122 + 1 <= v400 );
        v107 = v400;
      }
      v502 = *(double *)libm_sse2_sqrt_precise(v343, v356, v369, v382).m128_u64 * 4.0;
      v503 = v502 + *(double *)libm_sse2_sqrt_precise(v344, v357, v370, v383).m128_u64;
      v136 = 0.0;
      v504 = (v503 + *(double *)libm_sse2_sqrt_precise(v345, v358, v371, v384).m128_u64) * (v438 / 6.0);
      if ( v107 >= 1 )
      {
        v137 = v438 * *(double *)&qword_43E0E8;
        v138 = 0;
        v139 = (double *)(a3 + 32);
        v439 = v438 * *(double *)&qword_43E0E8;
        do
        {
          v140 = v137;
          v141 = v138;
          if ( v138 < 0 )
            v141 = -v138;
          v142 = 1.0;
          while ( 1 )
          {
            if ( (v141 & 1) != 0 )
              v142 = v142 * v140;
            v141 >>= 1;
            if ( !v141 )
              break;
            v140 = v140 * v140;
          }
          if ( v138 >= 0 )
            v143 = v142;
          else
            v143 = 1.0 / v142;
          v137 = v439;
          v144 = (double)++v138 * *v139++;
          v136 = v136 + v144 * v143;
        }
        while ( v138 + 1 <= v107 );
      }
      v536 = *(double *)libm_sse2_sqrt_precise(v346, v359, v372, v385).m128_u64;
      v497 = *(_DWORD *)(v373 + 108);
      v531 = v536 * v423;
      v145 = *(double *)(v451 + v497 + 32);
      v146 = v145 * v528;
      v473 = v536 * v445;
      v147 = v145 * v522;
      v468 = v536 * v456;
      v148 = *(double *)(v451 + v497 + 40);
      v594 = v536 * v509;
      *(double *)(v451 + v497 + 48) = v537;
      v397 = v147 + v148 * v523 + v552;
      v541 = v146 + v148 * v529 + v532;
      v505 = sub_406A70((int)v601, -4.0, 0.0, -1.0, 1.0e-10, v397, v533, v541, v495);
      v149 = *(double *)(v451 + v497 + 40);
      v150 = *(double *)(v451 + v497 + 48);
      v440 = *(double *)(v451 + v497 + 32);
      v457 = (v440 * v563 + v149 * v564 + v150 * v565) * v505;
      v151 = v602 - 1;
      v510 = (v440 * v581 + v149 * v582 + v150 * v583) * v505;
      v478 = (v440 * v572 + v149 * v573 + v150 * v574) * v505;
      v152 = v397;
      v539 = -(v505 * v530 * v460) - v557;
      v153 = 0.0;
      v154 = v505 * v397 - v533;
      v464 = v154;
      if ( v602 - 1 >= 0 )
      {
        if ( v602 >= 4 )
        {
          do
          {
            v153 = (((v153 * (v603 * v154) + *(double *)&v601[2 * v151 + 20]) * (v603 * v154)
                   + *(double *)&v601[2 * v151 + 18])
                  * (v603
                   * v154)
                  + *(double *)&v601[2 * v151 + 16])
                 * (v603
                  * v154)
                 + *(double *)&v601[2 * v151 + 14];
            v151 -= 4;
          }
          while ( v151 >= 3 );
          v152 = v397;
          v154 = v505 * v397 - v533;
        }
        for ( ; v151 >= 0; --v151 )
          v153 = v153 * (v603 * v154) + *(double *)&v601[2 * v151 + 20];
      }
      v541 = v541 - v152 * v153;
      v155 = -(((v440 * v569 + v149 * v570 + v150 * v571) * v505 - v555 - (v457 - v547) * v153) / v541);
      v156 = -(((v440 * v587 + v149 * v588 + v589 * v150) * v505 - v554 - (v510 - v550) * v153) / v541);
      v157 = -(((v578 * v440 + v579 * v149 + v580 * v150) * v505 - v553 - (v478 - v551) * v153) / v541);
      v539 = -((v539 - (-(v505 * v524 * v460) - v546) * v153) / v541);
      v160 = *(unsigned __int64 *)&v440;
      v446 = (v440 * v522 + v149 * v523 + v150 * v524) * v155 + v457 - v547;
      v458 = (v440 * v522 + v149 * v523 + v150 * v524) * v156 + v510 - v550;
      v479 = (v440 * v522 + v149 * v523 + v150 * v524) * v157 + v478 - v551;
      v484 = (v440 * v522 + v149 * v523 + v150 * v524) * v539 - v505 * v524 * v460 - v546;
      v158 = v440 * v525 + v149 * v526 + v150 * v527;
      v159 = v400;
      v540 = (v440 * v566 + v149 * v567 + v150 * v568) * v505 + v155 * v158 - v562;
      *(double *)&v160 = (v440 * v522 + v149 * v523 + v150 * v524) * v505 - v533;
      v424 = *(double *)&v160;
      v500 = (v440 * v584 + v149 * v585 + v150 * v586) * v505 + v156 * v158 - v558;
      v441 = (v440 * v575 + v149 * v576 + v150 * v577) * v505 + v157 * v158 - v556;
      v161 = v527 * v505 * v460;
      v506 = v505 * v158 - v543;
      v162 = 0.0;
      v163 = 0.0;
      v539 = v539 * v158 - v161 - v561;
      v164 = 0.0;
      if ( v400 >= 1 )
      {
        *((_QWORD *)&v165 + 1) = *((_QWORD *)&v160 + 1);
        *(double *)&v165 = *(double *)&v160 * *(double *)&qword_43E0E8;
        *((_QWORD *)&v168 + 1) = 0i64;
        v166 = 0;
        v167 = (double *)(a3 + 32);
        *(double *)&v168 = *(double *)&qword_43E0E8 * 0.0;
        v404 = *(double *)&v160 * *(double *)&qword_43E0E8 * 0.5;
        do
        {
          v169 = v168;
          v170 = v166;
          if ( v166 < 0 )
            v170 = -v166;
          v171 = 1.0;
          while ( 1 )
          {
            if ( (v170 & 1) != 0 )
              v171 = v171 * *(double *)&v169;
            v170 >>= 1;
            if ( !v170 )
              break;
            *((_QWORD *)&v172 + 1) = *((_QWORD *)&v169 + 1);
            *(double *)&v172 = *(double *)&v169 * *(double *)&v169;
            v169 = v172;
          }
          if ( v166 >= 0 )
            v173 = v171;
          else
            v173 = 1.0 / v171;
          v174 = v166 + 1;
          v175 = v166;
          v176 = (double)(v166 + 1) * *v167;
          v177 = v176 * v173;
          v178 = *(unsigned __int64 *)&v404;
          v162 = v177 + v162;
          if ( v166 < 0 )
            v175 = -v166;
          v179 = 1.0;
          while ( 1 )
          {
            if ( (v175 & 1) != 0 )
              v179 = v179 * *(double *)&v178;
            v175 >>= 1;
            if ( !v175 )
              break;
            *((_QWORD *)&v180 + 1) = *((_QWORD *)&v178 + 1);
            *(double *)&v180 = *(double *)&v178 * *(double *)&v178;
            v178 = v180;
          }
          if ( v166 >= 0 )
            v181 = v179;
          else
            v181 = 1.0 / v179;
          v182 = v166;
          v183 = v176 * v181;
          v184 = v165;
          v163 = v183 + v163;
          if ( v166 < 0 )
            v182 = -v166;
          v185 = 1.0;
          while ( 1 )
          {
            if ( (v182 & 1) != 0 )
              v185 = v185 * *(double *)&v184;
            v182 >>= 1;
            if ( !v182 )
              break;
            *((_QWORD *)&v186 + 1) = *((_QWORD *)&v184 + 1);
            *(double *)&v186 = *(double *)&v184 * *(double *)&v184;
            v184 = v186;
          }
          if ( v166 >= 0 )
            v187 = v185;
          else
            v187 = 1.0 / v185;
          ++v166;
          v188 = v176 * v187;
          ++v167;
          v168 = COERCE_UNSIGNED_INT64(*(double *)&qword_43E0E8 * 0.0);
          v164 = v164 + v188;
        }
        while ( v174 + 1 <= v400 );
        v159 = v400;
      }
      v512 = *(double *)libm_sse2_sqrt_precise(v347, v360, v373, v386).m128_u64 * 4.0;
      v513 = v512 + *(double *)libm_sse2_sqrt_precise(v348, v361, v374, v387).m128_u64;
      v189 = 0.0;
      v514 = (v513 + *(double *)libm_sse2_sqrt_precise(v349, v362, v375, v388).m128_u64) * (v424 / 6.0);
      if ( v159 >= 1 )
      {
        v190 = 0;
        v191 = (double *)(a3 + 32);
        do
        {
          v192 = v424 * *(double *)&qword_43E0E8;
          v193 = v190;
          if ( v190 < 0 )
            v193 = -v190;
          v194 = 1.0;
          while ( 1 )
          {
            if ( (v193 & 1) != 0 )
              v194 = v194 * v192;
            v193 >>= 1;
            if ( !v193 )
              break;
            v192 = v192 * v192;
          }
          if ( v190 >= 0 )
            v195 = v194;
          else
            v195 = 1.0 / v194;
          v196 = (double)++v190 * *v191++;
          v189 = v189 + v196 * v195;
        }
        while ( v190 + 1 <= v159 );
      }
      v197 = *(double *)libm_sse2_sqrt_precise(v350, v363, v376, v389).m128_u64;
      v198 = (double *)(*(_DWORD *)(v377 + 108) + 32 * (v89 + 2));
      v511 = v197 * v446;
      v199 = v522 * *v198;
      v200 = v528 * *v198;
      v598 = v197 * v484;
      v198[2] = v537;
      v201 = v523 * v198[1];
      v595 = v197 * v458;
      v202 = v199 + v201;
      v405 = v197;
      v203 = v529 * v198[1];
      v592 = v197 * v479;
      v417 = v202 + v552;
      v542 = v200 + v203 + v532;
      v204 = sub_406A70((int)v601, -4.0, 0.0, -1.0, 1.0e-10, v202 + v552, v533, v542, v495);
      v205 = v198[1];
      v206 = v198[2];
      v480 = (v563 * *v198 + v564 * v205 + v565 * v206) * v204;
      v207 = (v569 * *v198 + v570 * v205 + v571 * v206) * v204 - v555;
      v208 = v602 - 1;
      v485 = (v581 * *v198 + v582 * v205 + v583 * v206) * v204;
      v209 = (v587 * *v198 + v588 * v205 + v589 * v206) * v204 - v554;
      v518 = (v573 * v205 + v572 * *v198 + v574 * v206) * v204;
      v210 = (v578 * *v198 + v579 * v205 + v580 * v206) * v204 - v553;
      v549 = v204 * v524 * v460;
      v211 = v417;
      v545 = v204 * v417 - v533;
      v212 = 0.0;
      if ( v602 - 1 >= 0 )
      {
        if ( v602 >= 4 )
        {
          do
          {
            v212 = (((v212 * (v603 * v545) + *(double *)&v601[2 * v208 + 20]) * (v603 * v545)
                   + *(double *)&v601[2 * v208 + 18])
                  * (v603
                   * v545)
                  + *(double *)&v601[2 * v208 + 16])
                 * (v603
                  * v545)
                 + *(double *)&v601[2 * v208 + 14];
            v208 -= 4;
          }
          while ( v208 >= 3 );
          v211 = v417;
        }
        for ( ; v208 >= 0; --v208 )
          v212 = v212 * (v603 * v545) + *(double *)&v601[2 * v208 + 20];
      }
      v542 = v542 - v211 * v212;
      v213 = -((v207 - v212 * (v480 - v547)) / v542);
      v214 = -((v209 - v212 * (v485 - v550)) / v542);
      v215 = -((v210 - v212 * (v518 - v551)) / v542);
      v216 = -((-(v204 * v530 * v460) - v557 - v212 * (-(v204 * v524 * v460) - v546)) / v542);
      v535 = v522 * *v198 + v523 * v205;
      v217 = v198[2];
      v535 = v535 + v524 * v217;
      v593 = v535 * v213 + v480 - v547;
      v591 = v535 * v214 + v485 - v550;
      v599 = v535 * v215 + v518 - v551;
      v447 = v535 * v216 - v549 - v546;
      v548 = v525 * *v198;
      v218 = v566 * *v198;
      v548 = v548 + v526 * v205 + v527 * v217;
      v544 = (v218 + v567 * v205 + v568 * v217) * v204;
      v544 = v544 + v548 * v213 - v562;
      v597 = (v584 * *v198 + v585 * v205 + v586 * v217) * v204 + v548 * v214 - v558;
      v219 = v575 * *v198 + v576 * v205;
      v220 = *(unsigned __int64 *)&v204;
      v519 = v204 * v535 - v533;
      v600 = (v219 + v577 * v217) * v204 + v548 * v215 - v556;
      v221 = v548 * v216;
      v222 = 0.0;
      v501 = v204 * v548 - v543;
      v223 = 0.0;
      v224 = 0.0;
      v590 = v221 - v527 * v204 * v460 - v561;
      if ( v400 >= 1 )
      {
        *((_QWORD *)&v227 + 1) = 0i64;
        *(double *)&v220 = (v204 * v535 - v533) * *(double *)&qword_43E0E8;
        v225 = 0;
        v226 = (double *)(a3 + 32);
        *(double *)&v227 = *(double *)&qword_43E0E8 * 0.0;
        do
        {
          v228 = v227;
          v229 = v225;
          if ( v225 < 0 )
            v229 = -v225;
          v230 = 1.0;
          while ( 1 )
          {
            if ( (v229 & 1) != 0 )
              v230 = v230 * *(double *)&v228;
            v229 >>= 1;
            if ( !v229 )
              break;
            *((_QWORD *)&v231 + 1) = *((_QWORD *)&v228 + 1);
            *(double *)&v231 = *(double *)&v228 * *(double *)&v228;
            v228 = v231;
          }
          if ( v225 >= 0 )
            v232 = v230;
          else
            v232 = 1.0 / v230;
          v233 = COERCE_UNSIGNED_INT64(*(double *)&v220 * 0.5);
          v234 = v225 + 1;
          v235 = v225;
          v236 = (double)(v225 + 1) * *v226;
          v222 = v232 * v236 + v222;
          if ( v225 < 0 )
            v235 = -v225;
          v237 = 1.0;
          while ( 1 )
          {
            if ( (v235 & 1) != 0 )
              v237 = v237 * *(double *)&v233;
            v235 >>= 1;
            if ( !v235 )
              break;
            *((_QWORD *)&v238 + 1) = *((_QWORD *)&v233 + 1);
            *(double *)&v238 = *(double *)&v233 * *(double *)&v233;
            v233 = v238;
          }
          if ( v225 >= 0 )
            v239 = v237;
          else
            v239 = 1.0 / v237;
          v240 = v220;
          v241 = v225;
          v223 = v239 * v236 + v223;
          if ( v225 < 0 )
            v241 = -v225;
          v242 = 1.0;
          while ( 1 )
          {
            if ( (v241 & 1) != 0 )
              v242 = v242 * *(double *)&v240;
            v241 >>= 1;
            if ( !v241 )
              break;
            *((_QWORD *)&v243 + 1) = *((_QWORD *)&v240 + 1);
            *(double *)&v243 = *(double *)&v240 * *(double *)&v240;
            v240 = v243;
          }
          if ( v225 >= 0 )
            v244 = v242;
          else
            v244 = 1.0 / v242;
          ++v225;
          ++v226;
          v224 = v224 + v244 * v236;
          v227 = COERCE_UNSIGNED_INT64(*(double *)&qword_43E0E8 * 0.0);
        }
        while ( v234 + 1 <= v400 );
      }
      v515 = *(double *)libm_sse2_sqrt_precise(v351, v364, v377, v390).m128_u64 * 4.0;
      v516 = v515 + *(double *)libm_sse2_sqrt_precise(v352, v365, v378, v391).m128_u64;
      v245 = 0.0;
      v517 = (v516 + *(double *)libm_sse2_sqrt_precise(v353, v366, v379, v392).m128_u64) * (v519 / 6.0);
      if ( v400 >= 1 )
      {
        v246 = v519 * *(double *)&qword_43E0E8;
        v247 = 0;
        v248 = (double *)(a3 + 32);
        v520 = v519 * *(double *)&qword_43E0E8;
        do
        {
          v249 = v246;
          v250 = v247;
          if ( v247 < 0 )
            v250 = -v247;
          v251 = 1.0;
          while ( 1 )
          {
            if ( (v250 & 1) != 0 )
              v251 = v251 * v249;
            v250 >>= 1;
            if ( !v250 )
              break;
            v249 = v249 * v249;
          }
          if ( v247 >= 0 )
            v252 = v251;
          else
            v252 = 1.0 / v251;
          v246 = v520;
          v253 = (double)++v247 * *v248++;
          v245 = v245 + v253 * v252;
        }
        while ( v247 + 1 <= v400 );
      }
      v549 = *(double *)libm_sse2_sqrt_precise(v354, v367, v380, v393).m128_u64;
      v254 = *v435 * v522;
      v596 = v549 * v447;
      v459 = v254 + v435[1] * v523 + v435[2] * v524;
      v255 = *(double *)(v451 + v497 + 32);
      v256 = *(double *)(v451 + v497 + 48);
      v448 = v525 * *v435 + v526 * v435[1] + v527 * v435[2];
      v425 = v255 * v522 + *(double *)(v451 + v497 + 40) * v523 + v256 * v524;
      v414 = v255 * v525 + *(double *)(v451 + v497 + 40) * v526 + v256 * v527;
      v498 = v506 - v432;
      v436 = v504 - v514;
      v521 = v514 * v432 - v506 * v504 + (v506 - v432) * v517 + (v504 - v514) * v501;
      v486 = *(double *)libm_sse2_sqrt_precise(v355, v368, v381, v394).m128_u64;
      v481 = v531 - v511;
      v257 = v592;
      v258 = v382;
      v418 = v473 - v595;
      v259 = v399;
      v260 = v595 * v432;
      v398 = v468 - v592;
      v452 = v486 * v486;
      v261 = v549 * v591 * (v506 - v432) + (v500 - v487) * v517;
      *(double *)&v382[8 * v399] = ((v549 * v593 * (v506 - v432)
                                   + (v540 - v410) * v517
                                   + (v531 - v511) * v501
                                   + (v504 - v514) * v544
                                   + v514 * v410
                                   + v511 * v432
                                   - v506 * v531
                                   - v540 * v504)
                                  * v486
                                  - ((v531 - v511) * (v504 - v514) + (v540 - v410) * (v506 - v432)) / v486 * v521)
                                 * *(double *)(v369 + 80)
                                 / (v486
                                  * v486);
      v262 = v261 + v418 * v501 + (v504 - v514) * v597 + v260 + v514 * v487 - v506 * v473 - v500 * v504;
      v263 = v486;
      v264 = 1;
      *(double *)&v382[8 * v399 + 8] = (v262 * v486
                                      - (v418 * (v504 - v514) + (v500 - v487) * (v506 - v432)) / v486 * v521)
                                     * *(double *)(v369 + 80)
                                     / (v486
                                      * v486);
      v265 = ((v549 * v599 * v498
             + (v441 - v429) * v517
             + v398 * v501
             + v436 * v600
             + v257 * v432
             + v514 * v429
             - v506 * v468
             - v441 * v504)
            * v263
            - (v398 * v436 + (v441 - v429) * v498) / v263 * v521)
           * *(double *)(v369 + 80);
      *(_QWORD *)&v382[8 * v399 + 24] = 0i64;
      *(double *)&v382[8 * v399 + 16] = v265 / (v486 * v486);
      if ( v400 < 1 )
      {
        v301 = v504 - v514;
      }
      else
      {
        v266 = (double *)&v382[8 * v399 + 32];
        do
        {
          v268 = v534;
          v267 = v264;
          *(double *)&v268 = *(double *)&v534 * *(double *)&qword_43E0E8;
          v269 = v268;
          if ( v264 < 0 )
            v267 = -v264;
          v270 = 1.0;
          while ( 1 )
          {
            if ( (v267 & 1) != 0 )
              v270 = v270 * *(double *)&v269;
            v267 >>= 1;
            if ( !v267 )
              break;
            *((_QWORD *)&v271 + 1) = *((_QWORD *)&v269 + 1);
            *(double *)&v271 = *(double *)&v269 * *(double *)&v269;
            v269 = v271;
          }
          if ( v264 >= 0 )
            v272 = v270;
          else
            v272 = 1.0 / v270;
          v273 = v264;
          v274 = v272 / *(double *)&qword_43E0E8 / v538 * v459;
          if ( v264 < 0 )
            v273 = -v264;
          v275 = 1.0;
          while ( 1 )
          {
            if ( (v273 & 1) != 0 )
              v275 = v275 * *(double *)&v268;
            v273 >>= 1;
            if ( !v273 )
              break;
            *((_QWORD *)&v276 + 1) = *((_QWORD *)&v268 + 1);
            *(double *)&v276 = *(double *)&v268 * *(double *)&v268;
            v268 = v276;
          }
          if ( v264 >= 0 )
            v277 = v275;
          else
            v277 = 1.0 / v275;
          v278 = v264;
          v279 = v464 * *(double *)&qword_43E0E8;
          v469 = v277 / *(double *)&qword_43E0E8 / v538 * v448;
          v280 = v536 * v274;
          v281 = v464 * *(double *)&qword_43E0E8;
          v474 = v280;
          if ( v264 < 0 )
            v278 = -v264;
          v282 = 1.0;
          while ( 1 )
          {
            if ( (v278 & 1) != 0 )
              v282 = v282 * v281;
            v278 >>= 1;
            if ( !v278 )
              break;
            v281 = v281 * v281;
          }
          if ( v264 >= 0 )
            v283 = v282;
          else
            v283 = 1.0 / v282;
          v284 = v264;
          v285 = v283 / *(double *)&qword_43E0E8 / v541 * v425;
          if ( v264 < 0 )
            v284 = -v264;
          v286 = 1.0;
          while ( 1 )
          {
            if ( (v284 & 1) != 0 )
              v286 = v286 * v279;
            v284 >>= 1;
            if ( !v284 )
              break;
            v279 = v279 * v279;
          }
          if ( v264 >= 0 )
            v287 = v286;
          else
            v287 = 1.0 / v286;
          v288 = v264;
          v289 = v545 * *(double *)&qword_43E0E8;
          v290 = v405 * v285;
          v291 = v545 * *(double *)&qword_43E0E8;
          v292 = v287 / *(double *)&qword_43E0E8 / v541 * v414;
          if ( v264 < 0 )
            v288 = -v264;
          v293 = 1.0;
          while ( 1 )
          {
            if ( (v288 & 1) != 0 )
              v293 = v293 * v291;
            v288 >>= 1;
            if ( !v288 )
              break;
            v291 = v291 * v291;
          }
          if ( v264 >= 0 )
            v294 = v293;
          else
            v294 = 1.0 / v293;
          v295 = v264;
          v296 = v294 / *(double *)&qword_43E0E8 / v542 * v535;
          if ( v264 < 0 )
            v295 = -v264;
          v297 = 1.0;
          while ( 1 )
          {
            if ( (v295 & 1) != 0 )
              v297 = v297 * v289;
            v295 >>= 1;
            if ( !v295 )
              break;
            v289 = v289 * v289;
          }
          if ( v264 >= 0 )
            v298 = v297;
          else
            v298 = 1.0 / v297;
          ++v264;
          v299 = (v292 - v469) * v498;
          v300 = v296 * v549 * v498
               + (v292 - v469) * v517
               + (v280 - v290) * v501
               + v298 / *(double *)&qword_43E0E8 / v542 * v548 * v436;
          v301 = v504 - v514;
          v302 = v504 * v292;
          v263 = v486;
          *v266++ = ((v300 + v514 * v469 + v432 * v290 - v506 * v474 - v302) * v486
                   - ((v474 - v290) * v436 + v299) / v486 * v521)
                  * *(double *)(v369 + 80)
                  / v452;
        }
        while ( v264 <= v400 );
        v258 = v382;
        v259 = v399;
      }
      v531 = v594 - v598;
      v303 = v408;
      *(double *)&v258[8 * v259 + 64] = ((v598 * v432
                                        + v514 * v491
                                        - v506 * v594
                                        - v539 * v504
                                        + (v539 - v491) * v517
                                        + v498 * v596
                                        + (v594 - v598) * v501
                                        + v301 * v590)
                                       * v263
                                       - ((v594 - v598) * v301 + (v539 - v491) * v498) / v263 * v521)
                                      * *(double *)(v369 + 80)
                                      / v452;
      v399 = a5 + v259;
      if ( *(_BYTE *)(*(_DWORD *)(v369 + 192) + 40 * v408 + 32) == 1 )
      {
        v411 = v410 - v540;
        v470 = fabs(v301);
        v433 = v432 - v506;
        v488 = v487 - v500;
        v430 = v429 - v441;
        v475 = *(_QWORD *)&v433 & 0x7FFFFFFFFFFFFFFFi64;
        if ( v470 <= COERCE_DOUBLE(*(_QWORD *)&v433 & 0x7FFFFFFFFFFFFFFFi64) )
        {
          v306 = v433;
          v305 = *(double *)libm_sse2_pow_precise().m128_u64;
          v304 = v504 - v514;
          v307 = v420;
          v308 = v382;
          *(double *)&v382[8 * v420] = (v481 * v433 - v411 * v436) * (*(double *)(v369 + 72) * v433) / v305;
          *(double *)&v382[8 * v420 + 8] = (v418 * v433 - v488 * v436) * (*(double *)(v369 + 72) * v433) / v305;
          v309 = (v398 * v306 - v430 * v436) * (*(double *)(v369 + 72) * v306);
        }
        else
        {
          v304 = v504 - v514;
          v305 = *(double *)libm_sse2_pow_precise().m128_u64;
          v306 = v433;
          v307 = v420;
          *(double *)&v382[8 * v420] = (v481 * v433 - v411 * v436) * (*(double *)(v369 + 72) * v436) * -1.0 / v305;
          *(double *)&v382[8 * v420 + 8] = (v418 * v433 - v488 * v436) * (*(double *)(v369 + 72) * v436) * -1.0 / v305;
          v308 = v382;
          v309 = (v398 * v433 - v430 * v436) * (*(double *)(v369 + 72) * v436) * -1.0;
        }
        v310 = 1;
        *(double *)&v308[8 * v307 + 16] = v309 / v305;
        *(_QWORD *)&v308[8 * v307 + 24] = 0i64;
        if ( v400 >= 1 )
        {
          v311 = (double *)&v308[8 * v307 + 32];
          do
          {
            v312 = v310;
            v313 = *(double *)&v534 * *(double *)&qword_43E0E8;
            v314 = *(double *)&v534 * *(double *)&qword_43E0E8;
            if ( v310 < 0 )
              v312 = -v310;
            v315 = 1.0;
            while ( 1 )
            {
              if ( (v312 & 1) != 0 )
                v315 = v315 * v314;
              v312 >>= 1;
              if ( !v312 )
                break;
              v314 = v314 * v314;
            }
            if ( v310 >= 0 )
              v316 = v315;
            else
              v316 = 1.0 / v315;
            v317 = v310;
            v318 = v316 / *(double *)&qword_43E0E8 / v538 * v459;
            if ( v310 < 0 )
              v317 = -v310;
            v319 = 1.0;
            while ( 1 )
            {
              if ( (v317 & 1) != 0 )
                v319 = v319 * v313;
              v317 >>= 1;
              if ( !v317 )
                break;
              v313 = v313 * v313;
            }
            if ( v310 >= 0 )
              v320 = v319;
            else
              v320 = 1.0 / v319;
            v321 = v310;
            v322 = v536 * v318;
            v323 = v464 * *(double *)&qword_43E0E8;
            v324 = v464 * *(double *)&qword_43E0E8;
            v325 = v320 / *(double *)&qword_43E0E8 / v538 * v448;
            if ( v310 < 0 )
              v321 = -v310;
            v326 = 1.0;
            while ( 1 )
            {
              if ( (v321 & 1) != 0 )
                v326 = v326 * v324;
              v321 >>= 1;
              if ( !v321 )
                break;
              v324 = v324 * v324;
            }
            if ( v310 >= 0 )
              v327 = v326;
            else
              v327 = 1.0 / v326;
            v328 = v310;
            v329 = v327 / *(double *)&qword_43E0E8 / v541 * v425;
            if ( v310 < 0 )
              v328 = -v310;
            v330 = 1.0;
            while ( 1 )
            {
              if ( (v328 & 1) != 0 )
                v330 = v330 * v323;
              v328 >>= 1;
              if ( !v328 )
                break;
              v323 = v323 * v323;
            }
            if ( v310 >= 0 )
              v331 = v330;
            else
              v331 = 1.0 / v330;
            v332 = v405 * v329;
            v304 = v504 - v514;
            v333 = v322 - v332;
            v334 = *(double *)(v369 + 72);
            v335 = v333 * v433 - (v325 - v331 / *(double *)&qword_43E0E8 / v541 * v414) * v436;
            v306 = v433;
            if ( v470 <= *(double *)&v475 )
              v336 = v335 * (v334 * v433);
            else
              v336 = v335 * (v334 * v436) * -1.0;
            ++v310;
            *v311++ = v336 / v305;
          }
          while ( v310 <= v400 );
          v307 = v420;
          v303 = v408;
          v308 = v382;
        }
        v337 = *(double *)(v369 + 72);
        v338 = v531 * v306 - (v491 - v539) * v304;
        if ( v470 <= *(double *)&v475 )
          v339 = v338 * (v337 * v306);
        else
          v339 = v338 * (v337 * v304) * -1.0;
        *(double *)&v308[8 * v307 + 64] = v339 / v305;
        v83 = a5 + v307;
        v420 = v83;
      }
      else
      {
        v83 = v420;
      }
      v87 = v533;
      v82 = v303 + 1;
      v84 = v537;
      v86 = v552;
      v85 = v532;
      v88 = v495;
      v408 = v82;
    }
    while ( v82 < v559 );
  }
  v340 = 1.0;
  v341 = *(double *)(a3 + 64);
  if ( v341 <= 1.0 )
  {
    if ( v341 >= 1.0 )
    {
      *(_QWORD *)&v382[8 * v83 + 64] = 0i64;
      goto LABEL_336;
    }
    v340 = -1.0 / (v341 * v341);
  }
  *(double *)&v382[8 * v83 + 64] = v340;
LABEL_336:
  result = v382;
  *(double *)&v382[8 * v83 + 64] = *(double *)(v369 + 88) * *(double *)&v382[8 * v83 + 64];
  return result;
}
// 412610: could not find valid save-restore pair for edi
// 412610: could not find valid save-restore pair for esi
// 4139BC: variable 'v369' is possibly undefined
// 414213: variable 'v343' is possibly undefined
// 414213: variable 'v356' is possibly undefined
// 414213: variable 'v382' is possibly undefined
// 41423E: variable 'v344' is possibly undefined
// 41423E: variable 'v357' is possibly undefined
// 41423E: variable 'v370' is possibly undefined
// 41423E: variable 'v383' is possibly undefined
// 41426B: variable 'v345' is possibly undefined
// 41426B: variable 'v358' is possibly undefined
// 41426B: variable 'v371' is possibly undefined
// 41426B: variable 'v384' is possibly undefined
// 414335: variable 'v346' is possibly undefined
// 414335: variable 'v359' is possibly undefined
// 414335: variable 'v372' is possibly undefined
// 414335: variable 'v385' is possibly undefined
// 41435B: variable 'v373' is possibly undefined
// 414C34: variable 'v347' is possibly undefined
// 414C34: variable 'v360' is possibly undefined
// 414C34: variable 'v386' is possibly undefined
// 414C5C: variable 'v348' is possibly undefined
// 414C5C: variable 'v361' is possibly undefined
// 414C5C: variable 'v374' is possibly undefined
// 414C5C: variable 'v387' is possibly undefined
// 414C89: variable 'v349' is possibly undefined
// 414C89: variable 'v362' is possibly undefined
// 414C89: variable 'v375' is possibly undefined
// 414C89: variable 'v388' is possibly undefined
// 414D42: variable 'v350' is possibly undefined
// 414D42: variable 'v363' is possibly undefined
// 414D42: variable 'v376' is possibly undefined
// 414D42: variable 'v389' is possibly undefined
// 414D7E: variable 'v377' is possibly undefined
// 41563F: variable 'v351' is possibly undefined
// 41563F: variable 'v364' is possibly undefined
// 41563F: variable 'v390' is possibly undefined
// 415667: variable 'v352' is possibly undefined
// 415667: variable 'v365' is possibly undefined
// 415667: variable 'v378' is possibly undefined
// 415667: variable 'v391' is possibly undefined
// 415694: variable 'v353' is possibly undefined
// 415694: variable 'v366' is possibly undefined
// 415694: variable 'v379' is possibly undefined
// 415694: variable 'v392' is possibly undefined
// 415768: variable 'v354' is possibly undefined
// 415768: variable 'v367' is possibly undefined
// 415768: variable 'v380' is possibly undefined
// 415768: variable 'v393' is possibly undefined
// 415902: variable 'v355' is possibly undefined
// 415902: variable 'v368' is possibly undefined
// 415902: variable 'v381' is possibly undefined
// 415902: variable 'v394' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);
// 436A6E: using guessed type __m128 libm_sse2_pow_precise(void);
// 43E0E8: using guessed type __int64 qword_43E0E8;

//----- (00416640) --------------------------------------------------------
void *__thiscall sub_416640(int this, void *Src)
{
  size_t v3; // [esp-4h] [ebp-4h]

  v3 = 8 * *(_DWORD *)(this + 24);
  if ( Src )
    return memcpy(*(void **)(this + 4), Src, v3);
  else
    return memset(*(void **)(this + 4), 0, v3);
}

//----- (00416680) --------------------------------------------------------
double __thiscall sub_416680(int *this)
{
  int v2; // edi
  unsigned int v3; // esi
  double *v4; // esi
  int v5; // ecx
  int i; // eax
  double v7; // xmm0_8
  int v9; // [esp+0h] [ebp-BCh]
  int v10; // [esp+4h] [ebp-B8h]
  int v11; // [esp+8h] [ebp-B4h]
  int v12; // [esp+Ch] [ebp-B0h]
  double v13; // [esp+14h] [ebp-A8h]
  double v14; // [esp+14h] [ebp-A8h]
  void *v15[2]; // [esp+20h] [ebp-9Ch] BYREF
  int v16; // [esp+28h] [ebp-94h]
  int v17[4]; // [esp+2Ch] [ebp-90h] BYREF
  __int128 v18; // [esp+3Ch] [ebp-80h]
  __int64 v19; // [esp+4Ch] [ebp-70h]
  int v20[26]; // [esp+54h] [ebp-68h] BYREF

  v2 = this[6];
  v3 = this[7];
  *(_OWORD *)v17 = xmmword_439410;
  v18 = xmmword_439410;
  v16 = 0;
  v19 = 0x3EB0C6F7A0B5ED8Di64;
  v15[0] = 0;
  v15[1] = 0;
  v20[25] = 0;
  sub_4077E0(v15, v3);
  sub_4110D0(v2, v3, this[1], (int)v15[0], this[6], this[7], (int)this);
  v13 = 0.0;
  sub_401000(
    (void (__cdecl *)(int, double *, int, int, int))sub_4110D0,
    (void (__cdecl *)(int, int, int, int, int))sub_412610,
    this[1],
    this[2],
    v2,
    v3,
    1000,
    (double *)v17,
    (double *)v20,
    0,
    0,
    (int)this);
  v4 = (double *)v15[0];
  sub_4110D0(v2, (int)v15[0], this[1], (int)v15[0], this[6], this[7], (int)this);
  v5 = this[7];
  for ( i = 0; i < v5; v13 = v7 * v7 + v13 )
    v7 = v4[i++];
  *(_QWORD *)&v14 = libm_sse2_sqrt_precise(v9, v10, v11, v12).m128_u64[0];
  if ( v4 )
    operator delete(v4);
  return v14;
}
// 4167CB: variable 'v9' is possibly undefined
// 4167CB: variable 'v10' is possibly undefined
// 4167CB: variable 'v11' is possibly undefined
// 4167CB: variable 'v12' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);
// 439410: using guessed type __int128 xmmword_439410;

//----- (00416820) --------------------------------------------------------
void __cdecl sub_416820(_DWORD *a1, int a2)
{
  int v2; // edi
  int v3; // edx
  int i; // esi
  int v5; // ecx
  int v6; // edx

  v2 = 0;
  if ( (int)a1[11] > 0 )
  {
    v3 = a1[10];
    do
    {
      for ( i = 0; i < v3; v3 = a1[10] )
      {
        v5 = i + v2 * a1[18];
        v6 = i + v2 * v3;
        ++i;
        *(double *)(a2 + 8 * v6) = (double)*(unsigned __int8 *)(v5 + a1[17]);
      }
      ++v2;
    }
    while ( v2 < a1[11] );
  }
}

//----- (00416880) --------------------------------------------------------
void __usercall sub_416880(double a1@<st0>, int a2, _DWORD *a3, float a4)
{
  void *v4; // edi
  int v5; // eax
  int v6; // ebx
  int v7; // esi
  double *v8; // edi
  __int32 v9; // xmm0_4
  double v10; // xmm5_8
  double v11; // xmm0_8
  double v12; // xmm4_8
  __int32 v13; // xmm7_4
  double v14; // xmm0_8
  float v15; // xmm6_4
  double v16; // xmm0_8
  float v17; // xmm3_4
  float v18; // xmm0_4
  int v19; // [esp+0h] [ebp-8Ch]
  int v20; // [esp+4h] [ebp-88h]
  int v21; // [esp+8h] [ebp-84h]
  int v22; // [esp+Ch] [ebp-80h]
  void *v23; // [esp+14h] [ebp-78h]
  __int32 v24; // [esp+18h] [ebp-74h]
  unsigned int v25; // [esp+24h] [ebp-68h]
  _DWORD *Image; // [esp+38h] [ebp-54h] BYREF
  int v27; // [esp+3Ch] [ebp-50h] BYREF
  void *v28[2]; // [esp+40h] [ebp-4Ch] BYREF
  int v29; // [esp+48h] [ebp-44h]
  __m128i v30; // [esp+4Ch] [ebp-40h] BYREF
  float v31; // [esp+5Ch] [ebp-30h]
  float v32; // [esp+60h] [ebp-2Ch]
  double v33; // [esp+64h] [ebp-28h]
  char v34; // [esp+6Ch] [ebp-20h]
  int v35; // [esp+88h] [ebp-4h]

  a3[1] = *a3;
  Image = (_DWORD *)cvCreateImage((int)((double)*(int *)(a2 + 40) * 0.5));
  cvResize(a2, Image, 3);
  v28[0] = 0;
  v28[1] = 0;
  v29 = 0;
  v35 = 0;
  sub_4077E0(v28, Image[10] * Image[11]);
  v4 = v28[0];
  sub_416820(Image, (int)v28[0]);
  v5 = sub_4233F0(a1, &v27, (int)v4, Image[10], Image[11]);
  v6 = v27;
  v7 = 0;
  v23 = (void *)v5;
  if ( v27 > 0 )
  {
    v8 = (double *)(v5 + 24);
    do
    {
      *(float *)&v9 = *(v8 - 3) * 2.0;
      v10 = (*(v8 - 3) + *(v8 - 1)) * 2.0;
      v24 = v9;
      v11 = *(v8 - 2);
      v12 = v11 + *v8;
      v30.m128i_i32[0] = v24;
      *(float *)&v13 = v11 * 2.0;
      v14 = *(v8 - 1) * 2.0;
      v30.m128i_i32[1] = v13;
      v15 = v14;
      v16 = *v8 * 2.0;
      v31 = v15;
      v17 = v16;
      *(float *)&v16 = v10 * 0.5;
      v25 = LODWORD(v16);
      *(float *)&v16 = v12 * 2.0 * 0.5;
      v32 = v17;
      v30.m128i_i64[1] = __PAIR64__(LODWORD(v16), v25);
      v18 = *(double *)libm_sse2_sqrt_precise(v19, v20, v21, v22).m128_u64;
      v34 = 1;
      v33 = v18;
      if ( v18 > (double)a4 )
      {
        sub_4214D0(a3, &v30);
        v6 = v27;
      }
      ++v7;
      v8 += 7;
    }
    while ( v7 < v6 );
    v4 = v28[0];
  }
  cvReleaseImage(&Image);
  operator delete[](v23);
  if ( v4 )
    operator delete(v4);
}
// 416A8C: variable 'v19' is possibly undefined
// 416A8C: variable 'v20' is possibly undefined
// 416A8C: variable 'v21' is possibly undefined
// 416A8C: variable 'v22' is possibly undefined
// 43681E: using guessed type int __cdecl cvResize(_DWORD, _DWORD, _DWORD);
// 436848: using guessed type int __cdecl cvCreateImage(_DWORD);
// 43684E: using guessed type int __cdecl cvReleaseImage(_DWORD);
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00416B30) --------------------------------------------------------
int __cdecl sub_416B30(int a1, int a2, int a3, _DWORD *a4, unsigned __int8 (__cdecl *a5)(_DWORD, _DWORD))
{
  int v5; // ecx
  int v6; // ebx
  int v7; // esi
  bool i; // zf
  int j; // esi
  int result; // eax

  v5 = a3;
  v6 = a2;
  v7 = 2 * a2 + 2;
  for ( i = v7 == a3; v7 < a3; i = v7 == a3 )
  {
    if ( a5(*(_DWORD *)(a1 + 4 * v7), *(_DWORD *)(a1 + 4 * v7 - 4)) )
      --v7;
    v5 = a3;
    *(_DWORD *)(a1 + 4 * v6) = *(_DWORD *)(a1 + 4 * v7);
    v6 = v7;
    v7 = 2 * v7 + 2;
  }
  if ( i )
  {
    *(_DWORD *)(a1 + 4 * v6) = *(_DWORD *)(a1 + 4 * v5 - 4);
    v6 = v5 - 1;
  }
  for ( j = (v6 - 1) / 2; a2 < v6; j = (j - 1) / 2 )
  {
    if ( !a5(*(_DWORD *)(a1 + 4 * j), *a4) )
      break;
    *(_DWORD *)(a1 + 4 * v6) = *(_DWORD *)(a1 + 4 * j);
    v6 = j;
  }
  result = *a4;
  *(_DWORD *)(a1 + 4 * v6) = *a4;
  return result;
}

//----- (00416BD0) --------------------------------------------------------
void *__cdecl sub_416BD0(char *Src, char *a2, unsigned __int8 (__cdecl *a3)(int, int))
{
  void *result; // eax
  char *v4; // esi
  char *v5; // edi
  int v6; // ebx
  char *v7; // esi
  int v8; // [esp-Ch] [ebp-18h]
  char *i; // [esp+4h] [ebp-8h]
  char *v10; // [esp+8h] [ebp-4h]

  result = a2;
  v4 = Src;
  if ( Src != a2 )
  {
    v5 = Src + 4;
    for ( i = Src + 4; v5 != a2; i = v5 )
    {
      v6 = *(_DWORD *)v5;
      v10 = v5;
      if ( a3(*(_DWORD *)v5, *(_DWORD *)v4) )
      {
        result = memmove(&v5[-4 * ((v5 - v4) >> 2) + 4], v4, 4 * ((v5 - v4) >> 2));
        *(_DWORD *)v4 = v6;
      }
      else
      {
        v7 = v5 - 4;
        if ( a3(v6, *((_DWORD *)v5 - 1)) )
        {
          do
          {
            *(_DWORD *)v5 = *(_DWORD *)v7;
            v5 = v7;
            v8 = *((_DWORD *)v7 - 1);
            v7 -= 4;
          }
          while ( a3(v6, v8) );
          v10 = v5;
          v5 = i;
        }
        result = v10;
        v4 = Src;
        *(_DWORD *)v10 = v6;
      }
      v5 += 4;
    }
  }
  return result;
}

//----- (00416C80) --------------------------------------------------------
int __cdecl sub_416C80(int a1, int a2, unsigned __int8 (__cdecl *a3)(_DWORD, _DWORD))
{
  int v4; // ecx
  int result; // eax
  int v6; // edx
  int v7; // esi
  int v8; // eax
  int v9; // edx
  int v10; // esi
  int v11; // ebx
  int v12; // [esp+4h] [ebp-8h] BYREF
  int v13; // [esp+8h] [ebp-4h]
  int v14; // [esp+14h] [ebp+8h]
  int v15; // [esp+18h] [ebp+Ch]

  v15 = (a2 - a1) >> 2;
  v4 = v15;
  result = v4 - (v4 >> 31);
  v6 = v15 / 2;
  if ( v15 / 2 > 0 )
  {
    v7 = 2 * v6 + 2;
    do
    {
      v8 = *(_DWORD *)(a1 + 4 * v6 - 4);
      v9 = v6 - 1;
      v10 = v7 - 2;
      v14 = v9;
      v13 = v10;
      v11 = v9;
      v12 = v8;
      if ( v10 < v4 )
      {
        do
        {
          if ( a3(*(_DWORD *)(a1 + 4 * v10), *(_DWORD *)(a1 + 4 * v10 - 4)) )
            --v10;
          v4 = v15;
          *(_DWORD *)(a1 + 4 * v11) = *(_DWORD *)(a1 + 4 * v10);
          v11 = v10;
          v10 = 2 * v10 + 2;
        }
        while ( v10 < v15 );
        v9 = v14;
      }
      if ( v10 == v4 )
      {
        *(_DWORD *)(a1 + 4 * v11) = *(_DWORD *)(a1 + 4 * v4 - 4);
        v11 = v4 - 1;
      }
      result = sub_416F10(a1, v11, v9, &v12, a3);
      v6 = v14;
      v4 = v15;
      v7 = v13;
    }
    while ( v14 > 0 );
  }
  return result;
}

//----- (00416D30) --------------------------------------------------------
int __cdecl sub_416D30(int *a1, int *a2, int *a3, unsigned __int8 (__cdecl *a4)(int, int))
{
  int v5; // eax
  int v6; // eax
  int v7; // ecx
  int *v8; // ebx
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  int *v15; // edi
  int v16; // ecx
  int v17; // ecx
  int v18; // ecx
  int v19; // ecx
  int result; // eax
  int v21; // ecx
  int v22; // ecx
  int v23; // ecx
  int v24; // ecx
  int v25; // ecx
  int v26; // [esp-8h] [ebp-1Ch]
  int v27; // [esp-4h] [ebp-18h]
  int v28; // [esp+Ch] [ebp-8h]
  int *v29; // [esp+10h] [ebp-4h]
  int v30; // [esp+1Ch] [ebp+8h]
  int *v31; // [esp+1Ch] [ebp+8h]

  v5 = a3 - a1;
  v27 = *a1;
  if ( v5 <= 40 )
  {
    if ( a4(*a2, v27) )
    {
      v23 = *a2;
      *a2 = *a1;
      *a1 = v23;
    }
    result = ((int (__cdecl *)(int, int))a4)(*a3, *a2);
    if ( (_BYTE)result )
    {
      v24 = *a3;
      *a3 = *a2;
      *a2 = v24;
      result = ((int (__cdecl *)(int, int))a4)(v24, *a1);
      if ( (_BYTE)result )
      {
        v25 = *a2;
        result = *a1;
        *a2 = *a1;
        *a1 = v25;
      }
    }
  }
  else
  {
    v6 = (v5 + 1) / 8;
    v7 = 8 * v6;
    v6 *= 4;
    v26 = *(int *)((char *)a1 + v6);
    v8 = (int *)((char *)a1 + v6);
    v28 = v7;
    v30 = v6;
    if ( a4(v26, v27) )
    {
      v9 = *v8;
      *v8 = *a1;
      *a1 = v9;
    }
    if ( a4(*(int *)((char *)a1 + v28), *v8) )
    {
      v10 = *(int *)((char *)a1 + v28);
      *(int *)((char *)a1 + v28) = *v8;
      *v8 = v10;
      if ( a4(v10, *a1) )
      {
        v11 = *v8;
        *v8 = *a1;
        *a1 = v11;
      }
    }
    v29 = (int *)((char *)a2 - v30);
    if ( a4(*a2, *(int *)((char *)a2 - v30)) )
    {
      v12 = *a2;
      *a2 = *v29;
      *v29 = v12;
    }
    if ( a4(*(int *)((char *)a2 + v30), *a2) )
    {
      v13 = *(int *)((char *)a2 + v30);
      *(int *)((char *)a2 + v30) = *a2;
      *a2 = v13;
      if ( a4(v13, *v29) )
      {
        v14 = *a2;
        *a2 = *v29;
        *v29 = v14;
      }
    }
    v15 = (int *)((char *)a3 - v30);
    v31 = (int *)((char *)a3 - v28);
    if ( a4(*v15, *(int *)((char *)a3 - v28)) )
    {
      v16 = *v15;
      *v15 = *v31;
      *v31 = v16;
    }
    if ( a4(*a3, *v15) )
    {
      v17 = *a3;
      *a3 = *v15;
      *v15 = v17;
      if ( a4(v17, *v31) )
      {
        v18 = *v15;
        *v15 = *v31;
        *v31 = v18;
      }
    }
    if ( a4(*a2, *v8) )
    {
      v19 = *a2;
      *a2 = *v8;
      *v8 = v19;
    }
    result = ((int (__cdecl *)(int, int))a4)(*v15, *a2);
    if ( (_BYTE)result )
    {
      v21 = *v15;
      *v15 = *a2;
      *a2 = v21;
      result = ((int (__cdecl *)(int, int))a4)(v21, *v8);
      if ( (_BYTE)result )
      {
        v22 = *a2;
        result = *v8;
        *a2 = *v8;
        *v8 = v22;
      }
    }
  }
  return result;
}

//----- (00416F10) --------------------------------------------------------
int __cdecl sub_416F10(int a1, int a2, int a3, _DWORD *a4, unsigned __int8 (__cdecl *a5)(_DWORD, _DWORD))
{
  int v5; // edi
  int v6; // esi
  int result; // eax

  v5 = a2;
  v6 = (a2 - 1) / 2;
  if ( a3 >= a2 )
  {
    result = a1;
    *(_DWORD *)(a1 + 4 * a2) = *a4;
  }
  else
  {
    do
    {
      if ( !a5(*(_DWORD *)(a1 + 4 * v6), *a4) )
        break;
      *(_DWORD *)(a1 + 4 * v5) = *(_DWORD *)(a1 + 4 * v6);
      v5 = v6;
      v6 = (v6 - 1) / 2;
    }
    while ( a3 < v5 );
    result = *a4;
    *(_DWORD *)(a1 + 4 * v5) = *a4;
  }
  return result;
}

//----- (00416F80) --------------------------------------------------------
void *__cdecl sub_416F80(char *Src, char *a2, int a3, unsigned __int8 (__cdecl *a4)(int, int))
{
  unsigned __int8 (__cdecl *v4)(int, int); // edx
  char *v5; // esi
  char *v6; // edi
  int v7; // ecx
  void *result; // eax
  int v10; // [esp+Ch] [ebp-8h] BYREF
  void *v11; // [esp+10h] [ebp-4h]

  v4 = a4;
  v5 = a2;
  v6 = Src;
  v7 = (a2 - Src) >> 2;
  if ( v7 <= 32 )
  {
LABEL_7:
    if ( v7 > 1 )
      return sub_416BD0(v6, v5, v4);
  }
  else
  {
    while ( a3 > 0 )
    {
      sub_4170C0((int **)&v10, (int *)v6, (int *)v5, v4);
      a3 = a3 / 2 / 2 + a3 / 2;
      if ( (int)((v10 - (_DWORD)v6) & 0xFFFFFFFC) >= (int)((v5 - (_BYTE *)v11) & 0xFFFFFFFC) )
      {
        result = (void *)sub_416F80(v11, (int)v5, a3, (int)a4);
        v5 = (char *)v10;
      }
      else
      {
        result = (void *)sub_416F80(v6, v10, a3, (int)a4);
        v6 = (char *)v11;
      }
      v4 = a4;
      v7 = (v5 - v6) >> 2;
      if ( v7 <= 32 )
        goto LABEL_7;
    }
    if ( (int)((v5 - v6) & 0xFFFFFFFC) > 4 )
    {
      sub_416C80((int)v6, (int)v5, v4);
      v4 = a4;
    }
    return (void *)sub_417060(v6, (int)v5, v4);
  }
  return result;
}
// 41702C: conditional instruction was optimized away because ecx.4>=21

//----- (00417060) --------------------------------------------------------
signed int __cdecl sub_417060(_DWORD *a1, int a2, unsigned __int8 (__cdecl *a3)(_DWORD, _DWORD))
{
  int v3; // esi
  signed int result; // eax
  unsigned __int8 (__cdecl *v5)(_DWORD, _DWORD); // ebx

  v3 = a2 - (_DWORD)a1;
  result = (a2 - (_DWORD)a1) & 0xFFFFFFFC;
  if ( result > 4 )
  {
    v5 = a3;
    do
    {
      a2 = *(_DWORD *)((char *)a1 + v3 - 4);
      *(_DWORD *)((char *)a1 + v3 - 4) = *a1;
      v3 -= 4;
      sub_416B30((int)a1, 0, v3 >> 2, &a2, v5);
      result = v3 & 0xFFFFFFFC;
    }
    while ( (int)(v3 & 0xFFFFFFFC) > 4 );
  }
  return result;
}

//----- (004170C0) --------------------------------------------------------
int **__cdecl sub_4170C0(int **a1, int *a2, int *a3, unsigned __int8 (__cdecl *a4)(int, int))
{
  int *v4; // esi
  int *v5; // edi
  unsigned int v6; // eax
  int *v7; // edx
  int *v8; // ebx
  int *v9; // eax
  int v10; // ecx
  bool v11; // zf
  int *v12; // ebx
  int *v13; // edi
  int v14; // ecx
  int *v15; // eax
  int v16; // ecx
  int *v17; // edx
  int *v18; // edi
  int v19; // ecx
  int v20; // ecx
  int v21; // eax
  int v22; // ecx
  int v23; // ecx
  int **result; // eax
  int *v25; // [esp+Ch] [ebp-Ch]
  int *v26; // [esp+Ch] [ebp-Ch]
  int *v27; // [esp+10h] [ebp-8h]
  int *v28; // [esp+14h] [ebp-4h]

  v4 = &a2[(a3 - a2) / 2];
  sub_416D30(a2, v4, a3 - 1, a4);
  v5 = v4 + 1;
  v28 = v4 + 1;
  if ( a2 < v4 )
  {
    do
    {
      v25 = v4 - 1;
      if ( a4(*(v4 - 1), *v4) )
        break;
      if ( a4(*v4, *v25) )
        break;
      --v4;
    }
    while ( a2 < v25 );
    v5 = v28;
  }
  v6 = (unsigned int)a3;
  if ( v5 < a3 )
  {
    while ( !a4(*v5, *v4) )
    {
      v11 = a4(*v4, *v5) == 0;
      v6 = (unsigned int)a3;
      if ( v11 && ++v5 < a3 )
        continue;
      goto LABEL_12;
    }
    v6 = (unsigned int)a3;
LABEL_12:
    v28 = v5;
  }
  v7 = v4;
  v8 = v5;
  v27 = v4;
  while ( 2 )
  {
    while ( 2 )
    {
      v26 = v8;
LABEL_15:
      if ( (unsigned int)v8 < v6 )
      {
        do
        {
          if ( !a4(*v4, *v8) )
          {
            if ( a4(*v8, *v4) )
              break;
            v9 = v5++;
            if ( v9 != v8 )
            {
              v10 = *(v5 - 1);
              *(v5 - 1) = *v8;
              *v8 = v10;
            }
          }
          ++v8;
        }
        while ( v8 < a3 );
        v7 = v27;
        v28 = v5;
        v26 = v8;
      }
      v11 = v7 == a2;
      if ( v7 <= a2 )
        goto LABEL_32;
      v12 = v27;
      v13 = v27 - 1;
      while ( a4(*v13, *v4) )
      {
LABEL_28:
        v15 = a2;
        --v12;
        --v13;
        if ( a2 >= v12 )
          goto LABEL_31;
      }
      if ( !a4(*v4, *v13) )
      {
        if ( --v4 != v13 )
        {
          v14 = *v4;
          *v4 = *v13;
          *v13 = v14;
        }
        goto LABEL_28;
      }
      v15 = a2;
LABEL_31:
      v5 = v28;
      v27 = v12;
      v7 = v12;
      v11 = v12 == v15;
      v8 = v26;
LABEL_32:
      if ( !v11 )
      {
        v27 = --v7;
        if ( v8 != a3 )
        {
          v23 = *v8;
          *v8++ = *v7;
          v6 = (unsigned int)a3;
          *v7 = v23;
          continue;
        }
        if ( v7 != --v4 )
        {
          v20 = *v7;
          *v7 = *v4;
          *v4 = v20;
        }
        v21 = *--v5;
        v22 = *v4;
        *v4 = v21;
        v6 = (unsigned int)a3;
        v28 = v5;
        *v5 = v22;
        goto LABEL_15;
      }
      break;
    }
    if ( v8 != a3 )
    {
      if ( v5 != v8 )
      {
        v16 = *v4;
        *v4 = *v5;
        *v5 = v16;
      }
      v17 = v4;
      v28 = v5 + 1;
      ++v4;
      v18 = v8++;
      v19 = *v17;
      *v17 = *v18;
      v7 = v27;
      v6 = (unsigned int)a3;
      *v18 = v19;
      v5 = v28;
      continue;
    }
    break;
  }
  result = a1;
  a1[1] = v5;
  *a1 = v4;
  return result;
}

//----- (004172A0) --------------------------------------------------------
bool __cdecl sub_4172A0(int a1, int a2)
{
  return *(double *)(a1 + 24) > *(double *)(a2 + 24);
}

//----- (004172C0) --------------------------------------------------------
bool __cdecl sub_4172C0(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        double a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        double a16)
{
  return a7 > a16;
}

//----- (004172E0) --------------------------------------------------------
unsigned int __thiscall sub_4172E0(_DWORD *this)
{
  unsigned int v2; // edi
  unsigned int result; // eax
  int v4; // ebx
  char *v5; // ebx
  char *v6; // edx
  int v7; // ecx
  int v8; // [esp+8h] [ebp-4h]

  v2 = 1;
  result = (this[25] - this[24]) >> 2;
  if ( result > 1 )
  {
    v4 = 0;
    v8 = 0;
    do
    {
      v5 = (char *)(this[24] + v4);
      v6 = (char *)(this[24] + 4 * v2);
      if ( *(_DWORD *)(*(_DWORD *)v5 + 20) == *(_DWORD *)(*(_DWORD *)v6 + 20) )
      {
        v4 = v8;
        v7 = 4 * v2;
      }
      else
      {
        sub_416F80(v5, v6, (v6 - v5) >> 2, (unsigned __int8 (__cdecl *)(int, int))sub_4172A0);
        v7 = 4 * v2;
        v4 = 4 * v2;
        v8 = 4 * v2;
      }
      if ( v2 == ((this[25] - this[24]) >> 2) - 1 )
        sub_416F80(
          (char *)(v4 + this[24]),
          (char *)(v7 + this[24] + 4),
          (v7 + 4 - v4) >> 2,
          (unsigned __int8 (__cdecl *)(int, int))sub_4172A0);
      ++v2;
      result = (this[25] - this[24]) >> 2;
    }
    while ( v2 < result );
  }
  return result;
}

//----- (004173B0) --------------------------------------------------------
int __cdecl sub_4173B0(
        int a1,
        int a2,
        int a3,
        const __m128i *a4,
        unsigned __int8 (__cdecl *a5)(__int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32))
{
  int v5; // edx
  int v6; // edi
  int v7; // esi
  bool i; // zf
  const __m128i *v9; // ecx
  const __m128i *v10; // ecx
  int v11; // eax
  int v12; // ecx
  int v13; // eax
  int j; // esi
  const __m128i *v15; // ecx
  int v16; // eax
  int result; // eax
  __m128i v18; // [esp-50h] [ebp-5Ch]
  __m128i v19; // [esp-50h] [ebp-5Ch]
  __m128i v20; // [esp-40h] [ebp-4Ch]
  __m128i v21; // [esp-40h] [ebp-4Ch]
  __m128i v22; // [esp-28h] [ebp-34h]
  __m128i v23; // [esp-28h] [ebp-34h]
  __m128i v24; // [esp-18h] [ebp-24h]
  __m128i v25; // [esp-18h] [ebp-24h]
  const __m128i *v26; // [esp+1Ch] [ebp+10h]

  v5 = a3;
  v6 = a2;
  v7 = 2 * a2 + 2;
  for ( i = v7 == a3; v7 < a3; i = v7 == a3 )
  {
    v9 = (const __m128i *)(a1 + 40 * v7);
    v22 = _mm_loadu_si128((const __m128i *)((char *)v9 - 40));
    v24 = _mm_loadu_si128((const __m128i *)((char *)v9 - 24));
    v18 = _mm_loadu_si128(v9);
    v20 = _mm_loadu_si128(v9 + 1);
    if ( a5(
           v18.m128i_i32[0],
           v18.m128i_i32[1],
           v18.m128i_i32[2],
           v18.m128i_i32[3],
           v20.m128i_i32[0],
           v20.m128i_i32[1],
           v20.m128i_i32[2],
           v20.m128i_i32[3],
           v9[2].m128i_i32[0],
           v9[2].m128i_i32[1],
           v22.m128i_i32[0],
           v22.m128i_i32[1],
           v22.m128i_i32[2],
           v22.m128i_i32[3],
           v24.m128i_i32[0],
           v24.m128i_i32[1],
           v24.m128i_i32[2],
           v24.m128i_i32[3],
           v9[-1].m128i_i32[2],
           v9[-1].m128i_i32[3]) )
    {
      --v7;
    }
    v5 = a3;
    v10 = (const __m128i *)(a1 + 40 * v7);
    v11 = 5 * v6;
    v6 = v7;
    *(__m128i *)(a1 + 8 * v11) = _mm_loadu_si128(v10);
    v7 = 2 * v7 + 2;
    *(__m128i *)(a1 + 8 * v11 + 16) = _mm_loadu_si128(v10 + 1);
    *(_QWORD *)(a1 + 8 * v11 + 32) = v10[2].m128i_i64[0];
  }
  if ( i )
  {
    v12 = a1 + 40 * v5;
    v13 = 5 * v6;
    *(__m128i *)(a1 + 8 * v13) = _mm_loadu_si128((const __m128i *)(v12 - 40));
    v6 = v5 - 1;
    *(__m128i *)(a1 + 8 * v13 + 16) = _mm_loadu_si128((const __m128i *)(v12 - 24));
    *(_QWORD *)(a1 + 8 * v13 + 32) = *(_QWORD *)(v12 - 8);
  }
  for ( j = (v6 - 1) / 2; a2 < v6; j = (j - 1) / 2 )
  {
    v15 = (const __m128i *)(a1 + 40 * j);
    v26 = v15;
    v23 = _mm_loadu_si128(a4);
    v25 = _mm_loadu_si128(a4 + 1);
    v19 = _mm_loadu_si128(v15);
    v21 = _mm_loadu_si128(v15 + 1);
    if ( !a5(
            v19.m128i_i32[0],
            v19.m128i_i32[1],
            v19.m128i_i32[2],
            v19.m128i_i32[3],
            v21.m128i_i32[0],
            v21.m128i_i32[1],
            v21.m128i_i32[2],
            v21.m128i_i32[3],
            v15[2].m128i_i32[0],
            v15[2].m128i_i32[1],
            v23.m128i_i32[0],
            v23.m128i_i32[1],
            v23.m128i_i32[2],
            v23.m128i_i32[3],
            v25.m128i_i32[0],
            v25.m128i_i32[1],
            v25.m128i_i32[2],
            v25.m128i_i32[3],
            a4[2].m128i_i32[0],
            a4[2].m128i_i32[1]) )
      break;
    v16 = 5 * v6;
    v6 = j;
    *(__m128i *)(a1 + 8 * v16) = _mm_loadu_si128(v26);
    *(__m128i *)(a1 + 8 * v16 + 16) = _mm_loadu_si128(v26 + 1);
    *(_QWORD *)(a1 + 8 * v16 + 32) = v26[2].m128i_i64[0];
  }
  result = 5 * v6;
  *(__m128i *)(a1 + 8 * result) = _mm_loadu_si128(a4);
  *(__m128i *)(a1 + 8 * result + 16) = _mm_loadu_si128(a4 + 1);
  *(_QWORD *)(a1 + 8 * result + 32) = a4[2].m128i_i64[0];
  return result;
}

//----- (00417570) --------------------------------------------------------
void __cdecl sub_417570(int a1, int a2)
{
  int i; // esi

  for ( i = a1; i != a2; i += 12 )
  {
    if ( *(_DWORD *)i )
    {
      operator delete(*(void **)i);
      *(_DWORD *)i = 0;
      *(_DWORD *)(i + 4) = 0;
      *(_DWORD *)(i + 8) = 0;
    }
  }
}

//----- (004175B0) --------------------------------------------------------
__m128i *__cdecl sub_4175B0(
        const __m128i *a1,
        __m128i *a2,
        unsigned __int8 (__cdecl *a3)(__int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32))
{
  __m128i *result; // eax
  __m128i *v4; // edi
  const __m128i *v5; // ebx
  const __m128i *v6; // esi
  __m128i v7; // xmm0
  __m128i v8; // xmm0
  const __m128i *v9; // esi
  __m128i *v10; // edi
  __m128i v11; // xmm0
  __m128i v12; // [esp-50h] [ebp-8Ch]
  __m128i v13; // [esp-50h] [ebp-8Ch]
  __m128i v14; // [esp-50h] [ebp-8Ch]
  __m128i v15; // [esp-40h] [ebp-7Ch]
  __m128i v16; // [esp-40h] [ebp-7Ch]
  __m128i v17; // [esp-40h] [ebp-7Ch]
  __m128i v18; // [esp-28h] [ebp-64h]
  __m128i v19; // [esp-28h] [ebp-64h]
  __m128i v20; // [esp-18h] [ebp-54h]
  __m128i v21; // [esp-18h] [ebp-54h]
  __m128i v22; // [esp-18h] [ebp-54h]
  __m128i v23; // [esp+Ch] [ebp-30h] BYREF
  __m128i v24; // [esp+1Ch] [ebp-20h] BYREF
  __int64 v25; // [esp+2Ch] [ebp-10h]
  const __m128i *v26; // [esp+34h] [ebp-8h]
  __m128i *v27; // [esp+38h] [ebp-4h]

  result = a2;
  v4 = (__m128i *)a1;
  if ( a1 != a2 )
  {
    v5 = (const __m128i *)((char *)a1 + 40);
    if ( &a1[2].m128i_u64[1] != (unsigned __int64 *)a2 )
    {
      v6 = a1;
      v26 = a1;
      do
      {
        v7 = _mm_loadu_si128(v5);
        v27 = (__m128i *)v5;
        v24 = v7;
        v23 = _mm_loadu_si128(v5 + 1);
        v25 = v5[2].m128i_i64[0];
        v18 = _mm_loadu_si128(v4);
        v20 = _mm_loadu_si128(v4 + 1);
        v12 = _mm_loadu_si128(v5);
        v15 = _mm_loadu_si128(v5 + 1);
        if ( a3(
               v12.m128i_i32[0],
               v12.m128i_i32[1],
               v12.m128i_i32[2],
               v12.m128i_i32[3],
               v15.m128i_i32[0],
               v15.m128i_i32[1],
               v15.m128i_i32[2],
               v15.m128i_i32[3],
               v5[2].m128i_i32[0],
               v5[2].m128i_i32[1],
               v18.m128i_i32[0],
               v18.m128i_i32[1],
               v18.m128i_i32[2],
               v18.m128i_i32[3],
               v20.m128i_i32[0],
               v20.m128i_i32[1],
               v20.m128i_i32[2],
               v20.m128i_i32[3],
               v4[2].m128i_i32[0],
               v4[2].m128i_i32[1]) )
        {
          result = (__m128i *)v5;
          if ( v4 != v5 )
          {
            do
            {
              v8 = _mm_loadu_si128((__m128i *)((char *)result - 40));
              result = (__m128i *)((char *)result - 40);
              *(__m128i *)((char *)result + 40) = v8;
              *(__m128i *)((char *)result + 56) = _mm_loadu_si128(result + 1);
              result[4].m128i_i64[1] = result[2].m128i_i64[0];
            }
            while ( result != v4 );
          }
          *v4 = _mm_loadu_si128(&v24);
          v4[1] = _mm_loadu_si128(&v23);
          v4[2].m128i_i64[0] = v25;
        }
        else
        {
          v9 = v26;
          v19 = _mm_loadu_si128(v26);
          v21 = _mm_loadu_si128(v26 + 1);
          v13 = _mm_loadu_si128(&v24);
          v16 = _mm_loadu_si128(&v23);
          if ( a3(
                 v13.m128i_i32[0],
                 v13.m128i_i32[1],
                 v13.m128i_i32[2],
                 v13.m128i_i32[3],
                 v16.m128i_i32[0],
                 v16.m128i_i32[1],
                 v16.m128i_i32[2],
                 v16.m128i_i32[3],
                 v25,
                 HIDWORD(v25),
                 v19.m128i_i32[0],
                 v19.m128i_i32[1],
                 v19.m128i_i32[2],
                 v19.m128i_i32[3],
                 v21.m128i_i32[0],
                 v21.m128i_i32[1],
                 v21.m128i_i32[2],
                 v21.m128i_i32[3],
                 v26[2].m128i_i32[0],
                 v26[2].m128i_i32[1]) )
          {
            v10 = v27;
            do
            {
              *v10 = _mm_loadu_si128(v9);
              v10[1] = _mm_loadu_si128(v9 + 1);
              v10[2].m128i_i64[0] = v9[2].m128i_i64[0];
              v10 = (__m128i *)v9;
              v11 = _mm_loadu_si128((const __m128i *)((char *)v9 - 40));
              v9 = (const __m128i *)((char *)v9 - 40);
              v22 = _mm_loadu_si128(v9 + 1);
              v14 = _mm_loadu_si128(&v24);
              v17 = _mm_loadu_si128(&v23);
            }
            while ( a3(
                      v14.m128i_i32[0],
                      v14.m128i_i32[1],
                      v14.m128i_i32[2],
                      v14.m128i_i32[3],
                      v17.m128i_i32[0],
                      v17.m128i_i32[1],
                      v17.m128i_i32[2],
                      v17.m128i_i32[3],
                      v25,
                      HIDWORD(v25),
                      v11.m128i_i32[0],
                      v11.m128i_i32[1],
                      v11.m128i_i32[2],
                      v11.m128i_i32[3],
                      v22.m128i_i32[0],
                      v22.m128i_i32[1],
                      v22.m128i_i32[2],
                      v22.m128i_i32[3],
                      v9[2].m128i_i32[0],
                      v9[2].m128i_i32[1]) );
            v27 = v10;
            v4 = (__m128i *)a1;
          }
          result = v27;
          v6 = v26;
          *v27 = _mm_loadu_si128(&v24);
          result[1] = _mm_loadu_si128(&v23);
          result[2].m128i_i64[0] = v25;
        }
        v5 = (const __m128i *)((char *)v5 + 40);
        v6 = (const __m128i *)((char *)v6 + 40);
        v26 = v6;
      }
      while ( v5 != a2 );
    }
  }
  return result;
}

//----- (004177B0) --------------------------------------------------------
int __cdecl sub_4177B0(
        int a1,
        int a2,
        unsigned __int8 (__cdecl *a3)(__int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32))
{
  int result; // eax
  int v5; // esi
  int v6; // edx
  __m128i v7; // xmm0
  const __m128i *v8; // eax
  int v9; // ebx
  __m128i v10; // xmm0
  int v11; // esi
  int v12; // edx
  const __m128i *v13; // ecx
  const __m128i *v14; // ecx
  int v15; // eax
  int v16; // ecx
  int v17; // eax
  __m128i v18; // [esp-50h] [ebp-8Ch]
  __m128i v19; // [esp-40h] [ebp-7Ch]
  __m128i v20; // [esp-28h] [ebp-64h]
  __m128i v21; // [esp-18h] [ebp-54h]
  __m128i v22[2]; // [esp+Ch] [ebp-30h] BYREF
  __int64 i; // [esp+2Ch] [ebp-10h]
  const __m128i *v24; // [esp+34h] [ebp-8h]
  int v25; // [esp+38h] [ebp-4h]
  int v26; // [esp+44h] [ebp+8h]
  int v27; // [esp+48h] [ebp+Ch]

  v27 = (a2 - a1) / 40;
  result = v27 - (v27 >> 31);
  v5 = v27 / 2;
  if ( v27 / 2 > 0 )
  {
    v6 = 2 * v5 + 2;
    result = a1 + 40 * v5;
    do
    {
      v7 = _mm_loadu_si128((const __m128i *)(result - 40));
      v8 = (const __m128i *)(result - 40);
      v25 = v5 - 1;
      v22[0] = v7;
      v9 = v5 - 1;
      v26 = v6 - 2;
      v10 = _mm_loadu_si128(v8 + 1);
      v11 = v6 - 2;
      v24 = v8;
      v12 = v27;
      v22[1] = v10;
      for ( i = v8[2].m128i_i64[0]; v11 < v27; *(_QWORD *)(a1 + 8 * v15 + 32) = v14[2].m128i_i64[0] )
      {
        v13 = (const __m128i *)(a1 + 40 * v11);
        v20 = _mm_loadu_si128((const __m128i *)((char *)v13 - 40));
        v21 = _mm_loadu_si128((const __m128i *)((char *)v13 - 24));
        v18 = _mm_loadu_si128(v13);
        v19 = _mm_loadu_si128(v13 + 1);
        if ( a3(
               v18.m128i_i32[0],
               v18.m128i_i32[1],
               v18.m128i_i32[2],
               v18.m128i_i32[3],
               v19.m128i_i32[0],
               v19.m128i_i32[1],
               v19.m128i_i32[2],
               v19.m128i_i32[3],
               v13[2].m128i_i32[0],
               v13[2].m128i_i32[1],
               v20.m128i_i32[0],
               v20.m128i_i32[1],
               v20.m128i_i32[2],
               v20.m128i_i32[3],
               v21.m128i_i32[0],
               v21.m128i_i32[1],
               v21.m128i_i32[2],
               v21.m128i_i32[3],
               v13[-1].m128i_i32[2],
               v13[-1].m128i_i32[3]) )
        {
          --v11;
        }
        v12 = v27;
        v14 = (const __m128i *)(a1 + 40 * v11);
        v15 = 5 * v9;
        v9 = v11;
        *(__m128i *)(a1 + 8 * v15) = _mm_loadu_si128(v14);
        v11 = 2 * v11 + 2;
        *(__m128i *)(a1 + 8 * v15 + 16) = _mm_loadu_si128(v14 + 1);
      }
      if ( v11 == v12 )
      {
        v16 = a1 + 40 * v12;
        v17 = 5 * v9;
        *(__m128i *)(a1 + 8 * v17) = _mm_loadu_si128((const __m128i *)(v16 - 40));
        v9 = v12 - 1;
        *(__m128i *)(a1 + 8 * v17 + 16) = _mm_loadu_si128((const __m128i *)(v16 - 24));
        *(_QWORD *)(a1 + 8 * v17 + 32) = *(_QWORD *)(v16 - 8);
      }
      v5 = v25;
      sub_417B70(a1, v9, v25, v22, a3);
      result = (int)v24;
      v6 = v26;
    }
    while ( v5 > 0 );
  }
  return result;
}

//----- (00417920) --------------------------------------------------------
int __cdecl sub_417920(
        __m128i *a1,
        __m128i *a2,
        __m128i *a3,
        unsigned __int8 (__cdecl *a4)(__int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32))
{
  __m128i v4; // xmm1
  __m128i v5; // xmm2
  __int64 v6; // xmm3_8
  int result; // eax
  __m128i v8; // xmm1
  __m128i v9; // xmm2
  __int64 v10; // xmm3_8
  __m128i v11; // xmm1
  __m128i v12; // xmm2
  __int64 v13; // xmm3_8
  __m128i v14; // [esp-28h] [ebp-5Ch]
  __m128i v15; // [esp-28h] [ebp-5Ch]
  __m128i v16; // [esp-18h] [ebp-4Ch]
  __m128i v17; // [esp-18h] [ebp-4Ch]
  __m128i v18; // [esp+0h] [ebp-34h]
  __m128i v19; // [esp+0h] [ebp-34h]
  __m128i v20; // [esp+0h] [ebp-34h]
  __m128i v21; // [esp+10h] [ebp-24h]
  __m128i v22; // [esp+10h] [ebp-24h]
  __m128i v23; // [esp+10h] [ebp-24h]

  v18 = _mm_loadu_si128(a1);
  v21 = _mm_loadu_si128(a1 + 1);
  v14 = _mm_loadu_si128(a2);
  v16 = _mm_loadu_si128(a2 + 1);
  if ( a4(
         v14.m128i_i32[0],
         v14.m128i_i32[1],
         v14.m128i_i32[2],
         v14.m128i_i32[3],
         v16.m128i_i32[0],
         v16.m128i_i32[1],
         v16.m128i_i32[2],
         v16.m128i_i32[3],
         a2[2].m128i_i32[0],
         a2[2].m128i_i32[1],
         v18.m128i_i32[0],
         v18.m128i_i32[1],
         v18.m128i_i32[2],
         v18.m128i_i32[3],
         v21.m128i_i32[0],
         v21.m128i_i32[1],
         v21.m128i_i32[2],
         v21.m128i_i32[3],
         a1[2].m128i_i32[0],
         a1[2].m128i_i32[1]) )
  {
    v4 = _mm_loadu_si128(a2);
    v5 = _mm_loadu_si128(a2 + 1);
    v6 = a2[2].m128i_i64[0];
    *a2 = _mm_loadu_si128(a1);
    a2[1] = _mm_loadu_si128(a1 + 1);
    a2[2].m128i_i64[0] = a1[2].m128i_i64[0];
    *a1 = v4;
    a1[1] = v5;
    a1[2].m128i_i64[0] = v6;
  }
  v19 = _mm_loadu_si128(a2);
  v22 = _mm_loadu_si128(a2 + 1);
  v15 = _mm_loadu_si128(a3);
  v17 = _mm_loadu_si128(a3 + 1);
  result = ((int (__cdecl *)(__int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32))a4)(
             v15.m128i_i32[0],
             v15.m128i_i32[1],
             v15.m128i_i32[2],
             v15.m128i_i32[3],
             v17.m128i_i32[0],
             v17.m128i_i32[1],
             v17.m128i_i32[2],
             v17.m128i_i32[3],
             a3[2].m128i_i32[0],
             a3[2].m128i_i32[1],
             v19.m128i_i32[0],
             v19.m128i_i32[1],
             v19.m128i_i32[2],
             v19.m128i_i32[3],
             v22.m128i_i32[0],
             v22.m128i_i32[1],
             v22.m128i_i32[2],
             v22.m128i_i32[3],
             a2[2].m128i_i32[0],
             a2[2].m128i_i32[1]);
  if ( (_BYTE)result )
  {
    v8 = _mm_loadu_si128(a3);
    v9 = _mm_loadu_si128(a3 + 1);
    v10 = a3[2].m128i_i64[0];
    *a3 = _mm_loadu_si128(a2);
    a3[1] = _mm_loadu_si128(a2 + 1);
    a3[2].m128i_i64[0] = a2[2].m128i_i64[0];
    *a2 = v8;
    a2[1] = v9;
    a2[2].m128i_i64[0] = v10;
    v20 = _mm_loadu_si128(a1);
    v23 = _mm_loadu_si128(a1 + 1);
    result = ((int (__cdecl *)(__int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, _DWORD, _DWORD, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32))a4)(
               v8.m128i_i32[0],
               v8.m128i_i32[1],
               v8.m128i_i32[2],
               v8.m128i_i32[3],
               v9.m128i_i32[0],
               v9.m128i_i32[1],
               v9.m128i_i32[2],
               v9.m128i_i32[3],
               v10,
               HIDWORD(v10),
               v20.m128i_i32[0],
               v20.m128i_i32[1],
               v20.m128i_i32[2],
               v20.m128i_i32[3],
               v23.m128i_i32[0],
               v23.m128i_i32[1],
               v23.m128i_i32[2],
               v23.m128i_i32[3],
               a1[2].m128i_i32[0],
               a1[2].m128i_i32[1]);
    if ( (_BYTE)result )
    {
      v11 = _mm_loadu_si128(a2);
      v12 = _mm_loadu_si128(a2 + 1);
      v13 = a2[2].m128i_i64[0];
      *a2 = _mm_loadu_si128(a1);
      a2[1] = _mm_loadu_si128(a1 + 1);
      a2[2].m128i_i64[0] = a1[2].m128i_i64[0];
      *a1 = v11;
      a1[1] = v12;
      a1[2].m128i_i64[0] = v13;
    }
  }
  return result;
}

//----- (00417AC0) --------------------------------------------------------
int __cdecl sub_417AC0(
        __m128i *a1,
        __m128i *a2,
        __m128i *a3,
        unsigned __int8 (__cdecl *a4)(__int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32))
{
  int v5; // eax
  int v6; // eax
  int v7; // ebx
  __m128i *v9; // [esp+8h] [ebp-4h]
  int v10; // [esp+14h] [ebp+8h]

  v5 = ((char *)a3 - (char *)a1) / 40;
  if ( v5 <= 40 )
    return sub_417920(a1, a2, a3, a4);
  v6 = (v5 + 1) / 8;
  v7 = 40 * v6;
  v10 = 80 * v6;
  v9 = (__m128i *)((char *)a1 + 40 * v6);
  sub_417920(a1, v9, &a1[5 * v6], a4);
  sub_417920((__m128i *)((char *)a2 - v7), a2, (__m128i *)((char *)a2 + v7), a4);
  sub_417920(&a3[v10 / 0xFFFFFFF0], (__m128i *)((char *)a3 - v7), a3, a4);
  return sub_417920(v9, a2, (__m128i *)((char *)a3 - v7), a4);
}

//----- (00417B70) --------------------------------------------------------
int __cdecl sub_417B70(
        int a1,
        int a2,
        int a3,
        const __m128i *a4,
        unsigned __int8 (__cdecl *a5)(__int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32))
{
  int v5; // ecx
  int v6; // esi
  const __m128i *v7; // edi
  int v8; // eax
  int result; // eax
  __m128i v10; // [esp-50h] [ebp-5Ch]
  __m128i v11; // [esp-40h] [ebp-4Ch]
  __m128i v12; // [esp-28h] [ebp-34h]
  __m128i v13; // [esp-18h] [ebp-24h]

  v5 = a2;
  v6 = (a2 - 1) / 2;
  if ( a3 < a2 )
  {
    while ( 1 )
    {
      v7 = (const __m128i *)(a1 + 40 * v6);
      v12 = _mm_loadu_si128(a4);
      v13 = _mm_loadu_si128(a4 + 1);
      v10 = _mm_loadu_si128(v7);
      v11 = _mm_loadu_si128(v7 + 1);
      if ( !a5(
              v10.m128i_i32[0],
              v10.m128i_i32[1],
              v10.m128i_i32[2],
              v10.m128i_i32[3],
              v11.m128i_i32[0],
              v11.m128i_i32[1],
              v11.m128i_i32[2],
              v11.m128i_i32[3],
              v7[2].m128i_i32[0],
              v7[2].m128i_i32[1],
              v12.m128i_i32[0],
              v12.m128i_i32[1],
              v12.m128i_i32[2],
              v12.m128i_i32[3],
              v13.m128i_i32[0],
              v13.m128i_i32[1],
              v13.m128i_i32[2],
              v13.m128i_i32[3],
              a4[2].m128i_i32[0],
              a4[2].m128i_i32[1]) )
        break;
      v8 = 5 * a2;
      *(__m128i *)(a1 + 8 * v8) = _mm_loadu_si128(v7);
      *(__m128i *)(a1 + 8 * v8 + 16) = _mm_loadu_si128(v7 + 1);
      *(_QWORD *)(a1 + 8 * v8 + 32) = v7[2].m128i_i64[0];
      v5 = v6;
      a2 = v6;
      v6 = (v6 - 1) / 2;
      if ( a3 >= a2 )
        goto LABEL_6;
    }
    v5 = a2;
  }
LABEL_6:
  result = 5 * v5;
  *(__m128i *)(a1 + 8 * result) = _mm_loadu_si128(a4);
  *(__m128i *)(a1 + 8 * result + 16) = _mm_loadu_si128(a4 + 1);
  *(_QWORD *)(a1 + 8 * result + 32) = a4[2].m128i_i64[0];
  return result;
}

//----- (00417C60) --------------------------------------------------------
int __cdecl sub_417C60(
        __m128i *a1,
        __m128i *a2,
        int a3,
        unsigned __int8 (__cdecl *a4)(__int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32))
{
  __m128i *v4; // ebx
  __m128i *v5; // edi
  unsigned __int8 (__cdecl *v6)(__int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32); // ecx
  int result; // eax
  __m128i *v9; // [esp+Ch] [ebp-8h] BYREF
  __m128i *v10; // [esp+10h] [ebp-4h]
  int v11; // [esp+24h] [ebp+10h]

  v4 = a1;
  v5 = a2;
  v6 = a4;
  result = ((char *)a2 - (char *)a1) / 40;
  if ( result <= 32 )
  {
LABEL_7:
    if ( result > 1 )
      return (int)sub_4175B0(v4, v5, v6);
  }
  else
  {
    while ( a3 > 0 )
    {
      sub_417E60(&v9, v4, v5, v6);
      v11 = a3 / 2 / 2 + a3 / 2;
      a3 = v11;
      if ( ((char *)v9 - (char *)v4) / 40 >= ((char *)v5 - (char *)v10) / 40 )
      {
        sub_417C60(v10, v5, v11, a4);
        v5 = v9;
      }
      else
      {
        sub_417C60(v4, v9, v11, a4);
        v4 = v10;
      }
      v6 = a4;
      result = ((char *)v5 - (char *)v4) / 40;
      if ( result <= 32 )
        goto LABEL_7;
    }
    if ( ((char *)v5 - (char *)v4) / 40 > 1 )
      sub_4177B0((int)v4, (int)v5, a4);
    return sub_417DA0(v4, (int)v5, a4);
  }
  return result;
}
// 417D53: conditional instruction was optimized away because eax.4>=21

//----- (00417DA0) --------------------------------------------------------
int __cdecl sub_417DA0(
        const __m128i *a1,
        int a2,
        unsigned __int8 (__cdecl *a3)(__int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32))
{
  int v3; // ecx
  int result; // eax
  __m128i *v5; // esi
  __m128i v6[2]; // [esp+8h] [ebp-28h] BYREF
  __int64 v7; // [esp+28h] [ebp-8h]

  v3 = a2 - (_DWORD)a1;
  result = (a2 - (int)a1) / 40;
  if ( result > 1 )
  {
    v5 = (__m128i *)(a2 - 40);
    do
    {
      v6[0] = _mm_loadu_si128(v5);
      v6[1] = _mm_loadu_si128(v5 + 1);
      v7 = v5[2].m128i_i64[0];
      *v5 = _mm_loadu_si128(a1);
      v5[1] = _mm_loadu_si128(a1 + 1);
      v5[2].m128i_i64[0] = a1[2].m128i_i64[0];
      sub_4173B0((int)a1, 0, (v3 - 40) / 40, v6, a3);
      v5 = (__m128i *)((char *)v5 - 40);
      v3 = (char *)v5 - (char *)a1 + 40;
      result = v3 / 40;
    }
    while ( v3 / 40 > 1 );
  }
  return result;
}

//----- (00417E60) --------------------------------------------------------
__m128i **__cdecl sub_417E60(
        __m128i **a1,
        __m128i *a2,
        __m128i *a3,
        unsigned __int8 (__cdecl *a4)(__int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32))
{
  __m128i *v4; // esi
  __m128i *v5; // ebx
  unsigned int v6; // ecx
  unsigned __int8 v7; // al
  __m128i *v8; // eax
  __m128i *v9; // edi
  __m128i *v10; // eax
  __m128i *v11; // ecx
  __m128i v12; // xmm1
  __m128i v13; // xmm2
  __int64 v14; // xmm3_8
  bool v15; // zf
  __m128i *v16; // edi
  __m128i *v17; // ebx
  __m128i v18; // xmm1
  __m128i v19; // xmm2
  __int64 v20; // xmm3_8
  __m128i v21; // xmm1
  __m128i v22; // xmm2
  __int64 v23; // xmm3_8
  __m128i *v24; // ecx
  __m128i *v25; // eax
  __m128i v26; // xmm1
  __m128i v27; // xmm2
  __int64 v28; // xmm3_8
  __m128i v29; // xmm1
  __m128i v30; // xmm2
  __int64 v31; // xmm3_8
  __m128i v32; // xmm0
  __m128i v33; // xmm1
  __m128i v34; // xmm2
  __int64 v35; // xmm3_8
  __m128i v36; // xmm1
  __m128i v37; // xmm2
  __int64 v38; // xmm3_8
  __m128i **result; // eax
  __m128i v40; // [esp-50h] [ebp-68h]
  __m128i v41; // [esp-50h] [ebp-68h]
  __m128i v42; // [esp-50h] [ebp-68h]
  __m128i v43; // [esp-50h] [ebp-68h]
  __m128i v44; // [esp-50h] [ebp-68h]
  __m128i v45; // [esp-50h] [ebp-68h]
  __m128i v46; // [esp-50h] [ebp-68h]
  __m128i v47; // [esp-50h] [ebp-68h]
  __m128i v48; // [esp-40h] [ebp-58h]
  __m128i v49; // [esp-40h] [ebp-58h]
  __m128i v50; // [esp-40h] [ebp-58h]
  __m128i v51; // [esp-40h] [ebp-58h]
  __m128i v52; // [esp-40h] [ebp-58h]
  __m128i v53; // [esp-40h] [ebp-58h]
  __m128i v54; // [esp-40h] [ebp-58h]
  __m128i v55; // [esp-40h] [ebp-58h]
  __m128i v56; // [esp-28h] [ebp-40h]
  __m128i v57; // [esp-28h] [ebp-40h]
  __m128i v58; // [esp-28h] [ebp-40h]
  __m128i v59; // [esp-28h] [ebp-40h]
  __m128i v60; // [esp-28h] [ebp-40h]
  __m128i v61; // [esp-28h] [ebp-40h]
  __m128i v62; // [esp-28h] [ebp-40h]
  __m128i v63; // [esp-28h] [ebp-40h]
  __m128i v64; // [esp-18h] [ebp-30h]
  __m128i v65; // [esp-18h] [ebp-30h]
  __m128i v66; // [esp-18h] [ebp-30h]
  __m128i v67; // [esp-18h] [ebp-30h]
  __m128i v68; // [esp-18h] [ebp-30h]
  __m128i v69; // [esp-18h] [ebp-30h]
  __m128i v70; // [esp-18h] [ebp-30h]
  __m128i v71; // [esp-18h] [ebp-30h]
  const __m128i *v72; // [esp+Ch] [ebp-Ch]
  __m128i *v73; // [esp+Ch] [ebp-Ch]
  __int8 *v74; // [esp+Ch] [ebp-Ch]
  __m128i *v75; // [esp+10h] [ebp-8h]
  __m128i *v76; // [esp+14h] [ebp-4h]

  v4 = (__m128i *)((char *)a2 + 40 * (((char *)a3 - (char *)a2) / 40 / 2));
  sub_417AC0(a2, v4, (__m128i *)((char *)a3 - 40), a4);
  v5 = (__m128i *)((char *)v4 + 40);
  v75 = (__m128i *)((char *)v4 + 40);
  if ( a2 < v4 )
  {
    do
    {
      v72 = (__m128i *)((char *)v4 - 40);
      v56 = _mm_loadu_si128(v4);
      v64 = _mm_loadu_si128(v4 + 1);
      v40 = _mm_loadu_si128((__m128i *)((char *)v4 - 40));
      v48 = _mm_loadu_si128((__m128i *)((char *)v4 - 24));
      if ( a4(
             v40.m128i_i32[0],
             v40.m128i_i32[1],
             v40.m128i_i32[2],
             v40.m128i_i32[3],
             v48.m128i_i32[0],
             v48.m128i_i32[1],
             v48.m128i_i32[2],
             v48.m128i_i32[3],
             v4[-1].m128i_i32[2],
             v4[-1].m128i_i32[3],
             v56.m128i_i32[0],
             v56.m128i_i32[1],
             v56.m128i_i32[2],
             v56.m128i_i32[3],
             v64.m128i_i32[0],
             v64.m128i_i32[1],
             v64.m128i_i32[2],
             v64.m128i_i32[3],
             v4[2].m128i_i32[0],
             v4[2].m128i_i32[1]) )
      {
        break;
      }
      v57 = _mm_loadu_si128(v72);
      v65 = _mm_loadu_si128(v72 + 1);
      v41 = _mm_loadu_si128(v4);
      v49 = _mm_loadu_si128(v4 + 1);
      if ( a4(
             v41.m128i_i32[0],
             v41.m128i_i32[1],
             v41.m128i_i32[2],
             v41.m128i_i32[3],
             v49.m128i_i32[0],
             v49.m128i_i32[1],
             v49.m128i_i32[2],
             v49.m128i_i32[3],
             v4[2].m128i_i32[0],
             v4[2].m128i_i32[1],
             v57.m128i_i32[0],
             v57.m128i_i32[1],
             v57.m128i_i32[2],
             v57.m128i_i32[3],
             v65.m128i_i32[0],
             v65.m128i_i32[1],
             v65.m128i_i32[2],
             v65.m128i_i32[3],
             v72[2].m128i_i32[0],
             v72[2].m128i_i32[1]) )
      {
        break;
      }
      v4 = (__m128i *)((char *)v4 - 40);
    }
    while ( a2 < v72 );
    v5 = v75;
  }
  v6 = (unsigned int)a3;
  if ( v5 < a3 )
  {
    while ( 1 )
    {
      v58 = _mm_loadu_si128(v4);
      v66 = _mm_loadu_si128(v4 + 1);
      v42 = _mm_loadu_si128(v5);
      v50 = _mm_loadu_si128(v5 + 1);
      if ( a4(
             v42.m128i_i32[0],
             v42.m128i_i32[1],
             v42.m128i_i32[2],
             v42.m128i_i32[3],
             v50.m128i_i32[0],
             v50.m128i_i32[1],
             v50.m128i_i32[2],
             v50.m128i_i32[3],
             v5[2].m128i_i32[0],
             v5[2].m128i_i32[1],
             v58.m128i_i32[0],
             v58.m128i_i32[1],
             v58.m128i_i32[2],
             v58.m128i_i32[3],
             v66.m128i_i32[0],
             v66.m128i_i32[1],
             v66.m128i_i32[2],
             v66.m128i_i32[3],
             v4[2].m128i_i32[0],
             v4[2].m128i_i32[1]) )
      {
        break;
      }
      v59 = _mm_loadu_si128(v5);
      v67 = _mm_loadu_si128(v5 + 1);
      v43 = _mm_loadu_si128(v4);
      v51 = _mm_loadu_si128(v4 + 1);
      v7 = a4(
             v43.m128i_i32[0],
             v43.m128i_i32[1],
             v43.m128i_i32[2],
             v43.m128i_i32[3],
             v51.m128i_i32[0],
             v51.m128i_i32[1],
             v51.m128i_i32[2],
             v51.m128i_i32[3],
             v4[2].m128i_i32[0],
             v4[2].m128i_i32[1],
             v59.m128i_i32[0],
             v59.m128i_i32[1],
             v59.m128i_i32[2],
             v59.m128i_i32[3],
             v67.m128i_i32[0],
             v67.m128i_i32[1],
             v67.m128i_i32[2],
             v67.m128i_i32[3],
             v5[2].m128i_i32[0],
             v5[2].m128i_i32[1]);
      v6 = (unsigned int)a3;
      if ( !v7 )
      {
        v5 = (__m128i *)((char *)v5 + 40);
        if ( v5 < a3 )
          continue;
      }
      goto LABEL_12;
    }
    v6 = (unsigned int)a3;
LABEL_12:
    v75 = v5;
  }
  v8 = v4;
  v9 = v5;
  v76 = v4;
LABEL_14:
  while ( 1 )
  {
    v73 = v9;
    while ( 1 )
    {
      if ( (unsigned int)v9 < v6 )
      {
        v74 = &v5[-3].m128i_i8[8];
        do
        {
          v60 = _mm_loadu_si128(v9);
          v68 = _mm_loadu_si128(v9 + 1);
          v44 = _mm_loadu_si128(v4);
          v52 = _mm_loadu_si128(v4 + 1);
          if ( !a4(
                  v44.m128i_i32[0],
                  v44.m128i_i32[1],
                  v44.m128i_i32[2],
                  v44.m128i_i32[3],
                  v52.m128i_i32[0],
                  v52.m128i_i32[1],
                  v52.m128i_i32[2],
                  v52.m128i_i32[3],
                  v4[2].m128i_i32[0],
                  v4[2].m128i_i32[1],
                  v60.m128i_i32[0],
                  v60.m128i_i32[1],
                  v60.m128i_i32[2],
                  v60.m128i_i32[3],
                  v68.m128i_i32[0],
                  v68.m128i_i32[1],
                  v68.m128i_i32[2],
                  v68.m128i_i32[3],
                  v9[2].m128i_i32[0],
                  v9[2].m128i_i32[1]) )
          {
            v61 = _mm_loadu_si128(v4);
            v69 = _mm_loadu_si128(v4 + 1);
            v45 = _mm_loadu_si128(v9);
            v53 = _mm_loadu_si128(v9 + 1);
            if ( a4(
                   v45.m128i_i32[0],
                   v45.m128i_i32[1],
                   v45.m128i_i32[2],
                   v45.m128i_i32[3],
                   v53.m128i_i32[0],
                   v53.m128i_i32[1],
                   v53.m128i_i32[2],
                   v53.m128i_i32[3],
                   v9[2].m128i_i32[0],
                   v9[2].m128i_i32[1],
                   v61.m128i_i32[0],
                   v61.m128i_i32[1],
                   v61.m128i_i32[2],
                   v61.m128i_i32[3],
                   v69.m128i_i32[0],
                   v69.m128i_i32[1],
                   v69.m128i_i32[2],
                   v69.m128i_i32[3],
                   v4[2].m128i_i32[0],
                   v4[2].m128i_i32[1]) )
            {
              break;
            }
            v10 = v5;
            v11 = (__m128i *)(v74 + 40);
            v5 = (__m128i *)((char *)v5 + 40);
            v74 += 40;
            if ( v10 != v9 )
            {
              v12 = _mm_loadu_si128(v11);
              v13 = _mm_loadu_si128(v11 + 1);
              v14 = v11[2].m128i_i64[0];
              *v11 = _mm_loadu_si128(v9);
              v11[1] = _mm_loadu_si128(v9 + 1);
              v11[2].m128i_i64[0] = v9[2].m128i_i64[0];
              *v9 = v12;
              v9[1] = v13;
              v9[2].m128i_i64[0] = v14;
            }
          }
          v9 = (__m128i *)((char *)v9 + 40);
        }
        while ( v9 < a3 );
        v8 = v76;
        v75 = v5;
        v73 = v9;
      }
      v15 = v8 == a2;
      if ( v8 > a2 )
      {
        v16 = v76;
        v17 = (__m128i *)((char *)v76 - 40);
        do
        {
          v62 = _mm_loadu_si128(v4);
          v70 = _mm_loadu_si128(v4 + 1);
          v46 = _mm_loadu_si128(v17);
          v54 = _mm_loadu_si128(v17 + 1);
          if ( !a4(
                  v46.m128i_i32[0],
                  v46.m128i_i32[1],
                  v46.m128i_i32[2],
                  v46.m128i_i32[3],
                  v54.m128i_i32[0],
                  v54.m128i_i32[1],
                  v54.m128i_i32[2],
                  v54.m128i_i32[3],
                  v17[2].m128i_i32[0],
                  v17[2].m128i_i32[1],
                  v62.m128i_i32[0],
                  v62.m128i_i32[1],
                  v62.m128i_i32[2],
                  v62.m128i_i32[3],
                  v70.m128i_i32[0],
                  v70.m128i_i32[1],
                  v70.m128i_i32[2],
                  v70.m128i_i32[3],
                  v4[2].m128i_i32[0],
                  v4[2].m128i_i32[1]) )
          {
            v63 = _mm_loadu_si128(v17);
            v71 = _mm_loadu_si128(v17 + 1);
            v47 = _mm_loadu_si128(v4);
            v55 = _mm_loadu_si128(v4 + 1);
            if ( a4(
                   v47.m128i_i32[0],
                   v47.m128i_i32[1],
                   v47.m128i_i32[2],
                   v47.m128i_i32[3],
                   v55.m128i_i32[0],
                   v55.m128i_i32[1],
                   v55.m128i_i32[2],
                   v55.m128i_i32[3],
                   v4[2].m128i_i32[0],
                   v4[2].m128i_i32[1],
                   v63.m128i_i32[0],
                   v63.m128i_i32[1],
                   v63.m128i_i32[2],
                   v63.m128i_i32[3],
                   v71.m128i_i32[0],
                   v71.m128i_i32[1],
                   v71.m128i_i32[2],
                   v71.m128i_i32[3],
                   v17[2].m128i_i32[0],
                   v17[2].m128i_i32[1]) )
            {
              break;
            }
            v4 = (__m128i *)((char *)v4 - 40);
            if ( v4 != v17 )
            {
              v18 = _mm_loadu_si128(v4);
              v19 = _mm_loadu_si128(v4 + 1);
              v20 = v4[2].m128i_i64[0];
              *v4 = _mm_loadu_si128(v17);
              v4[1] = _mm_loadu_si128(v17 + 1);
              v4[2].m128i_i64[0] = v17[2].m128i_i64[0];
              *v17 = v18;
              v17[1] = v19;
              v17[2].m128i_i64[0] = v20;
            }
          }
          v16 = (__m128i *)((char *)v16 - 40);
          v17 = (__m128i *)((char *)v17 - 40);
        }
        while ( a2 < v16 );
        v5 = v75;
        v76 = v16;
        v8 = v16;
        v15 = v16 == a2;
        v9 = v73;
      }
      if ( v15 )
        break;
      v6 = (unsigned int)a3;
      v8 = (__m128i *)((char *)v8 - 40);
      v76 = v8;
      if ( v9 != a3 )
      {
        v36 = _mm_loadu_si128(v9);
        v37 = _mm_loadu_si128(v9 + 1);
        v38 = v9[2].m128i_i64[0];
        *v9 = _mm_loadu_si128(v8);
        v9[1] = _mm_loadu_si128(v8 + 1);
        v9[2].m128i_i64[0] = v8[2].m128i_i64[0];
        v9 = (__m128i *)((char *)v9 + 40);
        *v8 = v36;
        v8[1] = v37;
        v8[2].m128i_i64[0] = v38;
        goto LABEL_14;
      }
      v4 = (__m128i *)((char *)v4 - 40);
      if ( v8 != v4 )
      {
        v29 = _mm_loadu_si128(v8);
        v30 = _mm_loadu_si128(v8 + 1);
        v31 = v8[2].m128i_i64[0];
        *v8 = _mm_loadu_si128(v4);
        v8[1] = _mm_loadu_si128(v4 + 1);
        v8[2].m128i_i64[0] = v4[2].m128i_i64[0];
        *v4 = v29;
        v4[1] = v30;
        v4[2].m128i_i64[0] = v31;
      }
      v32 = _mm_loadu_si128((__m128i *)((char *)v5 - 40));
      v5 = (__m128i *)((char *)v5 - 40);
      v33 = _mm_loadu_si128(v4);
      v75 = v5;
      v34 = _mm_loadu_si128(v4 + 1);
      v35 = v4[2].m128i_i64[0];
      *v4 = v32;
      v4[1] = _mm_loadu_si128(v5 + 1);
      v4[2].m128i_i64[0] = v5[2].m128i_i64[0];
      *v5 = v33;
      v5[1] = v34;
      v5[2].m128i_i64[0] = v35;
    }
    if ( v9 == a3 )
      break;
    if ( v5 != v9 )
    {
      v21 = _mm_loadu_si128(v4);
      v22 = _mm_loadu_si128(v4 + 1);
      v23 = v4[2].m128i_i64[0];
      *v4 = _mm_loadu_si128(v5);
      v4[1] = _mm_loadu_si128(v5 + 1);
      v4[2].m128i_i64[0] = v5[2].m128i_i64[0];
      *v5 = v21;
      v5[1] = v22;
      v5[2].m128i_i64[0] = v23;
    }
    v24 = v9;
    v25 = v4;
    v5 = (__m128i *)((char *)v5 + 40);
    v4 = (__m128i *)((char *)v4 + 40);
    v75 = v5;
    v9 = (__m128i *)((char *)v9 + 40);
    v26 = _mm_loadu_si128(v25);
    v27 = _mm_loadu_si128(v25 + 1);
    v28 = v25[2].m128i_i64[0];
    *v25 = _mm_loadu_si128(v24);
    v25[1] = _mm_loadu_si128(v24 + 1);
    v25[2].m128i_i64[0] = v24[2].m128i_i64[0];
    v8 = v76;
    *v24 = v26;
    v24[1] = v27;
    v24[2].m128i_i64[0] = v28;
    v6 = (unsigned int)a3;
  }
  result = a1;
  *a1 = v4;
  a1[1] = v5;
  return result;
}

//----- (004183C0) --------------------------------------------------------
void __cdecl sub_4183C0(_OWORD *a1, int a2)
{
  int i; // ecx

  for ( i = a2; i; --i )
  {
    if ( a1 )
    {
      *a1 = 0i64;
      a1[1] = 0i64;
    }
    a1 += 2;
  }
}

//----- (004183F0) --------------------------------------------------------
__m128i *__cdecl sub_4183F0(const __m128i *a1, const __m128i *a2, __m128i *a3)
{
  const __m128i *v3; // ecx
  __m128i *result; // eax

  v3 = a1;
  for ( result = a3; v3 != a2; result += 2 )
  {
    if ( result )
    {
      *result = _mm_loadu_si128(v3);
      result[1] = _mm_loadu_si128(v3 + 1);
    }
    v3 += 2;
  }
  return result;
}

//----- (00418430) --------------------------------------------------------
__m128i *__cdecl sub_418430(const __m128i *a1, const __m128i *a2, __m128i *a3)
{
  const __m128i *v3; // ecx
  __m128i *result; // eax

  v3 = a1;
  for ( result = a3; v3 != a2; result = (__m128i *)((char *)result + 24) )
  {
    if ( result )
    {
      *result = _mm_loadu_si128(v3);
      result[1].m128i_i64[0] = v3[1].m128i_i64[0];
    }
    v3 = (const __m128i *)((char *)v3 + 24);
  }
  return result;
}

//----- (00418470) --------------------------------------------------------
_DWORD *__cdecl sub_418470(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result; // eax
  _DWORD *v4; // edx

  result = a3;
  if ( a1 != a2 )
  {
    v4 = a1 + 2;
    do
    {
      if ( result )
      {
        *result = 0;
        result[1] = 0;
        result[2] = 0;
        *result = *(v4 - 2);
        result[1] = *(v4 - 1);
        result[2] = *v4;
        *(v4 - 2) = 0;
        *(v4 - 1) = 0;
        *v4 = 0;
      }
      v4 += 3;
      result += 3;
    }
    while ( v4 - 2 != a2 );
  }
  return result;
}

//----- (004184D0) --------------------------------------------------------
int __thiscall sub_4184D0(int this, double a2, int a3, int a4, double a5)
{
  __int128 v6; // xmm0
  int result; // eax
  int v8; // ecx
  double v9; // xmm2_8
  double v10; // xmm4_8
  double v11; // xmm5_8
  int v12; // eax
  double v13; // xmm1_8
  unsigned int v14; // edx
  int v15; // esi
  double v16; // xmm6_8
  double v17; // xmm7_8
  double v18; // xmm4_8
  int v19; // ecx
  double v20; // xmm5_8
  int v21; // esi
  double v22; // xmm6_8
  double v23; // xmm7_8
  int v24; // eax
  double v25; // xmm3_8
  double v26; // st7
  double v27; // xmm3_8
  int v28; // ecx
  int v29; // edx
  double v30; // xmm1_8
  double v31; // xmm0_8
  double v32; // xmm2_8
  double v33; // xmm1_8
  int v34; // eax
  int v35; // eax
  double v36; // xmm1_8
  int v37; // ecx
  bool v38; // zf
  double v39; // xmm1_8
  double v40[2]; // [esp+48h] [ebp-174h] BYREF
  double v41; // [esp+58h] [ebp-164h]
  double v42; // [esp+60h] [ebp-15Ch]
  double v43; // [esp+68h] [ebp-154h]
  double v44; // [esp+70h] [ebp-14Ch]
  double v45; // [esp+78h] [ebp-144h]
  double v46; // [esp+80h] [ebp-13Ch]
  double v47; // [esp+88h] [ebp-134h]
  double v48; // [esp+90h] [ebp-12Ch]
  double v49; // [esp+98h] [ebp-124h]
  double v50; // [esp+A0h] [ebp-11Ch]
  double v51; // [esp+A8h] [ebp-114h]
  double v52; // [esp+B0h] [ebp-10Ch]
  double v53; // [esp+B8h] [ebp-104h]
  double v54; // [esp+C0h] [ebp-FCh]
  double v55; // [esp+C8h] [ebp-F4h]
  double v56; // [esp+D0h] [ebp-ECh]
  double v57; // [esp+D8h] [ebp-E4h]
  int v58; // [esp+E0h] [ebp-DCh]
  int v59; // [esp+E4h] [ebp-D8h]
  double v60; // [esp+E8h] [ebp-D4h]
  int v61; // [esp+F0h] [ebp-CCh]
  int v62; // [esp+F4h] [ebp-C8h]
  int v63; // [esp+F8h] [ebp-C4h]
  unsigned int v64; // [esp+FCh] [ebp-C0h]
  int v65; // [esp+100h] [ebp-BCh]
  int v66; // [esp+104h] [ebp-B8h]
  char v67[176]; // [esp+108h] [ebp-B4h] BYREF

  v60 = a5;
  v6 = *(_OWORD *)(a3 + 8);
  v63 = a3;
  sub_406C30(*(_QWORD *)a3, *(double *)&v6, *((double *)&v6 + 1), v40);
  sub_4216E0((_DWORD *)(this + 108), *(_DWORD *)(this + 16));
  sub_405750((_DWORD *)(this + 120), *(_DWORD *)(this + 16));
  result = sub_405EB0((int)v67, a4, v63 + 24, *(__int64 *)&v60);
  v8 = 0;
  v65 = 0;
  v66 = 0;
  if ( *(int *)(this + 8) > 0 )
  {
    v9 = a2;
    v10 = v47;
    v11 = v41;
    do
    {
      v12 = *(_DWORD *)(this + 96);
      v13 = 0.0;
      v60 = 0.0;
      v59 = *(_DWORD *)(v12 + 4 * v8);
      v14 = (int)((unsigned __int64)(1717986919i64 * (*(_DWORD *)(v59 + 12) - *(_DWORD *)(v59 + 8))) >> 32) >> 4;
      v15 = (*(_DWORD *)(v59 + 12) - *(_DWORD *)(v59 + 8)) / 40;
      v58 = v15;
      if ( v15 > 0 )
      {
        v16 = v10;
        v17 = v11;
        v18 = v10 * -v9;
        v19 = 0;
        v20 = v11 * -v9;
        v64 = v14 + (v14 >> 31);
        v21 = v66;
        v62 = 32 * v65;
        v52 = -v9;
        v22 = v16 * v9;
        v61 = 0;
        v23 = v17 * v9;
        v53 = v22;
        v56 = v18;
        v51 = v23;
        v55 = v20;
        v48 = v44 * -v9;
        v50 = v44 * v9;
        do
        {
          v24 = *(_DWORD *)(v59 + 8);
          v25 = *(double *)(v19 + v24 + 16) - *(double *)(this + 40);
          v57 = *(double *)(v19 + v24 + 8) - *(double *)(this + 32);
          v49 = v25;
          v26 = sub_406A70(
                  (int)v67,
                  -10.0,
                  0.0,
                  -1.0,
                  1.0e-10,
                  v40[1] * v25 + v40[0] * v57 + v20,
                  v23,
                  v46 * v25 + v45 * v57 + v18,
                  v22);
          v27 = v49;
          v28 = v62;
          v29 = v65;
          v30 = v43 * v49;
          v31 = v42 * v57;
          *(double *)(v62 + *(_DWORD *)(this + 108)) = v57;
          v32 = v52;
          v18 = v56;
          v20 = v55;
          v22 = v53;
          v23 = v51;
          *(double *)(*(_DWORD *)(this + 108) + v28 + 8) = v27;
          v33 = v30 + v31 + v48;
          v34 = *(_DWORD *)(this + 108);
          v54 = v26;
          *(double *)(v34 + v28 + 16) = v32;
          *(double *)(*(_DWORD *)(this + 108) + v28 + 24) = v26;
          v35 = *(_DWORD *)(this + 120);
          v36 = v33 * v26 - v50;
          v62 = v28 + 32;
          v37 = v61;
          *(_DWORD *)(v35 + 4 * v29) = v21;
          v19 = v37 + 40;
          v61 = v19;
          v38 = v64-- == 1;
          v13 = v36 + v60;
          v65 = v29 + 1;
          v60 = v13;
        }
        while ( !v38 );
        v9 = a2;
        v10 = v47;
        v11 = v41;
        v15 = v58;
      }
      v39 = v13 / *(double *)(this + 56);
      result = v66 + *(_DWORD *)(this + 204);
      v8 = ++v66;
      *(double *)(v63 + 8 * result) = v39 / (double)v15;
    }
    while ( v8 < *(_DWORD *)(this + 8) );
  }
  return result;
}

//----- (00418880) --------------------------------------------------------
_DWORD *__userpurge sub_418880@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, int a4, int a5, __int64 a6)
{
  int v6; // edi
  int *v7; // edx
  double v8; // xmm5_8
  int v9; // ecx
  double v10; // xmm6_8
  int v11; // esi
  double v12; // xmm3_8
  double v13; // xmm1_8
  int v14; // eax
  double v15; // xmm1_8
  int v16; // esi
  int v17; // ecx
  double v18; // xmm7_8
  double v19; // xmm6_8
  double v20; // xmm5_8
  double v21; // xmm7_8
  int v22; // eax
  double v23; // xmm3_8
  double v24; // st7
  double v25; // xmm2_8
  double v26; // xmm3_8
  double v27; // xmm0_8
  double v28; // xmm1_8
  double v29; // xmm0_8
  unsigned __int64 v30; // xmm2_8
  int v31; // eax
  double v32; // xmm1_8
  bool v33; // zf
  double v34; // xmm0_8
  int v35; // eax
  float *v36; // esi
  double v37; // xmm2_8
  double v38; // xmm7_8
  double v39; // xmm5_8
  double v40; // xmm6_8
  double v41; // st7
  double v42; // xmm1_8
  int v43; // ecx
  double v44; // st7
  double v45; // xmm1_8
  int v46; // ecx
  double v47; // st7
  int v48; // ecx
  _DWORD *result; // eax
  int v50; // edi
  int v51; // esi
  int v52; // edi
  double v53; // xmm3_8
  double v54; // xmm2_8
  double v55; // xmm4_8
  double v56; // xmm1_8
  double v57; // xmm0_8
  double v58; // xmm3_8
  int v59; // [esp+40h] [ebp-1A8h]
  int v60; // [esp+44h] [ebp-1A4h]
  int v61; // [esp+48h] [ebp-1A0h]
  int v62; // [esp+48h] [ebp-1A0h]
  int v63; // [esp+48h] [ebp-1A0h]
  int v64; // [esp+4Ch] [ebp-19Ch]
  _DWORD *v65; // [esp+4Ch] [ebp-19Ch]
  int v66; // [esp+50h] [ebp-198h]
  double v67; // [esp+50h] [ebp-198h]
  _DWORD *v68; // [esp+50h] [ebp-198h]
  int v69; // [esp+58h] [ebp-190h]
  int v70; // [esp+60h] [ebp-188h]
  double v71; // [esp+60h] [ebp-188h]
  double v72; // [esp+68h] [ebp-180h]
  double v73; // [esp+68h] [ebp-180h]
  double v74; // [esp+68h] [ebp-180h]
  double v75; // [esp+68h] [ebp-180h]
  double v76; // [esp+70h] [ebp-178h]
  double v77; // [esp+70h] [ebp-178h]
  double v78; // [esp+70h] [ebp-178h]
  double v79; // [esp+70h] [ebp-178h]
  double v80; // [esp+78h] [ebp-170h]
  double v81; // [esp+78h] [ebp-170h]
  int v82; // [esp+80h] [ebp-168h]
  double v83; // [esp+80h] [ebp-168h]
  double v84; // [esp+88h] [ebp-160h]
  int v85; // [esp+90h] [ebp-158h]
  double v87; // [esp+A0h] [ebp-148h]
  double v88; // [esp+A8h] [ebp-140h] BYREF
  double v89; // [esp+B0h] [ebp-138h]
  double v90; // [esp+B8h] [ebp-130h]
  double v91; // [esp+C0h] [ebp-128h]
  double v92; // [esp+C8h] [ebp-120h]
  double v93; // [esp+D0h] [ebp-118h]
  double v94; // [esp+D8h] [ebp-110h]
  double v95; // [esp+E0h] [ebp-108h]
  double v96; // [esp+E8h] [ebp-100h]
  double v97; // [esp+F0h] [ebp-F8h]
  double v98; // [esp+F8h] [ebp-F0h]
  double v99; // [esp+100h] [ebp-E8h]
  double v100; // [esp+108h] [ebp-E0h]
  double v101; // [esp+110h] [ebp-D8h]
  double v102; // [esp+118h] [ebp-D0h]
  double v103; // [esp+120h] [ebp-C8h]
  unsigned __int64 v104; // [esp+128h] [ebp-C0h]
  char v105[180]; // [esp+130h] [ebp-B8h] BYREF

  v60 = a3;
  v59 = a2;
  v6 = a1;
  sub_406C30(*(_QWORD *)a4, *(double *)(a4 + 8), *(double *)(a4 + 16), &v88);
  v7 = (int *)(v6 + 48);
  if ( *(_DWORD *)(v6 + 48) < *(_DWORD *)(v6 + 52) )
    v7 = (int *)(v6 + 52);
  v87 = (double)*v7 * *(double *)(a4 + 64);
  sub_405EB0((int)v105, a5, a4 + 24, a6);
  sub_4216E0((_DWORD *)(v6 + 108), *(_DWORD *)(v6 + 16) + 3 * *(_DWORD *)(v6 + 24));
  sub_405750((_DWORD *)(v6 + 120), *(_DWORD *)(v6 + 16));
  v8 = v96;
  v9 = 0;
  v10 = v90;
  v11 = 0;
  v61 = 0;
  v70 = 0;
  v84 = 0.0;
  if ( *(int *)(v6 + 8) > 0 )
  {
    v12 = v93;
    do
    {
      v13 = 0.0;
      v80 = 0.0;
      v85 = *(_DWORD *)(*(_DWORD *)(v6 + 96) + 4 * v9);
      v14 = (*(_DWORD *)(v85 + 12) - *(_DWORD *)(v85 + 8)) / 40;
      v69 = v14;
      if ( v14 > 0 )
      {
        v15 = v10 * v87;
        v16 = 32 * v11;
        v17 = 0;
        v82 = 0;
        v18 = v8;
        v19 = v10 * COERCE_DOUBLE(*(_QWORD *)&v87 ^ 0x8000000000000000ui64);
        v66 = (*(_DWORD *)(v85 + 12) - *(_DWORD *)(v85 + 8)) / 40;
        v97 = v15;
        v20 = v8 * COERCE_DOUBLE(*(_QWORD *)&v87 ^ 0x8000000000000000ui64);
        v104 = *(_QWORD *)&v87 ^ 0x8000000000000000ui64;
        v21 = v18 * v87;
        v98 = v20;
        v72 = v21;
        v76 = v19;
        v103 = v12 * COERCE_DOUBLE(*(_QWORD *)&v87 ^ 0x8000000000000000ui64);
        v100 = v12 * v87;
        do
        {
          v22 = *(_DWORD *)(v85 + 8);
          v23 = *(double *)(v17 + v22 + 16) - *(double *)(v6 + 40);
          v101 = *(double *)(v17 + v22 + 8) - *(double *)(v6 + 32);
          v99 = v23;
          v24 = sub_406A70(
                  (int)v105,
                  -10.0,
                  0.0,
                  -1.0,
                  1.0e-10,
                  v89 * v23 + v88 * v101 + v19,
                  v97,
                  v95 * v23 + v94 * v101 + v20,
                  v21);
          v25 = v101;
          v26 = v99;
          v27 = v91;
          v28 = v92;
          *(double *)(v16 + *(_DWORD *)(v6 + 108)) = v101;
          v29 = v27 * v25;
          v30 = v104;
          *(double *)(v16 + *(_DWORD *)(v6 + 108) + 8) = v26;
          v20 = v98;
          v19 = v76;
          v21 = v72;
          *(_QWORD *)(v16 + *(_DWORD *)(v6 + 108) + 16) = v30;
          v31 = *(_DWORD *)(v6 + 108);
          v32 = v28 * v26 + v29 + v103;
          v102 = v24;
          *(double *)(v16 + v31 + 24) = v24;
          v16 += 32;
          *(_DWORD *)(*(_DWORD *)(v6 + 120) + 4 * v61++) = v70;
          v17 = v82 + 40;
          v33 = v66-- == 1;
          v82 += 40;
          v13 = v32 * v24 - v100 + v80;
          v80 = v13;
        }
        while ( !v33 );
        v8 = v96;
        v10 = v90;
        v12 = v93;
        v11 = v61;
        v14 = v69;
      }
      v34 = (double)v14;
      v35 = v70 + *(_DWORD *)(v6 + 204);
      v9 = ++v70;
      *(double *)(a4 + 8 * v35) = v13 / *(double *)(v6 + 56) / v34;
    }
    while ( v70 < *(_DWORD *)(v6 + 8) );
  }
  v36 = *(float **)(v6 + 192);
  v62 = 0;
  v64 = 0;
  if ( *(int *)(v6 + 24) > 0 )
  {
    v37 = v10 * v87;
    v38 = v8 * v87;
    v39 = v8 * -v87;
    v40 = v10 * -v87;
    v67 = -v87;
    v81 = v38;
    v83 = v39;
    v71 = v40;
    do
    {
      v73 = *v36 - *(double *)(v6 + 32);
      v77 = v36[1] - *(double *)(v6 + 40);
      v41 = sub_406A70(
              (int)v105,
              -10.0,
              0.0,
              -1.0,
              1.0e-10,
              v89 * v77 + v88 * v73 + v40,
              v37,
              v95 * v77 + v94 * v73 + v39,
              v38);
      v42 = v95;
      *(double *)(32 * (v62 + *(_DWORD *)(v6 + 16)) + *(_DWORD *)(v6 + 108)) = v73;
      *(double *)(32 * (v62 + *(_DWORD *)(v6 + 16)) + *(_DWORD *)(v6 + 108) + 8) = v77;
      *(double *)(32 * (v62 + *(_DWORD *)(v6 + 16)) + *(_DWORD *)(v6 + 108) + 16) = v67;
      v43 = v62 + *(_DWORD *)(v6 + 16);
      v63 = v62 + 1;
      *(double *)(32 * v43 + *(_DWORD *)(v6 + 108) + 24) = v41;
      v74 = v36[4] - *(double *)(v6 + 32);
      v78 = v36[5] - *(double *)(v6 + 40);
      v44 = sub_406A70(
              (int)v105,
              -10.0,
              0.0,
              -1.0,
              1.0e-10,
              v89 * v78 + v88 * v74 + v71,
              v37,
              v42 * v78 + v94 * v74 + v83,
              v81);
      v45 = v95;
      *(double *)(32 * (v63 + *(_DWORD *)(v6 + 16)) + *(_DWORD *)(v6 + 108)) = v74;
      *(double *)(32 * (v63 + *(_DWORD *)(v6 + 16)) + *(_DWORD *)(v6 + 108) + 8) = v78;
      *(double *)(32 * (v63 + *(_DWORD *)(v6 + 16)) + *(_DWORD *)(v6 + 108) + 16) = v67;
      v46 = v63 + *(_DWORD *)(v6 + 16);
      ++v63;
      *(double *)(32 * v46 + *(_DWORD *)(v6 + 108) + 24) = v44;
      v75 = v36[2] - *(double *)(v6 + 32);
      v79 = v36[3] - *(double *)(v6 + 40);
      v47 = sub_406A70(
              (int)v105,
              -10.0,
              0.0,
              -1.0,
              1.0e-10,
              v89 * v79 + v88 * v75 + v71,
              v37,
              v45 * v79 + v94 * v75 + v83,
              v81);
      *(double *)(32 * (v63 + *(_DWORD *)(v6 + 16)) + *(_DWORD *)(v6 + 108)) = v75;
      v36 += 10;
      v39 = v83;
      v40 = v71;
      v38 = v81;
      *(double *)(32 * (v63 + *(_DWORD *)(v6 + 16)) + *(_DWORD *)(v6 + 108) + 8) = v79;
      *(double *)(32 * (v63 + *(_DWORD *)(v6 + 16)) + *(_DWORD *)(v6 + 108) + 16) = v67;
      v48 = v63 + *(_DWORD *)(v6 + 16);
      v62 = v63 + 1;
      *(double *)(32 * v48 + *(_DWORD *)(v6 + 108) + 24) = v47;
      ++v64;
    }
    while ( v64 < *(_DWORD *)(v6 + 24) );
  }
  result = *(_DWORD **)(v6 + 8);
  v68 = result;
  if ( (int)result > 0 )
  {
    result = *(_DWORD **)(v6 + 96);
    v65 = result;
    do
    {
      v50 = *result;
      v51 = (*(_DWORD *)(v50 + 12) - *(_DWORD *)(v50 + 8)) / 40;
      if ( v51 > 0 )
      {
        v52 = *(_DWORD *)(v50 + 8);
        do
        {
          v52 += 40;
          v84 = *(double *)libm_sse2_sqrt_precise(v59, v60, v62, v65).m128_u64 + v84;
          --v51;
        }
        while ( v51 );
      }
      result = v65 + 1;
      v33 = v68 == (_DWORD *)1;
      v68 = (_DWORD *)((char *)v68 - 1);
      ++v65;
    }
    while ( !v33 );
    v6 = a1;
  }
  v53 = (double)*(int *)(v6 + 16);
  v54 = 50.0;
  v55 = v53 / (double)*(int *)(v6 + 24);
  v56 = v84 / v53;
  if ( v55 < 50.0 )
    v55 = 50.0;
  v57 = (double)*(int *)(v6 + 28);
  *(double *)(v6 + 80) = v55;
  v58 = v53 / v57;
  if ( v58 >= 50.0 )
    v54 = v58;
  *(_QWORD *)(v6 + 88) = 0x4059000000000000i64;
  *(double *)(v6 + 72) = v54 * v56;
  return result;
}
// 418880: could not find valid save-restore pair for edi
// 418880: could not find valid save-restore pair for esi
// 419098: variable 'v59' is possibly undefined
// 419098: variable 'v60' is possibly undefined
// 419098: variable 'v62' is possibly undefined
// 419098: variable 'v65' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00419150) --------------------------------------------------------
void __thiscall sub_419150(unsigned int *this, double a2, int a3, int a4, double a5)
{
  __int128 v6; // xmm0
  double *v7; // edi
  int *v8; // esi
  int v9; // edx
  int v10; // ecx
  double v11; // xmm1_8
  int v12; // eax
  int v13; // esi
  double v14; // xmm4_8
  int v15; // edi
  int v16; // ecx
  double v17; // xmm5_8
  double v18; // xmm6_8
  double v19; // xmm7_8
  int v20; // eax
  double v21; // xmm3_8
  double v22; // st7
  int *v23; // ecx
  double v24; // xmm3_8
  double v25; // xmm0_8
  int v26; // edx
  double v27; // xmm1_8
  double v28; // xmm2_8
  double v29; // xmm1_8
  int v30; // eax
  int v31; // ecx
  bool v32; // zf
  int v33; // ecx
  int v34; // eax
  signed int v35; // esi
  unsigned int v36; // ecx
  unsigned int v37; // esi
  unsigned int v38; // ecx
  int v39; // eax
  signed int v40; // esi
  unsigned int v41; // ecx
  unsigned int v42; // esi
  unsigned int v43; // ecx
  int v44; // eax
  double v45; // xmm2_8
  double v46; // xmm1_8
  double v47; // xmm0_8
  int v48; // ecx
  signed int v49; // edi
  unsigned int v50; // edx
  unsigned int v51; // edi
  unsigned int v52; // edx
  double *v53; // ecx
  signed int v54; // edi
  unsigned int v55; // edx
  unsigned int v56; // edi
  unsigned int v57; // edx
  int v58; // ecx
  int v59; // edi
  int v60; // esi
  int v61; // edx
  double *v62; // eax
  int v63; // esi
  int v64; // ecx
  double v65; // xmm2_8
  double v66; // xmm3_8
  int v67; // edx
  double v68; // xmm0_8
  char v69; // al
  double *v70; // edi
  __int32 *v71; // esi
  int v72; // ecx
  double v73; // xmm0_8
  int v74; // eax
  _DWORD *v75; // esi
  int v76; // eax
  double v77; // xmm0_8
  int v78; // eax
  unsigned int v79; // [esp+3Ch] [ebp-210h]
  double v80[2]; // [esp+4Ch] [ebp-200h] BYREF
  double v81; // [esp+5Ch] [ebp-1F0h]
  double v82; // [esp+64h] [ebp-1E8h]
  double v83; // [esp+6Ch] [ebp-1E0h]
  double v84; // [esp+74h] [ebp-1D8h]
  double v85; // [esp+7Ch] [ebp-1D0h]
  double v86; // [esp+84h] [ebp-1C8h]
  double v87; // [esp+8Ch] [ebp-1C0h]
  double v88; // [esp+94h] [ebp-1B8h]
  double v89; // [esp+9Ch] [ebp-1B0h]
  double v90; // [esp+A4h] [ebp-1A8h]
  double v91; // [esp+ACh] [ebp-1A0h]
  double v92; // [esp+B4h] [ebp-198h]
  double v93; // [esp+BCh] [ebp-190h]
  double v94; // [esp+C4h] [ebp-188h]
  double v95; // [esp+CCh] [ebp-180h]
  double v96; // [esp+D4h] [ebp-178h]
  __int64 v97[2]; // [esp+DCh] [ebp-170h] BYREF
  int *v98; // [esp+ECh] [ebp-160h]
  double v99; // [esp+F0h] [ebp-15Ch]
  _DWORD *v100; // [esp+F8h] [ebp-154h]
  double v101; // [esp+FCh] [ebp-150h]
  double v102; // [esp+104h] [ebp-148h]
  int v103; // [esp+10Ch] [ebp-140h]
  int v104; // [esp+110h] [ebp-13Ch]
  double v105; // [esp+114h] [ebp-138h]
  double v106; // [esp+11Ch] [ebp-130h]
  double v107; // [esp+124h] [ebp-128h]
  int v108; // [esp+12Ch] [ebp-120h]
  int v109; // [esp+130h] [ebp-11Ch]
  double *v110; // [esp+134h] [ebp-118h]
  int v111; // [esp+138h] [ebp-114h]
  double *v112; // [esp+13Ch] [ebp-110h]
  int v113; // [esp+140h] [ebp-10Ch]
  int *v114; // [esp+144h] [ebp-108h]
  int *v115; // [esp+148h] [ebp-104h]
  int v116; // [esp+14Ch] [ebp-100h]
  unsigned int *v117; // [esp+150h] [ebp-FCh]
  char v118; // [esp+157h] [ebp-F5h]
  int v119; // [esp+158h] [ebp-F4h] BYREF
  char v120[176]; // [esp+15Ch] [ebp-F0h] BYREF
  __m128i v121; // [esp+20Ch] [ebp-40h] BYREF
  double v122; // [esp+21Ch] [ebp-30h]
  void *v123[2]; // [esp+224h] [ebp-28h] BYREF
  double *v124; // [esp+22Ch] [ebp-20h]
  void *v125[2]; // [esp+230h] [ebp-1Ch] BYREF
  int *v126; // [esp+238h] [ebp-14h]
  int v127; // [esp+248h] [ebp-4h]

  v117 = this;
  v107 = a5;
  v6 = *(_OWORD *)(a3 + 8);
  v104 = a3;
  sub_406C30(*(_QWORD *)a3, *(double *)&v6, *((double *)&v6 + 1), v80);
  v98 = (int *)(this + 27);
  sub_4216E0(this + 27, this[4]);
  v79 = this[4];
  v100 = this + 30;
  sub_405750(this + 30, v79);
  *(double *)&v6 = v107;
  this[34] = this[33];
  sub_405EB0((int)v120, a4, v104 + 24, v6);
  v111 = 0;
  v7 = 0;
  v109 = 0;
  v103 = -1;
  v123[0] = 0;
  v112 = 0;
  v123[1] = 0;
  v110 = 0;
  v124 = 0;
  v8 = 0;
  v127 = 1;
  v125[0] = 0;
  v115 = 0;
  v125[1] = 0;
  v114 = 0;
  v126 = 0;
  v9 = (int)v117;
  v10 = 0;
  v119 = 0;
  if ( (int)v117[2] <= 0 )
    return;
  do
  {
    v11 = 0.0;
    HIDWORD(v106) = *(_DWORD *)(*(_DWORD *)(v9 + 96) + 4 * v10);
    v107 = 0.0;
    v12 = (*(_DWORD *)(HIDWORD(v106) + 12) - *(_DWORD *)(HIDWORD(v106) + 8)) / 40;
    v108 = v12;
    if ( v12 > 0 )
    {
      v13 = HIDWORD(v106);
      v14 = v87 * -a2;
      v15 = 32 * v111;
      v16 = 0;
      v17 = v81 * -a2;
      v113 = 0;
      v91 = -a2;
      v116 = v12;
      v18 = v87 * a2;
      v19 = v81 * a2;
      v88 = -a2 * v84;
      v96 = v87 * a2;
      v89 = v14;
      v92 = v81 * a2;
      v94 = v17;
      v93 = v84 * a2;
      do
      {
        v20 = *(_DWORD *)(v13 + 8);
        v21 = *(double *)(v16 + v20 + 16) - *((double *)v117 + 5);
        v90 = *(double *)(v16 + v20 + 8) - *((double *)v117 + 4);
        v106 = v21;
        v22 = sub_406A70(
                (int)v120,
                -10.0,
                0.0,
                -1.0,
                1.0e-10,
                v80[1] * v21 + v80[0] * v90 + v17,
                v19,
                v86 * v21 + v85 * v90 + v14,
                v18);
        v23 = v98;
        v24 = v106;
        v25 = v90 * v82;
        v26 = v111;
        v27 = v83 * v106;
        *(double *)(v15 + *v98) = v90;
        v28 = v91;
        v14 = v89;
        v17 = v94;
        *(double *)(v15 + *v23 + 8) = v24;
        v18 = v96;
        v29 = v27 + v25 + v88;
        v19 = v92;
        *(double *)(v15 + *v23 + 16) = v28;
        v30 = *v23;
        v31 = v119;
        v95 = v22;
        *(double *)(v15 + v30 + 24) = v22;
        v15 += 32;
        v11 = v29 * v22 - v93 + v107;
        *(_DWORD *)(*v100 + 4 * v26) = v31;
        v16 = v113 + 40;
        v111 = v26 + 1;
        v32 = v116-- == 1;
        v107 = v11;
        v113 += 40;
      }
      while ( !v32 );
      v8 = v115;
      v7 = v112;
      v12 = v108;
    }
    v33 = v119;
    *(double *)(v104 + 8 * (v119 + v117[51])) = v11 / *((double *)v117 + 7) / (double)v12;
    v9 = (int)v117;
    if ( v103 == *(_DWORD *)(*(_DWORD *)(v117[24] + 4 * v33) + 20) )
    {
      if ( &v119 >= v8 || v125[0] > &v119 )
      {
        if ( v8 == v114 && !(v114 - v8) )
        {
          v40 = ((char *)v8 - (char *)v125[0]) >> 2;
          if ( v40 == 0x3FFFFFFF )
            goto LABEL_104;
          v41 = ((char *)v114 - (char *)v125[0]) >> 2;
          v42 = v40 + 1;
          if ( 0x3FFFFFFF - (v41 >> 1) >= v41 )
            v43 = (v41 >> 1) + v41;
          else
            v43 = 0;
          if ( v43 < v42 )
            v43 = v42;
          sub_405400((int)v125, v43);
          v8 = (int *)v125[1];
          v9 = (int)v117;
          v114 = v126;
        }
        if ( v8 )
        {
          v39 = v119;
          goto LABEL_32;
        }
      }
      else
      {
        v34 = ((char *)&v119 - (char *)v125[0]) >> 2;
        v116 = v34;
        if ( v8 == v114 )
        {
          if ( !(v114 - v8) )
          {
            v35 = ((char *)v8 - (char *)v125[0]) >> 2;
            if ( v35 == 0x3FFFFFFF )
              goto LABEL_104;
            v36 = ((char *)v114 - (char *)v125[0]) >> 2;
            v37 = v35 + 1;
            if ( 0x3FFFFFFF - (v36 >> 1) >= v36 )
              v38 = (v36 >> 1) + v36;
            else
              v38 = 0;
            if ( v38 < v37 )
              v38 = v37;
            sub_405400((int)v125, v38);
            v8 = (int *)v125[1];
            v9 = (int)v117;
            v114 = v126;
          }
          v34 = v116;
        }
        if ( v8 )
        {
          v39 = *((_DWORD *)v125[0] + v34);
LABEL_32:
          *v8 = v39;
        }
      }
      ++v8;
      v44 = *(_DWORD *)(v9 + 96);
      v125[1] = v8;
      v115 = v8;
      v106 = *(double *)(*(_DWORD *)(v44 + 4 * v119) + 24);
      v45 = v106;
      v46 = v106 - v102;
      v107 = v106 - v102;
      v47 = (v102 + v106) * 0.5;
      *(double *)&v97[1] = v106 - v102;
      v102 = v47;
      *(double *)v97 = v47;
      if ( v97 >= (__int64 *)v7 || v123[0] > v97 )
      {
        if ( v7 == v110 && !(((char *)v110 - (char *)v7) >> 4) )
        {
          v54 = ((char *)v7 - (char *)v123[0]) >> 4;
          if ( v54 == 0xFFFFFFF )
LABEL_104:
            std::_Xlength_error("vector<T> too long");
          v55 = ((char *)v110 - (char *)v123[0]) >> 4;
          v56 = v54 + 1;
          if ( 0xFFFFFFF - (v55 >> 1) >= v55 )
            v57 = (v55 >> 1) + v55;
          else
            v57 = 0;
          if ( v57 < v56 )
            v57 = v56;
          sub_406840((_QWORD **)v123, v57);
          v7 = (double *)v123[1];
          v46 = v107;
          v47 = v102;
          v45 = v106;
          v110 = v124;
        }
        if ( v7 )
        {
          *v7 = v47;
          v7[1] = v46;
        }
      }
      else
      {
        v48 = ((char *)v97 - (char *)v123[0]) >> 4;
        v108 = v48;
        if ( v7 == v110 && !(((char *)v110 - (char *)v7) >> 4) )
        {
          v49 = ((char *)v7 - (char *)v123[0]) >> 4;
          if ( v49 == 0xFFFFFFF )
            goto LABEL_104;
          v50 = ((char *)v110 - (char *)v123[0]) >> 4;
          v51 = v49 + 1;
          if ( 0xFFFFFFF - (v50 >> 1) >= v50 )
            v52 = (v50 >> 1) + v50;
          else
            v52 = 0;
          if ( v52 < v51 )
            v52 = v51;
          sub_406840((_QWORD **)v123, v52);
          v7 = (double *)v123[1];
          v46 = v107;
          v45 = v106;
          v48 = v108;
          v110 = v124;
        }
        v53 = (double *)((char *)v123[0] + 16 * v48);
        if ( v7 )
        {
          *v7 = *v53;
          v7[1] = v53[1];
        }
      }
      v7 += 2;
      v123[1] = v7;
      v112 = v7;
      if ( v46 < 0.0 )
        v46 = -v46;
      if ( v105 > v46 )
        v105 = v46;
      v9 = (int)v117;
      v58 = v109 + 1;
      v102 = v45;
      ++v109;
      if ( v119 != v117[2] - 1 )
        goto LABEL_98;
      goto LABEL_64;
    }
    v58 = v109;
LABEL_64:
    if ( v119 && v58 > 5 )
    {
      v59 = v58 - 1;
      v116 = 2;
      v115 = (int *)(v58 - 1);
      v113 = 0;
      v105 = v105 * 0.1;
      do
      {
        v60 = rand() % v59;
        v61 = rand() % v59;
        if ( v60 == v61 )
          goto LABEL_78;
        v62 = (double *)v123[0];
        v63 = 2 * v60;
        v64 = 0;
        v65 = (*((double *)v123[0] + v63 + 1) - *((double *)v123[0] + 2 * v61 + 1))
            / (*((double *)v123[0] + v63) - *((double *)v123[0] + 2 * v61));
        v66 = *((double *)v123[0] + v63 + 1) - *((double *)v123[0] + v63) * v65;
        if ( v59 > 0 )
        {
          v67 = v59;
          do
          {
            v68 = *v62 * v65 + v66 - v62[1];
            if ( v68 < 0.0 )
              v68 = -v68;
            if ( v105 > v68 )
              ++v64;
            v62 += 2;
            --v67;
          }
          while ( v67 );
        }
        if ( v64 <= v116 )
        {
LABEL_78:
          v66 = v99;
          v65 = v101;
        }
        else
        {
          v116 = v64;
          v101 = v65;
          v99 = v66;
          if ( (double)v64 > (double)v111 * 0.95 )
            break;
        }
        ++v113;
      }
      while ( v113 < 100 );
      v69 = 0;
      v118 = 0;
      if ( v59 > 0 )
      {
        v70 = (double *)v123[0];
        v71 = (__int32 *)((char *)v125[0] + 4);
        v72 = (int)v115;
        while ( 1 )
        {
          v73 = *v70 * v65 + v66 - v70[1];
          if ( v73 < 0.0 )
            v73 = -v73;
          if ( v105 <= v73 )
            break;
          if ( !v69 )
          {
            v69 = 1;
LABEL_89:
            v118 = v69;
            goto LABEL_90;
          }
          v121.m128i_i64[0] = *((_QWORD *)v71 - 1);
          v121.m128i_i32[2] = *v71;
          v122 = (double)((int)v117[4] / (int)v117[3]);
          sub_421580(v117 + 33, &v121);
          v65 = v101;
          v66 = v99;
          v69 = v118;
          v72 = (int)v115;
LABEL_90:
          v70 += 2;
          ++v71;
          v115 = (int *)--v72;
          if ( !v72 )
            goto LABEL_91;
        }
        v69 = 0;
        goto LABEL_89;
      }
LABEL_91:
      v9 = (int)v117;
    }
    v74 = *(_DWORD *)(v9 + 96);
    v75 = v125[0];
    v7 = (double *)v123[0];
    v109 = 1;
    v76 = *(_DWORD *)(v74 + 4 * v119);
    v112 = (double *)v123[0];
    v123[1] = v123[0];
    v125[1] = v125[0];
    v77 = *(double *)(v76 + 24);
    v78 = *(_DWORD *)(v76 + 20);
    v102 = v77;
    v103 = v78;
    v105 = 1.0e11;
    if ( v125[0] == v114 && !(((char *)v114 - (char *)v125[0]) >> 2) )
    {
      sub_405400((int)v125, 1u);
      v75 = v125[1];
      v9 = (int)v117;
      v114 = v126;
    }
    if ( v75 )
      *v75 = v119;
    v8 = v75 + 1;
    v115 = v8;
    v125[1] = v8;
LABEL_98:
    v10 = v119 + 1;
    v119 = v10;
  }
  while ( v10 < *(_DWORD *)(v9 + 8) );
  if ( v125[0] )
    operator delete(v125[0]);
  if ( v123[0] )
    operator delete(v123[0]);
}
// 419B2E: conditional instruction was optimized away because ecx.4==0
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (00419BD0) --------------------------------------------------------
void __thiscall sub_419BD0(int this, int a2, int a3, __int64 a4)
{
  int *v5; // edx
  double *v6; // edi
  int *v7; // esi
  int v8; // edx
  int v9; // ecx
  double v10; // xmm6_8
  double v11; // xmm7_8
  double v12; // xmm1_8
  int v13; // eax
  double v14; // xmm7_8
  double v15; // xmm5_8
  int v16; // edi
  int v17; // ecx
  double v18; // xmm6_8
  double v19; // xmm7_8
  int v20; // eax
  double v21; // xmm3_8
  double v22; // st7
  double v23; // xmm3_8
  double v24; // xmm1_8
  int v25; // ecx
  double v26; // xmm0_8
  unsigned __int64 v27; // xmm2_8
  int v28; // eax
  double v29; // xmm1_8
  double v30; // xmm1_8
  bool v31; // zf
  int v32; // ecx
  int v33; // eax
  signed int v34; // esi
  unsigned int v35; // ecx
  unsigned int v36; // esi
  unsigned int v37; // ecx
  int v38; // eax
  signed int v39; // esi
  unsigned int v40; // ecx
  unsigned int v41; // esi
  unsigned int v42; // ecx
  int v43; // eax
  double *v44; // edx
  double v45; // xmm2_8
  double v46; // xmm1_8
  double v47; // xmm0_8
  int v48; // eax
  signed int v49; // edi
  unsigned int v50; // ecx
  unsigned int v51; // edi
  unsigned int v52; // ecx
  int v53; // eax
  signed int v54; // edi
  unsigned int v55; // ecx
  unsigned int v56; // edi
  unsigned int v57; // ecx
  int v58; // ecx
  int v59; // edi
  int v60; // esi
  int v61; // edx
  double *v62; // eax
  int v63; // esi
  int v64; // ecx
  double v65; // xmm2_8
  double v66; // xmm3_8
  int v67; // edx
  double v68; // xmm0_8
  char v69; // cl
  double *v70; // edi
  __int32 *v71; // esi
  int v72; // eax
  double v73; // xmm0_8
  int v74; // ecx
  int *v75; // esi
  int v76; // eax
  int v77; // edi
  float *v78; // esi
  double v79; // xmm1_8
  double v80; // xmm6_8
  double v81; // xmm5_8
  double v82; // xmm7_8
  double v83; // st7
  double v84; // xmm1_8
  int v85; // ecx
  double v86; // st7
  double v87; // xmm1_8
  int v88; // ecx
  double v89; // st7
  int v90; // ecx
  _DWORD *v91; // eax
  int v92; // edi
  int v93; // esi
  int v94; // edi
  double v95; // xmm2_8
  double v96; // xmm3_8
  double v97; // xmm4_8
  double v98; // xmm1_8
  double v99; // xmm0_8
  double v100; // xmm2_8
  void *v101; // eax
  int v102; // [esp+44h] [ebp-234h]
  int v103; // [esp+48h] [ebp-230h]
  int v104; // [esp+4Ch] [ebp-22Ch]
  int v105; // [esp+50h] [ebp-228h]
  int v106; // [esp+54h] [ebp-224h]
  int v107; // [esp+54h] [ebp-224h]
  int v108; // [esp+54h] [ebp-224h]
  int v109; // [esp+54h] [ebp-224h]
  int v110; // [esp+54h] [ebp-224h]
  int *v111; // [esp+58h] [ebp-220h]
  int v112; // [esp+58h] [ebp-220h]
  int v113; // [esp+58h] [ebp-220h]
  int *v115; // [esp+60h] [ebp-218h]
  int v116; // [esp+60h] [ebp-218h]
  int v117; // [esp+64h] [ebp-214h]
  int v118; // [esp+64h] [ebp-214h]
  _DWORD *v119; // [esp+64h] [ebp-214h]
  double v120; // [esp+68h] [ebp-210h]
  double v121; // [esp+68h] [ebp-210h]
  int v122; // [esp+74h] [ebp-204h]
  int v123; // [esp+74h] [ebp-204h]
  double *v124; // [esp+78h] [ebp-200h]
  int v125; // [esp+7Ch] [ebp-1FCh]
  int v126; // [esp+80h] [ebp-1F8h]
  int v127; // [esp+84h] [ebp-1F4h]
  int v128; // [esp+88h] [ebp-1F0h]
  double v129; // [esp+88h] [ebp-1F0h]
  double v130; // [esp+90h] [ebp-1E8h]
  double v131; // [esp+90h] [ebp-1E8h]
  double v132; // [esp+98h] [ebp-1E0h]
  double v133; // [esp+98h] [ebp-1E0h]
  double v134; // [esp+A0h] [ebp-1D8h]
  double v135; // [esp+A0h] [ebp-1D8h]
  double v136; // [esp+B0h] [ebp-1C8h]
  double v137; // [esp+B0h] [ebp-1C8h]
  double v138; // [esp+B0h] [ebp-1C8h]
  double v139; // [esp+B0h] [ebp-1C8h]
  double v140; // [esp+B8h] [ebp-1C0h]
  double v141; // [esp+B8h] [ebp-1C0h]
  double v142; // [esp+B8h] [ebp-1C0h]
  double v143; // [esp+B8h] [ebp-1C0h]
  double v144; // [esp+C0h] [ebp-1B8h]
  int v145; // [esp+C8h] [ebp-1B0h]
  double v146; // [esp+C8h] [ebp-1B0h]
  double v147; // [esp+D0h] [ebp-1A8h]
  double v148; // [esp+D8h] [ebp-1A0h]
  double v149; // [esp+E0h] [ebp-198h] BYREF
  double v150; // [esp+E8h] [ebp-190h]
  double v151; // [esp+F0h] [ebp-188h]
  double v152; // [esp+F8h] [ebp-180h]
  double v153; // [esp+100h] [ebp-178h]
  double v154; // [esp+108h] [ebp-170h]
  double v155; // [esp+110h] [ebp-168h]
  double v156; // [esp+118h] [ebp-160h]
  double v157; // [esp+120h] [ebp-158h]
  double v158[3]; // [esp+128h] [ebp-150h] BYREF
  double v159; // [esp+140h] [ebp-138h]
  double v160; // [esp+148h] [ebp-130h]
  double v161; // [esp+150h] [ebp-128h]
  unsigned __int64 v162; // [esp+158h] [ebp-120h]
  double v163; // [esp+160h] [ebp-118h]
  double v164; // [esp+168h] [ebp-110h]
  double v165; // [esp+170h] [ebp-108h]
  int v166; // [esp+17Ch] [ebp-FCh] BYREF
  void *v167[2]; // [esp+180h] [ebp-F8h] BYREF
  int *v168; // [esp+188h] [ebp-F0h]
  void *v169[2]; // [esp+18Ch] [ebp-ECh] BYREF
  int v170; // [esp+194h] [ebp-E4h]
  __m128i v171; // [esp+198h] [ebp-E0h] BYREF
  double v172; // [esp+1A8h] [ebp-D0h]
  char v173[180]; // [esp+1B0h] [ebp-C8h] BYREF
  int v174; // [esp+274h] [ebp-4h]

  sub_406C30(*(_QWORD *)a2, *(double *)(a2 + 8), *(double *)(a2 + 16), &v149);
  v5 = (int *)(this + 48);
  if ( *(_DWORD *)(this + 48) < *(_DWORD *)(this + 52) )
    v5 = (int *)(this + 52);
  v148 = (double)*v5 * *(double *)(a2 + 64);
  sub_4216E0((_DWORD *)(this + 108), *(_DWORD *)(this + 16) + 3 * *(_DWORD *)(this + 24));
  sub_405750((_DWORD *)(this + 120), *(_DWORD *)(this + 16));
  *(_DWORD *)(this + 136) = *(_DWORD *)(this + 132);
  sub_405EB0((int)v173, a3, a2 + 24, a4);
  v125 = 0;
  v6 = 0;
  v126 = 0;
  v117 = -1;
  v169[0] = 0;
  v124 = 0;
  v169[1] = 0;
  v127 = 0;
  v170 = 0;
  v7 = 0;
  v174 = 1;
  v167[0] = 0;
  v115 = 0;
  v167[1] = 0;
  v111 = 0;
  v168 = 0;
  v8 = this;
  v9 = 0;
  v10 = v157;
  v11 = v151;
  v166 = 0;
  v147 = 0.0;
  if ( *(int *)(this + 8) > 0 )
  {
    while ( 1 )
    {
      v12 = 0.0;
      v144 = 0.0;
      v145 = *(_DWORD *)(*(_DWORD *)(v8 + 96) + 4 * v9);
      v13 = (*(_DWORD *)(v145 + 12) - *(_DWORD *)(v145 + 8)) / 40;
      v128 = v13;
      if ( v13 > 0 )
      {
        v14 = v10;
        v15 = v10 * COERCE_DOUBLE(*(_QWORD *)&v148 ^ 0x8000000000000000ui64);
        v16 = 32 * v125;
        v17 = 0;
        v122 = 0;
        v18 = v151 * COERCE_DOUBLE(*(_QWORD *)&v148 ^ 0x8000000000000000ui64);
        v106 = (*(_DWORD *)(v145 + 12) - *(_DWORD *)(v145 + 8)) / 40;
        v162 = *(_QWORD *)&v148 ^ 0x8000000000000000ui64;
        v160 = v151 * v148;
        v19 = v14 * v148;
        v163 = v15;
        v136 = v19;
        v140 = v18;
        v161 = v154 * COERCE_DOUBLE(*(_QWORD *)&v148 ^ 0x8000000000000000ui64);
        v165 = v154 * v148;
        do
        {
          v20 = *(_DWORD *)(v145 + 8);
          v21 = *(double *)(v17 + v20 + 16) - *(double *)(this + 40);
          v164 = *(double *)(v17 + v20 + 8) - *(double *)(this + 32);
          v159 = v21;
          v22 = sub_406A70(
                  (int)v173,
                  -10.0,
                  0.0,
                  -1.0,
                  1.0e-10,
                  v150 * v21 + v149 * v164 + v18,
                  v160,
                  v156 * v21 + v155 * v164 + v15,
                  v19);
          v23 = v159;
          v24 = v153 * v159;
          v25 = v166;
          v26 = v152 * v164;
          *(double *)(v16 + *(_DWORD *)(this + 108)) = v164;
          v27 = v162;
          v15 = v163;
          v18 = v140;
          v19 = v136;
          *(double *)(v16 + *(_DWORD *)(this + 108) + 8) = v23;
          v28 = *(_DWORD *)(this + 108);
          v29 = v24 + v26 + v161;
          v158[2] = v22;
          *(_QWORD *)(v16 + v28 + 16) = v27;
          *(double *)(v16 + *(_DWORD *)(this + 108) + 24) = v22;
          v16 += 32;
          v30 = v29 * v22 - v165;
          *(_DWORD *)(*(_DWORD *)(this + 120) + 4 * v125) = v25;
          v12 = v30 + v144;
          v17 = v122 + 40;
          ++v125;
          v31 = v106-- == 1;
          v122 += 40;
          v144 = v12;
        }
        while ( !v31 );
        v7 = v115;
        v6 = v124;
        v13 = v128;
      }
      v32 = v166;
      *(double *)(a2 + 8 * (v166 + *(_DWORD *)(this + 204))) = v12 / *(double *)(this + 56) / (double)v13;
      v8 = this;
      if ( v117 != *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 96) + 4 * v32) + 20) )
      {
        v58 = v126;
LABEL_67:
        if ( v166 && v58 > 5 )
        {
          v59 = v58 - 1;
          v109 = 2;
          v116 = v58 - 1;
          v123 = 0;
          v121 = v120 * 0.1;
          do
          {
            v60 = rand() % v59;
            v61 = rand() % v59;
            if ( v60 == v61 )
              goto LABEL_81;
            v62 = (double *)v169[0];
            v63 = 2 * v60;
            v64 = 0;
            v65 = (*((double *)v169[0] + v63 + 1) - *((double *)v169[0] + 2 * v61 + 1))
                / (*((double *)v169[0] + v63) - *((double *)v169[0] + 2 * v61));
            v66 = *((double *)v169[0] + v63 + 1) - v65 * *((double *)v169[0] + v63);
            if ( v59 > 0 )
            {
              v67 = v59;
              do
              {
                v68 = *v62 * v65 + v66 - v62[1];
                if ( v68 < 0.0 )
                  v68 = -v68;
                if ( v121 > v68 )
                  ++v64;
                v62 += 2;
                --v67;
              }
              while ( v67 );
            }
            if ( v64 <= v109 )
            {
LABEL_81:
              v66 = v132;
              v65 = v134;
            }
            else
            {
              v109 = v64;
              v134 = v65;
              v132 = *((double *)v169[0] + v63 + 1) - v65 * *((double *)v169[0] + v63);
              if ( (double)v64 > (double)v125 * 0.95 )
                break;
            }
            ++v123;
          }
          while ( v123 < 100 );
          v69 = 0;
          HIBYTE(v105) = 0;
          if ( v59 > 0 )
          {
            v70 = (double *)v169[0];
            v71 = (__int32 *)((char *)v167[0] + 4);
            v72 = v116;
            while ( 1 )
            {
              v73 = *v70 * v65 + v66 - v70[1];
              if ( v73 < 0.0 )
                v73 = -v73;
              if ( v121 <= v73 )
                break;
              if ( !v69 )
              {
                v69 = 1;
LABEL_92:
                HIBYTE(v105) = v69;
                goto LABEL_93;
              }
              v171.m128i_i64[0] = *((_QWORD *)v71 - 1);
              v171.m128i_i32[2] = *v71;
              v172 = (double)(*(_DWORD *)(this + 16) / *(_DWORD *)(this + 12));
              sub_421580((_DWORD *)(this + 132), &v171);
              v65 = v134;
              v66 = v132;
              v72 = v116;
              v69 = HIBYTE(v105);
LABEL_93:
              v70 += 2;
              ++v71;
              v116 = --v72;
              if ( !v72 )
                goto LABEL_94;
            }
            v69 = 0;
            goto LABEL_92;
          }
LABEL_94:
          v8 = this;
        }
        v74 = v166;
        v75 = (int *)v167[0];
        v6 = (double *)v169[0];
        v126 = 1;
        v76 = *(_DWORD *)(*(_DWORD *)(v8 + 96) + 4 * v166);
        v124 = (double *)v169[0];
        v169[1] = v169[0];
        v167[1] = v167[0];
        v130 = *(double *)(v76 + 24);
        v117 = *(_DWORD *)(v76 + 20);
        v120 = 1.0e11;
        if ( v167[0] == v111 )
        {
          if ( !(((char *)v111 - (char *)v167[0]) >> 2) )
          {
            sub_405400((int)v167, 1u);
            v75 = (int *)v167[1];
            v8 = this;
            v111 = v168;
          }
          v74 = v166;
        }
        if ( v75 )
          *v75 = v74;
        v7 = v75 + 1;
        v115 = v7;
        v167[1] = v7;
        goto LABEL_102;
      }
      if ( &v166 >= v7 || v167[0] > &v166 )
      {
        if ( v7 == v111 && !(v111 - v7) )
        {
          v39 = ((char *)v7 - (char *)v167[0]) >> 2;
          if ( v39 == 0x3FFFFFFF )
            goto LABEL_106;
          v40 = ((char *)v111 - (char *)v167[0]) >> 2;
          v41 = v39 + 1;
          if ( 0x3FFFFFFF - (v40 >> 1) >= v40 )
            v42 = (v40 >> 1) + v40;
          else
            v42 = 0;
          if ( v42 < v41 )
            v42 = v41;
          sub_405400((int)v167, v42);
          v7 = (int *)v167[1];
          v8 = this;
          v111 = v168;
        }
        if ( v7 )
        {
          v38 = v166;
          goto LABEL_34;
        }
      }
      else
      {
        v33 = ((char *)&v166 - (char *)v167[0]) >> 2;
        v107 = v33;
        if ( v7 == v111 )
        {
          if ( !(v111 - v7) )
          {
            v34 = ((char *)v7 - (char *)v167[0]) >> 2;
            if ( v34 == 0x3FFFFFFF )
              goto LABEL_106;
            v35 = ((char *)v111 - (char *)v167[0]) >> 2;
            v36 = v34 + 1;
            if ( 0x3FFFFFFF - (v35 >> 1) >= v35 )
              v37 = (v35 >> 1) + v35;
            else
              v37 = 0;
            if ( v37 < v36 )
              v37 = v36;
            sub_405400((int)v167, v37);
            v7 = (int *)v167[1];
            v8 = this;
            v111 = v168;
          }
          v33 = v107;
        }
        if ( v7 )
        {
          v38 = *((_DWORD *)v167[0] + v33);
LABEL_34:
          *v7 = v38;
        }
      }
      v43 = *(_DWORD *)(v8 + 96);
      ++v7;
      v44 = (double *)v169[0];
      v167[1] = v7;
      v115 = v7;
      v45 = *(double *)(*(_DWORD *)(v43 + 4 * v166) + 24);
      v46 = v45 - v130;
      v47 = (v130 + v45) * 0.5;
      v158[1] = v45 - v130;
      v158[0] = v47;
      if ( v158 >= v6 || v169[0] > v158 )
      {
        if ( v6 == (double *)v127 && !((v127 - (int)v6) >> 4) )
        {
          v54 = ((char *)v6 - (char *)v169[0]) >> 4;
          if ( v54 == 0xFFFFFFF )
LABEL_106:
            std::_Xlength_error("vector<T> too long");
          v55 = (signed int)(v127 - (unsigned int)v169[0]) >> 4;
          v56 = v54 + 1;
          if ( 0xFFFFFFF - (v55 >> 1) >= v55 )
            v57 = (v55 >> 1) + v55;
          else
            v57 = 0;
          if ( v57 < v56 )
            v57 = v56;
          sub_406840((_QWORD **)v169, v57);
          v6 = (double *)v169[1];
          v46 = v45 - v130;
          v127 = v170;
        }
        if ( v6 )
        {
          *v6 = v47;
          v6[1] = v46;
        }
      }
      else
      {
        v48 = ((char *)v158 - (char *)v169[0]) >> 4;
        v108 = v48;
        if ( v6 == (double *)v127 )
        {
          if ( !((v127 - (int)v6) >> 4) )
          {
            v49 = ((char *)v6 - (char *)v169[0]) >> 4;
            if ( v49 == 0xFFFFFFF )
              goto LABEL_106;
            v50 = (signed int)(v127 - (unsigned int)v169[0]) >> 4;
            v51 = v49 + 1;
            if ( 0xFFFFFFF - (v50 >> 1) >= v50 )
              v52 = (v50 >> 1) + v50;
            else
              v52 = 0;
            if ( v52 < v51 )
              v52 = v51;
            sub_406840((_QWORD **)v169, v52);
            v6 = (double *)v169[1];
            v46 = v45 - v130;
            v44 = (double *)v169[0];
            v127 = v170;
          }
          v48 = v108;
        }
        v53 = 2 * v48;
        if ( v6 )
        {
          *v6 = v44[v53];
          v6[1] = v44[v53 + 1];
        }
      }
      v6 += 2;
      v169[1] = v6;
      v124 = v6;
      if ( v46 < 0.0 )
        v46 = -v46;
      if ( v120 > v46 )
        v120 = v46;
      v8 = this;
      v58 = v126 + 1;
      v130 = v45;
      ++v126;
      if ( v166 == *(_DWORD *)(this + 8) - 1 )
        goto LABEL_67;
LABEL_102:
      v9 = v166 + 1;
      v10 = v157;
      v166 = v9;
      if ( v9 >= *(_DWORD *)(v8 + 8) )
      {
        v11 = v151;
        break;
      }
    }
  }
  v77 = this;
  v112 = 0;
  v118 = 0;
  v78 = *(float **)(this + 192);
  if ( *(int *)(this + 24) > 0 )
  {
    v79 = v10 * v148;
    v80 = v10 * -v148;
    v81 = v11 * v148;
    v82 = v11 * -v148;
    v133 = -v148;
    v135 = v79;
    v129 = v80;
    v131 = v81;
    v146 = v82;
    do
    {
      v137 = *v78 - *(double *)(this + 32);
      v141 = v78[1] - *(double *)(this + 40);
      v83 = sub_406A70(
              (int)v173,
              -10.0,
              0.0,
              -1.0,
              1.0e-10,
              v150 * v141 + v149 * v137 + v82,
              v81,
              v156 * v141 + v155 * v137 + v80,
              v79);
      v84 = v156;
      *(double *)(32 * (v112 + *(_DWORD *)(this + 16)) + *(_DWORD *)(this + 108)) = v137;
      *(double *)(32 * (v112 + *(_DWORD *)(this + 16)) + *(_DWORD *)(this + 108) + 8) = v141;
      *(double *)(32 * (v112 + *(_DWORD *)(this + 16)) + *(_DWORD *)(this + 108) + 16) = v133;
      v85 = v112 + *(_DWORD *)(this + 16);
      v113 = v112 + 1;
      *(double *)(32 * v85 + *(_DWORD *)(this + 108) + 24) = v83;
      v138 = v78[4] - *(double *)(this + 32);
      v142 = v78[5] - *(double *)(this + 40);
      v86 = sub_406A70(
              (int)v173,
              -10.0,
              0.0,
              -1.0,
              1.0e-10,
              v150 * v142 + v149 * v138 + v146,
              v131,
              v84 * v142 + v155 * v138 + v129,
              v135);
      v87 = v156;
      *(double *)(32 * (v113 + *(_DWORD *)(this + 16)) + *(_DWORD *)(this + 108)) = v138;
      *(double *)(32 * (v113 + *(_DWORD *)(this + 16)) + *(_DWORD *)(this + 108) + 8) = v142;
      *(double *)(32 * (v113 + *(_DWORD *)(this + 16)) + *(_DWORD *)(this + 108) + 16) = v133;
      v88 = v113 + *(_DWORD *)(this + 16);
      ++v113;
      *(double *)(32 * v88 + *(_DWORD *)(this + 108) + 24) = v86;
      v139 = v78[2] - *(double *)(this + 32);
      v143 = v78[3] - *(double *)(this + 40);
      v89 = sub_406A70(
              (int)v173,
              -10.0,
              0.0,
              -1.0,
              1.0e-10,
              v150 * v143 + v149 * v139 + v146,
              v131,
              v87 * v143 + v155 * v139 + v129,
              v135);
      v78 += 10;
      v79 = v135;
      v81 = v131;
      v80 = v129;
      *(double *)(32 * (v113 + *(_DWORD *)(this + 16)) + *(_DWORD *)(this + 108)) = v139;
      v82 = v146;
      *(double *)(32 * (v113 + *(_DWORD *)(this + 16)) + *(_DWORD *)(this + 108) + 8) = v143;
      *(double *)(32 * (v113 + *(_DWORD *)(this + 16)) + *(_DWORD *)(this + 108) + 16) = v133;
      v90 = v113 + *(_DWORD *)(this + 16);
      v112 = v113 + 1;
      *(double *)(32 * v90 + *(_DWORD *)(this + 108) + 24) = v89;
      ++v118;
    }
    while ( v118 < *(_DWORD *)(this + 24) );
  }
  v110 = *(_DWORD *)(this + 8);
  if ( v110 > 0 )
  {
    v91 = *(_DWORD **)(this + 96);
    v119 = v91;
    do
    {
      v92 = *v91;
      v93 = (*(_DWORD *)(v92 + 12) - *(_DWORD *)(v92 + 8)) / 40;
      if ( v93 > 0 )
      {
        v94 = *(_DWORD *)(v92 + 8);
        do
        {
          v94 += 40;
          v147 = *(double *)libm_sse2_sqrt_precise(v102, v103, v104, v105).m128_u64 + v147;
          --v93;
        }
        while ( v93 );
      }
      v91 = v119 + 1;
      v31 = v110-- == 1;
      ++v119;
    }
    while ( !v31 );
    v77 = this;
  }
  v95 = (double)*(int *)(v77 + 16);
  v96 = 50.0;
  v97 = v95 / (double)*(int *)(v77 + 24);
  v98 = v147 / v95;
  if ( v97 < 50.0 )
    v97 = 50.0;
  v99 = (double)*(int *)(v77 + 28);
  *(double *)(v77 + 80) = v97;
  v100 = v95 / v99;
  if ( v100 >= 50.0 )
    v96 = v100;
  v101 = v167[0];
  *(_QWORD *)(v77 + 88) = 0x4059000000000000i64;
  *(double *)(v77 + 72) = v98 * v96;
  if ( v101 )
    operator delete(v101);
  if ( v169[0] )
    operator delete(v169[0]);
}
// 41A630: conditional instruction was optimized away because ecx.4==0
// 41A1CC: variable 'v130' is possibly undefined
// 41A365: variable 'v120' is possibly undefined
// 41A4B4: variable 'v132' is possibly undefined
// 41A4BA: variable 'v134' is possibly undefined
// 41AB48: variable 'v102' is possibly undefined
// 41AB48: variable 'v103' is possibly undefined
// 41AB48: variable 'v104' is possibly undefined
// 41AB48: variable 'v105' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (0041AC40) --------------------------------------------------------
void __thiscall sub_41AC40(int this, double a2, int a3, int a4, __int64 a5)
{
  int *v6; // edi
  __int64 v7; // xmm0_8
  _DWORD *v8; // esi
  _DWORD *v9; // edx
  signed int v10; // ecx
  int v11; // ecx
  int v12; // eax
  int v13; // esi
  double v14; // xmm6_8
  int v15; // edi
  double v16; // xmm5_8
  double v17; // xmm7_8
  double v18; // xmm4_8
  int v19; // eax
  double v20; // st7
  double v21; // xmm1_8
  int *v22; // ecx
  double v23; // xmm0_8
  int v24; // eax
  unsigned int v25; // ecx
  bool v26; // zf
  unsigned int v27; // ecx
  int v28; // edi
  int v29; // ecx
  unsigned int v30; // esi
  unsigned int v31; // esi
  unsigned int *v32; // ecx
  unsigned int v33; // eax
  int v34; // ecx
  unsigned int v35; // esi
  unsigned int v36; // esi
  int v37; // ecx
  int v38; // edi
  int v39; // eax
  int v40; // esi
  signed int v41; // edx
  int v42; // ecx
  __m128i v43; // xmm4
  __m128i v44; // xmm5
  __m128i v45; // xmm6
  __m128i v46; // xmm7
  int v47; // eax
  __m128i v48; // xmm2
  __m128i v49; // xmm3
  __m128i v50; // xmm0
  __m128i v51; // xmm5
  __m128i v52; // xmm5
  __m128i v53; // xmm4
  __m128i v54; // xmm4
  int v55; // ecx
  int v56; // edi
  int v57; // edx
  int v58; // eax
  int v59; // eax
  int v60; // eax
  int *v61; // ecx
  int v62; // eax
  int v63; // ecx
  unsigned int v64; // edx
  unsigned int v65; // edx
  int v66; // ecx
  unsigned int v67; // edx
  unsigned int v68; // edx
  double v69; // xmm2_8
  double v70; // xmm6_8
  double v71; // xmm7_8
  double v72; // xmm1_8
  unsigned int v73; // ecx
  int v74; // edx
  int v75; // eax
  unsigned int v76; // esi
  double v77; // xmm1_8
  double v78; // xmm1_8
  double v79; // xmm3_8
  int v80; // ecx
  double v81; // xmm4_8
  double v82; // xmm5_8
  int v83; // edx
  unsigned int v84; // edi
  int v85; // esi
  int v86; // esi
  double *v87; // ecx
  int v88; // eax
  int v89; // edx
  double v90; // xmm1_8
  double v91; // xmm0_8
  __m128i v92; // xmm0
  int v93; // ecx
  int v94; // edx
  double v95; // xmm2_8
  double v96; // xmm5_8
  int v97; // esi
  int v98; // eax
  double v99; // xmm3_8
  double v100; // xmm4_8
  double v101; // xmm1_8
  double v102; // xmm0_8
  double v103; // xmm2_8
  int v104; // ecx
  double v105; // xmm1_8
  double v106; // xmm0_8
  int v107; // ecx
  double v108; // xmm1_8
  double v109; // xmm0_8
  void *v110; // esi
  unsigned int v111; // eax
  int v112; // esi
  int v113; // edi
  int v114; // esi
  int v115; // esi
  int v116; // ecx
  int v117; // esi
  double v118; // xmm4_8
  double v119; // xmm1_8
  double v120; // xmm2_8
  double v121; // xmm0_8
  double v122; // xmm2_8
  int v123; // edi
  double v124; // xmm3_8
  double v125; // xmm4_8
  int v126; // esi
  int v127; // eax
  int v128; // ecx
  double v129; // xmm1_8
  int v130; // ecx
  double v131; // xmm1_8
  double v132; // xmm0_8
  int v133; // esi
  int v134; // eax
  int v135; // ecx
  double v136; // xmm1_8
  int v137; // ecx
  double v138; // xmm1_8
  double v139; // xmm0_8
  void *v140; // esi
  int v141; // edi
  unsigned int v142; // eax
  int v143; // ecx
  double v144; // xmm5_8
  double v145; // xmm1_8
  double v146; // xmm0_8
  double v147; // xmm1_8
  double v148; // xmm3_8
  int v149; // eax
  int v150; // edi
  int v151; // esi
  double v152; // xmm4_8
  double v153; // xmm6_8
  double v154; // xmm3_8
  unsigned int v155; // esi
  unsigned int v156; // edi
  double v157; // xmm0_8
  double v158; // xmm1_8
  double v159; // xmm2_8
  double v160; // xmm1_8
  double v161; // xmm1_8
  unsigned int v162; // edx
  bool v163; // cf
  int *v164; // edi
  unsigned int v165; // eax
  int v166; // esi
  void **v167; // eax
  int v168; // ecx
  double v169; // xmm1_8
  double v170; // xmm0_8
  double v171; // xmm1_8
  double v172; // xmm3_8
  int v173; // eax
  int v174; // edi
  int v175; // esi
  double v176; // xmm6_8
  double v177; // xmm3_8
  unsigned int v178; // esi
  unsigned int v179; // eax
  int v180; // esi
  void **v181; // eax
  int v182; // ecx
  unsigned int v183; // esi
  unsigned int v184; // eax
  int v185; // esi
  void **v186; // eax
  int v187; // ecx
  unsigned int v188; // esi
  unsigned int v189; // eax
  int v190; // esi
  unsigned int v191; // eax
  int v192; // esi
  void **v193; // eax
  int v194; // ecx
  unsigned int v195; // eax
  int v196; // esi
  double v197; // xmm1_8
  double v198; // xmm1_8
  double v199; // xmm2_8
  double v200; // xmm2_8
  unsigned int v201; // edx
  unsigned int v202; // eax
  int v203; // esi
  void **v204; // eax
  int v205; // ecx
  unsigned int v206; // esi
  unsigned int v207; // eax
  int v208; // esi
  unsigned int v209; // esi
  unsigned int v210; // eax
  int v211; // esi
  void **v212; // eax
  int v213; // ecx
  unsigned int v214; // esi
  unsigned int v215; // eax
  int v216; // esi
  unsigned int v217; // eax
  int v218; // esi
  void **v219; // eax
  int v220; // ecx
  unsigned int v221; // eax
  int v222; // esi
  unsigned int v223; // edx
  bool v224; // cc
  unsigned int v225; // eax
  int v226; // esi
  void **v227; // eax
  int v228; // ecx
  unsigned int v229; // esi
  unsigned int v230; // eax
  int v231; // esi
  int v232; // edi
  int v233; // ecx
  signed int v234; // esi
  int v235; // ecx
  __m128i v236; // xmm4
  __m128i v237; // xmm7
  __m128i v238; // xmm6
  __m128i v239; // xmm5
  int v240; // eax
  __m128i v241; // xmm2
  __m128i v242; // xmm3
  __m128i v243; // xmm3
  __m128i v244; // xmm5
  __m128i v245; // xmm5
  __m128i v246; // xmm4
  __m128i v247; // xmm4
  int v248; // edx
  int v249; // edi
  int v250; // esi
  int v251; // eax
  int v252; // eax
  int v253; // esi
  int v254; // edi
  int v255; // esi
  unsigned int v256; // edx
  double v257; // xmm0_8
  int v258; // eax
  double v259; // xmm0_8
  unsigned int v260; // [esp+3Ch] [ebp-2B0h]
  int v261; // [esp+40h] [ebp-2ACh]
  int v262; // [esp+44h] [ebp-2A8h]
  int v263; // [esp+48h] [ebp-2A4h]
  int v264; // [esp+4Ch] [ebp-2A0h]
  char v265; // [esp+53h] [ebp-299h]
  int v266; // [esp+54h] [ebp-298h]
  double v267; // [esp+54h] [ebp-298h]
  int v268; // [esp+54h] [ebp-298h]
  double v269; // [esp+5Ch] [ebp-290h]
  unsigned int v270; // [esp+5Ch] [ebp-290h]
  int v271; // [esp+5Ch] [ebp-290h]
  double v272; // [esp+5Ch] [ebp-290h]
  double v273; // [esp+5Ch] [ebp-290h]
  int *v275; // [esp+6Ch] [ebp-280h]
  int v276; // [esp+70h] [ebp-27Ch]
  int v277; // [esp+70h] [ebp-27Ch]
  double v278; // [esp+74h] [ebp-278h]
  int v279; // [esp+74h] [ebp-278h]
  _DWORD *v280; // [esp+74h] [ebp-278h]
  int v281; // [esp+74h] [ebp-278h]
  unsigned int v282; // [esp+74h] [ebp-278h]
  int v283; // [esp+74h] [ebp-278h]
  int v284; // [esp+74h] [ebp-278h]
  int v285; // [esp+7Ch] [ebp-270h]
  int v286; // [esp+7Ch] [ebp-270h]
  int v287; // [esp+7Ch] [ebp-270h]
  int v288; // [esp+7Ch] [ebp-270h]
  double v289; // [esp+7Ch] [ebp-270h]
  double v290; // [esp+7Ch] [ebp-270h]
  int v291; // [esp+7Ch] [ebp-270h]
  int v292; // [esp+7Ch] [ebp-270h]
  int v293; // [esp+84h] [ebp-268h]
  int v294; // [esp+84h] [ebp-268h]
  int v295; // [esp+84h] [ebp-268h]
  int v296; // [esp+84h] [ebp-268h]
  double v297; // [esp+84h] [ebp-268h]
  double v298; // [esp+84h] [ebp-268h]
  int v299; // [esp+90h] [ebp-25Ch]
  double v300; // [esp+94h] [ebp-258h]
  unsigned int v301; // [esp+94h] [ebp-258h]
  double v302; // [esp+94h] [ebp-258h]
  double v303; // [esp+94h] [ebp-258h]
  int v304; // [esp+9Ch] [ebp-250h]
  int v305; // [esp+A0h] [ebp-24Ch]
  unsigned int v306; // [esp+A0h] [ebp-24Ch]
  double v307; // [esp+A4h] [ebp-248h]
  double v308; // [esp+A4h] [ebp-248h]
  double v309; // [esp+A4h] [ebp-248h]
  double v310; // [esp+ACh] [ebp-240h]
  double v311; // [esp+ACh] [ebp-240h]
  double v312; // [esp+ACh] [ebp-240h]
  double v313; // [esp+ACh] [ebp-240h]
  double v314; // [esp+ACh] [ebp-240h]
  double v315; // [esp+ACh] [ebp-240h]
  double v316; // [esp+B4h] [ebp-238h]
  double v317; // [esp+B4h] [ebp-238h]
  double v318; // [esp+B4h] [ebp-238h]
  double v319; // [esp+B4h] [ebp-238h]
  double v320; // [esp+B4h] [ebp-238h]
  double v321; // [esp+BCh] [ebp-230h]
  double v322; // [esp+BCh] [ebp-230h]
  double v323; // [esp+BCh] [ebp-230h]
  double v324; // [esp+BCh] [ebp-230h]
  double v325; // [esp+BCh] [ebp-230h]
  double v326; // [esp+C4h] [ebp-228h]
  double v327; // [esp+C4h] [ebp-228h]
  double v328; // [esp+CCh] [ebp-220h]
  double v329; // [esp+CCh] [ebp-220h]
  double v330; // [esp+CCh] [ebp-220h]
  double v331; // [esp+D4h] [ebp-218h]
  double v332; // [esp+D4h] [ebp-218h]
  double v333; // [esp+D4h] [ebp-218h]
  double v334; // [esp+DCh] [ebp-210h]
  double v335; // [esp+DCh] [ebp-210h]
  double v336; // [esp+ECh] [ebp-200h]
  double v337; // [esp+F4h] [ebp-1F8h]
  double v338; // [esp+FCh] [ebp-1F0h]
  double v339; // [esp+104h] [ebp-1E8h]
  double v340; // [esp+10Ch] [ebp-1E0h] BYREF
  double v341; // [esp+114h] [ebp-1D8h]
  double v342; // [esp+11Ch] [ebp-1D0h]
  double v343; // [esp+124h] [ebp-1C8h]
  double v344; // [esp+12Ch] [ebp-1C0h]
  double v345; // [esp+134h] [ebp-1B8h]
  double v346; // [esp+13Ch] [ebp-1B0h]
  double v347; // [esp+144h] [ebp-1A8h]
  double v348; // [esp+14Ch] [ebp-1A0h]
  int v349[2]; // [esp+154h] [ebp-198h] BYREF
  __int64 v350; // [esp+15Ch] [ebp-190h] BYREF
  int *v351; // [esp+168h] [ebp-184h]
  _DWORD *v352; // [esp+16Ch] [ebp-180h]
  signed int v353; // [esp+170h] [ebp-17Ch] BYREF
  void *v354[2]; // [esp+174h] [ebp-178h] BYREF
  void *v355; // [esp+17Ch] [ebp-170h]
  void *v356[2]; // [esp+180h] [ebp-16Ch] BYREF
  int v357; // [esp+188h] [ebp-164h]
  void *v358[2]; // [esp+18Ch] [ebp-160h] BYREF
  int v359; // [esp+194h] [ebp-158h]
  void *v360[2]; // [esp+198h] [ebp-154h] BYREF
  void *v361; // [esp+1A0h] [ebp-14Ch]
  void *v362[2]; // [esp+1A4h] [ebp-148h] BYREF
  int v363; // [esp+1ACh] [ebp-140h]
  void *v364[2]; // [esp+1B0h] [ebp-13Ch] BYREF
  int v365; // [esp+1B8h] [ebp-134h]
  void *v366[2]; // [esp+1BCh] [ebp-130h] BYREF
  int v367; // [esp+1C4h] [ebp-128h]
  void *v368[2]; // [esp+1C8h] [ebp-124h] BYREF
  int v369; // [esp+1D0h] [ebp-11Ch]
  __m128i v370; // [esp+1D4h] [ebp-118h] BYREF
  double v371; // [esp+1E4h] [ebp-108h]
  double v372; // [esp+1ECh] [ebp-100h]
  double v373; // [esp+1F4h] [ebp-F8h]
  __m128i v374; // [esp+1FCh] [ebp-F0h] BYREF
  double v375; // [esp+20Ch] [ebp-E0h]
  double v376; // [esp+214h] [ebp-D8h]
  double v377; // [esp+21Ch] [ebp-D0h]
  char v378[180]; // [esp+224h] [ebp-C8h] BYREF
  int v379; // [esp+2E8h] [ebp-4h]

  v350 = a5;
  sub_406C30(*(_QWORD *)a3, *(double *)(a3 + 8), *(double *)(a3 + 16), &v340);
  v351 = (int *)(this + 108);
  sub_4216E0((_DWORD *)(this + 108), *(_DWORD *)(this + 16));
  v260 = *(_DWORD *)(this + 16);
  v352 = (_DWORD *)(this + 120);
  sub_405750((_DWORD *)(this + 120), v260);
  v6 = (int *)(this + 156);
  v275 = v6;
  sub_417570(*v6, v6[1]);
  v7 = v350;
  v6[1] = *v6;
  sub_405EB0((int)v378, a4, a3 + 24, v7);
  v305 = 0;
  v276 = 0;
  v293 = -1;
  v354[0] = 0;
  v354[1] = 0;
  v355 = 0;
  v8 = 0;
  v379 = 1;
  v360[0] = 0;
  v360[1] = 0;
  v361 = 0;
  v9 = (_DWORD *)this;
  v10 = 0;
  v353 = 0;
  if ( *(int *)(this + 8) > 0 )
  {
    while ( 1 )
    {
      v304 = *(_DWORD *)(v9[24] + 4 * v10);
      v326 = 0.0;
      v11 = *(_DWORD *)(v304 + 12) - *(_DWORD *)(v304 + 8);
      v12 = v11 / 40;
      v299 = v11 / 40;
      if ( v11 / 40 > 0 )
      {
        v13 = 32 * v305;
        v14 = v348 * a2;
        v15 = 0;
        v285 = v11 / 40;
        v16 = v348 * -a2;
        v17 = v342 * -a2;
        v18 = v342 * a2;
        v269 = v16;
        v300 = v348 * a2;
        v278 = v17;
        v310 = v342 * a2;
        v307 = v345 * -a2;
        v334 = v345 * a2;
        do
        {
          v19 = *(_DWORD *)(v304 + 8);
          v321 = *(double *)(v15 + v19 + 8) - *(double *)(this + 32);
          v328 = *(double *)(v15 + v19 + 16) - *(double *)(this + 40);
          v331 = v321 * v340 + v341 * v328 + v17;
          v20 = sub_406A70((int)v378, -10.0, 0.0, -1.0, 1.0e-10, v331, v18, v321 * v346 + v347 * v328 + v16, v14);
          v21 = v321 * v343;
          v16 = v269;
          v14 = v300;
          *(double *)(v15 + *(_DWORD *)(v304 + 8) + 24) = v331 * v20 - v310;
          *(double *)(v15 + *(_DWORD *)(v304 + 8) + 32) = (v21 + v344 * v328 + v307) * v20 - v334;
          v22 = v351;
          v23 = *(double *)(v15 + *(_DWORD *)(v304 + 8) + 32);
          v15 += 40;
          *(double *)(v13 + *v351) = v321;
          v326 = v23 + v326;
          *(double *)(*v22 + v13 + 8) = v328;
          v18 = v310;
          *(double *)(*v22 + v13 + 16) = -a2;
          v24 = *v22;
          v25 = v353;
          *(double *)(v24 + v13 + 24) = v20;
          v13 += 32;
          *(_DWORD *)(*v352 + 4 * v305) = v25;
          v26 = v285-- == 1;
          ++v305;
          v17 = v278;
        }
        while ( !v26 );
        v12 = v299;
      }
      sub_417C60(
        *(__m128i **)(v304 + 8),
        (__m128i *)(40 * v12 + *(_DWORD *)(v304 + 8)),
        40 * v12 / 40,
        (unsigned __int8 (__cdecl *)(__int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32))sub_4172C0);
      *(_QWORD *)v304 = libm_sse2_sqrt_precise(v261, v262, v263, v264).m128_u64[0];
      v27 = v353;
      *(double *)(a3 + 8 * (v353 + *(_DWORD *)(this + 204))) = v326 / *(double *)(this + 56) / (double)v299;
      if ( v293 == *(_DWORD *)(v304 + 20) )
        break;
      v38 = v276;
LABEL_73:
      if ( !v27 )
        goto LABEL_395;
      while ( 1 )
      {
        if ( v38 < 4 )
          goto LABEL_395;
        v69 = 0.0;
        v308 = 1.0e11;
        v70 = 0.0;
        v71 = 0.0;
        v287 = 2;
        v72 = 0.0;
        v282 = 0;
        v364[0] = 0;
        v364[1] = 0;
        v365 = 0;
        v362[0] = 0;
        v362[1] = 0;
        v363 = 0;
        v73 = 0;
        v74 = (v354[1] - v354[0]) >> 2;
        if ( v74 )
        {
          do
          {
            v75 = *((_DWORD *)v354[0] + v73++);
            v72 = v72 + *(double *)*(_DWORD *)(*(_DWORD *)(this + 96) + 4 * v75);
          }
          while ( v73 < v74 );
        }
        v76 = 0;
        v77 = v72 / ((double)v74 + qword_439340[(unsigned int)(v354[1] - v354[0]) >> 31]);
        if ( v74 )
        {
          v78 = v77 * 0.8;
          v316 = v78;
          do
          {
            if ( v78 > *(double *)*(_DWORD *)(*(_DWORD *)(this + 96) + 4 * *((_DWORD *)v354[0] + v76)) )
            {
              memmove(
                (char *)v354[0] + 4 * v76,
                (char *)v354[0] + 4 * v76 + 4,
                ((char *)v354[1] - ((char *)v354[0] + 4 * v76 + 4)) & 0xFFFFFFFC);
              v354[1] = (char *)v354[1] - 4;
              v78 = v316;
              --v76;
            }
            ++v76;
          }
          while ( v76 < (v354[1] - v354[0]) >> 2 );
          v70 = 0.0;
          v69 = 0.0;
          v71 = 0.0;
        }
        v38 = (v354[1] - v354[0]) >> 2;
        v277 = v38;
        if ( v38 >= 4 )
          break;
        if ( v362[0] )
        {
          operator delete(v362[0]);
          v362[0] = 0;
          v362[1] = 0;
          v363 = 0;
        }
        LOBYTE(v379) = 1;
        if ( v364[0] )
        {
          operator delete(v364[0]);
          v364[0] = 0;
          v364[1] = 0;
          v365 = 0;
        }
      }
      v79 = 0.0;
      v80 = (v354[1] - v354[0]) >> 2;
      v332 = 0.0;
      v329 = 0.0;
      v270 = v80;
      v81 = (double)*(int *)(this + 52);
      v82 = (double)*(int *)(this + 48);
      v317 = v81;
      v322 = v82;
      if ( v80 )
      {
        v83 = *(_DWORD *)(this + 96);
        v84 = 0;
        do
        {
          v85 = *(_DWORD *)(v83 + 4 * *((_DWORD *)v354[0] + v84));
          v294 = v85;
          if ( (*(_DWORD *)(v85 + 12) - *(_DWORD *)(v85 + 8)) / 40 > 0 )
          {
            v86 = *(_DWORD *)(v85 + 8);
            v87 = (double *)(v86 + 8);
            v295 = (*(_DWORD *)(v294 + 12) - *(_DWORD *)(v294 + 8)) / 40;
            v88 = 0;
            v89 = 0;
            do
            {
              v90 = *(double *)(v88 + v86 + 8);
              ++v282;
              v70 = v70 + *(double *)(v88 + v86 + 16);
              v71 = v71 + v90;
              if ( v82 > v90 )
                v82 = *v87;
              if ( v90 > v69 )
                v69 = *(double *)(v88 + v86 + 8);
              v91 = *(double *)(v88 + v86 + 16);
              if ( v81 > v91 )
                v81 = *(double *)(v88 + v86 + 16);
              if ( v91 > v79 )
                v79 = *(double *)(v88 + v86 + 16);
              ++v89;
              v88 += 40;
              v87 += 5;
            }
            while ( v89 < v295 );
            v322 = v82;
            v317 = v81;
            v329 = v69;
            v332 = v79;
          }
          v80 = v270;
          ++v84;
          v83 = *(_DWORD *)(this + 96);
        }
        while ( v84 < v270 );
        v38 = v277;
      }
      v92 = _mm_cvtsi32_si128(v282);
      v265 = 0;
      v283 = 0;
      *(double *)v92.m128i_i64 = _mm_cvtepi32_pd(v92).m128d_f64[0];
      v335 = v70 / *(double *)v92.m128i_i64;
      v327 = v71 / *(double *)v92.m128i_i64;
      if ( (v80 & 0xFFFFFFF) != 0 )
      {
        while ( 1 )
        {
          v266 = rand() % v38;
          v271 = rand() % v38;
          if ( v266 != v271 )
            break;
LABEL_129:
          if ( ++v283 >= (unsigned int)(16 * ((v354[1] - v354[0]) >> 2)) )
            goto LABEL_133;
        }
        v368[0] = 0;
        v368[1] = 0;
        v369 = 0;
        LOBYTE(v379) = 4;
        v93 = *(_DWORD *)(this + 96);
        v94 = *(_DWORD *)(*(_DWORD *)(v93 + 4 * *((_DWORD *)v354[0] + v266)) + 8);
        v95 = *(double *)(v94 + 8);
        v96 = *(double *)(v94 + 16);
        v97 = 0;
        v98 = *(_DWORD *)(*(_DWORD *)(v93 + 4 * *((_DWORD *)v354[0] + v271)) + 8);
        v99 = v95 - *(double *)(v98 + 8);
        v100 = v96 - *(double *)(v98 + 16);
        v267 = v99 / v100;
        v101 = v95 - v96 * (v99 / v100);
        v102 = v99 / v100;
        v272 = v101;
        if ( v99 / v100 <= 1.0 )
        {
          v265 = 0;
          v103 = 0.0;
          if ( v38 > 0 )
          {
            do
            {
              v107 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 96) + 4 * *((_DWORD *)v354[0] + v97)) + 8);
              v108 = *(double *)(v107 + 16) * v102 + v272 - *(double *)(v107 + 8);
              v109 = v108;
              if ( v108 < 0.0 )
                v109 = -v108;
              v103 = v103 + v109;
              if ( (double)*((int *)v360[0] + 2 * v97 + 1) * 0.5 > v108 * v108 )
                sub_4214D0(v368, (const __m128i *)v107);
              v102 = v99 / v100;
              ++v97;
            }
            while ( v97 < v38 );
LABEL_120:
            v101 = v272;
            v102 = v267;
          }
        }
        else
        {
          v265 = 1;
          v102 = v100 / v99;
          v267 = v100 / v99;
          v101 = v96 - v95 * (v100 / v99);
          v103 = 0.0;
          v272 = v101;
          if ( v38 > 0 )
          {
            do
            {
              v104 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 96) + 4 * *((_DWORD *)v354[0] + v97)) + 8);
              v105 = *(double *)(v104 + 8) * v102 + v272 - *(double *)(v104 + 16);
              v106 = v105;
              if ( v105 < 0.0 )
                v106 = -v105;
              v103 = v103 + v106;
              if ( (double)*((int *)v360[0] + 2 * v97 + 1) * 0.5 > v105 * v105 )
                sub_4214D0(v368, (const __m128i *)v104);
              v102 = v100 / v99;
              ++v97;
            }
            while ( v97 < v38 );
            goto LABEL_120;
          }
        }
        v110 = v368[0];
        v111 = (v368[1] - v368[0]) / 40;
        if ( v111 >= v287 )
        {
          if ( v287 != v111 )
          {
            v287 = (v368[1] - v368[0]) / 40;
            goto LABEL_125;
          }
          if ( v308 > v103 )
          {
LABEL_125:
            v364[1] = v364[0];
            v308 = v103;
            v338 = v101;
            v339 = v102;
            sub_404AC0((int)v364, (const __m128i **)v368);
            v110 = v368[0];
          }
          if ( (double)v287 > (double)v305 * 0.95 )
          {
            if ( v110 )
            {
              operator delete(v110);
              v368[0] = 0;
              v368[1] = 0;
              v369 = 0;
            }
            goto LABEL_133;
          }
        }
        if ( v110 )
        {
          operator delete(v110);
          v368[0] = 0;
          v368[1] = 0;
          v369 = 0;
        }
        goto LABEL_129;
      }
LABEL_133:
      v311 = 1.0e11;
      v301 = 2;
      v296 = 0;
      if ( (((v354[1] - v354[0]) >> 2) & 0xFFFFFFF) == 0 )
        goto LABEL_165;
      while ( 1 )
      {
        v112 = rand() % v38;
        v268 = rand() % v38;
        if ( v112 != v268 )
          break;
LABEL_161:
        if ( ++v296 >= (unsigned int)(16 * ((v354[1] - v354[0]) >> 2)) )
          goto LABEL_165;
      }
      v366[0] = 0;
      v366[1] = 0;
      v367 = 0;
      LOBYTE(v379) = 5;
      v113 = *(_DWORD *)(this + 96);
      v114 = *(_DWORD *)(v113 + 4 * *((_DWORD *)v354[0] + v112));
      v288 = 5 * ((*(_DWORD *)(v114 + 12) - *(_DWORD *)(v114 + 8)) / 40);
      v284 = *(_DWORD *)(v114 + 8);
      v115 = *(_DWORD *)(v113 + 4 * *((_DWORD *)v354[0] + v268));
      v116 = *(_DWORD *)(v115 + 12) - *(_DWORD *)(v115 + 8);
      v117 = *(_DWORD *)(v115 + 8);
      if ( v265 )
      {
        v118 = *(double *)(v284 + 8 * v288 - 24);
        v119 = *(double *)(v284 + 8 * v288 - 32);
        v120 = v118 - *(double *)(v117 + 40 * (v116 / 40) - 24);
        v121 = v119 - *(double *)(v117 + 40 * (v116 / 40) - 32);
      }
      else
      {
        v118 = *(double *)(v284 + 8 * v288 - 32);
        v119 = *(double *)(v284 + 8 * v288 - 24);
        v120 = v118 - *(double *)(v117 + 40 * (v116 / 40) - 32);
        v121 = v119 - *(double *)(v117 + 40 * (v116 / 40) - 24);
      }
      v122 = v120 / v121;
      v123 = 0;
      v124 = 0.0;
      v309 = v122;
      v125 = v118 - v119 * v122;
      v273 = v125;
      if ( v265 )
      {
        if ( v277 > 0 )
        {
          do
          {
            v126 = *(_DWORD *)(*(_DWORD *)(this + 96) + 4 * *((_DWORD *)v354[0] + v123));
            v127 = *(_DWORD *)(v126 + 8);
            v128 = 5 * ((*(_DWORD *)(v126 + 12) - v127) / 40) - 5;
            v129 = *(double *)(v127 + 8 * v128 + 8);
            v130 = v127 + 8 * v128;
            v131 = v129 * v122 + v125 - *(double *)(v130 + 16);
            v132 = v131;
            if ( v131 < 0.0 )
              v132 = -v131;
            v124 = v124 + v132;
            if ( (double)*((int *)v360[0] + 2 * v123 + 1) * 0.5 > v131 * v131 )
            {
              sub_4214D0(v366, (const __m128i *)v130);
              v122 = v309;
              v125 = v273;
            }
            ++v123;
          }
          while ( v123 < v277 );
        }
      }
      else if ( v277 > 0 )
      {
        do
        {
          v133 = *(_DWORD *)(*(_DWORD *)(this + 96) + 4 * *((_DWORD *)v354[0] + v123));
          v134 = *(_DWORD *)(v133 + 8);
          v135 = 5 * ((*(_DWORD *)(v133 + 12) - v134) / 40) - 5;
          v136 = *(double *)(v134 + 8 * v135 + 16);
          v137 = v134 + 8 * v135;
          v138 = v136 * v122 + v125 - *(double *)(v137 + 8);
          v139 = v138;
          if ( v138 < 0.0 )
            v139 = -v138;
          v124 = v124 + v139;
          if ( (double)*((int *)v360[0] + 2 * v123 + 1) * 0.5 > v138 * v138 )
          {
            sub_4214D0(v366, (const __m128i *)v137);
            v122 = v309;
            v125 = v273;
          }
          ++v123;
        }
        while ( v123 < v277 );
      }
      v140 = v366[0];
      v141 = v301;
      v142 = (v366[1] - v366[0]) / 40;
      if ( v142 < v301 )
      {
LABEL_158:
        if ( v140 )
        {
          operator delete(v140);
          v366[0] = 0;
          v366[1] = 0;
          v367 = 0;
        }
        v38 = v277;
        goto LABEL_161;
      }
      if ( v301 == v142 )
      {
        if ( v311 <= v124 )
          goto LABEL_157;
      }
      else
      {
        v141 = (v366[1] - v366[0]) / 40;
        v301 = v141;
      }
      v362[1] = v362[0];
      v336 = v125;
      v311 = v124;
      v337 = v122;
      sub_404AC0((int)v362, (const __m128i **)v366);
      v140 = v366[0];
LABEL_157:
      if ( (double)v141 <= (double)v305 * 0.95 )
        goto LABEL_158;
      if ( v140 )
      {
        operator delete(v140);
        v366[0] = 0;
        v366[1] = 0;
        v367 = 0;
      }
LABEL_165:
      v358[0] = 0;
      v358[1] = 0;
      v359 = 0;
      v356[0] = 0;
      v356[1] = 0;
      v357 = 0;
      v143 = this;
      LOBYTE(v379) = 7;
      if ( !v265 )
      {
        v152 = v335;
        v169 = (double)*(int *)(this + 52);
        v170 = v335 - (v332 - v317);
        if ( v170 <= v169 * 0.1 )
          v170 = v169 * 0.1;
        v171 = v169 * 0.9;
        v172 = v332 - v317 + v335;
        v173 = (int)v170;
        if ( v171 <= v172 )
          v172 = v171;
        v174 = (int)v172;
        v175 = (int)v170;
        if ( v173 < (int)v172 )
        {
          while ( 1 )
          {
            v371 = (double)v175;
            v375 = (double)v175;
            *(double *)&v370.m128i_i64[1] = (double)v175 * v339 + v338;
            *(double *)&v374.m128i_i64[1] = (double)v175 * v337 + v336;
            if ( v175 == v173 || v175 == v174 - 1 )
            {
              v303 = v348 * a2;
              v298 = (double)v175 * v339 + v338 - *(double *)(v143 + 32);
              v330 = (double)v175 - *(double *)(v143 + 40);
              v320 = v342 * a2;
              v324 = v341 * v330 + v340 * v298 + v342 * -a2;
              v314 = sub_406A70(
                       (int)v378,
                       -10.0,
                       0.0,
                       -1.0,
                       1.0e-10,
                       v324,
                       v342 * a2,
                       v347 * v330 + v346 * v298 + v348 * -a2,
                       v348 * a2);
              v176 = (double)v175 - *(double *)(this + 40);
              v290 = v345 * a2;
              v372 = v314 * v324 - v320;
              v177 = (double)v175 * v337 + v336 - *(double *)(this + 32);
              v373 = (v344 * v330 + v343 * v298 + v345 * -a2) * v314 - v345 * a2;
              v325 = v341 * v176 + v340 * v177 + v342 * -a2;
              v315 = sub_406A70(
                       (int)v378,
                       -10.0,
                       0.0,
                       -1.0,
                       1.0e-10,
                       v325,
                       v320,
                       v347 * v176 + v346 * v177 + v348 * -a2,
                       v303);
              v376 = v315 * v325 - v320;
              v377 = (v344 * v176 + v343 * v177 + v345 * -a2) * v315 - v290;
            }
            sub_4214D0(v358, &v370);
            sub_4214D0(v356, &v374);
            v173 = (int)v170;
            v175 += 2;
            if ( v175 >= v174 )
              break;
            v143 = this;
          }
LABEL_177:
          v152 = v335;
        }
        v144 = v327;
        goto LABEL_179;
      }
      v144 = v327;
      v145 = (double)*(int *)(this + 48);
      v146 = v327 - (v329 - v322);
      if ( v146 <= v145 * 0.1 )
        v146 = v145 * 0.1;
      v147 = v145 * 0.9;
      v148 = v329 - v322 + v327;
      v149 = (int)v146;
      if ( v147 <= v148 )
        v148 = v147;
      v150 = (int)v148;
      v151 = (int)v146;
      if ( v149 < (int)v148 )
      {
        while ( 1 )
        {
          *(double *)&v374.m128i_i64[1] = (double)v151;
          *(double *)&v370.m128i_i64[1] = (double)v151;
          v375 = (double)v151 * v339 + v338;
          v371 = (double)v151 * v337 + v336;
          if ( v151 == v149 || v151 == v150 - 1 )
          {
            v302 = v348 * a2;
            v297 = (double)v151 - *(double *)(v143 + 32);
            v333 = (double)v151 * v339 + v338 - *(double *)(v143 + 40);
            v323 = v342 * a2;
            v318 = v341 * v333 + v340 * v297 + v342 * -a2;
            v312 = sub_406A70(
                     (int)v378,
                     -10.0,
                     0.0,
                     -1.0,
                     1.0e-10,
                     v318,
                     v342 * a2,
                     v347 * v333 + v346 * v297 + v348 * -a2,
                     v348 * a2);
            v153 = (double)v151 - *(double *)(this + 32);
            v289 = v345 * a2;
            v376 = v312 * v318 - v323;
            v154 = (double)v151 * v337 + v336 - *(double *)(this + 40);
            v377 = (v344 * v333 + v343 * v297 + v345 * -a2) * v312 - v345 * a2;
            v319 = v341 * v154 + v340 * v153 + v342 * -a2;
            v313 = sub_406A70(
                     (int)v378,
                     -10.0,
                     0.0,
                     -1.0,
                     1.0e-10,
                     v319,
                     v323,
                     v347 * v154 + v346 * v153 + v348 * -a2,
                     v302);
            v372 = v313 * v319 - v323;
            v373 = (v344 * v154 + v343 * v153 + v345 * -a2) * v313 - v289;
          }
          sub_4214D0(v358, &v374);
          sub_4214D0(v356, &v370);
          v149 = (int)v146;
          v151 += 2;
          if ( v151 >= v150 )
            break;
          v143 = this;
        }
        goto LABEL_177;
      }
      v152 = v335;
LABEL_179:
      v155 = (v354[1] - v354[0]) >> 2;
      v156 = (v364[1] - v364[0]) / 40;
      if ( v156 <= v155 / 3 || (v362[1] - v362[0]) / 40 <= v155 / 3 )
      {
        v223 = 3 * v155 / 5;
        if ( v223 < 4 )
          v223 = 4;
        v224 = v156 <= v223;
        v164 = v275;
        if ( !v224 )
        {
          v225 = v275[1];
          if ( (unsigned int)v358 >= v225 || *v275 > (unsigned int)v358 )
          {
            if ( v225 == v275[2] )
              sub_4213C0(v275, 1u);
            v228 = v275[1];
            LOBYTE(v379) = 33;
            if ( v228 )
            {
              v227 = v358;
              goto LABEL_369;
            }
          }
          else
          {
            v226 = ((int)v358 - *v275) / 12;
            if ( v275[1] == v275[2] )
              sub_4213C0(v275, 1u);
            v227 = (void **)(*v275 + 12 * v226);
            v228 = v275[1];
            LOBYTE(v379) = 32;
            if ( v228 )
LABEL_369:
              sub_404A00(v228, (const __m128i **)v227);
          }
          v275[1] += 12;
          LOBYTE(v379) = 7;
        }
        v229 = 3 * ((v354[1] - v354[0]) >> 2) / 5u;
        if ( v229 < 4 )
          v229 = 4;
        if ( (v362[1] - v362[0]) / 40 <= v229 )
          goto LABEL_387;
        v230 = v275[1];
        if ( (unsigned int)v356 < v230 && *v275 <= (unsigned int)v356 )
        {
          v231 = ((int)v356 - *v275) / 12;
          if ( v275[1] == v275[2] )
            sub_4213C0(v275, 1u);
          v181 = (void **)(*v275 + 12 * v231);
          v182 = v275[1];
          LOBYTE(v379) = 34;
          if ( !v182 )
            goto LABEL_386;
LABEL_385:
          sub_404A00(v182, (const __m128i **)v181);
          goto LABEL_386;
        }
        if ( v230 == v275[2] )
          sub_4213C0(v275, 1u);
        v182 = v275[1];
        LOBYTE(v379) = 35;
LABEL_383:
        if ( v182 )
        {
          v181 = v356;
          goto LABEL_385;
        }
        goto LABEL_386;
      }
      v157 = v339 - v337;
      if ( !v265 )
      {
        v197 = v339 - v337;
        if ( v157 < 0.0 )
          v197 = -v157;
        if ( v197 > 0.00001 )
        {
          v198 = (v336 - v338) / v157;
          v199 = (double)*(int *)(this + 52);
          if ( v152 - v199 <= v198 && v198 <= v199 + v152 )
          {
            v200 = v199 * 0.5;
            if ( v152 - v200 <= v198 && v198 <= v152 + v200 )
              goto LABEL_387;
            v201 = 4 * v155 / 5;
            if ( v201 < 4 )
              v201 = 4;
            v163 = v156 < v201;
            v164 = v275;
            if ( !v163 )
            {
              v202 = v275[1];
              if ( (unsigned int)v358 >= v202 || *v275 > (unsigned int)v358 )
              {
                if ( v202 == v275[2] )
                  sub_4213C0(v275, 1u);
                v205 = v275[1];
                LOBYTE(v379) = 25;
                if ( v205 )
                {
                  v204 = v358;
                  goto LABEL_295;
                }
              }
              else
              {
                v203 = ((int)v358 - *v275) / 12;
                if ( v275[1] == v275[2] )
                  sub_4213C0(v275, 1u);
                v204 = (void **)(*v275 + 12 * v203);
                v205 = v275[1];
                LOBYTE(v379) = 24;
                if ( v205 )
LABEL_295:
                  sub_404A00(v205, (const __m128i **)v204);
              }
              v275[1] += 12;
              LOBYTE(v379) = 7;
            }
            v206 = ((v354[1] - v354[0]) & 0xFFFFFFFC) / 5;
            if ( v206 < 4 )
              v206 = 4;
            if ( (v362[1] - v362[0]) / 40 < v206 )
              goto LABEL_387;
            v207 = v275[1];
            if ( (unsigned int)v356 < v207 && *v275 <= (unsigned int)v356 )
            {
              v208 = ((int)v356 - *v275) / 12;
              if ( v275[1] == v275[2] )
                sub_4213C0(v275, 1u);
              v181 = (void **)(*v275 + 12 * v208);
              v182 = v275[1];
              LOBYTE(v379) = 26;
              if ( !v182 )
                goto LABEL_386;
              goto LABEL_385;
            }
            if ( v207 == v275[2] )
              sub_4213C0(v275, 1u);
            v182 = v275[1];
            LOBYTE(v379) = 27;
            goto LABEL_383;
          }
          v209 = v155 >> 1;
          if ( v209 < 4 )
            v209 = 4;
          v163 = v156 < v209;
          v164 = v275;
          if ( !v163 )
          {
            v210 = v275[1];
            if ( (unsigned int)v358 >= v210 || *v275 > (unsigned int)v358 )
            {
              if ( v210 == v275[2] )
                sub_4213C0(v275, 1u);
              v213 = v275[1];
              LOBYTE(v379) = 21;
              if ( v213 )
              {
                v212 = v358;
                goto LABEL_322;
              }
            }
            else
            {
              v211 = ((int)v358 - *v275) / 12;
              if ( v275[1] == v275[2] )
                sub_4213C0(v275, 1u);
              v212 = (void **)(*v275 + 12 * v211);
              v213 = v275[1];
              LOBYTE(v379) = 20;
              if ( v213 )
LABEL_322:
                sub_404A00(v213, (const __m128i **)v212);
            }
            v275[1] += 12;
            LOBYTE(v379) = 7;
          }
          v214 = (unsigned int)((v354[1] - v354[0]) >> 2) >> 1;
          if ( v214 < 4 )
            v214 = 4;
          if ( (v362[1] - v362[0]) / 40 < v214 )
            goto LABEL_387;
          v215 = v275[1];
          if ( (unsigned int)v356 < v215 && *v275 <= (unsigned int)v356 )
          {
            v216 = ((int)v356 - *v275) / 12;
            if ( v275[1] == v275[2] )
              sub_4213C0(v275, 1u);
            v181 = (void **)(*v275 + 12 * v216);
            v182 = v275[1];
            LOBYTE(v379) = 22;
            if ( !v182 )
              goto LABEL_386;
            goto LABEL_385;
          }
          if ( v215 == v275[2] )
            sub_4213C0(v275, 1u);
          v182 = v275[1];
          LOBYTE(v379) = 23;
          goto LABEL_383;
        }
        v164 = v275;
        v217 = v275[1];
        if ( (unsigned int)v358 >= v217 || *v275 > (unsigned int)v358 )
        {
          if ( v217 == v275[2] )
            sub_4213C0(v275, 1u);
          v220 = v275[1];
          LOBYTE(v379) = 29;
          if ( v220 )
          {
            v219 = v358;
            goto LABEL_346;
          }
        }
        else
        {
          v218 = ((int)v358 - *v275) / 12;
          if ( v275[1] == v275[2] )
            sub_4213C0(v275, 1u);
          v219 = (void **)(*v275 + 12 * v218);
          v220 = v275[1];
          LOBYTE(v379) = 28;
          if ( v220 )
LABEL_346:
            sub_404A00(v220, (const __m128i **)v219);
        }
        v275[1] += 12;
        v221 = v275[1];
        LOBYTE(v379) = 7;
        if ( (unsigned int)v356 < v221 && *v275 <= (unsigned int)v356 )
        {
          v222 = ((int)v356 - *v275) / 12;
          if ( v275[1] == v275[2] )
            sub_4213C0(v275, 1u);
          v181 = (void **)(*v275 + 12 * v222);
          v182 = v275[1];
          LOBYTE(v379) = 30;
          if ( !v182 )
            goto LABEL_386;
          goto LABEL_385;
        }
        if ( v221 == v275[2] )
          sub_4213C0(v275, 1u);
        v182 = v275[1];
        LOBYTE(v379) = 31;
        goto LABEL_383;
      }
      v158 = v339 - v337;
      if ( v157 < 0.0 )
        v158 = -v157;
      if ( v158 <= 0.00001 )
      {
        v164 = v275;
        v191 = v275[1];
        if ( (unsigned int)v358 >= v191 || *v275 > (unsigned int)v358 )
        {
          if ( v191 == v275[2] )
            sub_4213C0(v275, 1u);
          v194 = v275[1];
          LOBYTE(v379) = 17;
          if ( v194 )
          {
            v193 = v358;
            goto LABEL_265;
          }
        }
        else
        {
          v192 = ((int)v358 - *v275) / 12;
          if ( v275[1] == v275[2] )
            sub_4213C0(v275, 1u);
          v193 = (void **)(*v275 + 12 * v192);
          v194 = v275[1];
          LOBYTE(v379) = 16;
          if ( v194 )
LABEL_265:
            sub_404A00(v194, (const __m128i **)v193);
        }
        v275[1] += 12;
        v195 = v275[1];
        LOBYTE(v379) = 7;
        if ( (unsigned int)v356 < v195 && *v275 <= (unsigned int)v356 )
        {
          v196 = ((int)v356 - *v275) / 12;
          if ( v275[1] == v275[2] )
            sub_4213C0(v275, 1u);
          v181 = (void **)(*v275 + 12 * v196);
          v182 = v275[1];
          LOBYTE(v379) = 18;
          if ( !v182 )
            goto LABEL_386;
          goto LABEL_385;
        }
        if ( v195 == v275[2] )
          sub_4213C0(v275, 1u);
        v182 = v275[1];
        LOBYTE(v379) = 19;
        goto LABEL_383;
      }
      v159 = (v336 - v338) / v157;
      v160 = (double)*(int *)(this + 48);
      if ( v144 - v160 > v159 || v159 > v160 + v144 )
      {
        v183 = v155 >> 1;
        if ( v183 < 4 )
          v183 = 4;
        v163 = v156 < v183;
        v164 = v275;
        if ( !v163 )
        {
          v184 = v275[1];
          if ( (unsigned int)v358 >= v184 || *v275 > (unsigned int)v358 )
          {
            if ( v184 == v275[2] )
              sub_4213C0(v275, 1u);
            v187 = v275[1];
            LOBYTE(v379) = 9;
            if ( v187 )
            {
              v186 = v358;
              goto LABEL_241;
            }
          }
          else
          {
            v185 = ((int)v358 - *v275) / 12;
            if ( v275[1] == v275[2] )
              sub_4213C0(v275, 1u);
            v186 = (void **)(*v275 + 12 * v185);
            v187 = v275[1];
            LOBYTE(v379) = 8;
            if ( v187 )
LABEL_241:
              sub_404A00(v187, (const __m128i **)v186);
          }
          v275[1] += 12;
          LOBYTE(v379) = 7;
        }
        v188 = (unsigned int)((v354[1] - v354[0]) >> 2) >> 1;
        if ( v188 < 4 )
          v188 = 4;
        if ( (v362[1] - v362[0]) / 40 < v188 )
          goto LABEL_387;
        v189 = v275[1];
        if ( (unsigned int)v356 < v189 && *v275 <= (unsigned int)v356 )
        {
          v190 = ((int)v356 - *v275) / 12;
          if ( v275[1] == v275[2] )
            sub_4213C0(v275, 1u);
          v181 = (void **)(*v275 + 12 * v190);
          v182 = v275[1];
          LOBYTE(v379) = 10;
          if ( !v182 )
            goto LABEL_386;
          goto LABEL_385;
        }
        if ( v189 == v275[2] )
          sub_4213C0(v275, 1u);
        v182 = v275[1];
        LOBYTE(v379) = 11;
        goto LABEL_383;
      }
      v161 = v160 * 0.5;
      if ( v144 - v161 <= v159 && v159 <= v161 + v144 )
        goto LABEL_387;
      v162 = 4 * v155 / 5;
      if ( v162 < 4 )
        v162 = 4;
      v163 = v156 < v162;
      v164 = v275;
      if ( !v163 )
      {
        v165 = v275[1];
        if ( (unsigned int)v358 >= v165 || *v275 > (unsigned int)v358 )
        {
          if ( v165 == v275[2] )
            sub_4213C0(v275, 1u);
          v168 = v275[1];
          LOBYTE(v379) = 13;
          if ( v168 )
          {
            v167 = v358;
            goto LABEL_214;
          }
        }
        else
        {
          v166 = ((int)v358 - *v275) / 12;
          if ( v275[1] == v275[2] )
            sub_4213C0(v275, 1u);
          v167 = (void **)(*v275 + 12 * v166);
          v168 = v275[1];
          LOBYTE(v379) = 12;
          if ( v168 )
LABEL_214:
            sub_404A00(v168, (const __m128i **)v167);
        }
        v275[1] += 12;
        LOBYTE(v379) = 7;
      }
      v178 = ((v354[1] - v354[0]) & 0xFFFFFFFC) / 5;
      if ( v178 < 4 )
        v178 = 4;
      if ( (v362[1] - v362[0]) / 40 < v178 )
        goto LABEL_387;
      v179 = v275[1];
      if ( (unsigned int)v356 >= v179 || *v275 > (unsigned int)v356 )
      {
        if ( v179 == v275[2] )
          sub_4213C0(v275, 1u);
        v182 = v275[1];
        LOBYTE(v379) = 15;
        goto LABEL_383;
      }
      v180 = ((int)v356 - *v275) / 12;
      if ( v275[1] == v275[2] )
        sub_4213C0(v275, 1u);
      v181 = (void **)(*v275 + 12 * v180);
      v182 = v275[1];
      LOBYTE(v379) = 14;
      if ( v182 )
        goto LABEL_385;
LABEL_386:
      v164[1] += 12;
LABEL_387:
      LOBYTE(v379) = 6;
      if ( v356[0] )
      {
        std::_Container_base0::_Orphan_all((std::_Container_base0 *)v356);
        operator delete(v356[0]);
        v356[0] = 0;
        v356[1] = 0;
        v357 = 0;
      }
      LOBYTE(v379) = 3;
      if ( v358[0] )
      {
        std::_Container_base0::_Orphan_all((std::_Container_base0 *)v358);
        operator delete(v358[0]);
        v358[0] = 0;
        v358[1] = 0;
        v359 = 0;
      }
      LOBYTE(v379) = 2;
      if ( v362[0] )
      {
        std::_Container_base0::_Orphan_all((std::_Container_base0 *)v362);
        operator delete(v362[0]);
        v362[0] = 0;
        v362[1] = 0;
        v363 = 0;
      }
      LOBYTE(v379) = 1;
      if ( v364[0] )
      {
        std::_Container_base0::_Orphan_all((std::_Container_base0 *)v364);
        operator delete(v364[0]);
        v364[0] = 0;
        v364[1] = 0;
        v365 = 0;
      }
LABEL_395:
      v293 = *(_DWORD *)(v304 + 20);
      std::_Container_base0::_Orphan_all((std::_Container_base0 *)v360);
      v360[1] = v360[0];
      std::_Container_base0::_Orphan_all((std::_Container_base0 *)v354);
      v354[1] = v354[0];
      sub_421460(v354, (unsigned int *)&v353);
      v232 = v299;
      v233 = 0;
      v276 = 1;
      v234 = 0;
      v291 = 0;
      if ( v299 <= 0 )
      {
        v250 = 0;
      }
      else
      {
        if ( (unsigned int)v299 >= 8 && dword_5019B4 >= 2 )
        {
          v235 = *(_DWORD *)(v304 + 8);
          v236 = 0i64;
          v237 = 0i64;
          v238 = 0i64;
          v239 = 0i64;
          v240 = 80;
          do
          {
            v241 = _mm_cvtsi32_si128(*(_DWORD *)(v240 + v235 + 40));
            v240 += 320;
            v234 += 8;
            v242 = _mm_unpacklo_epi32(
                     _mm_unpacklo_epi32(
                       _mm_cvtsi32_si128(*(_DWORD *)(v240 + v235 - 400)),
                       _mm_cvtsi32_si128(*(_DWORD *)(v240 + v235 - 320))),
                     _mm_unpacklo_epi32(_mm_cvtsi32_si128(*(_DWORD *)(v240 + v235 - 360)), v241));
            v237 = _mm_add_epi32(v237, v242);
            v236 = _mm_max_epi32(v236, v242);
            v243 = _mm_unpacklo_epi32(
                     _mm_unpacklo_epi32(
                       _mm_cvtsi32_si128(*(_DWORD *)(v240 + v235 - 240)),
                       _mm_cvtsi32_si128(*(_DWORD *)(v240 + v235 - 160))),
                     _mm_unpacklo_epi32(
                       _mm_cvtsi32_si128(*(_DWORD *)(v240 + v235 - 200)),
                       _mm_cvtsi32_si128(*(_DWORD *)(v240 + v235 - 120))));
            v239 = _mm_add_epi32(v239, v243);
            v238 = _mm_max_epi32(v238, v243);
          }
          while ( v234 < (int)(v299 - (v299 & 0x80000007)) );
          v244 = _mm_add_epi32(v239, v237);
          v245 = _mm_add_epi32(v244, _mm_srli_si128(v244, 8));
          v246 = _mm_max_epi32(v236, v238);
          v291 = _mm_cvtsi128_si32(_mm_add_epi32(v245, _mm_srli_si128(v245, 4)));
          v247 = _mm_max_epi32(v246, _mm_srli_si128(v246, 8));
          v233 = _mm_cvtsi128_si32(_mm_max_epi32(v247, _mm_srli_si128(v247, 4)));
        }
        if ( v234 >= v299 )
        {
          v250 = v291;
        }
        else
        {
          v248 = 40 * v234;
          v249 = v299 - v234;
          v250 = v291;
          v251 = *(_DWORD *)(v304 + 8);
          do
          {
            v252 = *(_DWORD *)(v248 + v251);
            v248 += 40;
            v250 += v252;
            if ( v233 < v252 )
              v233 = v252;
            v251 = *(_DWORD *)(v304 + 8);
            --v249;
          }
          while ( v249 );
          v232 = v299;
        }
      }
      LODWORD(v350) = v233;
      HIDWORD(v350) = (v250 + v232 / 2) / v232;
      sub_4056D0((unsigned int *)v360, &v350);
      v8 = v360[0];
      v27 = v353;
      v9 = (_DWORD *)this;
LABEL_410:
      v10 = v27 + 1;
      v353 = v10;
      if ( v10 >= v9[2] )
      {
        v6 = v275;
        goto LABEL_412;
      }
    }
    if ( &v353 >= v354[1] || v354[0] > &v353 )
    {
      if ( v354[1] == v355 && !((signed int)((int)v355 - (unsigned int)v354[1]) >> 2) )
      {
        v34 = (v354[1] - v354[0]) >> 2;
        if ( v34 == 0x3FFFFFFF )
          goto LABEL_423;
        v35 = (signed int)((int)v355 - (unsigned int)v354[0]) >> 2;
        if ( 0x3FFFFFFF - (v35 >> 1) >= v35 )
          v36 = (v35 >> 1) + v35;
        else
          v36 = 0;
        if ( v36 < v34 + 1 )
          v36 = v34 + 1;
        sub_405400((int)v354, v36);
      }
      v32 = (unsigned int *)v354[1];
      if ( !v354[1] )
        goto LABEL_32;
      v33 = v353;
    }
    else
    {
      v28 = ((char *)&v353 - (char *)v354[0]) >> 2;
      if ( v354[1] == v355 && !((signed int)((int)v355 - (unsigned int)v354[1]) >> 2) )
      {
        v29 = (v354[1] - v354[0]) >> 2;
        if ( v29 == 0x3FFFFFFF )
          goto LABEL_423;
        v30 = (signed int)((int)v355 - (unsigned int)v354[0]) >> 2;
        if ( 0x3FFFFFFF - (v30 >> 1) >= v30 )
          v31 = (v30 >> 1) + v30;
        else
          v31 = 0;
        if ( v31 < v29 + 1 )
          v31 = v29 + 1;
        sub_405400((int)v354, v31);
      }
      v32 = (unsigned int *)v354[1];
      if ( !v354[1] )
        goto LABEL_32;
      v33 = *((_DWORD *)v354[0] + v28);
    }
    *v32 = v33;
LABEL_32:
    v37 = 0;
    v354[1] = (char *)v354[1] + 4;
    v38 = v276 + 1;
    v39 = v299;
    v40 = 0;
    v41 = 0;
    ++v276;
    v279 = 0;
    if ( v299 > 0 )
    {
      if ( (unsigned int)v299 >= 8 && dword_5019B4 >= 2 )
      {
        v42 = *(_DWORD *)(v304 + 8);
        v43 = 0i64;
        v44 = 0i64;
        v45 = 0i64;
        v46 = 0i64;
        v47 = 80;
        do
        {
          v48 = _mm_cvtsi32_si128(*(_DWORD *)(v47 + v42 + 40));
          v47 += 320;
          v41 += 8;
          v49 = _mm_unpacklo_epi32(
                  _mm_unpacklo_epi32(
                    _mm_cvtsi32_si128(*(_DWORD *)(v47 + v42 - 400)),
                    _mm_cvtsi32_si128(*(_DWORD *)(v47 + v42 - 320))),
                  _mm_unpacklo_epi32(_mm_cvtsi32_si128(*(_DWORD *)(v47 + v42 - 360)), v48));
          v44 = _mm_add_epi32(v44, v49);
          v43 = _mm_max_epi32(v43, v49);
          v50 = _mm_unpacklo_epi32(
                  _mm_unpacklo_epi32(
                    _mm_cvtsi32_si128(*(_DWORD *)(v47 + v42 - 240)),
                    _mm_cvtsi32_si128(*(_DWORD *)(v47 + v42 - 160))),
                  _mm_unpacklo_epi32(
                    _mm_cvtsi32_si128(*(_DWORD *)(v47 + v42 - 200)),
                    _mm_cvtsi32_si128(*(_DWORD *)(v47 + v42 - 120))));
          v46 = _mm_add_epi32(v46, v50);
          v45 = _mm_max_epi32(v45, v50);
        }
        while ( v41 < (int)(v299 - (v299 & 0x80000007)) );
        v39 = v299;
        v51 = _mm_add_epi32(v44, v46);
        v52 = _mm_add_epi32(v51, _mm_srli_si128(v51, 8));
        v53 = _mm_max_epi32(v43, v45);
        v37 = _mm_cvtsi128_si32(_mm_add_epi32(v52, _mm_srli_si128(v52, 4)));
        v54 = _mm_max_epi32(v53, _mm_srli_si128(v53, 8));
        v279 = v37;
        v40 = _mm_cvtsi128_si32(_mm_max_epi32(v54, _mm_srli_si128(v54, 4)));
      }
      if ( v41 < v39 )
      {
        v55 = 40 * v41;
        v56 = v299 - v41;
        v57 = v279;
        v58 = *(_DWORD *)(v304 + 8);
        do
        {
          v59 = *(_DWORD *)(v55 + v58);
          v55 += 40;
          v57 += v59;
          if ( v40 < v59 )
            v40 = v59;
          v58 = *(_DWORD *)(v304 + 8);
          --v56;
        }
        while ( v56 );
        v38 = v276;
        v37 = v57;
        v39 = v299;
      }
    }
    v349[0] = v40;
    v60 = v37 + v39 / 2;
    v61 = (int *)v360[1];
    v286 = v60 / v299;
    v349[1] = v60 / v299;
    v280 = v360[0];
    if ( v349 >= v360[1] || v360[0] > v349 )
    {
      if ( v360[1] == v361 && !((signed int)((int)v361 - (unsigned int)v360[1]) >> 3) )
      {
        v66 = (v360[1] - v360[0]) >> 3;
        if ( v66 == 0x1FFFFFFF )
LABEL_423:
          std::_Xlength_error("vector<T> too long");
        v67 = (signed int)((int)v361 - (unsigned int)v360[0]) >> 3;
        if ( 0x1FFFFFFF - (v67 >> 1) >= v67 )
          v68 = (v67 >> 1) + v67;
        else
          v68 = 0;
        if ( v68 < v66 + 1 )
          v68 = v66 + 1;
        sub_405480((_DWORD **)v360, v68);
        v61 = (int *)v360[1];
        v280 = v360[0];
      }
      if ( v61 )
      {
        *v61 = v40;
        v61[1] = v286;
        v61 = (int *)v360[1];
        v8 = v360[0];
      }
      else
      {
        v8 = v280;
      }
    }
    else
    {
      v8 = v360[0];
      v62 = ((char *)v349 - (char *)v360[0]) >> 3;
      v281 = v62;
      if ( v360[1] == v361 )
      {
        if ( !((signed int)((int)v361 - (unsigned int)v360[1]) >> 3) )
        {
          v63 = (v360[1] - v360[0]) >> 3;
          if ( v63 == 0x1FFFFFFF )
            goto LABEL_423;
          v64 = (signed int)((int)v361 - (unsigned int)v360[0]) >> 3;
          if ( 0x1FFFFFFF - (v64 >> 1) >= v64 )
            v65 = (v64 >> 1) + v64;
          else
            v65 = 0;
          if ( v65 < v63 + 1 )
            v65 = v63 + 1;
          sub_405480((_DWORD **)v360, v65);
          v61 = (int *)v360[1];
          v8 = v360[0];
        }
        v62 = v281;
      }
      if ( v61 )
      {
        *v61 = v8[2 * v62];
        v61[1] = v8[2 * v281 + 1];
        v61 = (int *)v360[1];
        v8 = v360[0];
      }
    }
    v9 = (_DWORD *)this;
    v360[1] = v61 + 2;
    v27 = v353;
    if ( v353 != *(_DWORD *)(this + 8) - 1 )
      goto LABEL_410;
    goto LABEL_73;
  }
LABEL_412:
  v9[5] = 0;
  v306 = 0;
  if ( (v6[1] - *v6) / 12 )
  {
    v253 = 0;
    v292 = 0;
    do
    {
      v254 = *v6;
      *(_DWORD *)(this + 20) += (*(_DWORD *)(v253 + v254 + 4) - *(_DWORD *)(v253 + v254)) / 40;
      v255 = *(_DWORD *)(v253 + v254);
      v256 = (int)((unsigned __int64)(1717986919i64 * (*(_DWORD *)(v292 + v254 + 4) - *(_DWORD *)(v292 + v254))) >> 32) >> 4;
      v6 = v275;
      v257 = *(double *)(v255 + 40 * (v256 + (v256 >> 31)) - 16) + *(double *)(v255 + 24);
      v258 = *(_DWORD *)(this + 8) + v306 + *(_DWORD *)(this + 204);
      ++v306;
      v253 = v292 + 12;
      v292 += 12;
      *(double *)(a3 + 8 * v258) = v257 * 0.5 / *(double *)(this + 56);
    }
    while ( v306 < (v6[1] - *v6) / 12 );
    v8 = v360[0];
  }
  v259 = 10.0;
  if ( (double)*(int *)(this + 16) / (double)(*(_DWORD *)(this + 8) + *(_DWORD *)(this + 20)) * 0.25 <= 10.0 )
    v259 = (double)*(int *)(this + 16) / (double)(*(_DWORD *)(this + 8) + *(_DWORD *)(this + 20)) * 0.25;
  *(double *)(this + 64) = v259;
  LOBYTE(v379) = 0;
  if ( v8 )
  {
    std::_Container_base0::_Orphan_all((std::_Container_base0 *)v360);
    operator delete(v360[0]);
    v360[0] = 0;
    v360[1] = 0;
    v361 = 0;
  }
  v379 = -1;
  if ( v354[0] )
  {
    std::_Container_base0::_Orphan_all((std::_Container_base0 *)v354);
    operator delete(v354[0]);
  }
}
// 41B29B: conditional instruction was optimized away because %var_25C.4>=8
// 41D740: conditional instruction was optimized away because %var_25C.4>=8
// 41B0DC: variable 'v261' is possibly undefined
// 41B0DC: variable 'v262' is possibly undefined
// 41B0DC: variable 'v263' is possibly undefined
// 41B0DC: variable 'v264' is possibly undefined
// 41C236: variable 'v339' is possibly undefined
// 41C270: variable 'v338' is possibly undefined
// 41C243: variable 'v337' is possibly undefined
// 41C27F: variable 'v336' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);
// 439028: using guessed type void __thiscall std::_Container_base0::_Orphan_all(std::_Container_base0 *__hidden this);
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);
// 439340: using guessed type double qword_439340[2];
// 5019B4: using guessed type int dword_5019B4;

//----- (0041DA90) --------------------------------------------------------
void __thiscall sub_41DA90(int this, int a2, int a3, double a4)
{
  __int128 v5; // xmm0
  unsigned int *v6; // ecx
  __m128i v7; // xmm0
  int v8; // eax
  int *v9; // edi
  _DWORD *v10; // edx
  signed int v11; // ecx
  bool v12; // cc
  double v13; // xmm7_8
  double v14; // xmm3_8
  int v15; // eax
  int v16; // ecx
  int v17; // eax
  double v18; // xmm6_8
  int v19; // esi
  int v20; // edi
  double v21; // xmm5_8
  double v22; // xmm4_8
  double v23; // xmm7_8
  int v24; // eax
  double v25; // st7
  double v26; // xmm3_8
  double v27; // xmm1_8
  int *v28; // ecx
  double v29; // xmm0_8
  double v30; // xmm0_8
  int v31; // eax
  int v32; // eax
  unsigned int v33; // ecx
  bool v34; // zf
  unsigned __int64 v35; // xmm0_8
  double v36; // xmm1_8
  unsigned int v37; // ecx
  int v38; // edi
  int v39; // ecx
  unsigned int v40; // esi
  unsigned int v41; // esi
  unsigned int *v42; // ecx
  unsigned int v43; // eax
  int v44; // ecx
  unsigned int v45; // esi
  unsigned int v46; // esi
  int v47; // ecx
  int v48; // edi
  int v49; // eax
  int v50; // esi
  signed int v51; // edx
  int v52; // ecx
  __m128i v53; // xmm4
  __m128i v54; // xmm5
  __m128i v55; // xmm6
  __m128i v56; // xmm7
  int v57; // eax
  __m128i v58; // xmm2
  __m128i v59; // xmm3
  __m128i v60; // xmm0
  __m128i v61; // xmm5
  __m128i v62; // xmm5
  __m128i v63; // xmm4
  __m128i v64; // xmm4
  int v65; // ecx
  int v66; // edi
  int v67; // edx
  int v68; // eax
  int v69; // eax
  int v70; // eax
  int *v71; // ecx
  _DWORD *v72; // esi
  int v73; // eax
  int v74; // ecx
  unsigned int v75; // edx
  unsigned int v76; // edx
  int v77; // ecx
  unsigned int v78; // edx
  unsigned int v79; // edx
  double v80; // xmm2_8
  double v81; // xmm6_8
  double v82; // xmm7_8
  double v83; // xmm1_8
  unsigned int v84; // ecx
  int v85; // edx
  int v86; // eax
  unsigned int v87; // esi
  double v88; // xmm1_8
  double v89; // xmm1_8
  double v90; // xmm3_8
  double v91; // xmm4_8
  double v92; // xmm5_8
  int v93; // eax
  unsigned int v94; // edi
  int v95; // ecx
  int v96; // esi
  int v97; // esi
  double *v98; // ecx
  int v99; // eax
  int v100; // edx
  double v101; // xmm1_8
  double v102; // xmm0_8
  __m128i v103; // xmm0
  int v104; // ecx
  int v105; // edx
  double v106; // xmm5_8
  double v107; // xmm6_8
  int v108; // esi
  int v109; // eax
  double v110; // xmm2_8
  double v111; // xmm4_8
  double v112; // xmm1_8
  double v113; // xmm3_8
  double v114; // xmm3_8
  double v115; // xmm2_8
  int v116; // ecx
  double v117; // xmm1_8
  double v118; // xmm0_8
  int v119; // ecx
  double v120; // xmm1_8
  double v121; // xmm0_8
  void *v122; // esi
  unsigned int v123; // eax
  int v124; // esi
  int v125; // edi
  int v126; // esi
  int v127; // esi
  int v128; // ecx
  int v129; // esi
  double v130; // xmm4_8
  double v131; // xmm1_8
  double v132; // xmm3_8
  double v133; // xmm0_8
  double v134; // xmm3_8
  int v135; // edi
  double v136; // xmm4_8
  double v137; // xmm0_8
  int v138; // esi
  int v139; // eax
  int v140; // ecx
  double v141; // xmm1_8
  int v142; // ecx
  double v143; // xmm1_8
  double v144; // xmm2_8
  int v145; // esi
  int v146; // eax
  int v147; // ecx
  double v148; // xmm1_8
  int v149; // ecx
  double v150; // xmm1_8
  double v151; // xmm2_8
  void *v152; // esi
  int v153; // edi
  unsigned int v154; // eax
  double v155; // xmm5_8
  double v156; // xmm1_8
  double v157; // xmm0_8
  double v158; // xmm1_8
  double v159; // xmm3_8
  int v160; // eax
  int v161; // edi
  int v162; // esi
  double v163; // xmm1_8
  double v164; // xmm4_8
  unsigned int v165; // esi
  unsigned int v166; // edi
  double v167; // xmm0_8
  double v168; // xmm1_8
  double v169; // xmm2_8
  double v170; // xmm1_8
  double v171; // xmm1_8
  unsigned int v172; // edx
  bool v173; // cf
  int *v174; // edi
  unsigned int v175; // eax
  int v176; // esi
  void **v177; // eax
  int v178; // ecx
  double v179; // xmm1_8
  double v180; // xmm0_8
  double v181; // xmm1_8
  double v182; // xmm3_8
  int v183; // eax
  int v184; // edi
  int v185; // esi
  double v186; // xmm6_8
  double v187; // xmm1_8
  double v188; // xmm3_8
  unsigned int v189; // esi
  unsigned int v190; // eax
  int v191; // esi
  const __m128i **v192; // eax
  int v193; // ecx
  int v194; // ecx
  unsigned int v195; // esi
  unsigned int v196; // eax
  int v197; // esi
  void **v198; // eax
  int v199; // ecx
  unsigned int v200; // esi
  unsigned int v201; // eax
  int v202; // esi
  unsigned int v203; // eax
  int v204; // esi
  void **v205; // eax
  int v206; // ecx
  unsigned int v207; // eax
  int v208; // esi
  double v209; // xmm1_8
  double v210; // xmm2_8
  double v211; // xmm1_8
  double v212; // xmm1_8
  unsigned int v213; // edx
  unsigned int v214; // eax
  int v215; // esi
  void **v216; // eax
  int v217; // ecx
  unsigned int v218; // esi
  unsigned int v219; // eax
  int v220; // esi
  unsigned int v221; // esi
  unsigned int v222; // eax
  int v223; // esi
  void **v224; // eax
  int v225; // ecx
  unsigned int v226; // esi
  unsigned int v227; // eax
  int v228; // esi
  unsigned int v229; // eax
  int v230; // esi
  void **v231; // eax
  int v232; // ecx
  unsigned int v233; // eax
  int v234; // esi
  unsigned int v235; // edx
  unsigned int v236; // esi
  int v237; // edi
  int v238; // ecx
  signed int v239; // esi
  int v240; // ecx
  __m128i v241; // xmm4
  __m128i v242; // xmm5
  __m128i v243; // xmm6
  __m128i v244; // xmm7
  int v245; // eax
  __m128i v246; // xmm2
  __m128i v247; // xmm3
  __m128i v248; // xmm0
  __m128i v249; // xmm5
  __m128i v250; // xmm5
  __m128i v251; // xmm4
  __m128i v252; // xmm4
  int v253; // edx
  int v254; // edi
  int v255; // esi
  int v256; // eax
  int v257; // eax
  int v258; // esi
  int v259; // edi
  int v260; // esi
  unsigned int v261; // edx
  double v262; // xmm0_8
  int v263; // eax
  void *v264; // ecx
  int v265; // edx
  double v266; // xmm0_8
  float *v267; // esi
  int v268; // edi
  double v269; // xmm4_8
  double v270; // xmm5_8
  double v271; // xmm7_8
  double v272; // xmm3_8
  double v273; // st7
  int v274; // ecx
  int v275; // edi
  double v276; // xmm3_8
  double v277; // st7
  int v278; // ecx
  double v279; // st7
  int v280; // ecx
  _DWORD *v281; // eax
  int v282; // edi
  int v283; // esi
  int v284; // edi
  double v285; // xmm0_8
  double v286; // xmm1_8
  double v287; // xmm2_8
  double v288; // xmm3_8
  double v289; // xmm4_8
  double v290; // xmm0_8
  double v291; // xmm1_8
  unsigned int v292; // [esp+3Ch] [ebp-2D0h]
  int v293; // [esp+40h] [ebp-2CCh]
  int v294; // [esp+44h] [ebp-2C8h]
  int v295; // [esp+48h] [ebp-2C4h]
  int v296; // [esp+4Ch] [ebp-2C0h]
  double v298; // [esp+54h] [ebp-2B8h]
  int v299; // [esp+54h] [ebp-2B8h]
  int v300; // [esp+54h] [ebp-2B8h]
  double v301; // [esp+54h] [ebp-2B8h]
  int v302; // [esp+54h] [ebp-2B8h]
  double v303; // [esp+54h] [ebp-2B8h]
  double v304; // [esp+5Ch] [ebp-2B0h]
  unsigned int v305; // [esp+5Ch] [ebp-2B0h]
  int v306; // [esp+5Ch] [ebp-2B0h]
  double v307; // [esp+5Ch] [ebp-2B0h]
  double v308; // [esp+5Ch] [ebp-2B0h]
  double v309; // [esp+5Ch] [ebp-2B0h]
  double v310; // [esp+5Ch] [ebp-2B0h]
  int *v311; // [esp+68h] [ebp-2A4h]
  int v312; // [esp+6Ch] [ebp-2A0h]
  int v313; // [esp+6Ch] [ebp-2A0h]
  int v314; // [esp+6Ch] [ebp-2A0h]
  int v315; // [esp+6Ch] [ebp-2A0h]
  double v316; // [esp+6Ch] [ebp-2A0h]
  int v317; // [esp+6Ch] [ebp-2A0h]
  _DWORD *v318; // [esp+6Ch] [ebp-2A0h]
  int v319; // [esp+78h] [ebp-294h]
  int v320; // [esp+78h] [ebp-294h]
  void *v321; // [esp+7Ch] [ebp-290h]
  double v322; // [esp+7Ch] [ebp-290h]
  int v323; // [esp+7Ch] [ebp-290h]
  int v324; // [esp+7Ch] [ebp-290h]
  int v325; // [esp+7Ch] [ebp-290h]
  int v326; // [esp+84h] [ebp-288h]
  int v327; // [esp+84h] [ebp-288h]
  int v328; // [esp+84h] [ebp-288h]
  unsigned int v329; // [esp+84h] [ebp-288h]
  int v330; // [esp+84h] [ebp-288h]
  int v331; // [esp+84h] [ebp-288h]
  double v332; // [esp+84h] [ebp-288h]
  double v333; // [esp+84h] [ebp-288h]
  int v334; // [esp+84h] [ebp-288h]
  double v335; // [esp+8Ch] [ebp-280h]
  unsigned int v336; // [esp+8Ch] [ebp-280h]
  double v337; // [esp+8Ch] [ebp-280h]
  double v338; // [esp+8Ch] [ebp-280h]
  int v339; // [esp+8Ch] [ebp-280h]
  int v340; // [esp+98h] [ebp-274h]
  double v341; // [esp+9Ch] [ebp-270h]
  double v342; // [esp+9Ch] [ebp-270h]
  double v343; // [esp+9Ch] [ebp-270h]
  double v344; // [esp+9Ch] [ebp-270h]
  double v345; // [esp+9Ch] [ebp-270h]
  double v346; // [esp+A4h] [ebp-268h]
  double v347; // [esp+A4h] [ebp-268h]
  double v348; // [esp+A4h] [ebp-268h]
  double v349; // [esp+A4h] [ebp-268h]
  double v350; // [esp+A4h] [ebp-268h]
  double v351; // [esp+A4h] [ebp-268h]
  int v352; // [esp+B0h] [ebp-25Ch]
  double v353; // [esp+B4h] [ebp-258h]
  double v354; // [esp+B4h] [ebp-258h]
  double v355; // [esp+B4h] [ebp-258h]
  double v356; // [esp+B4h] [ebp-258h]
  double v357; // [esp+B4h] [ebp-258h]
  double v358; // [esp+B4h] [ebp-258h]
  double v359; // [esp+B4h] [ebp-258h]
  int *v360; // [esp+BCh] [ebp-250h]
  int v361; // [esp+BCh] [ebp-250h]
  int *v362; // [esp+C0h] [ebp-24Ch]
  unsigned int v363; // [esp+C0h] [ebp-24Ch]
  double v364; // [esp+C4h] [ebp-248h]
  double v365; // [esp+CCh] [ebp-240h]
  double v366; // [esp+CCh] [ebp-240h]
  double v367; // [esp+CCh] [ebp-240h]
  double v368; // [esp+CCh] [ebp-240h]
  double v369; // [esp+CCh] [ebp-240h]
  int v370; // [esp+D8h] [ebp-234h]
  double v371; // [esp+DCh] [ebp-230h] BYREF
  double v372; // [esp+E4h] [ebp-228h]
  double v373; // [esp+ECh] [ebp-220h]
  double v374; // [esp+F4h] [ebp-218h]
  int v375; // [esp+100h] [ebp-20Ch]
  double v376; // [esp+104h] [ebp-208h]
  double v377; // [esp+10Ch] [ebp-200h]
  double v378; // [esp+114h] [ebp-1F8h]
  double v379; // [esp+11Ch] [ebp-1F0h]
  double v380; // [esp+124h] [ebp-1E8h] BYREF
  double v381; // [esp+12Ch] [ebp-1E0h]
  double v382; // [esp+134h] [ebp-1D8h]
  double v383; // [esp+13Ch] [ebp-1D0h]
  double v384; // [esp+144h] [ebp-1C8h]
  double v385; // [esp+14Ch] [ebp-1C0h]
  double v386; // [esp+154h] [ebp-1B8h]
  double v387; // [esp+15Ch] [ebp-1B0h]
  double v388; // [esp+164h] [ebp-1A8h]
  double v389; // [esp+16Ch] [ebp-1A0h]
  int v390[2]; // [esp+174h] [ebp-198h] BYREF
  double v391; // [esp+17Ch] [ebp-190h]
  _DWORD *v392; // [esp+188h] [ebp-184h]
  int *v393; // [esp+18Ch] [ebp-180h]
  signed int v394; // [esp+190h] [ebp-17Ch] BYREF
  void *v395[2]; // [esp+194h] [ebp-178h] BYREF
  void *v396; // [esp+19Ch] [ebp-170h]
  void *v397[2]; // [esp+1A0h] [ebp-16Ch] BYREF
  int v398; // [esp+1A8h] [ebp-164h]
  void *v399[2]; // [esp+1ACh] [ebp-160h] BYREF
  int v400; // [esp+1B4h] [ebp-158h]
  void *v401[2]; // [esp+1B8h] [ebp-154h] BYREF
  void *v402; // [esp+1C0h] [ebp-14Ch]
  void *v403[2]; // [esp+1C4h] [ebp-148h] BYREF
  int v404; // [esp+1CCh] [ebp-140h]
  void *v405[2]; // [esp+1D0h] [ebp-13Ch] BYREF
  int v406; // [esp+1D8h] [ebp-134h]
  void *v407[2]; // [esp+1DCh] [ebp-130h] BYREF
  int v408; // [esp+1E4h] [ebp-128h]
  void *v409[2]; // [esp+1E8h] [ebp-124h] BYREF
  int v410; // [esp+1F0h] [ebp-11Ch]
  __m128i v411; // [esp+1F4h] [ebp-118h] BYREF
  double v412; // [esp+204h] [ebp-108h]
  double v413; // [esp+20Ch] [ebp-100h]
  double v414; // [esp+214h] [ebp-F8h]
  __m128i v415; // [esp+21Ch] [ebp-F0h] BYREF
  double v416; // [esp+22Ch] [ebp-E0h]
  double v417; // [esp+234h] [ebp-D8h]
  double v418; // [esp+23Ch] [ebp-D0h]
  char v419[180]; // [esp+244h] [ebp-C8h] BYREF
  int v420; // [esp+308h] [ebp-4h]

  v371 = a4;
  v5 = *(_OWORD *)(a2 + 8);
  v375 = a2;
  sub_406C30(*(_QWORD *)a2, *(double *)&v5, *((double *)&v5 + 1), &v380);
  v6 = (unsigned int *)(this + 48);
  v360 = (int *)(this + 52);
  v362 = (int *)(this + 48);
  if ( *(_DWORD *)(this + 48) < *(_DWORD *)(this + 52) )
    v6 = (unsigned int *)(this + 52);
  v7 = _mm_cvtsi32_si128(*v6);
  v393 = (int *)(this + 108);
  v8 = 3 * *(_DWORD *)(this + 24);
  v389 = _mm_cvtepi32_pd(v7).m128d_f64[0] * *(double *)(v375 + 64);
  sub_4216E0((_DWORD *)(this + 108), *(_DWORD *)(this + 16) + v8);
  v292 = *(_DWORD *)(this + 16);
  v392 = (_DWORD *)(this + 120);
  sub_405750((_DWORD *)(this + 120), v292);
  v9 = (int *)(this + 156);
  v311 = v9;
  sub_417570(*v9, v9[1]);
  *(double *)v7.m128i_i64 = v371;
  v9[1] = *v9;
  sub_405EB0((int)v419, a3, v375 + 24, v7.m128i_i64[0]);
  v370 = 0;
  v319 = 0;
  v312 = -1;
  v395[0] = 0;
  v395[1] = 0;
  v396 = 0;
  v420 = 1;
  v321 = 0;
  v401[0] = 0;
  v401[1] = 0;
  v402 = 0;
  v10 = (_DWORD *)this;
  v11 = 0;
  v394 = 0;
  v12 = *(_DWORD *)(this + 8) <= 0;
  v13 = v388;
  v14 = v382;
  v391 = 0.0;
  if ( !v12 )
  {
    while ( 1 )
    {
      v15 = v10[24];
      v372 = 0.0;
      v352 = *(_DWORD *)(v15 + 4 * v11);
      v16 = *(_DWORD *)(v352 + 12) - *(_DWORD *)(v352 + 8);
      v17 = v16 / 40;
      v340 = v16 / 40;
      if ( v16 / 40 > 0 )
      {
        v18 = v13 * v389;
        v19 = 32 * v370;
        v20 = 0;
        v298 = -v389;
        v21 = -v389 * v13;
        v326 = v16 / 40;
        v22 = v14 * v389;
        v23 = -v389 * v14;
        v304 = v21;
        v341 = -v389 * v385;
        v335 = v18;
        v322 = v23;
        v353 = v14 * v389;
        v379 = v385 * v389;
        do
        {
          v24 = *(_DWORD *)(v352 + 8);
          v365 = *(double *)(v24 + v20 + 16) - *(double *)(this + 40);
          v378 = *(double *)(v24 + v20 + 8) - *(double *)(this + 32);
          v377 = v365 * v381 + v378 * v380 + v23;
          v25 = sub_406A70((int)v419, -10.0, 0.0, -1.0, 1.0e-10, v377, v22, v365 * v387 + v378 * v386 + v21, v18);
          v26 = v378;
          v27 = v365 * v384;
          v21 = v304;
          v18 = v335;
          *(double *)(*(_DWORD *)(v352 + 8) + v20 + 24) = v377 * v25 - v353;
          *(double *)(*(_DWORD *)(v352 + 8) + v20 + 32) = (v27 + v26 * v383 + v341) * v25 - v379;
          v28 = v393;
          v29 = *(double *)(*(_DWORD *)(v352 + 8) + v20 + 32);
          v20 += 40;
          v30 = v29 + v372;
          *(double *)(v19 + *v393) = v26;
          v31 = *v28;
          v372 = v30;
          *(double *)(v31 + v19 + 8) = v365;
          v22 = v353;
          *(double *)(*v28 + v19 + 16) = v298;
          v32 = *v28;
          v33 = v394;
          *(double *)(v32 + v19 + 24) = v25;
          v19 += 32;
          *(_DWORD *)(*v392 + 4 * v370) = v33;
          v34 = v326-- == 1;
          ++v370;
          v23 = v322;
        }
        while ( !v34 );
        v17 = v340;
      }
      sub_417C60(
        *(__m128i **)(v352 + 8),
        (__m128i *)(40 * v17 + *(_DWORD *)(v352 + 8)),
        40 * v17 / 40,
        (unsigned __int8 (__cdecl *)(__int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32, __int32))sub_4172C0);
      v35 = libm_sse2_sqrt_precise(v293, v294, v295, v296).m128_u64[0];
      v36 = v372;
      *(_QWORD *)v352 = v35;
      v37 = v394;
      *(double *)(v375 + 8 * (v394 + *(_DWORD *)(this + 204))) = v36 / *(double *)(this + 56) / (double)v340;
      if ( v312 == *(_DWORD *)(v352 + 20) )
        break;
      v48 = v319;
LABEL_75:
      if ( !v37 )
        goto LABEL_375;
      while ( 1 )
      {
        if ( v48 < 4 )
          goto LABEL_375;
        v80 = 0.0;
        v342 = 1.0e11;
        v81 = 0.0;
        v82 = 0.0;
        v324 = 2;
        v83 = 0.0;
        v379 = 0.0;
        v372 = 0.0;
        v329 = 0;
        v405[0] = 0;
        v405[1] = 0;
        v406 = 0;
        v403[0] = 0;
        v403[1] = 0;
        v404 = 0;
        v84 = 0;
        v85 = (v395[1] - v395[0]) >> 2;
        if ( v85 )
        {
          do
          {
            v86 = *((_DWORD *)v395[0] + v84++);
            v83 = v83 + *(double *)*(_DWORD *)(*(_DWORD *)(this + 96) + 4 * v86);
          }
          while ( v84 < v85 );
        }
        v87 = 0;
        v88 = v83 / ((double)v85 + qword_439340[(unsigned int)(v395[1] - v395[0]) >> 31]);
        if ( v85 )
        {
          v89 = v88 * 0.8;
          v346 = v89;
          do
          {
            if ( v89 > *(double *)*(_DWORD *)(*(_DWORD *)(this + 96) + 4 * *((_DWORD *)v395[0] + v87)) )
            {
              memmove(
                (char *)v395[0] + 4 * v87,
                (char *)v395[0] + 4 * v87 + 4,
                ((char *)v395[1] - ((char *)v395[0] + 4 * v87 + 4)) & 0xFFFFFFFC);
              v395[1] = (char *)v395[1] - 4;
              v89 = v346;
              --v87;
            }
            ++v87;
          }
          while ( v87 < (v395[1] - v395[0]) >> 2 );
          v81 = v379;
          v80 = 0.0;
          v82 = v372;
        }
        v48 = (v395[1] - v395[0]) >> 2;
        v320 = v48;
        if ( v48 >= 4 )
          break;
        if ( v403[0] )
        {
          operator delete(v403[0]);
          v403[0] = 0;
          v403[1] = 0;
          v404 = 0;
        }
        LOBYTE(v420) = 1;
        if ( v405[0] )
        {
          operator delete(v405[0]);
          v405[0] = 0;
          v405[1] = 0;
          v406 = 0;
        }
      }
      v90 = 0.0;
      v377 = 0.0;
      v378 = 0.0;
      v91 = (double)*v360;
      v92 = (double)*v362;
      v93 = (v395[1] - v395[0]) >> 2;
      v305 = v93;
      v347 = v91;
      v366 = v92;
      if ( v93 )
      {
        v94 = 0;
        v95 = *(_DWORD *)(this + 96);
        v299 = v95;
        do
        {
          v96 = *(_DWORD *)(v95 + 4 * *((_DWORD *)v395[0] + v94));
          v313 = v96;
          if ( (*(_DWORD *)(v96 + 12) - *(_DWORD *)(v96 + 8)) / 40 > 0 )
          {
            v97 = *(_DWORD *)(v96 + 8);
            v98 = (double *)(v97 + 8);
            v314 = (*(_DWORD *)(v313 + 12) - *(_DWORD *)(v313 + 8)) / 40;
            v99 = 0;
            v100 = 0;
            do
            {
              v101 = *(double *)(v99 + v97 + 8);
              ++v329;
              v81 = v81 + *(double *)(v99 + v97 + 16);
              v82 = v82 + v101;
              if ( v92 > v101 )
                v92 = *v98;
              if ( v101 > v80 )
                v80 = *(double *)(v99 + v97 + 8);
              v102 = *(double *)(v99 + v97 + 16);
              if ( v91 > v102 )
                v91 = *(double *)(v99 + v97 + 16);
              if ( v102 > v90 )
                v90 = *(double *)(v99 + v97 + 16);
              ++v100;
              v99 += 40;
              v98 += 5;
            }
            while ( v100 < v314 );
            v366 = v92;
            v347 = v91;
            v378 = v80;
            v377 = v90;
          }
          v93 = v305;
          ++v94;
          v95 = v299;
        }
        while ( v94 < v305 );
        v48 = v320;
      }
      v103 = _mm_cvtsi32_si128(v329);
      HIBYTE(v296) = 0;
      v330 = 0;
      *(double *)v103.m128i_i64 = _mm_cvtepi32_pd(v103).m128d_f64[0];
      v379 = v81 / *(double *)v103.m128i_i64;
      v372 = v82 / *(double *)v103.m128i_i64;
      if ( (v93 & 0xFFFFFFF) != 0 )
      {
        while ( 1 )
        {
          v300 = rand() % v48;
          v306 = rand() % v48;
          if ( v300 != v306 )
            break;
LABEL_131:
          if ( ++v330 >= (unsigned int)(16 * ((v395[1] - v395[0]) >> 2)) )
            goto LABEL_135;
        }
        v407[0] = 0;
        v407[1] = 0;
        v408 = 0;
        LOBYTE(v420) = 4;
        v104 = *(_DWORD *)(this + 96);
        v105 = *(_DWORD *)(*(_DWORD *)(v104 + 4 * *((_DWORD *)v395[0] + v300)) + 8);
        v106 = *(double *)(v105 + 8);
        v107 = *(double *)(v105 + 16);
        v108 = 0;
        v109 = *(_DWORD *)(*(_DWORD *)(v104 + 4 * *((_DWORD *)v395[0] + v306)) + 8);
        v110 = v106 - *(double *)(v109 + 8);
        v111 = v107 - *(double *)(v109 + 16);
        v112 = v110 / v111;
        v301 = v110 / v111;
        v113 = v106 - v110 / v111 * v107;
        v307 = v113;
        if ( v110 / v111 <= 1.0 )
        {
          HIBYTE(v296) = 0;
          v115 = 0.0;
          if ( v48 > 0 )
          {
            do
            {
              v119 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 96) + 4 * *((_DWORD *)v395[0] + v108)) + 8);
              v120 = *(double *)(v119 + 16) * v301 + v113 - *(double *)(v119 + 8);
              v121 = v120;
              if ( v120 < 0.0 )
                v121 = -v120;
              v115 = v115 + v121;
              if ( (double)*((int *)v401[0] + 2 * v108 + 1) * 0.5 > v120 * v120 )
              {
                sub_4214D0(v407, (const __m128i *)v119);
                v113 = v307;
              }
              ++v108;
            }
            while ( v108 < v48 );
LABEL_122:
            v112 = v301;
          }
        }
        else
        {
          HIBYTE(v296) = 1;
          v112 = v111 / v110;
          v301 = v111 / v110;
          v114 = v107 - v111 / v110 * v106;
          v115 = 0.0;
          v307 = v114;
          if ( v48 > 0 )
          {
            do
            {
              v116 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 96) + 4 * *((_DWORD *)v395[0] + v108)) + 8);
              v117 = *(double *)(v116 + 8) * v301 + v114 - *(double *)(v116 + 16);
              v118 = v117;
              if ( v117 < 0.0 )
                v118 = -v117;
              v115 = v115 + v118;
              if ( (double)*((int *)v401[0] + 2 * v108 + 1) * 0.5 > v117 * v117 )
              {
                sub_4214D0(v407, (const __m128i *)v116);
                v114 = v307;
              }
              ++v108;
            }
            while ( v108 < v48 );
            goto LABEL_122;
          }
        }
        v122 = v407[0];
        v123 = (v407[1] - v407[0]) / 40;
        if ( v123 >= v324 )
        {
          if ( v324 != v123 )
          {
            v324 = (v407[1] - v407[0]) / 40;
            goto LABEL_127;
          }
          if ( v342 > v115 )
          {
LABEL_127:
            v405[1] = v405[0];
            v342 = v115;
            v374 = v112;
            v364 = v307;
            sub_404AC0((int)v405, (const __m128i **)v407);
            v122 = v407[0];
          }
          if ( (double)v324 > (double)v370 * 0.95 )
          {
            if ( v122 )
            {
              operator delete(v122);
              v407[0] = 0;
              v407[1] = 0;
              v408 = 0;
            }
            goto LABEL_135;
          }
        }
        if ( v122 )
        {
          operator delete(v122);
          v407[0] = 0;
          v407[1] = 0;
          v408 = 0;
        }
        goto LABEL_131;
      }
LABEL_135:
      v354 = 1.0e11;
      v336 = 2;
      v315 = 0;
      if ( (((v395[1] - v395[0]) >> 2) & 0xFFFFFFF) == 0 )
        goto LABEL_168;
      while ( 1 )
      {
        v124 = rand() % v48;
        v302 = rand() % v48;
        if ( v124 != v302 )
          break;
LABEL_164:
        if ( ++v315 >= (unsigned int)(16 * ((v395[1] - v395[0]) >> 2)) )
          goto LABEL_168;
      }
      v409[0] = 0;
      v409[1] = 0;
      v410 = 0;
      LOBYTE(v420) = 5;
      v125 = *(_DWORD *)(this + 96);
      v126 = *(_DWORD *)(v125 + 4 * *((_DWORD *)v395[0] + v124));
      v331 = 5 * ((*(_DWORD *)(v126 + 12) - *(_DWORD *)(v126 + 8)) / 40);
      v325 = *(_DWORD *)(v126 + 8);
      v127 = *(_DWORD *)(v125 + 4 * *((_DWORD *)v395[0] + v302));
      v128 = *(_DWORD *)(v127 + 12) - *(_DWORD *)(v127 + 8);
      v129 = *(_DWORD *)(v127 + 8);
      if ( HIBYTE(v296) )
      {
        v130 = *(double *)(v325 + 8 * v331 - 24);
        v131 = *(double *)(v325 + 8 * v331 - 32);
        v132 = v130 - *(double *)(v129 + 40 * (v128 / 40) - 24);
        v133 = v131 - *(double *)(v129 + 40 * (v128 / 40) - 32);
      }
      else
      {
        v130 = *(double *)(v325 + 8 * v331 - 32);
        v131 = *(double *)(v325 + 8 * v331 - 24);
        v132 = v130 - *(double *)(v129 + 40 * (v128 / 40) - 32);
        v133 = v131 - *(double *)(v129 + 40 * (v128 / 40) - 24);
      }
      v134 = v132 / v133;
      v135 = 0;
      v343 = v134;
      v136 = v130 - v134 * v131;
      v137 = 0.0;
      v308 = v136;
      if ( HIBYTE(v296) )
      {
        if ( v320 <= 0 )
          goto LABEL_155;
        do
        {
          v138 = *(_DWORD *)(*(_DWORD *)(this + 96) + 4 * *((_DWORD *)v395[0] + v135));
          v139 = *(_DWORD *)(v138 + 8);
          v140 = 5 * ((*(_DWORD *)(v138 + 12) - v139) / 40) - 5;
          v141 = *(double *)(v139 + 8 * v140 + 8);
          v142 = v139 + 8 * v140;
          v143 = v141 * v134 + v136 - *(double *)(v142 + 16);
          v144 = v143;
          if ( v143 < 0.0 )
            v144 = -v143;
          v303 = v137 + v144;
          if ( (double)*((int *)v401[0] + 2 * v135 + 1) * 0.5 > v143 * v143 )
          {
            sub_4214D0(v409, (const __m128i *)v142);
            v134 = v343;
            v136 = v308;
          }
          v137 = v137 + v144;
          ++v135;
        }
        while ( v135 < v320 );
      }
      else
      {
        if ( v320 <= 0 )
          goto LABEL_155;
        do
        {
          v145 = *(_DWORD *)(*(_DWORD *)(this + 96) + 4 * *((_DWORD *)v395[0] + v135));
          v146 = *(_DWORD *)(v145 + 8);
          v147 = 5 * ((*(_DWORD *)(v145 + 12) - v146) / 40) - 5;
          v148 = *(double *)(v146 + 8 * v147 + 16);
          v149 = v146 + 8 * v147;
          v150 = v148 * v134 + v136 - *(double *)(v149 + 8);
          v151 = v150;
          if ( v150 < 0.0 )
            v151 = -v150;
          v303 = v137 + v151;
          if ( (double)*((int *)v401[0] + 2 * v135 + 1) * 0.5 > v150 * v150 )
          {
            sub_4214D0(v409, (const __m128i *)v149);
            v134 = v343;
            v136 = v308;
          }
          v137 = v137 + v151;
          ++v135;
        }
        while ( v135 < v320 );
      }
      v137 = v303;
LABEL_155:
      v152 = v409[0];
      v153 = v336;
      v154 = (v409[1] - v409[0]) / 40;
      if ( v154 < v336 )
        goto LABEL_161;
      if ( v336 == v154 )
      {
        if ( v354 <= v137 )
          goto LABEL_160;
      }
      else
      {
        v153 = (v409[1] - v409[0]) / 40;
        v336 = v153;
      }
      v403[1] = v403[0];
      v376 = v136;
      v373 = v134;
      v354 = v137;
      sub_404AC0((int)v403, (const __m128i **)v409);
      v152 = v409[0];
LABEL_160:
      if ( (double)v153 <= (double)v370 * 0.95 )
      {
LABEL_161:
        if ( v152 )
        {
          operator delete(v152);
          v409[0] = 0;
          v409[1] = 0;
          v410 = 0;
        }
        v48 = v320;
        goto LABEL_164;
      }
      if ( v152 )
      {
        operator delete(v152);
        v409[0] = 0;
        v409[1] = 0;
        v410 = 0;
      }
LABEL_168:
      v399[0] = 0;
      v399[1] = 0;
      v400 = 0;
      v397[0] = 0;
      v397[1] = 0;
      v398 = 0;
      LOBYTE(v420) = 7;
      if ( HIBYTE(v296) )
      {
        v155 = v372;
        v156 = (double)*v362;
        v157 = v372 - (v378 - v366);
        if ( v157 <= v156 * 0.1 )
          v157 = v156 * 0.1;
        v158 = v156 * 0.9;
        v159 = v378 - v366 + v372;
        v160 = (int)v157;
        if ( v158 <= v159 )
          v159 = v158;
        v161 = (int)v159;
        v162 = (int)v157;
        if ( v160 < (int)v159 )
        {
          do
          {
            *(double *)&v415.m128i_i64[1] = (double)v162;
            *(double *)&v411.m128i_i64[1] = (double)v162;
            v344 = v373 * (double)v162 + v376;
            v416 = (double)v162 * v374 + v364;
            v412 = v344;
            if ( v162 == v160 || v162 == v161 - 1 )
            {
              v337 = v388 * v389;
              v316 = (double)v162 - *(double *)(this + 32);
              v377 = (double)v162 * v374 + v364 - *(double *)(this + 40);
              v378 = -v389;
              v367 = v382 * v389;
              v348 = v377 * v381 + v316 * v380 + -v389 * v382;
              v355 = sub_406A70(
                       (int)v419,
                       -10.0,
                       0.0,
                       -1.0,
                       1.0e-10,
                       v348,
                       v382 * v389,
                       v377 * v387 + v316 * v386 + -v389 * v388,
                       v388 * v389);
              v163 = v344 - *(double *)(this + 40);
              v332 = v385 * v389;
              v417 = v355 * v348 - v367;
              v418 = (v377 * v384 + v316 * v383 + v378 * v385) * v355 - v385 * v389;
              v309 = (double)v162 - *(double *)(this + 32);
              v349 = v163 * v381 + v309 * v380 + v378 * v382;
              v356 = sub_406A70(
                       (int)v419,
                       -10.0,
                       0.0,
                       -1.0,
                       1.0e-10,
                       v349,
                       v367,
                       v163 * v387 + v309 * v386 + v378 * v388,
                       v337);
              v413 = v356 * v349 - v367;
              v414 = (v163 * v384 + v309 * v383 + v378 * v385) * v356 - v332;
            }
            sub_4214D0(v399, &v415);
            sub_4214D0(v397, &v411);
            v160 = (int)v157;
            v162 += 2;
          }
          while ( v162 < v161 );
          goto LABEL_178;
        }
        v164 = v379;
      }
      else
      {
        v164 = v379;
        v179 = (double)*v360;
        v180 = v379 - (v377 - v347);
        if ( v180 <= v179 * 0.1 )
          v180 = v179 * 0.1;
        v181 = v179 * 0.9;
        v182 = v377 - v347 + v379;
        v183 = (int)v180;
        if ( v181 <= v182 )
          v182 = v181;
        v184 = (int)v182;
        v185 = (int)v180;
        if ( v183 < (int)v182 )
        {
          do
          {
            v412 = (double)v185;
            v416 = (double)v185;
            v310 = v373 * (double)v185 + v376;
            *(double *)&v411.m128i_i64[1] = (double)v185 * v374 + v364;
            *(double *)&v415.m128i_i64[1] = v310;
            if ( v185 == v183 || v185 == v184 - 1 )
            {
              v186 = (double)v185 * v374 + v364 - *(double *)(this + 32);
              v378 = (double)v185 - *(double *)(this + 40);
              v377 = -v389;
              v338 = v388 * v389;
              v350 = v382 * v389;
              v368 = v378 * v381 + v186 * v380 + -v389 * v382;
              v357 = sub_406A70(
                       (int)v419,
                       -10.0,
                       0.0,
                       -1.0,
                       1.0e-10,
                       v368,
                       v382 * v389,
                       v378 * v387 + v186 * v386 + -v389 * v388,
                       v388 * v389);
              v187 = (double)v185 - *(double *)(this + 40);
              v333 = v385 * v389;
              v413 = v357 * v368 - v350;
              v188 = v310 - *(double *)(this + 32);
              v414 = (v378 * v384 + v186 * v383 + v377 * v385) * v357 - v385 * v389;
              v369 = v187 * v381 + v188 * v380 + v377 * v382;
              v358 = sub_406A70(
                       (int)v419,
                       -10.0,
                       0.0,
                       -1.0,
                       1.0e-10,
                       v369,
                       v350,
                       v187 * v387 + v188 * v386 + v377 * v388,
                       v338);
              v417 = v358 * v369 - v350;
              v418 = (v187 * v384 + v188 * v383 + v377 * v385) * v358 - v333;
            }
            sub_4214D0(v399, &v411);
            sub_4214D0(v397, &v415);
            v183 = (int)v180;
            v185 += 2;
          }
          while ( v185 < v184 );
LABEL_178:
          v164 = v379;
        }
        v155 = v372;
      }
      v165 = (v395[1] - v395[0]) >> 2;
      v166 = (v405[1] - v405[0]) / 40;
      if ( v166 <= v165 / 3 || (v403[1] - v403[0]) / 40 <= v165 / 3 )
      {
        v235 = 3 * v165 / 5;
        if ( v235 < 4 )
          v235 = 4;
        if ( v166 > v235 )
          sub_421620(v311, (const __m128i **)v399);
        v236 = 3 * ((v395[1] - v395[0]) >> 2) / 5u;
        if ( v236 < 4 )
          v236 = 4;
        if ( (v403[1] - v403[0]) / 40 > v236 )
          sub_421620(v311, (const __m128i **)v397);
        goto LABEL_367;
      }
      v167 = v374 - v373;
      if ( !HIBYTE(v296) )
      {
        v209 = v374 - v373;
        if ( v167 < 0.0 )
          v209 = -v167;
        if ( v209 > 0.00001 )
        {
          v210 = (v376 - v364) / v167;
          v211 = (double)*v360;
          if ( v164 - v211 <= v210 && v210 <= v211 + v164 )
          {
            v212 = v211 * 0.5;
            if ( v164 - v212 <= v210 && v210 <= v212 + v164 )
              goto LABEL_367;
            v213 = 4 * v165 / 5;
            if ( v213 < 4 )
              v213 = 4;
            v173 = v166 < v213;
            v174 = v311;
            if ( !v173 )
            {
              v214 = v311[1];
              if ( (unsigned int)v399 >= v214 || *v311 > (unsigned int)v399 )
              {
                if ( v214 == v311[2] )
                  sub_4213C0(v311, 1u);
                v217 = v311[1];
                LOBYTE(v420) = 25;
                if ( v217 )
                {
                  v216 = v399;
                  goto LABEL_295;
                }
              }
              else
              {
                v215 = ((int)v399 - *v311) / 12;
                if ( v311[1] == v311[2] )
                  sub_4213C0(v311, 1u);
                v216 = (void **)(*v311 + 12 * v215);
                v217 = v311[1];
                LOBYTE(v420) = 24;
                if ( v217 )
LABEL_295:
                  sub_404A00(v217, (const __m128i **)v216);
              }
              v311[1] += 12;
              LOBYTE(v420) = 7;
            }
            v218 = ((v395[1] - v395[0]) & 0xFFFFFFFC) / 5;
            if ( v218 < 4 )
              v218 = 4;
            if ( (v403[1] - v403[0]) / 40 < v218 )
              goto LABEL_367;
            v219 = v311[1];
            if ( (unsigned int)v397 >= v219 || *v311 > (unsigned int)v397 )
            {
              if ( v219 == v311[2] )
                sub_4213C0(v311, 1u);
              v194 = v311[1];
              LOBYTE(v420) = 27;
              goto LABEL_356;
            }
            v220 = ((int)v397 - *v311) / 12;
            if ( v311[1] == v311[2] )
              sub_4213C0(v311, 1u);
            v192 = (const __m128i **)(*v311 + 12 * v220);
            v193 = v311[1];
            LOBYTE(v420) = 26;
            if ( !v193 )
              goto LABEL_358;
LABEL_352:
            sub_404A00(v193, v192);
            v174[1] += 12;
            goto LABEL_367;
          }
          v221 = v165 >> 1;
          if ( v221 < 4 )
            v221 = 4;
          v173 = v166 < v221;
          v174 = v311;
          if ( !v173 )
          {
            v222 = v311[1];
            if ( (unsigned int)v399 >= v222 || *v311 > (unsigned int)v399 )
            {
              if ( v222 == v311[2] )
                sub_4213C0(v311, 1u);
              v225 = v311[1];
              LOBYTE(v420) = 21;
              if ( v225 )
              {
                v224 = v399;
                goto LABEL_322;
              }
            }
            else
            {
              v223 = ((int)v399 - *v311) / 12;
              if ( v311[1] == v311[2] )
                sub_4213C0(v311, 1u);
              v224 = (void **)(*v311 + 12 * v223);
              v225 = v311[1];
              LOBYTE(v420) = 20;
              if ( v225 )
LABEL_322:
                sub_404A00(v225, (const __m128i **)v224);
            }
            v311[1] += 12;
            LOBYTE(v420) = 7;
          }
          v226 = (unsigned int)((v395[1] - v395[0]) >> 2) >> 1;
          if ( v226 < 4 )
            v226 = 4;
          if ( (v403[1] - v403[0]) / 40 < v226 )
            goto LABEL_367;
          v227 = v311[1];
          if ( (unsigned int)v397 >= v227 || *v311 > (unsigned int)v397 )
          {
            if ( v227 == v311[2] )
              sub_4213C0(v311, 1u);
            v194 = v311[1];
            LOBYTE(v420) = 23;
            goto LABEL_356;
          }
          v228 = ((int)v397 - *v311) / 12;
          if ( v311[1] == v311[2] )
            sub_4213C0(v311, 1u);
          v192 = (const __m128i **)(*v311 + 12 * v228);
          v193 = v311[1];
          LOBYTE(v420) = 22;
          if ( !v193 )
            goto LABEL_358;
          goto LABEL_352;
        }
        v174 = v311;
        v229 = v311[1];
        if ( (unsigned int)v399 >= v229 || *v311 > (unsigned int)v399 )
        {
          if ( v229 == v311[2] )
            sub_4213C0(v311, 1u);
          v232 = v311[1];
          LOBYTE(v420) = 29;
          if ( v232 )
          {
            v231 = v399;
            goto LABEL_346;
          }
        }
        else
        {
          v230 = ((int)v399 - *v311) / 12;
          if ( v311[1] == v311[2] )
            sub_4213C0(v311, 1u);
          v231 = (void **)(*v311 + 12 * v230);
          v232 = v311[1];
          LOBYTE(v420) = 28;
          if ( v232 )
LABEL_346:
            sub_404A00(v232, (const __m128i **)v231);
        }
        v311[1] += 12;
        v233 = v311[1];
        LOBYTE(v420) = 7;
        if ( (unsigned int)v397 >= v233 || *v311 > (unsigned int)v397 )
        {
          if ( v233 == v311[2] )
            sub_4213C0(v311, 1u);
          v194 = v311[1];
          LOBYTE(v420) = 31;
          goto LABEL_356;
        }
        v234 = ((int)v397 - *v311) / 12;
        if ( v311[1] == v311[2] )
          sub_4213C0(v311, 1u);
        v192 = (const __m128i **)(*v311 + 12 * v234);
        v193 = v311[1];
        LOBYTE(v420) = 30;
        if ( !v193 )
          goto LABEL_358;
        goto LABEL_352;
      }
      v168 = v374 - v373;
      if ( v167 < 0.0 )
        v168 = -v167;
      if ( v168 <= 0.00001 )
      {
        v174 = v311;
        v203 = v311[1];
        if ( (unsigned int)v399 >= v203 || *v311 > (unsigned int)v399 )
        {
          if ( v203 == v311[2] )
            sub_4213C0(v311, 1u);
          v206 = v311[1];
          LOBYTE(v420) = 17;
          if ( v206 )
          {
            v205 = v399;
            goto LABEL_265;
          }
        }
        else
        {
          v204 = ((int)v399 - *v311) / 12;
          if ( v311[1] == v311[2] )
            sub_4213C0(v311, 1u);
          v205 = (void **)(*v311 + 12 * v204);
          v206 = v311[1];
          LOBYTE(v420) = 16;
          if ( v206 )
LABEL_265:
            sub_404A00(v206, (const __m128i **)v205);
        }
        v311[1] += 12;
        v207 = v311[1];
        LOBYTE(v420) = 7;
        if ( (unsigned int)v397 >= v207 || *v311 > (unsigned int)v397 )
        {
          if ( v207 == v311[2] )
            sub_4213C0(v311, 1u);
          v194 = v311[1];
          LOBYTE(v420) = 19;
          goto LABEL_356;
        }
        v208 = ((int)v397 - *v311) / 12;
        if ( v311[1] == v311[2] )
          sub_4213C0(v311, 1u);
        v192 = (const __m128i **)(*v311 + 12 * v208);
        v193 = v311[1];
        LOBYTE(v420) = 18;
        if ( !v193 )
          goto LABEL_358;
        goto LABEL_352;
      }
      v169 = (v376 - v364) / v167;
      v170 = (double)*v362;
      if ( v155 - v170 > v169 || v169 > v170 + v155 )
      {
        v195 = v165 >> 1;
        if ( v195 < 4 )
          v195 = 4;
        v173 = v166 < v195;
        v174 = v311;
        if ( !v173 )
        {
          v196 = v311[1];
          if ( (unsigned int)v399 >= v196 || *v311 > (unsigned int)v399 )
          {
            if ( v196 == v311[2] )
              sub_4213C0(v311, 1u);
            v199 = v311[1];
            LOBYTE(v420) = 9;
            if ( v199 )
            {
              v198 = v399;
              goto LABEL_241;
            }
          }
          else
          {
            v197 = ((int)v399 - *v311) / 12;
            if ( v311[1] == v311[2] )
              sub_4213C0(v311, 1u);
            v198 = (void **)(*v311 + 12 * v197);
            v199 = v311[1];
            LOBYTE(v420) = 8;
            if ( v199 )
LABEL_241:
              sub_404A00(v199, (const __m128i **)v198);
          }
          v311[1] += 12;
          LOBYTE(v420) = 7;
        }
        v200 = (unsigned int)((v395[1] - v395[0]) >> 2) >> 1;
        if ( v200 < 4 )
          v200 = 4;
        if ( (v403[1] - v403[0]) / 40 < v200 )
          goto LABEL_367;
        v201 = v311[1];
        if ( (unsigned int)v397 >= v201 || *v311 > (unsigned int)v397 )
        {
          if ( v201 == v311[2] )
            sub_4213C0(v311, 1u);
          v194 = v311[1];
          LOBYTE(v420) = 11;
          goto LABEL_356;
        }
        v202 = ((int)v397 - *v311) / 12;
        if ( v311[1] == v311[2] )
          sub_4213C0(v311, 1u);
        v192 = (const __m128i **)(*v311 + 12 * v202);
        v193 = v311[1];
        LOBYTE(v420) = 10;
        if ( !v193 )
          goto LABEL_358;
        goto LABEL_352;
      }
      v171 = v170 * 0.5;
      if ( v155 - v171 <= v169 && v169 <= v171 + v155 )
        goto LABEL_367;
      v172 = 4 * v165 / 5;
      if ( v172 < 4 )
        v172 = 4;
      v173 = v166 < v172;
      v174 = v311;
      if ( !v173 )
      {
        v175 = v311[1];
        if ( (unsigned int)v399 >= v175 || *v311 > (unsigned int)v399 )
        {
          if ( v175 == v311[2] )
            sub_4213C0(v311, 1u);
          v178 = v311[1];
          LOBYTE(v420) = 13;
          if ( v178 )
          {
            v177 = v399;
            goto LABEL_214;
          }
        }
        else
        {
          v176 = ((int)v399 - *v311) / 12;
          if ( v311[1] == v311[2] )
            sub_4213C0(v311, 1u);
          v177 = (void **)(*v311 + 12 * v176);
          v178 = v311[1];
          LOBYTE(v420) = 12;
          if ( v178 )
LABEL_214:
            sub_404A00(v178, (const __m128i **)v177);
        }
        v311[1] += 12;
        LOBYTE(v420) = 7;
      }
      v189 = ((v395[1] - v395[0]) & 0xFFFFFFFC) / 5;
      if ( v189 < 4 )
        v189 = 4;
      if ( (v403[1] - v403[0]) / 40 < v189 )
        goto LABEL_367;
      v190 = v311[1];
      if ( (unsigned int)v397 >= v190 || *v311 > (unsigned int)v397 )
      {
        if ( v190 == v311[2] )
          sub_4213C0(v311, 1u);
        v194 = v311[1];
        LOBYTE(v420) = 15;
LABEL_356:
        if ( v194 )
          sub_404A00(v194, (const __m128i **)v397);
        goto LABEL_358;
      }
      v191 = ((int)v397 - *v311) / 12;
      if ( v311[1] == v311[2] )
        sub_4213C0(v311, 1u);
      v192 = (const __m128i **)(*v311 + 12 * v191);
      v193 = v311[1];
      LOBYTE(v420) = 14;
      if ( v193 )
        goto LABEL_352;
LABEL_358:
      v174[1] += 12;
LABEL_367:
      LOBYTE(v420) = 6;
      if ( v397[0] )
      {
        std::_Container_base0::_Orphan_all((std::_Container_base0 *)v397);
        operator delete(v397[0]);
        v397[0] = 0;
        v397[1] = 0;
        v398 = 0;
      }
      LOBYTE(v420) = 3;
      if ( v399[0] )
      {
        std::_Container_base0::_Orphan_all((std::_Container_base0 *)v399);
        operator delete(v399[0]);
        v399[0] = 0;
        v399[1] = 0;
        v400 = 0;
      }
      LOBYTE(v420) = 2;
      if ( v403[0] )
      {
        std::_Container_base0::_Orphan_all((std::_Container_base0 *)v403);
        operator delete(v403[0]);
        v403[0] = 0;
        v403[1] = 0;
        v404 = 0;
      }
      LOBYTE(v420) = 1;
      if ( v405[0] )
      {
        std::_Container_base0::_Orphan_all((std::_Container_base0 *)v405);
        operator delete(v405[0]);
        v405[0] = 0;
        v405[1] = 0;
        v406 = 0;
      }
LABEL_375:
      v312 = *(_DWORD *)(v352 + 20);
      std::_Container_base0::_Orphan_all((std::_Container_base0 *)v401);
      v401[1] = v401[0];
      std::_Container_base0::_Orphan_all((std::_Container_base0 *)v395);
      v395[1] = v395[0];
      sub_421460(v395, (unsigned int *)&v394);
      v237 = v340;
      v238 = 0;
      v319 = 1;
      v239 = 0;
      v334 = 0;
      if ( v340 <= 0 )
      {
        v255 = 0;
      }
      else
      {
        if ( (unsigned int)v340 >= 8 && dword_5019B4 >= 2 )
        {
          v240 = *(_DWORD *)(v352 + 8);
          v241 = 0i64;
          v242 = 0i64;
          v243 = 0i64;
          v244 = 0i64;
          v245 = 80;
          do
          {
            v246 = _mm_cvtsi32_si128(*(_DWORD *)(v240 + v245 + 40));
            v245 += 320;
            v239 += 8;
            v247 = _mm_unpacklo_epi32(
                     _mm_unpacklo_epi32(
                       _mm_cvtsi32_si128(*(_DWORD *)(v240 + v245 - 400)),
                       _mm_cvtsi32_si128(*(_DWORD *)(v240 + v245 - 320))),
                     _mm_unpacklo_epi32(_mm_cvtsi32_si128(*(_DWORD *)(v240 + v245 - 360)), v246));
            v242 = _mm_add_epi32(v242, v247);
            v241 = _mm_max_epi32(v241, v247);
            v248 = _mm_unpacklo_epi32(
                     _mm_unpacklo_epi32(
                       _mm_cvtsi32_si128(*(_DWORD *)(v240 + v245 - 240)),
                       _mm_cvtsi32_si128(*(_DWORD *)(v240 + v245 - 160))),
                     _mm_unpacklo_epi32(
                       _mm_cvtsi32_si128(*(_DWORD *)(v240 + v245 - 200)),
                       _mm_cvtsi32_si128(*(_DWORD *)(v240 + v245 - 120))));
            v244 = _mm_add_epi32(v244, v248);
            v243 = _mm_max_epi32(v243, v248);
          }
          while ( v239 < (int)(v340 - (v340 & 0x80000007)) );
          v249 = _mm_add_epi32(v242, v244);
          v250 = _mm_add_epi32(v249, _mm_srli_si128(v249, 8));
          v251 = _mm_max_epi32(v241, v243);
          v334 = _mm_cvtsi128_si32(_mm_add_epi32(v250, _mm_srli_si128(v250, 4)));
          v252 = _mm_max_epi32(v251, _mm_srli_si128(v251, 8));
          v238 = _mm_cvtsi128_si32(_mm_max_epi32(v252, _mm_srli_si128(v252, 4)));
        }
        if ( v239 >= v340 )
        {
          v255 = v334;
        }
        else
        {
          v253 = 40 * v239;
          v254 = v340 - v239;
          v255 = v334;
          v256 = *(_DWORD *)(v352 + 8);
          do
          {
            v257 = *(_DWORD *)(v253 + v256);
            v253 += 40;
            v255 += v257;
            if ( v238 < v257 )
              v238 = v257;
            v256 = *(_DWORD *)(v352 + 8);
            --v254;
          }
          while ( v254 );
          v237 = v340;
        }
      }
      LODWORD(v371) = v238;
      HIDWORD(v371) = (v255 + v237 / 2) / v237;
      sub_4056D0((unsigned int *)v401, &v371);
      v37 = v394;
      v10 = (_DWORD *)this;
      v321 = v401[0];
LABEL_390:
      v11 = v37 + 1;
      v14 = v382;
      v13 = v388;
      v394 = v11;
      if ( v11 >= v10[2] )
      {
        v9 = v311;
        goto LABEL_392;
      }
    }
    if ( &v394 >= v395[1] || v395[0] > &v394 )
    {
      if ( v395[1] == v396 && !((signed int)((int)v396 - (unsigned int)v395[1]) >> 2) )
      {
        v44 = (v395[1] - v395[0]) >> 2;
        if ( v44 == 0x3FFFFFFF )
          goto LABEL_396;
        v45 = (signed int)((int)v396 - (unsigned int)v395[0]) >> 2;
        if ( 0x3FFFFFFF - (v45 >> 1) >= v45 )
          v46 = (v45 >> 1) + v45;
        else
          v46 = 0;
        if ( v46 < v44 + 1 )
          v46 = v44 + 1;
        sub_405400((int)v395, v46);
      }
      v42 = (unsigned int *)v395[1];
      if ( v395[1] )
      {
        v43 = v394;
        goto LABEL_33;
      }
    }
    else
    {
      v38 = ((char *)&v394 - (char *)v395[0]) >> 2;
      if ( v395[1] == v396 && !((signed int)((int)v396 - (unsigned int)v395[1]) >> 2) )
      {
        v39 = (v395[1] - v395[0]) >> 2;
        if ( v39 == 0x3FFFFFFF )
          goto LABEL_396;
        v40 = (signed int)((int)v396 - (unsigned int)v395[0]) >> 2;
        if ( 0x3FFFFFFF - (v40 >> 1) >= v40 )
          v41 = (v40 >> 1) + v40;
        else
          v41 = 0;
        if ( v41 < v39 + 1 )
          v41 = v39 + 1;
        sub_405400((int)v395, v41);
      }
      v42 = (unsigned int *)v395[1];
      if ( v395[1] )
      {
        v43 = *((_DWORD *)v395[0] + v38);
LABEL_33:
        *v42 = v43;
      }
    }
    v47 = 0;
    v395[1] = (char *)v395[1] + 4;
    v48 = v319 + 1;
    v49 = v340;
    v50 = 0;
    v51 = 0;
    ++v319;
    v323 = 0;
    if ( v340 > 0 )
    {
      if ( (unsigned int)v340 >= 8 && dword_5019B4 >= 2 )
      {
        v52 = *(_DWORD *)(v352 + 8);
        v53 = 0i64;
        v54 = 0i64;
        v55 = 0i64;
        v56 = 0i64;
        v57 = 80;
        do
        {
          v58 = _mm_cvtsi32_si128(*(_DWORD *)(v52 + v57 + 40));
          v57 += 320;
          v51 += 8;
          v59 = _mm_unpacklo_epi32(
                  _mm_unpacklo_epi32(
                    _mm_cvtsi32_si128(*(_DWORD *)(v52 + v57 - 400)),
                    _mm_cvtsi32_si128(*(_DWORD *)(v52 + v57 - 320))),
                  _mm_unpacklo_epi32(_mm_cvtsi32_si128(*(_DWORD *)(v52 + v57 - 360)), v58));
          v54 = _mm_add_epi32(v54, v59);
          v53 = _mm_max_epi32(v53, v59);
          v60 = _mm_unpacklo_epi32(
                  _mm_unpacklo_epi32(
                    _mm_cvtsi32_si128(*(_DWORD *)(v52 + v57 - 240)),
                    _mm_cvtsi32_si128(*(_DWORD *)(v52 + v57 - 160))),
                  _mm_unpacklo_epi32(
                    _mm_cvtsi32_si128(*(_DWORD *)(v52 + v57 - 200)),
                    _mm_cvtsi32_si128(*(_DWORD *)(v52 + v57 - 120))));
          v56 = _mm_add_epi32(v56, v60);
          v55 = _mm_max_epi32(v55, v60);
        }
        while ( v51 < (int)(v340 - (v340 & 0x80000007)) );
        v49 = v340;
        v61 = _mm_add_epi32(v54, v56);
        v62 = _mm_add_epi32(v61, _mm_srli_si128(v61, 8));
        v63 = _mm_max_epi32(v53, v55);
        v47 = _mm_cvtsi128_si32(_mm_add_epi32(v62, _mm_srli_si128(v62, 4)));
        v64 = _mm_max_epi32(v63, _mm_srli_si128(v63, 8));
        v323 = v47;
        v50 = _mm_cvtsi128_si32(_mm_max_epi32(v64, _mm_srli_si128(v64, 4)));
      }
      if ( v51 < v49 )
      {
        v65 = 40 * v51;
        v66 = v340 - v51;
        v67 = v323;
        v68 = *(_DWORD *)(v352 + 8);
        do
        {
          v69 = *(_DWORD *)(v68 + v65);
          v65 += 40;
          v67 += v69;
          if ( v50 < v69 )
            v50 = v69;
          v68 = *(_DWORD *)(v352 + 8);
          --v66;
        }
        while ( v66 );
        v48 = v319;
        v47 = v67;
        v49 = v340;
      }
    }
    v390[0] = v50;
    v70 = v47 + v49 / 2;
    v71 = (int *)v401[1];
    v327 = v70 / v340;
    v390[1] = v70 / v340;
    v321 = v401[0];
    if ( v390 >= v401[1] || v401[0] > v390 )
    {
      if ( v401[1] == v402 && !((signed int)((int)v402 - (unsigned int)v401[1]) >> 3) )
      {
        v77 = (v401[1] - v401[0]) >> 3;
        if ( v77 == 0x1FFFFFFF )
LABEL_396:
          std::_Xlength_error("vector<T> too long");
        v78 = (signed int)((int)v402 - (unsigned int)v401[0]) >> 3;
        if ( 0x1FFFFFFF - (v78 >> 1) >= v78 )
          v79 = (v78 >> 1) + v78;
        else
          v79 = 0;
        if ( v79 < v77 + 1 )
          v79 = v77 + 1;
        sub_405480((_DWORD **)v401, v79);
        v71 = (int *)v401[1];
        v321 = v401[0];
      }
      if ( !v71 )
        goto LABEL_72;
      *v71 = v50;
      v71[1] = v327;
      v321 = v401[0];
    }
    else
    {
      v72 = v401[0];
      v73 = ((char *)v390 - (char *)v401[0]) >> 3;
      v328 = v73;
      if ( v401[1] == v402 )
      {
        if ( !((signed int)((int)v402 - (unsigned int)v401[1]) >> 3) )
        {
          v74 = (v401[1] - v401[0]) >> 3;
          if ( v74 == 0x1FFFFFFF )
            goto LABEL_396;
          v75 = (signed int)((int)v402 - (unsigned int)v401[0]) >> 3;
          if ( 0x1FFFFFFF - (v75 >> 1) >= v75 )
            v76 = (v75 >> 1) + v75;
          else
            v76 = 0;
          if ( v76 < v74 + 1 )
            v76 = v74 + 1;
          sub_405480((_DWORD **)v401, v76);
          v72 = v401[0];
          v71 = (int *)v401[1];
          v321 = v401[0];
        }
        v73 = v328;
      }
      if ( !v71 )
        goto LABEL_72;
      *v71 = v72[2 * v73];
      v71[1] = v72[2 * v328 + 1];
      v321 = v401[0];
    }
    v71 = (int *)v401[1];
LABEL_72:
    v10 = (_DWORD *)this;
    v401[1] = v71 + 2;
    v37 = v394;
    if ( v394 != *(_DWORD *)(this + 8) - 1 )
      goto LABEL_390;
    goto LABEL_75;
  }
LABEL_392:
  v10[5] = 0;
  v363 = 0;
  if ( (v9[1] - *v9) / 12 )
  {
    v258 = 0;
    v361 = 0;
    do
    {
      v259 = *v9;
      *(_DWORD *)(this + 20) += (*(_DWORD *)(v258 + v259 + 4) - *(_DWORD *)(v258 + v259)) / 40;
      v260 = *(_DWORD *)(v258 + v259);
      v261 = (int)((unsigned __int64)(1717986919i64 * (*(_DWORD *)(v361 + v259 + 4) - *(_DWORD *)(v361 + v259))) >> 32) >> 4;
      v9 = v311;
      v262 = *(double *)(v260 + 40 * (v261 + (v261 >> 31)) - 16) + *(double *)(v260 + 24);
      v263 = *(_DWORD *)(this + 204) + v363 + *(_DWORD *)(this + 8);
      ++v363;
      v258 = v361 + 12;
      v361 += 12;
      *(double *)(v375 + 8 * v263) = v262 * 0.5 / *(double *)(this + 56);
    }
    while ( v363 < (v9[1] - *v9) / 12 );
    v264 = v401[0];
    v321 = v401[0];
  }
  else
  {
    v264 = v321;
  }
  v265 = this;
  v266 = 10.0;
  if ( (double)*(int *)(this + 16) / (double)(*(_DWORD *)(this + 20) + *(_DWORD *)(this + 8)) * 0.25 <= 10.0 )
    v266 = (double)*(int *)(this + 16) / (double)(*(_DWORD *)(this + 20) + *(_DWORD *)(this + 8)) * 0.25;
  v267 = *(float **)(this + 192);
  v268 = 0;
  *(double *)(this + 64) = v266;
  v317 = 0;
  if ( *(int *)(this + 24) > 0 )
  {
    v345 = -v389;
    v269 = -v389 * v14;
    v270 = -v389 * v13;
    v271 = v13 * v389;
    v376 = v269;
    v359 = v14 * v389;
    v373 = v270;
    v374 = v271;
    do
    {
      v272 = v267[1] - *(double *)(v265 + 40);
      v371 = *v267 - *(double *)(v265 + 32);
      v273 = sub_406A70(
               (int)v419,
               -10.0,
               0.0,
               -1.0,
               1.0e-10,
               v272 * v381 + v371 * v380 + v269,
               v359,
               v272 * v387 + v371 * v386 + v270,
               v271);
      *(double *)(32 * (v268 + *(_DWORD *)(this + 16)) + *(_DWORD *)(this + 108)) = v371;
      *(double *)(32 * (v268 + *(_DWORD *)(this + 16)) + *(_DWORD *)(this + 108) + 8) = v272;
      *(double *)(32 * (v268 + *(_DWORD *)(this + 16)) + *(_DWORD *)(this + 108) + 16) = v345;
      v274 = v268 + *(_DWORD *)(this + 16);
      v275 = v268 + 1;
      *(double *)(32 * v274 + *(_DWORD *)(this + 108) + 24) = v273;
      v276 = v267[5] - *(double *)(this + 40);
      v371 = v267[4] - *(double *)(this + 32);
      v277 = sub_406A70(
               (int)v419,
               -10.0,
               0.0,
               -1.0,
               1.0e-10,
               v276 * v381 + v371 * v380 + v376,
               v359,
               v276 * v387 + v371 * v386 + v373,
               v374);
      *(double *)(32 * (v275 + *(_DWORD *)(this + 16)) + *(_DWORD *)(this + 108)) = v371;
      *(double *)(32 * (v275 + *(_DWORD *)(this + 16)) + *(_DWORD *)(this + 108) + 8) = v276;
      *(double *)(32 * (v275 + *(_DWORD *)(this + 16)) + *(_DWORD *)(this + 108) + 16) = v345;
      v278 = v275 + *(_DWORD *)(this + 16);
      ++v275;
      *(double *)(32 * v278 + *(_DWORD *)(this + 108) + 24) = v277;
      v351 = v267[5] - *(double *)(this + 40);
      v371 = v267[4] - *(double *)(this + 32);
      v279 = sub_406A70(
               (int)v419,
               -10.0,
               0.0,
               -1.0,
               1.0e-10,
               v351 * v381 + v371 * v380 + v376,
               v359,
               v351 * v387 + v371 * v386 + v373,
               v374);
      v265 = this;
      v267 += 10;
      *(double *)(32 * (v275 + *(_DWORD *)(this + 16)) + *(_DWORD *)(this + 108)) = v371;
      v269 = v376;
      v270 = v373;
      v271 = v374;
      *(double *)(32 * (v275 + *(_DWORD *)(this + 16)) + *(_DWORD *)(this + 108) + 8) = v351;
      *(double *)(32 * (v275 + *(_DWORD *)(this + 16)) + *(_DWORD *)(this + 108) + 16) = v345;
      v280 = v275 + *(_DWORD *)(this + 16);
      v268 = v275 + 1;
      *(double *)(32 * v280 + *(_DWORD *)(this + 108) + 24) = v279;
      ++v317;
    }
    while ( v317 < *(_DWORD *)(this + 24) );
    v264 = v401[0];
    v321 = v401[0];
  }
  v339 = *(_DWORD *)(v265 + 8);
  if ( v339 > 0 )
  {
    v281 = *(_DWORD **)(v265 + 96);
    v318 = v281;
    do
    {
      v282 = *v281;
      v283 = (*(_DWORD *)(v282 + 12) - *(_DWORD *)(v282 + 8)) / 40;
      if ( v283 > 0 )
      {
        v284 = *(_DWORD *)(v282 + 8);
        do
        {
          v285 = *(double *)libm_sse2_sqrt_precise(v293, v294, v295, v296).m128_u64;
          v284 += 40;
          v391 = v285 + v391;
          --v283;
        }
        while ( v283 );
      }
      v281 = v318 + 1;
      v34 = v339-- == 1;
      ++v318;
    }
    while ( !v34 );
    v264 = v321;
    v265 = this;
  }
  v286 = (double)*(int *)(v265 + 16);
  v287 = 50.0;
  v288 = v286 / (double)*(int *)(v265 + 24);
  v289 = v391 / v286;
  if ( v288 < 50.0 )
    v288 = 50.0;
  v290 = (double)*(int *)(v265 + 28);
  *(double *)(v265 + 80) = v288;
  v291 = v286 / v290;
  if ( v291 >= 50.0 )
    v287 = v291;
  LOBYTE(v420) = 0;
  *(_QWORD *)(v265 + 88) = 0x4059000000000000i64;
  *(double *)(v265 + 72) = v289 * v287;
  if ( v264 )
  {
    std::_Container_base0::_Orphan_all((std::_Container_base0 *)v401);
    operator delete(v401[0]);
    v401[0] = 0;
    v401[1] = 0;
    v402 = 0;
  }
  v420 = -1;
  if ( v395[0] )
  {
    std::_Container_base0::_Orphan_all((std::_Container_base0 *)v395);
    operator delete(v395[0]);
  }
}
// 41E156: conditional instruction was optimized away because %var_274.4>=8
// 42055A: conditional instruction was optimized away because %var_274.4>=8
// 41DF97: variable 'v293' is possibly undefined
// 41DF97: variable 'v294' is possibly undefined
// 41DF97: variable 'v295' is possibly undefined
// 41DF97: variable 'v296' is possibly undefined
// 41F142: variable 'v364' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);
// 439028: using guessed type void __thiscall std::_Container_base0::_Orphan_all(std::_Container_base0 *__hidden this);
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);
// 439340: using guessed type double qword_439340[2];
// 5019B4: using guessed type int dword_5019B4;

//----- (00420E20) --------------------------------------------------------
__int8 *__thiscall sub_420E20(int this, unsigned int a2)
{
  __m128i *v3; // esi
  __m128i *v4; // eax
  void *v5; // ecx
  __int8 *result; // eax
  int v7; // [esp+0h] [ebp-28h] BYREF
  void *v8; // [esp+14h] [ebp-14h]
  int *v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+24h] [ebp-4h]

  v9 = &v7;
  v3 = 0;
  v8 = 0;
  if ( a2 )
  {
    if ( a2 > 0x6666666 || (v3 = (__m128i *)operator new(40 * a2), (v8 = v3) == 0) )
      std::_Xbad_alloc();
  }
  v10 = 0;
  sub_404940(*(const __m128i **)this, *(const __m128i **)(this + 4), v3);
  v4 = *(__m128i **)this;
  v5 = (void *)((*(_DWORD *)(this + 4) - *(_DWORD *)this) / 40);
  v8 = v5;
  if ( v4 )
  {
    operator delete(v4);
    v5 = v8;
  }
  *(_DWORD *)this = v3;
  *(_DWORD *)(this + 8) = (char *)v3 + 40 * a2;
  result = &v3->m128i_i8[40 * (_DWORD)v5];
  *(_DWORD *)(this + 4) = result;
  return result;
}
// 43903C: using guessed type void __cdecl std::_Xbad_alloc();

//----- (00420F10) --------------------------------------------------------
__m128i **__thiscall sub_420F10(const __m128i **this, unsigned int a2)
{
  __m128i *v3; // edi
  __m128i *v4; // eax
  int v5; // ebx
  __m128i **result; // eax
  int v7; // [esp+0h] [ebp-2Ch] BYREF
  const __m128i **v8; // [esp+10h] [ebp-1Ch]
  void *v9; // [esp+14h] [ebp-18h]
  int *v10; // [esp+1Ch] [ebp-10h]
  int v11; // [esp+28h] [ebp-4h]

  v10 = &v7;
  v8 = this;
  v3 = 0;
  v9 = 0;
  if ( a2 )
  {
    if ( a2 > 0x7FFFFFF || (v3 = (__m128i *)operator new(32 * a2), (v9 = v3) == 0) )
      std::_Xbad_alloc();
  }
  v11 = 0;
  sub_4183F0(*this, this[1], v3);
  v4 = (__m128i *)*this;
  v5 = (char *)this[1] - (char *)*this;
  if ( v4 )
    operator delete(v4);
  result = (__m128i **)v8;
  v8[2] = &v3[2 * a2];
  result[1] = (__m128i *)((char *)v3 + (v5 & 0xFFFFFFE0));
  *result = v3;
  return result;
}
// 43903C: using guessed type void __cdecl std::_Xbad_alloc();

//----- (00420FF0) --------------------------------------------------------
__int8 *__thiscall sub_420FF0(int this, unsigned int a2)
{
  __m128i *v3; // esi
  __m128i *v4; // eax
  void *v5; // ecx
  __int8 *result; // eax
  int v7; // [esp+0h] [ebp-28h] BYREF
  void *v8; // [esp+14h] [ebp-14h]
  int *v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+24h] [ebp-4h]

  v9 = &v7;
  v3 = 0;
  v8 = 0;
  if ( a2 )
  {
    if ( a2 > 0xAAAAAAA || (v3 = (__m128i *)operator new(24 * a2), (v8 = v3) == 0) )
      std::_Xbad_alloc();
  }
  v10 = 0;
  sub_418430(*(const __m128i **)this, *(const __m128i **)(this + 4), v3);
  v4 = *(__m128i **)this;
  v5 = (void *)((*(_DWORD *)(this + 4) - *(_DWORD *)this) / 24);
  v8 = v5;
  if ( v4 )
  {
    operator delete(v4);
    v5 = v8;
  }
  *(_DWORD *)this = v3;
  *(_DWORD *)(this + 8) = (char *)v3 + 24 * a2;
  result = &v3->m128i_i8[24 * (_DWORD)v5];
  *(_DWORD *)(this + 4) = result;
  return result;
}
// 43903C: using guessed type void __cdecl std::_Xbad_alloc();

//----- (004210E0) --------------------------------------------------------
char *__thiscall sub_4210E0(int *this, unsigned int a2)
{
  char *v3; // esi
  int v4; // eax
  void *v5; // ecx
  char *result; // eax
  int v7; // [esp+0h] [ebp-28h] BYREF
  void *v8; // [esp+10h] [ebp-18h]
  int *v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+24h] [ebp-4h]

  v9 = &v7;
  v3 = 0;
  v8 = 0;
  if ( a2 )
  {
    if ( a2 > 0x15555555 || (v3 = (char *)operator new(12 * a2), (v8 = v3) == 0) )
      std::_Xbad_alloc();
  }
  v10 = 0;
  sub_418470((_DWORD *)*this, (_DWORD *)this[1], v3);
  v4 = *this;
  v5 = (void *)((this[1] - *this) / 12);
  v8 = v5;
  if ( v4 )
  {
    sub_417570(v4, this[1]);
    operator delete((void *)*this);
    v5 = v8;
  }
  *this = (int)v3;
  this[2] = (int)&v3[12 * a2];
  result = &v3[12 * (_DWORD)v5];
  this[1] = (int)result;
  return result;
}
// 43903C: using guessed type void __cdecl std::_Xbad_alloc();

//----- (004211E0) --------------------------------------------------------
unsigned int __thiscall sub_4211E0(_DWORD *this, unsigned int a2)
{
  int v2; // esi
  unsigned int result; // eax
  int v4; // esi
  int v5; // ebx
  unsigned int v6; // esi
  unsigned int v7; // edx
  unsigned int v8; // eax

  v2 = this[1];
  result = (this[2] - v2) / 40;
  if ( result < a2 )
  {
    v4 = (v2 - *this) / 40;
    if ( 107374182 - v4 < a2 )
      std::_Xlength_error("vector<T> too long");
    v5 = this[2] - *this;
    v6 = a2 + v4;
    v7 = (unsigned int)(v5 / 40) >> 1;
    if ( 107374182 - v7 >= v5 / 40 )
    {
      v8 = v7 + v5 / 40;
      if ( v8 < v6 )
        v8 = v6;
    }
    else
    {
      v8 = 0;
      if ( v6 )
        v8 = v6;
    }
    return (unsigned int)sub_420E20((int)this, v8);
  }
  return result;
}
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (00421290) --------------------------------------------------------
unsigned int __thiscall sub_421290(int this, unsigned int a2)
{
  int v2; // esi
  unsigned int result; // eax
  int v4; // esi
  unsigned int v5; // esi
  unsigned int v6; // edx
  unsigned int v7; // edx

  v2 = *(_DWORD *)(this + 4);
  result = (*(_DWORD *)(this + 8) - v2) >> 5;
  if ( result < a2 )
  {
    v4 = (v2 - *(_DWORD *)this) >> 5;
    if ( 0x7FFFFFF - v4 < a2 )
      std::_Xlength_error("vector<T> too long");
    v5 = a2 + v4;
    v6 = (*(_DWORD *)(this + 8) - *(_DWORD *)this) >> 5;
    if ( 0x7FFFFFF - (v6 >> 1) >= v6 )
    {
      v7 = (v6 >> 1) + v6;
      if ( v7 < v5 )
        v7 = v5;
    }
    else
    {
      v7 = 0;
      if ( v5 )
        v7 = v5;
    }
    return (unsigned int)sub_420F10((const __m128i **)this, v7);
  }
  return result;
}
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (00421310) --------------------------------------------------------
unsigned int __thiscall sub_421310(_DWORD *this, unsigned int a2)
{
  int v2; // esi
  unsigned int result; // eax
  int v4; // esi
  int v5; // ebx
  unsigned int v6; // esi
  unsigned int v7; // edx
  unsigned int v8; // eax

  v2 = this[1];
  result = (this[2] - v2) / 24;
  if ( result < a2 )
  {
    v4 = (v2 - *this) / 24;
    if ( 178956970 - v4 < a2 )
      std::_Xlength_error("vector<T> too long");
    v5 = this[2] - *this;
    v6 = a2 + v4;
    v7 = (unsigned int)(v5 / 24) >> 1;
    if ( 178956970 - v7 >= v5 / 24 )
    {
      v8 = v7 + v5 / 24;
      if ( v8 < v6 )
        v8 = v6;
    }
    else
    {
      v8 = 0;
      if ( v6 )
        v8 = v6;
    }
    return (unsigned int)sub_420FF0((int)this, v8);
  }
  return result;
}
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (004213C0) --------------------------------------------------------
unsigned int __thiscall sub_4213C0(int *this, unsigned int a2)
{
  int v2; // esi
  unsigned int result; // eax
  int v4; // esi
  int v5; // ebx
  unsigned int v6; // esi
  unsigned int v7; // edx
  unsigned int v8; // eax

  v2 = this[1];
  result = (this[2] - v2) / 12;
  if ( result < a2 )
  {
    v4 = (v2 - *this) / 12;
    if ( 357913941 - v4 < a2 )
      std::_Xlength_error("vector<T> too long");
    v5 = this[2] - *this;
    v6 = a2 + v4;
    v7 = (unsigned int)(v5 / 12) >> 1;
    if ( 357913941 - v7 >= v5 / 12 )
    {
      v8 = v7 + v5 / 12;
      if ( v8 < v6 )
        v8 = v6;
    }
    else
    {
      v8 = 0;
      if ( v6 )
        v8 = v6;
    }
    return (unsigned int)sub_4210E0(this, v8);
  }
  return result;
}
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (00421460) --------------------------------------------------------
unsigned int __thiscall sub_421460(_DWORD *this, unsigned int *a2)
{
  unsigned int result; // eax
  int v4; // edi
  unsigned int *v5; // ecx
  unsigned int *v6; // ecx

  result = this[1];
  if ( (unsigned int)a2 >= result || *this > (unsigned int)a2 )
  {
    if ( result == this[2] )
      result = sub_405560(this, 1u);
    v6 = (unsigned int *)this[1];
    if ( v6 )
    {
      result = *a2;
      *v6 = *a2;
    }
  }
  else
  {
    v4 = ((int)a2 - *this) >> 2;
    if ( result == this[2] )
      result = sub_405560(this, 1u);
    v5 = (unsigned int *)this[1];
    if ( v5 )
    {
      result = *(_DWORD *)(*this + 4 * v4);
      *v5 = result;
      this[1] += 4;
      return result;
    }
  }
  this[1] += 4;
  return result;
}

//----- (004214D0) --------------------------------------------------------
__m128i *__thiscall sub_4214D0(_DWORD *this, const __m128i *a2)
{
  unsigned int v3; // ecx
  int v4; // edi
  const __m128i *v5; // ecx
  __m128i *result; // eax

  v3 = this[1];
  if ( (unsigned int)a2 >= v3 || *this > (unsigned int)a2 )
  {
    if ( v3 == this[2] )
      sub_4211E0(this, 1u);
    result = (__m128i *)this[1];
    if ( result )
    {
      *result = _mm_loadu_si128(a2);
      result[1] = _mm_loadu_si128(a2 + 1);
      result[2].m128i_i64[0] = a2[2].m128i_i64[0];
    }
  }
  else
  {
    v4 = ((int)a2->m128i_i32 - *this) / 40;
    if ( v3 == this[2] )
      sub_4211E0(this, 1u);
    v5 = (const __m128i *)(*this + 40 * v4);
    result = (__m128i *)this[1];
    if ( result )
    {
      *result = _mm_loadu_si128(v5);
      result[1] = _mm_loadu_si128(v5 + 1);
      result[2].m128i_i64[0] = v5[2].m128i_i64[0];
      this[1] += 40;
      return result;
    }
  }
  this[1] += 40;
  return result;
}

//----- (00421580) --------------------------------------------------------
__m128i *__thiscall sub_421580(_DWORD *this, const __m128i *a2)
{
  unsigned int v3; // ecx
  int v4; // edi
  const __m128i *v5; // ecx
  __m128i *result; // eax

  v3 = this[1];
  if ( (unsigned int)a2 >= v3 || *this > (unsigned int)a2 )
  {
    if ( v3 == this[2] )
      sub_421310(this, 1u);
    result = (__m128i *)this[1];
    if ( result )
    {
      *result = _mm_loadu_si128(a2);
      result[1].m128i_i64[0] = a2[1].m128i_i64[0];
    }
  }
  else
  {
    v4 = ((int)a2->m128i_i32 - *this) / 24;
    if ( v3 == this[2] )
      sub_421310(this, 1u);
    v5 = (const __m128i *)(*this + 24 * v4);
    result = (__m128i *)this[1];
    if ( result )
    {
      *result = _mm_loadu_si128(v5);
      result[1].m128i_i64[0] = v5[1].m128i_i64[0];
      this[1] += 24;
      return result;
    }
  }
  this[1] += 24;
  return result;
}

//----- (00421620) --------------------------------------------------------
void __thiscall sub_421620(int *this, const __m128i **a2)
{
  unsigned int v3; // ecx
  int v4; // edi
  int v5; // ecx
  int v6; // ecx

  v3 = this[1];
  if ( (unsigned int)a2 >= v3 || *this > (unsigned int)a2 )
  {
    if ( v3 == this[2] )
      sub_4213C0(this, 1u);
    v6 = this[1];
    if ( v6 )
      sub_404A00(v6, a2);
  }
  else
  {
    v4 = ((int)a2 - *this) / 12;
    if ( v3 == this[2] )
      sub_4213C0(this, 1u);
    v5 = this[1];
    if ( v5 )
      sub_404A00(v5, (const __m128i **)(*this + 12 * v4));
  }
  this[1] += 12;
}

//----- (004216E0) --------------------------------------------------------
int __thiscall sub_4216E0(_DWORD *this, unsigned int a2)
{
  int result; // eax
  unsigned int v4; // ecx
  _OWORD *v5; // edx
  _DWORD v6[9]; // [esp+0h] [ebp-24h] BYREF

  v6[5] = v6;
  v6[4] = this;
  result = this[1];
  v4 = (result - *this) >> 5;
  if ( v4 <= a2 )
  {
    if ( v4 < a2 )
    {
      sub_421290((int)this, a2 - v4);
      v5 = (_OWORD *)this[1];
      v6[8] = 0;
      sub_4183C0(v5, a2 - (((int)v5 - *this) >> 5));
      result = (this[1] - *this) >> 5;
      this[1] += 32 * (a2 - result);
    }
  }
  else
  {
    this[1] = result + 32 * (a2 - v4);
  }
  return result;
}

//----- (004217B0) --------------------------------------------------------
int __usercall sub_4217B0@<eax>(
        double a1@<st0>,
        _DWORD *a2,
        int a3,
        int a4,
        int a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        int Count,
        _DWORD *a13,
        unsigned int *a14,
        _DWORD *a15)
{
  _DWORD *v15; // eax
  _DWORD *v16; // edi
  void *v17; // eax
  _DWORD *i; // edi
  _DWORD *v20; // eax
  void **v21; // esi
  _DWORD *v22; // eax
  unsigned int v23; // esi
  _DWORD *v24; // eax
  unsigned int v25; // edx
  unsigned int v26; // ecx
  int *v27; // esi
  _DWORD *v28; // eax
  int v29; // edx
  double v30; // xmm1_8
  double v31; // xmm2_8
  double v32; // xmm3_8
  double v33; // xmm4_8
  double v34; // xmm5_8
  int j; // edx
  int v36; // ecx
  unsigned int v37; // eax
  _DWORD *v38; // edx
  int v39; // esi
  void *v41; // [esp+34h] [ebp-B8h]
  double v42; // [esp+40h] [ebp-ACh] BYREF
  double v43; // [esp+48h] [ebp-A4h]
  double v44; // [esp+50h] [ebp-9Ch]
  double v45; // [esp+58h] [ebp-94h]
  double v46; // [esp+60h] [ebp-8Ch]
  __int64 v47; // [esp+98h] [ebp-54h]
  double v48; // [esp+A0h] [ebp-4Ch]
  double v49; // [esp+A8h] [ebp-44h] BYREF
  void *Block; // [esp+B0h] [ebp-3Ch]
  int v51; // [esp+B4h] [ebp-38h]
  int *v52; // [esp+B8h] [ebp-34h]
  double v53; // [esp+BCh] [ebp-30h]
  void *v54; // [esp+C4h] [ebp-28h] BYREF
  void *v55; // [esp+C8h] [ebp-24h]
  double v56; // [esp+CCh] [ebp-20h]
  int v57; // [esp+D4h] [ebp-18h]
  void *v58; // [esp+D8h] [ebp-14h] BYREF
  void *v59; // [esp+DCh] [ebp-10h]
  int v60; // [esp+E0h] [ebp-Ch] BYREF
  void *v61; // [esp+E4h] [ebp-8h]
  int v62; // [esp+E8h] [ebp-4h] BYREF
  double v63; // [esp+114h] [ebp+28h]
  double v64; // [esp+11Ch] [ebp+30h]

  v15 = malloc(0x10u);
  v16 = v15;
  v55 = v15;
  if ( !v15 )
    sub_422090("not enough memory.");
  *v15 = 0;
  v15[1] = 1;
  v15[2] = 7;
  v17 = malloc(0x38u);
  v16[3] = v17;
  if ( !v17 )
    sub_422090("not enough memory.");
  i = 0;
  v57 = 0;
  if ( !a3 || a4 <= 0 || a5 <= 0 )
    sub_422090("invalid image input.");
  if ( *(double *)&a6 <= 0.0 )
    sub_422090("'scale' value must be positive.");
  if ( *(double *)&a7 <= 0.0 )
    sub_422090("'sigma_scale' value must be positive.");
  if ( *(double *)&a8 < 0.0 )
    sub_422090("'quant' value must be positive.");
  if ( *(double *)&a9 <= 0.0 || *(double *)&a9 >= 180.0 )
    sub_422090("'ang_th' value must be in the range (0,180).");
  if ( *(double *)&a11 < 0.0 || *(double *)&a11 > 1.0 )
    sub_422090("'density_th' value must be in the range [0,1].");
  if ( Count <= 0 )
    sub_422090("'n_bins' value must be positive.");
  v64 = *(double *)&a9 / 180.0;
  v53 = *(double *)&a9 * 3.141592653589793 / 180.0;
  v63 = *(double *)&a8 / *(double *)libm_sse2_sin_precise().m128_u64;
  v20 = sub_423590(a4, a5, a3);
  Block = v20;
  if ( *(double *)&a6 == 1.0 )
  {
    v22 = sub_422DD0(0, v20, *(__int64 *)&v63, &v60, &v54, &v58, Count);
    v61 = v22;
  }
  else
  {
    v21 = (void **)sub_422240(v20, *(double *)&a6, *(double *)&a7);
    v61 = sub_422DD0(0, v21, *(__int64 *)&v63, &v60, &v54, &v58, Count);
    sub_4220C0(v21);
    v22 = v61;
  }
  v23 = v22[2];
  v62 = v22[1];
  v56 = *(double *)libm_sse2_log10_precise().m128_u64;
  v56 = (v56 + *(double *)libm_sse2_log10_precise().m128_u64) * 5.0 * 0.5;
  v56 = v56 + *(double *)libm_sse2_log10_precise().m128_u64;
  v51 = (int)-(v56 / *(double *)libm_sse2_log10_precise().m128_u64);
  if ( a13 )
  {
    if ( a14 )
    {
      if ( a15 )
      {
        v24 = sub_4235F0(v62, v23);
        v25 = v23 * v62;
        v26 = 0;
        for ( i = v24; v26 < v25; ++v26 )
          *(_DWORD *)(*v24 + 4 * v26) = 0;
      }
    }
  }
  v59 = sub_4234C0(v62, v23, 0);
  v27 = (int *)calloc((v23 * (unsigned __int64)(unsigned int)v62) >> 32 != 0 ? -1 : v23 * v62, 8u);
  v52 = v27;
  if ( !v27 )
    sub_422090("not enough memory!");
  v28 = (_DWORD *)v60;
  if ( v60 )
  {
    do
    {
      v29 = v28[1];
      if ( !*(_BYTE *)(*v28 + v29 * *((_DWORD *)v59 + 1) + *(_DWORD *)v59)
        && *(double *)(*(_DWORD *)v61 + 8 * (*(_DWORD *)v60 + v29 * *((_DWORD *)v61 + 1))) != -1024.0 )
      {
        sub_424E00(*(_DWORD *)v60, v29, v61, v27, &v62, &v49, v59, v53);
        if ( v62 >= v51 )
        {
          sub_424B60((int)v27, v62, v58, v49, v53, *(__int64 *)&v64, (int)&v42);
          if ( sub_424790(v27, &v62, v58, v49, v53, *(__int64 *)&v64, (int)&v42, v59, v61, *(double *)&a11) )
          {
            a1 = sub_423A70(a1, &v42, v61, v56, *(double *)&a10);
            v48 = a1;
            if ( *(double *)&a10 < a1 )
            {
              ++v57;
              v30 = v42 + 0.5;
              v31 = v43 + 0.5;
              v32 = v44 + 0.5;
              v33 = v45 + 0.5;
              v34 = v46;
              v42 = v42 + 0.5;
              v43 = v43 + 0.5;
              v44 = v44 + 0.5;
              v45 = v45 + 0.5;
              if ( *(double *)&a6 != 1.0 )
              {
                v30 = v30 / *(double *)&a6;
                v31 = v31 / *(double *)&a6;
                v32 = v32 / *(double *)&a6;
                v33 = v33 / *(double *)&a6;
                v34 = v46 / *(double *)&a6;
                v42 = v30;
                v43 = v31;
                v44 = v32;
                v45 = v33;
                v46 = v46 / *(double *)&a6;
              }
              sub_421E50(
                v55,
                *(__int64 *)&v30,
                *(__int64 *)&v31,
                *(__int64 *)&v32,
                *(__int64 *)&v33,
                *(__int64 *)&v34,
                v47,
                *(__int64 *)&a1);
              if ( i )
              {
                for ( j = 0; j < v62; v27 = v52 )
                {
                  v36 = v27[2 * j] + i[1] * v27[2 * j + 1];
                  ++j;
                  *(_DWORD *)(*i + 4 * v36) = v57;
                }
              }
            }
          }
        }
      }
      v28 = *(_DWORD **)(v60 + 8);
      v60 = (int)v28;
    }
    while ( v28 );
  }
  free(Block);
  sub_4220C0((void **)v61);
  sub_4220C0((void **)v58);
  if ( !v59 || !*(_DWORD *)v59 )
    sub_422090("free_image_char: invalid input image.");
  free(*(void **)v59);
  free(v59);
  free(v27);
  free(v54);
  if ( a13 && a14 && a15 )
  {
    if ( !i )
      sub_422090("'region' should be a valid image.");
    *a13 = *i;
    v37 = i[1];
    if ( v37 > 0x7FFFFFFF )
      sub_422090("region image to big to fit in INT sizes.");
    *a14 = v37;
    *a15 = i[2];
    free(i);
  }
  v38 = v55;
  if ( *(_DWORD *)v55 > 0x7FFFFFFFu )
    sub_422090("too many detections to fit in an INT.");
  v41 = v55;
  *a2 = *(_DWORD *)v55;
  v39 = v38[3];
  free(v41);
  return v39;
}
// 421BAF: inconsistent fpu stack
// 436A68: using guessed type __m128 libm_sse2_sin_precise(void);
// 437082: using guessed type __m128 libm_sse2_log10_precise(void);

//----- (00421E50) --------------------------------------------------------
int __cdecl sub_421E50(_DWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8)
{
  int v8; // ecx
  int result; // eax

  if ( !a1 )
    sub_422090("add_7tuple: invalid n-tuple input.");
  if ( a1[2] != 7 )
    sub_422090("add_7tuple: the n-tuple must be a 7-tuple.");
  if ( *a1 == a1[1] )
    sub_422020((int)a1);
  v8 = a1[3];
  if ( !v8 )
    sub_422090("add_7tuple: invalid n-tuple input.");
  *(_QWORD *)(v8 + 8 * *a1 * a1[2]) = a2;
  *(_QWORD *)(a1[3] + 8 * *a1 * a1[2] + 8) = a3;
  *(_QWORD *)(a1[3] + 8 * *a1 * a1[2] + 16) = a4;
  *(_QWORD *)(a1[3] + 8 * *a1 * a1[2] + 24) = a5;
  *(_QWORD *)(a1[3] + 8 * *a1 * a1[2] + 32) = a6;
  *(_QWORD *)(a1[3] + 8 * *a1 * a1[2] + 40) = a7;
  result = a1[3];
  *(_QWORD *)(result + 8 * *a1 * a1[2] + 48) = a8;
  ++*a1;
  return result;
}

//----- (00421F30) --------------------------------------------------------
double __cdecl sub_421F30(double a1, double a2)
{
  double v2; // xmm1_8
  double v4; // [esp+8h] [ebp+8h]

  v2 = a1 - a2;
  v4 = a1 - a2;
  if ( v4 <= -3.141592653589793 )
  {
    do
      v2 = v2 + 6.28318530718;
    while ( v2 <= -3.141592653589793 );
    v4 = v2;
  }
  if ( v2 > 3.141592653589793 )
  {
    do
      v2 = v2 - 6.28318530718;
    while ( v2 > 3.141592653589793 );
    v4 = v2;
  }
  if ( v2 < 0.0 )
    return -v2;
  return v4;
}

//----- (00421FB0) --------------------------------------------------------
BOOL __cdecl sub_421FB0(double a1, double a2)
{
  double v3; // xmm1_8
  double v4; // xmm2_8
  double v5; // xmm3_8

  if ( a1 == a2 )
    return 1;
  v3 = fabs(a1);
  v4 = fabs(a2);
  v5 = fabs(a1 - a2);
  if ( v3 <= v4 )
    v3 = v4;
  if ( v3 < 2.225073858507201e-308 )
    v3 = 2.225073858507201e-308;
  return v5 / v3 <= 2.220446049250313e-14;
}

//----- (00422020) --------------------------------------------------------
void *__cdecl sub_422020(int a1)
{
  int v1; // ecx
  int v2; // ecx
  int v3; // eax
  void *result; // eax

  if ( !a1 || !*(_DWORD *)(a1 + 12) || (v1 = *(_DWORD *)(a1 + 4)) == 0 )
    sub_422090("enlarge_ntuple_list: invalid n-tuple.");
  v2 = 2 * v1;
  v3 = v2 * *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 4) = v2;
  result = realloc(*(void **)(a1 + 12), (unsigned __int64)(unsigned int)v3 >> 29 != 0 ? -1 : 8 * v3);
  *(_DWORD *)(a1 + 12) = result;
  if ( !result )
    sub_422090("not enough memory.");
  return result;
}

//----- (00422090) --------------------------------------------------------
void __cdecl __noreturn sub_422090(const char *a1)
{
  FILE *v1; // eax

  v1 = _iob_func();
  fprintf(v1 + 2, "LSD Error: %s\n", a1);
  exit(1);
}

//----- (004220C0) --------------------------------------------------------
void __cdecl sub_4220C0(void **Block)
{
  if ( !Block || !*Block )
    sub_422090("free_image_double: invalid input image.");
  free(*Block);
  free(Block);
}

//----- (004220F0) --------------------------------------------------------
void __cdecl sub_4220F0(void *Block)
{
  if ( !Block || !*((_DWORD *)Block + 3) )
    sub_422090("free_ntuple_list: invalid n-tuple input.");
  free(*((void **)Block + 3));
  free(Block);
}

//----- (00422130) --------------------------------------------------------
void __cdecl sub_422130(_DWORD *a1, double a2)
{
  double v2; // xmm1_8
  unsigned int v3; // edi
  int v4; // ebx
  double v5; // xmm0_8
  double v6; // xmm0_8
  unsigned int i; // ecx
  double v8; // [esp+4h] [ebp-8h]

  v2 = 0.0;
  v8 = 0.0;
  if ( !a1 || !a1[3] )
    sub_422090("gaussian_kernel: invalid n-tuple 'kernel'.");
  if ( a2 <= 0.0 )
    sub_422090("gaussian_kernel: 'sigma' must be positive.");
  if ( !a1[1] )
  {
    sub_422020((int)a1);
    v2 = 0.0;
  }
  v3 = 0;
  *a1 = 1;
  if ( !a1[2] )
    goto LABEL_10;
  v4 = a1[3];
  do
  {
    *(_QWORD *)(v4 + 8 * v3) = libm_sse2_exp_precise().m128_u64[0];
    v4 = a1[3];
    v5 = *(double *)(v4 + 8 * v3++);
    v6 = v5 + v8;
    v2 = v6;
    v8 = v6;
  }
  while ( v3 < a1[2] );
  if ( v6 >= 0.0 )
  {
LABEL_10:
    for ( i = 0; i < a1[2]; ++i )
      *(double *)(a1[3] + 8 * i) = *(double *)(a1[3] + 8 * i) / v2;
  }
}
// 43707C: using guessed type __m128 libm_sse2_exp_precise(void);

//----- (00422240) --------------------------------------------------------
_DWORD *__cdecl sub_422240(_DWORD *a1, double a2, double a3)
{
  unsigned int v3; // eax
  unsigned int v4; // ebx
  unsigned int v5; // edi
  unsigned int v6; // esi
  double v7; // xmm0_8
  double v8; // xmm0_8
  unsigned int v9; // ebx
  int v10; // esi
  int v11; // edi
  _DWORD *v12; // edi
  unsigned int v13; // edx
  double v14; // xmm1_8
  int v15; // eax
  double *v16; // ebx
  int v17; // edi
  int v18; // edx
  int j; // ecx
  double v20; // xmm0_8
  bool v21; // zf
  int v22; // ecx
  unsigned int v23; // esi
  unsigned int v24; // ebx
  unsigned int v25; // edx
  int v26; // eax
  _DWORD *v27; // esi
  double *v28; // eax
  _DWORD *v29; // ecx
  int v30; // ebx
  double v31; // xmm1_8
  double *v32; // esi
  int v33; // edx
  int k; // ecx
  double v35; // xmm0_8
  int v37; // [esp+10h] [ebp-80h]
  int v38; // [esp+10h] [ebp-80h]
  int v39; // [esp+14h] [ebp-7Ch]
  int v40; // [esp+18h] [ebp-78h]
  int v41; // [esp+1Ch] [ebp-74h]
  _DWORD *v42; // [esp+50h] [ebp-40h]
  _DWORD *Block; // [esp+54h] [ebp-3Ch]
  _DWORD *v44; // [esp+58h] [ebp-38h]
  unsigned int v45; // [esp+5Ch] [ebp-34h]
  int v46; // [esp+60h] [ebp-30h]
  unsigned int v47; // [esp+60h] [ebp-30h]
  int i; // [esp+64h] [ebp-2Ch]
  unsigned int v49; // [esp+64h] [ebp-2Ch]
  unsigned int v50; // [esp+68h] [ebp-28h]
  double *v51; // [esp+68h] [ebp-28h]
  int v52; // [esp+6Ch] [ebp-24h]
  int v53; // [esp+70h] [ebp-20h]
  double v54; // [esp+80h] [ebp-10h]
  double v55; // [esp+80h] [ebp-10h]
  double v56; // [esp+A4h] [ebp+14h]

  if ( !a1 || !*a1 || (v3 = a1[1]) == 0 || (v4 = a1[2]) == 0 )
    sub_422090("gaussian_sampler: invalid image.");
  if ( a2 <= 0.0 )
    sub_422090("gaussian_sampler: 'scale' must be positive.");
  if ( a3 <= 0.0 )
    sub_422090("gaussian_sampler: 'sigma_scale' must be positive.");
  if ( (double)v3 * a2 > 4294967295.0 || (double)v4 * a2 > 4294967295.0 )
    sub_422090("gaussian_sampler: the output image size exceeds the handled size.");
  v5 = (unsigned int)ceil((double)v3 * a2);
  v6 = (unsigned int)ceil((double)v4 * a2);
  Block = sub_423520(v5, v4);
  v44 = sub_423520(v5, v6);
  v7 = a3;
  if ( a2 < 1.0 )
    v7 = a3 / a2;
  v56 = v7;
  libm_sse2_log_precise(v37);
  v8 = *(double *)libm_sse2_sqrt_precise(v38, v39, v40, v41).m128_u64;
  v45 = (unsigned int)ceil(v8 * v56);
  v9 = 0;
  v42 = sub_423660(2 * v45 + 1);
  v50 = 0;
  v10 = 2 * a1[1];
  v11 = 2 * a1[2];
  v53 = v10;
  v52 = v11;
  if ( Block[1] )
  {
    v12 = Block;
    do
    {
      v54 = floor((double)v9 / a2 + 0.5);
      sub_422130(v42, v56);
      v13 = 0;
      for ( i = 0; v13 < v12[2]; *(double *)(*v12 + 8 * (v9 + v22)) = v14 )
      {
        v14 = 0.0;
        v46 = v42[2];
        if ( v46 )
        {
          v15 = a1[1];
          v16 = (double *)v42[3];
          v17 = v13 * v15;
          v18 = (int)v54 - v45;
          do
          {
            for ( j = v18; j < 0; j += v10 )
              ;
            for ( ; j >= v10; j -= v10 )
              ;
            if ( j >= v15 )
              j = v10 - j - 1;
            ++v18;
            v10 = v53;
            v20 = *(double *)(*a1 + 8 * (v17 + j)) * *v16++;
            v21 = v46-- == 1;
            v15 = a1[1];
            v14 = v14 + v20;
          }
          while ( !v21 );
          v13 = i;
          v9 = v50;
          v12 = Block;
        }
        v22 = v13 * v12[1];
        i = ++v13;
      }
      v50 = ++v9;
    }
    while ( v9 < v12[1] );
    v11 = v52;
  }
  v23 = 0;
  v49 = 0;
  if ( v44[2] )
  {
    v24 = v44[1];
    do
    {
      v55 = floor((double)v23 / a2 + 0.5);
      sub_422130(v42, v56);
      v25 = 0;
      v47 = 0;
      if ( v24 )
      {
        v26 = v23 * v24;
        v27 = v44;
        v28 = (double *)(*v44 + 8 * v26);
        v29 = v42;
        v51 = v28;
        do
        {
          v30 = v29[2];
          v31 = 0.0;
          if ( v30 )
          {
            v32 = (double *)v29[3];
            v33 = (int)v55 - v45;
            do
            {
              for ( k = v33; k < 0; k += v11 )
                ;
              for ( ; k >= v11; k -= v11 )
                ;
              if ( k >= a1[2] )
                k = v11 - k - 1;
              ++v33;
              v11 = v52;
              v35 = *(double *)(*Block + 8 * (v47 + k * Block[1])) * *v32++;
              v31 = v31 + v35;
              --v30;
            }
            while ( v30 );
            v25 = v47;
            v28 = v51;
            v29 = v42;
            v27 = v44;
          }
          v24 = v27[1];
          ++v25;
          *v28++ = v31;
          v47 = v25;
          v51 = v28;
        }
        while ( v25 < v24 );
        v23 = v49;
      }
      v49 = ++v23;
    }
    while ( v23 < v44[2] );
  }
  sub_4220F0(v42);
  sub_4220C0((void **)Block);
  return v44;
}
// 422375: variable 'v37' is possibly undefined
// 422382: variable 'v38' is possibly undefined
// 422382: variable 'v39' is possibly undefined
// 422382: variable 'v40' is possibly undefined
// 422382: variable 'v41' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);
// 437088: using guessed type __m128 __stdcall libm_sse2_log_precise(_DWORD);

//----- (00422760) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __usercall sub_422760@<st0>(
        __int64 a1@<esi:edi>,
        int a2,
        int a3,
        double a4,
        double a5,
        _DWORD *a6,
        double a7,
        double a8)
{
  int v8; // edx
  double v9; // xmm5_8
  double v10; // xmm7_8
  double v11; // xmm6_8
  int v12; // esi
  int v13; // ecx
  int v14; // edx
  double v15; // xmm3_8
  double v16; // xmm2_8
  double v17; // xmm1_8
  double v18; // xmm1_8
  double v19; // xmm0_8
  double v20; // xmm0_8
  double v21; // xmm1_8
  double v22; // xmm0_8
  double v23; // xmm1_8
  double v24; // xmm3_8
  double v25; // xmm4_8
  double v26; // xmm2_8
  long double v27; // st7
  long double v28; // st6
  double result; // st7
  double v31; // [esp+30h] [ebp-8h]
  int _38; // [esp+38h] [ebp+0h] OVERLAPPED

  v8 = a2;
  v9 = 0.0;
  v10 = 0.0;
  v11 = 0.0;
  if ( !a2 )
    sub_422090("get_theta: invalid region.");
  if ( a3 <= 1 )
    sub_422090("get_theta: region size <= 1.");
  if ( !a6 || !*a6 )
    sub_422090("get_theta: invalid 'modgrad'.");
  if ( a8 < 0.0 )
    sub_422090("get_theta: 'prec' must be positive.");
  v12 = 0;
  do
  {
    v13 = *(_DWORD *)(v8 + 8 * v12 + 4);
    v14 = *(_DWORD *)(v8 + 8 * v12++);
    v15 = (double)v13 - a5;
    v16 = *(double *)(*a6 + 8 * (v14 + a6[1] * v13));
    v17 = (double)v14;
    v8 = a2;
    v18 = v17 - a4;
    v9 = v9 + v15 * v15 * v16;
    v10 = v10 - v15 * v18 * v16;
    v19 = v18 * v18 * v16 + v11;
    v11 = v19;
  }
  while ( v12 < a3 );
  v31 = v19;
  if ( v9 == 0.0 )
    goto LABEL_19;
  v20 = fabs(v9);
  v21 = fabs(v9 - 0.0);
  if ( v20 <= 0.0 )
    v20 = 0.0;
  if ( v20 < 2.225073858507201e-308 )
    v20 = 2.225073858507201e-308;
  if ( v21 / v20 <= 2.220446049250313e-14 )
  {
LABEL_19:
    if ( v11 == 0.0 )
      goto LABEL_34;
    v22 = fabs(v11);
    v23 = fabs(v11 - 0.0);
    if ( v22 <= 0.0 )
      v22 = 0.0;
    if ( v22 < 2.225073858507201e-308 )
      v22 = 2.225073858507201e-308;
    if ( v23 / v22 <= 2.220446049250313e-14 )
    {
LABEL_34:
      if ( sub_421FB0(v10, 0.0) )
        sub_422090("get_theta: null inertia matrix.");
    }
  }
  v24 = v11 + v9;
  v25 = *(double *)&_38;
  v26 = (v10 - *(double *)libm_sse2_sqrt_precise(a1, HIDWORD(a1), LODWORD(v9), HIDWORD(v9)).m128_u64) * 0.5;
  if ( fabs(v11 + v9) <= fabs(*(double *)&_38) )
  {
    v27 = v31;
    *(double *)&_38 = v26 - *(double *)&_38;
    v28 = v26 - v25;
  }
  else
  {
    *(double *)&_38 = v26 - v24;
    v27 = v26 - v24;
    v28 = v31;
  }
  result = atan2(v27, v28);
  *(double *)&_38 = sub_421F30(result, a7);
  if ( *(double *)&_38 > a8 )
    return result + 3.141592653589793;
  return result;
}
// 422760: could not find valid save-restore pair for edi
// 422760: could not find valid save-restore pair for esi
// 4227CA: conditional instruction was optimized away because %arg_4.4>=2
// 422760: variables would overlap: ^38.4 and ^38.8
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00422A60) --------------------------------------------------------
double __cdecl sub_422A60(double a1, double a2, double a3, double a4, double a5)
{
  double v5; // xmm0_8
  double v6; // xmm3_8
  double v7; // xmm0_8
  double v8; // xmm5_8
  double v10; // xmm3_8
  double v11; // xmm0_8
  double v12; // xmm5_8

  if ( a2 > a4 || (v5 = a1, a2 > a1) || a1 > a4 )
    sub_422090("inter_hi: unsuitable input, 'x1>x2' or 'x<x1' or 'x>x2'.");
  if ( a2 == a4 )
    goto LABEL_10;
  v6 = fabs(a2);
  v7 = fabs(a4);
  v8 = fabs(a2 - a4);
  if ( v6 <= v7 )
    v6 = v7;
  v5 = a1;
  if ( v6 < 2.225073858507201e-308 )
    v6 = 2.225073858507201e-308;
  if ( v8 / v6 <= 2.220446049250313e-14 )
  {
LABEL_10:
    if ( a5 > a3 )
      return a5;
  }
  if ( a2 == a4 )
    goto LABEL_18;
  v10 = fabs(a2);
  v11 = fabs(a4);
  v12 = fabs(a2 - a4);
  if ( v10 <= v11 )
    v10 = v11;
  v5 = a1;
  if ( v10 < 2.225073858507201e-308 )
    v10 = 2.225073858507201e-308;
  if ( v12 / v10 <= 2.220446049250313e-14 )
  {
LABEL_18:
    if ( a3 > a5 )
      return a3;
  }
  return (v5 - a2) * (a5 - a3) / (a4 - a2) + a3;
}

//----- (00422BB0) --------------------------------------------------------
double __cdecl sub_422BB0(double a1, double a2, double a3, double a4, double a5)
{
  double v5; // xmm0_8
  double v6; // xmm3_8
  double v7; // xmm0_8
  double v8; // xmm5_8
  double v10; // xmm3_8
  double v11; // xmm0_8
  double v12; // xmm5_8

  if ( a2 > a4 || (v5 = a1, a2 > a1) || a1 > a4 )
    sub_422090("inter_low: unsuitable input, 'x1>x2' or 'x<x1' or 'x>x2'.");
  if ( a2 == a4 )
    goto LABEL_10;
  v6 = fabs(a2);
  v7 = fabs(a4);
  v8 = fabs(a2 - a4);
  if ( v6 <= v7 )
    v6 = v7;
  v5 = a1;
  if ( v6 < 2.225073858507201e-308 )
    v6 = 2.225073858507201e-308;
  if ( v8 / v6 <= 2.220446049250313e-14 )
  {
LABEL_10:
    if ( a5 > a3 )
      return a3;
  }
  if ( a2 == a4 )
    goto LABEL_18;
  v10 = fabs(a2);
  v11 = fabs(a4);
  v12 = fabs(a2 - a4);
  if ( v10 <= v11 )
    v10 = v11;
  v5 = a1;
  if ( v10 < 2.225073858507201e-308 )
    v10 = 2.225073858507201e-308;
  if ( v12 / v10 <= 2.220446049250313e-14 )
  {
LABEL_18:
    if ( a3 > a5 )
      return a5;
  }
  return (v5 - a2) * (a5 - a3) / (a4 - a2) + a3;
}

//----- (00422D00) --------------------------------------------------------
BOOL __cdecl sub_422D00(int a1, int a2, _DWORD *a3, double a4, double a5)
{
  int v5; // ecx
  double v6; // xmm2_8
  double v8; // xmm0_8

  if ( !a3 || !*a3 )
    sub_422090("isaligned: invalid image 'angles'.");
  if ( a1 < 0 || a2 < 0 || (v5 = a3[1], a1 >= v5) || a2 >= a3[2] )
    sub_422090("isaligned: (x,y) out of the image.");
  if ( a5 < 0.0 )
    sub_422090("isaligned: 'prec' must be positive.");
  v6 = *(double *)(*a3 + 8 * (a1 + a2 * v5));
  if ( v6 == -1024.0 )
    return 0;
  v8 = a4 - v6;
  if ( a4 - v6 < 0.0 )
    v8 = -v8;
  if ( v8 > 4.71238898038 )
  {
    v8 = v8 - 6.28318530718;
    if ( v8 < 0.0 )
      v8 = -v8;
  }
  return a5 >= v8;
}

//----- (00422DD0) --------------------------------------------------------
_DWORD *__usercall sub_422DD0@<eax>(
        int a1@<edi>,
        _DWORD *a2,
        __int64 a3,
        _DWORD *a4,
        _DWORD *a5,
        _DWORD *a6,
        size_t Count)
{
  unsigned int v7; // ecx
  unsigned int v8; // eax
  _DWORD *v9; // eax
  unsigned int v10; // edx
  _QWORD *v11; // edi
  unsigned int v12; // esi
  unsigned int v13; // ecx
  _QWORD *v14; // eax
  unsigned int v15; // edi
  unsigned int v16; // esi
  int v17; // ecx
  int v18; // edx
  unsigned int v19; // eax
  int v20; // esi
  int v21; // edi
  double v22; // xmm0_8
  double v23; // xmm2_8
  unsigned int v24; // eax
  unsigned int v25; // ecx
  int v26; // edx
  unsigned int v27; // esi
  unsigned int v28; // edi
  double v29; // xmm1_8
  char *v30; // esi
  int v31; // ecx
  unsigned int v32; // eax
  int v33; // edx
  unsigned int *v34; // eax
  size_t v35; // eax
  void *v36; // edi
  char *v37; // ecx
  int v38; // edx
  int v39; // esi
  int v40; // edx
  int v42; // [esp-4h] [ebp-60h]
  int v43; // [esp+0h] [ebp-5Ch]
  char *Block; // [esp+4h] [ebp-58h]
  int v45; // [esp+8h] [ebp-54h]
  unsigned int v46; // [esp+Ch] [ebp-50h]
  _DWORD *v47; // [esp+10h] [ebp-4Ch]
  unsigned int v48; // [esp+14h] [ebp-48h]
  unsigned int v49; // [esp+14h] [ebp-48h]
  unsigned int v50; // [esp+18h] [ebp-44h]
  _DWORD *v51; // [esp+1Ch] [ebp-40h]
  unsigned int v52; // [esp+20h] [ebp-3Ch]
  int v53; // [esp+28h] [ebp-34h]
  int v54; // [esp+28h] [ebp-34h]
  int v55; // [esp+2Ch] [ebp-30h]
  unsigned int v56; // [esp+2Ch] [ebp-30h]
  unsigned int v57; // [esp+30h] [ebp-2Ch]
  int v58; // [esp+30h] [ebp-2Ch]
  char *v59; // [esp+34h] [ebp-28h]
  int v60; // [esp+34h] [ebp-28h]
  _DWORD *v61; // [esp+38h] [ebp-24h]
  double v62; // [esp+3Ch] [ebp-20h]
  double v63; // [esp+44h] [ebp-18h]
  double v64; // [esp+4Ch] [ebp-10h]
  double v65; // [esp+54h] [ebp-8h]

  v45 = 0;
  v62 = 0.0;
  v42 = a1;
  if ( !a2 || !*a2 || (v7 = a2[1], (v46 = v7) == 0) || (v8 = a2[2], (v48 = v8) == 0) )
    sub_422090("ll_angle: invalid image.");
  if ( *(double *)&a3 < 0.0 )
    sub_422090("ll_angle: 'threshold' must be positive.");
  if ( !a4 )
    sub_422090("ll_angle: NULL pointer 'list_p'.");
  if ( !a5 )
    sub_422090("ll_angle: NULL pointer 'mem_p'.");
  if ( !a6 )
    sub_422090("ll_angle: NULL pointer 'modgrad'.");
  if ( !Count )
    sub_422090("ll_angle: 'n_bins' must be positive.");
  v47 = sub_423520(v7, v8);
  *a6 = sub_423520(a2[1], a2[2]);
  v59 = (char *)calloc((v46 * (unsigned __int64)v48) >> 32 != 0 ? -1 : v46 * v48, 0xCu);
  *a5 = v59;
  Block = (char *)calloc(Count, 4u);
  v9 = calloc(Count, 4u);
  v51 = v9;
  if ( !v59 || !Block || !v9 )
    sub_422090("not enough memory.");
  memset(v9, 0, 4 * ((4 * Count) >> 2));
  memset(Block, 0, 4 * ((4 * Count) >> 2));
  v10 = v46;
  if ( v46 )
  {
    v11 = (_QWORD *)(*v47 + 8 * v46 * (v48 - 1));
    *v11 = 0xC090000000000000ui64;
    qmemcpy(v11 + 1, v11, 4 * ((8 * v46 - 5) >> 2));
  }
  v12 = v48;
  if ( v48 )
  {
    v13 = v48;
    v14 = (_QWORD *)(8 * v46 + *v47 - 8);
    do
    {
      *v14 = 0xC090000000000000ui64;
      v14 += v46;
      --v13;
    }
    while ( v13 );
    v10 = v46;
  }
  v15 = v10 - 1;
  v50 = v10 - 1;
  if ( v10 != 1 )
  {
    v16 = v48 - 1;
    v57 = v10 - 1;
    v17 = 0;
    v18 = 8 * v10;
    v53 = 0;
    v55 = v18;
    v19 = v15;
    do
    {
      if ( v16 )
      {
        v20 = v17;
        v21 = v18;
        v61 = (_DWORD *)*a6;
        v52 = v48 - 1;
        do
        {
          v22 = *(double *)(*a2 + v20 + 8) - *(double *)(*a2 + v21);
          v23 = *(double *)(*a2 + v21 + 8) - *(double *)(*a2 + v20);
          v64 = v22 + v23;
          v63 = v23 - v22;
          v65 = *(double *)libm_sse2_sqrt_precise(v42, v43, Block, v45).m128_u64;
          *(double *)(v20 + *v61) = v65;
          if ( *(double *)&a3 < v65 )
          {
            *(long double *)(*v47 + v20) = atan2(v64, -v63);
            if ( v65 > v62 )
              v62 = v65;
          }
          else
          {
            *(_QWORD *)(*v47 + v20) = 0xC090000000000000ui64;
          }
          v21 += 8 * v46;
          v20 += 8 * v46;
          --v52;
        }
        while ( v52 );
        v17 = v53;
        v18 = v55;
        v19 = v57;
        v16 = v48 - 1;
      }
      v17 += 8;
      v18 += 8;
      --v19;
      v53 = v17;
      v55 = v18;
      v57 = v19;
    }
    while ( v19 );
    v12 = v48;
    v15 = v50;
  }
  v24 = 0;
  v49 = 0;
  if ( v15 )
  {
    v25 = v12 - 1;
    v26 = 0;
    v27 = v50;
    v56 = v25;
    v54 = 0;
    do
    {
      v28 = 0;
      if ( v25 )
      {
        v29 = (double)Count;
        v30 = &v59[12 * v45];
        v31 = v26;
        v58 = v26;
        do
        {
          v32 = (unsigned int)(*(double *)(*(_DWORD *)*a6 + v31) * v29 / v62);
          if ( v32 >= Count )
            v32 = Count - 1;
          ++v45;
          v33 = v51[v32];
          v51[v32] = v30;
          if ( v33 )
            *(_DWORD *)(v33 + 8) = v30;
          else
            *(_DWORD *)&Block[4 * v32] = v30;
          v34 = (unsigned int *)v51[v32];
          v30 += 12;
          v29 = (double)Count;
          *v34 = v49;
          v34[1] = v28++;
          v34[2] = 0;
          v31 = 8 * v46 + v58;
          v58 = v31;
        }
        while ( v28 < v56 );
        v24 = v49;
        v25 = v56;
        v26 = v54;
        v27 = v50;
      }
      ++v24;
      v26 += 8;
      v49 = v24;
      v54 = v26;
    }
    while ( v24 < v27 );
  }
  v35 = Count - 1;
  if ( Count != 1 )
  {
    do
    {
      if ( *(_DWORD *)&Block[4 * v35] )
        break;
      --v35;
    }
    while ( v35 );
  }
  v36 = v51;
  v37 = &Block[4 * v35];
  v38 = *(_DWORD *)v37;
  v60 = *(_DWORD *)v37;
  v39 = v51[v35];
  if ( *(_DWORD *)v37 && v35 )
  {
    do
    {
      v40 = *((_DWORD *)v37 - 1);
      v37 -= 4;
      --v35;
      if ( v40 )
      {
        *(_DWORD *)(v39 + 8) = v40;
        v39 = *(_DWORD *)&v37[(char *)v51 - Block];
      }
    }
    while ( v35 );
    v36 = v51;
    v38 = v60;
  }
  *a4 = v38;
  free(Block);
  free(v36);
  return v47;
}
// 422DD0: could not find valid save-restore pair for edi
// 422ECB: conditional instruction was optimized away because %Count.4!=0
// 422FDA: variable 'v42' is possibly undefined
// 422FDA: variable 'v43' is possibly undefined
// 422FDA: variable 'Block' is possibly undefined
// 422FDA: variable 'v45' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00423270) --------------------------------------------------------
double __usercall sub_423270@<st0>(int a1@<esi>, double a2)
{
  double v2; // xmm0_8
  int v3; // esi
  double v4; // xmm0_8
  double v6; // [esp+0h] [ebp-10h]
  double v7; // [esp+8h] [ebp-8h]

  v2 = *(double *)libm_sse2_log_precise(a1).m128_u64;
  v3 = 0;
  v6 = 0.0;
  v7 = v2 * (a2 + 0.5) - (a2 + 5.5);
  do
  {
    v7 = v7 - *(double *)libm_sse2_log_precise(LODWORD(v6)).m128_u64;
    v4 = *(double *)libm_sse2_pow_precise().m128_u64 * qword_43E010[v3++];
    v6 = v4 + v6;
  }
  while ( v3 < 7 );
  return *(double *)libm_sse2_log_precise(LODWORD(v6)).m128_u64 + v7;
}
// 423305: variable 'v6' is possibly undefined
// 436A6E: using guessed type __m128 libm_sse2_pow_precise(void);
// 437088: using guessed type __m128 __stdcall libm_sse2_log_precise(_DWORD);
// 43E010: using guessed type double qword_43E010[7];

//----- (00423330) --------------------------------------------------------
double __cdecl sub_423330(double a1)
{
  double v1; // xmm0_8
  double v2; // xmm0_8
  double v4; // [esp+0h] [ebp-10h]

  v1 = *(double *)libm_sse2_pow_precise().m128_u64;
  v4 = *(double *)libm_sse2_log_precise(COERCE_UNSIGNED_INT64(1.0 / (v1 * 810.0))).m128_u64 * (a1 * 0.5);
  v2 = *(double *)libm_sse2_log_precise(LODWORD(v4)).m128_u64;
  return v4 + v2 * (a1 - 0.5) + 0.918938533204673 - a1;
}
// 4233D9: variable 'v4' is possibly undefined
// 436A6E: using guessed type __m128 libm_sse2_pow_precise(void);
// 437088: using guessed type __m128 __stdcall libm_sse2_log_precise(_DWORD);

//----- (004233F0) --------------------------------------------------------
int __usercall sub_4233F0@<eax>(double a1@<st0>, _DWORD *a2, int a3, int a4, int a5)
{
  return sub_4217B0(
           a1,
           a2,
           a3,
           a4,
           a5,
           0x3FE999999999999Ai64,
           0x3FE999999999999Ai64,
           0x4000000000000000i64,
           0x402E000000000000i64,
           0x4000000000000000i64,
           0x3FE999999999999Ai64,
           1024,
           0,
           0,
           0);
}

//----- (00423450) --------------------------------------------------------
_DWORD *__cdecl sub_423450(unsigned int a1, unsigned int a2)
{
  _DWORD *v2; // esi
  void *v3; // eax
  _DWORD *result; // eax

  if ( !a1 || !a2 )
    sub_422090("new_image_char: invalid image size.");
  v2 = malloc(0xCu);
  if ( !v2 )
    sub_422090("not enough memory.");
  v3 = calloc((a2 * (unsigned __int64)a1) >> 32 != 0 ? -1 : a2 * a1, 1u);
  *v2 = v3;
  if ( !v3 )
    sub_422090("not enough memory.");
  v2[1] = a1;
  result = v2;
  v2[2] = a2;
  return result;
}

//----- (004234C0) --------------------------------------------------------
void **__cdecl sub_4234C0(unsigned int a1, unsigned int a2, unsigned __int8 a3)
{
  void **result; // eax
  unsigned int v4; // ebx
  char *v5; // edi

  result = (void **)sub_423450(a1, a2);
  v4 = a2 * a1;
  if ( !result || (v5 = (char *)*result) == 0 )
    sub_422090("new_image_char_ini: invalid image.");
  if ( v4 )
  {
    memset32(v5, 16843009 * a3, v4 >> 2);
    memset(&v5[4 * (v4 >> 2)], a3, v4 & 3);
  }
  return result;
}

//----- (00423520) --------------------------------------------------------
_DWORD *__cdecl sub_423520(unsigned int a1, unsigned int a2)
{
  _DWORD *v2; // esi
  void *v3; // eax
  _DWORD *result; // eax

  if ( !a1 || !a2 )
    sub_422090("new_image_double: invalid image size.");
  v2 = malloc(0xCu);
  if ( !v2 )
    sub_422090("not enough memory.");
  v3 = calloc((a2 * (unsigned __int64)a1) >> 32 != 0 ? -1 : a2 * a1, 8u);
  *v2 = v3;
  if ( !v3 )
    sub_422090("not enough memory.");
  v2[1] = a1;
  result = v2;
  v2[2] = a2;
  return result;
}

//----- (00423590) --------------------------------------------------------
_DWORD *__cdecl sub_423590(int a1, int a2, int a3)
{
  _DWORD *result; // eax

  if ( !a1 || !a2 )
    sub_422090("new_image_double_ptr: invalid image size.");
  if ( !a3 )
    sub_422090("new_image_double_ptr: NULL data pointer.");
  result = malloc(0xCu);
  if ( !result )
    sub_422090("not enough memory.");
  result[2] = a2;
  result[1] = a1;
  *result = a3;
  return result;
}

//----- (004235F0) --------------------------------------------------------
_DWORD *__cdecl sub_4235F0(unsigned int a1, unsigned int a2)
{
  _DWORD *v2; // esi
  void *v3; // eax
  _DWORD *result; // eax

  if ( !a1 || !a2 )
    sub_422090("new_image_int: invalid image size.");
  v2 = malloc(0xCu);
  if ( !v2 )
    sub_422090("not enough memory.");
  v3 = calloc((a2 * (unsigned __int64)a1) >> 32 != 0 ? -1 : a2 * a1, 4u);
  *v2 = v3;
  if ( !v3 )
    sub_422090("not enough memory.");
  v2[1] = a1;
  result = v2;
  v2[2] = a2;
  return result;
}

//----- (00423660) --------------------------------------------------------
_DWORD *__cdecl sub_423660(unsigned int a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // esi
  void *v3; // eax

  if ( !a1 )
    sub_422090("new_ntuple_list: 'dim' must be positive.");
  v1 = malloc(0x10u);
  v2 = v1;
  if ( !v1 )
    sub_422090("not enough memory.");
  *v1 = 0;
  v1[1] = 1;
  v1[2] = a1;
  v3 = malloc((unsigned __int64)a1 >> 29 != 0 ? -1 : 8 * a1);
  v2[3] = v3;
  if ( !v3 )
    sub_422090("not enough memory.");
  return v2;
}

//----- (004236E0) --------------------------------------------------------
double __usercall sub_4236E0@<st0>(int a1@<esi>, int a2, int a3, double a4, double a5)
{
  double v7; // st7
  double v8; // st7
  int v9; // esi
  double v10; // st7
  double v11; // xmm0_8
  double v12; // xmm5_8
  double v13; // xmm3_8
  int v14; // esi
  int v15; // ecx
  double v16; // xmm1_8
  double v17; // xmm2_8
  double v18; // [esp+8h] [ebp-38h]
  double v19; // [esp+Ch] [ebp-34h]
  double v20; // [esp+Ch] [ebp-34h]
  int v22; // [esp+10h] [ebp-30h]
  double v23; // [esp+18h] [ebp-28h]
  double v24; // [esp+20h] [ebp-20h]
  double v25; // [esp+20h] [ebp-20h]
  double v26; // [esp+28h] [ebp-18h]
  double v27; // [esp+30h] [ebp-10h]
  double v28; // [esp+38h] [ebp-8h]
  int v29; // [esp+48h] [ebp+8h]

  if ( a2 < 0 || a3 < 0 || a3 > a2 || a4 <= 0.0 || a4 >= 1.0 )
    sub_422090("nfa: wrong n, k or p values.");
  if ( !a2 || !a3 )
    return -a5;
  if ( a2 == a3 )
    return -a5 - *(double *)libm_sse2_log10_precise().m128_u64 * (double)a2;
  v23 = a4 / (1.0 - a4);
  v19 = (double)a2 + 1.0;
  if ( v19 <= 15.0 )
    v7 = sub_423270(a1, v19);
  else
    v7 = sub_423330(v19);
  v28 = v7;
  v20 = (double)a3 + 1.0;
  if ( v20 <= 15.0 )
    v8 = sub_423270(a1, v20);
  else
    v8 = sub_423330(v20);
  v27 = v8;
  v9 = a2 - a3;
  v18 = (double)(a2 - a3) + 1.0;
  if ( v18 <= 15.0 )
    v10 = sub_423270(v9, v18);
  else
    v10 = sub_423330(v18);
  v26 = *(double *)libm_sse2_log_precise(a1).m128_u64 * (double)a3 + v28 - v27 - v10;
  v24 = v26 + *(double *)libm_sse2_log_precise(v22).m128_u64 * (double)v9;
  *(_QWORD *)&v11 = libm_sse2_exp_precise().m128_u64[0];
  v12 = v11;
  if ( sub_421FB0(v11, 0.0) )
  {
    if ( (double)a3 <= (double)a2 * a4 )
      return -a5;
    else
      return v24 / -2.302585092994046 - a5;
  }
  else
  {
    v13 = v11;
    v14 = a3 + 1;
    if ( a3 + 1 <= a2 )
    {
      v15 = a2 - a3;
      v29 = a2 - a3;
      do
      {
        if ( v14 >= 100000 )
        {
          v16 = 1.0 / (double)v14;
        }
        else
        {
          v16 = qword_43E468[v14];
          if ( v16 == 0.0 )
          {
            v16 = 1.0 / (double)v14;
            qword_43E468[v14] = v16;
          }
        }
        v17 = (double)v15 * v16;
        v12 = v12 * (v17 * v23);
        v13 = v13 + v12;
        if ( v17 < 1.0 )
        {
          v25 = ((1.0 - *(double *)libm_sse2_pow_precise().m128_u64) / (1.0 - v17 * v23) - 1.0) * v12;
          if ( fabs(-*(double *)libm_sse2_log10_precise().m128_u64 - a5) * 0.1 * v13 > v25 )
            return -*(double *)libm_sse2_log10_precise().m128_u64 - a5;
          v15 = v29;
        }
        ++v14;
        v29 = --v15;
      }
      while ( v14 <= a2 );
    }
    return -*(double *)libm_sse2_log10_precise().m128_u64 - a5;
  }
}
// 423864: variable 'v22' is possibly undefined
// 436A6E: using guessed type __m128 libm_sse2_pow_precise(void);
// 43707C: using guessed type __m128 libm_sse2_exp_precise(void);
// 437082: using guessed type __m128 libm_sse2_log10_precise(void);
// 437088: using guessed type __m128 __stdcall libm_sse2_log_precise(_DWORD);
// 43E468: using guessed type double qword_43E468[100001];

//----- (00423A70) --------------------------------------------------------
double __usercall sub_423A70@<st0>(double result@<st0>, double *a2, _DWORD *a3, double a4, double a5)
{
  double v5; // xmm1_8
  int v6; // edi
  double v7; // xmm0_8
  int v8; // edi
  double v9; // xmm3_8
  int v10; // edi
  double v11; // xmm4_8
  double v12; // xmm6_8
  double v13; // xmm5_8
  double v14; // xmm7_8
  double v15; // xmm1_8
  int v16; // edi
  double v17; // xmm4_8
  double v18; // xmm5_8
  double v19; // xmm6_8
  double v20; // xmm7_8
  double v21; // xmm1_8
  int v22; // edi
  double v23; // xmm0_8
  double v24; // [esp+14h] [ebp-D0h] BYREF
  double v25; // [esp+1Ch] [ebp-C8h]
  double v26; // [esp+24h] [ebp-C0h]
  double v27; // [esp+2Ch] [ebp-B8h]
  double v28; // [esp+34h] [ebp-B0h]
  double v29; // [esp+3Ch] [ebp-A8h]
  double v30; // [esp+44h] [ebp-A0h]
  double v31; // [esp+4Ch] [ebp-98h]
  double v32; // [esp+54h] [ebp-90h]
  double v33; // [esp+5Ch] [ebp-88h]
  double v34; // [esp+64h] [ebp-80h]
  double v35; // [esp+6Ch] [ebp-78h]
  double v36; // [esp+74h] [ebp-70h]
  double v37; // [esp+7Ch] [ebp-68h]
  double v38; // [esp+84h] [ebp-60h]
  double v39; // [esp+8Ch] [ebp-58h]
  double v40; // [esp+94h] [ebp-50h]
  double v41; // [esp+9Ch] [ebp-48h]
  double v42; // [esp+A4h] [ebp-40h]
  double v43; // [esp+ACh] [ebp-38h]
  double v44; // [esp+B4h] [ebp-30h]
  double v45; // [esp+BCh] [ebp-28h]
  double v46; // [esp+C4h] [ebp-20h]
  double v47; // [esp+CCh] [ebp-18h]
  double v48; // [esp+D4h] [ebp-10h]
  double v49; // [esp+DCh] [ebp-8h]
  double v50; // [esp+FCh] [ebp+18h]

  sub_4243C0(a2, a3, a4);
  v49 = result;
  if ( result <= a5 )
  {
    if ( !a2 )
      sub_422090("rect_copy: invalid 'in' or 'out'.");
    v47 = *a2;
    v24 = v47;
    v5 = a2[11];
    v48 = a2[1];
    v25 = v48;
    v44 = a2[2];
    v26 = v44;
    v45 = a2[3];
    v27 = v45;
    v43 = a2[4];
    v28 = v43;
    v42 = a2[5];
    v29 = v42;
    v41 = a2[6];
    v30 = v41;
    v38 = a2[7];
    v31 = v38;
    v40 = a2[8];
    v32 = v40;
    v39 = a2[9];
    v6 = 5;
    v33 = v39;
    do
    {
      v46 = v5 * 0.5;
      v35 = v5 * 0.5;
      v37 = v5 * 0.5 * 3.141592653589793;
      v34 = v37;
      sub_4243C0(&v24, a3, a4);
      v7 = v49;
      v36 = result;
      if ( result <= v49 )
      {
        v5 = v46;
      }
      else
      {
        v7 = result;
        *a2 = v47;
        a2[1] = v48;
        a2[2] = v44;
        a2[3] = v45;
        a2[4] = v43;
        a2[5] = v42;
        a2[6] = v41;
        a2[7] = v38;
        a2[8] = v40;
        a2[9] = v39;
        a2[10] = v37;
        v5 = v46;
        v49 = result;
        a2[11] = v46;
      }
      --v6;
    }
    while ( v6 );
    if ( v7 <= a5 )
    {
      v8 = 5;
      v37 = *a2;
      v24 = v37;
      v39 = a2[1];
      v25 = v39;
      v9 = a2[4];
      v40 = a2[2];
      v26 = v40;
      v38 = a2[3];
      v27 = v38;
      v41 = a2[5];
      v29 = v41;
      v47 = a2[6];
      v30 = v47;
      v48 = a2[7];
      v31 = v48;
      v44 = a2[8];
      v32 = v44;
      v45 = a2[9];
      v33 = v45;
      v43 = a2[10];
      v34 = v43;
      v42 = a2[11];
      v35 = v42;
      do
      {
        if ( v9 - 0.5 >= 0.5 )
        {
          v46 = v9 - 0.5;
          v28 = v9 - 0.5;
          sub_4243C0(&v24, a3, a4);
          v7 = v49;
          v9 = v46;
          v36 = result;
          if ( result > v49 )
          {
            *a2 = v37;
            a2[1] = v39;
            a2[2] = v40;
            a2[3] = v38;
            a2[5] = v41;
            a2[6] = v47;
            a2[7] = v48;
            a2[8] = v44;
            a2[9] = v45;
            a2[10] = v43;
            a2[11] = v42;
            v7 = result;
            a2[4] = v9;
            v49 = result;
          }
        }
        --v8;
      }
      while ( v8 );
      if ( v7 <= a5 )
      {
        v10 = 5;
        v11 = *a2;
        v12 = a2[1];
        v13 = a2[2];
        v14 = a2[3];
        v15 = a2[4];
        v37 = a2[5];
        v29 = v37;
        v39 = a2[6];
        v30 = v39;
        v40 = a2[7];
        v31 = v40;
        v46 = a2[8];
        v32 = v46;
        v42 = a2[9];
        v33 = v42;
        v38 = a2[10];
        v34 = v38;
        v41 = a2[11];
        v35 = v41;
        do
        {
          if ( v15 - 0.5 >= 0.5 )
          {
            v43 = v15 - 0.5;
            v28 = v15 - 0.5;
            v45 = v11 - v42 * 0.25;
            v24 = v45;
            v48 = v12 + v46 * 0.25;
            v25 = v48;
            v44 = v13 - v42 * 0.25;
            v26 = v44;
            v47 = v14 + v46 * 0.25;
            v27 = v47;
            sub_4243C0(&v24, a3, a4);
            v7 = v49;
            v11 = v45;
            v12 = v48;
            v13 = v44;
            v14 = v47;
            v15 = v43;
            v36 = result;
            if ( result > v49 )
            {
              a2[5] = v37;
              a2[6] = v39;
              a2[7] = v40;
              a2[8] = v46;
              a2[9] = v42;
              a2[10] = v38;
              a2[11] = v41;
              v7 = result;
              *a2 = v11;
              a2[1] = v12;
              a2[2] = v13;
              a2[3] = v14;
              a2[4] = v15;
              v49 = result;
            }
          }
          --v10;
        }
        while ( v10 );
        if ( v7 <= a5 )
        {
          v16 = 5;
          v17 = *a2;
          v18 = a2[1];
          v19 = a2[2];
          v20 = a2[3];
          v21 = a2[4];
          v37 = a2[5];
          v29 = v37;
          v39 = a2[6];
          v30 = v39;
          v40 = a2[7];
          v31 = v40;
          v47 = a2[8];
          v32 = v47;
          v48 = a2[9];
          v33 = v48;
          v38 = a2[10];
          v34 = v38;
          v41 = a2[11];
          v35 = v41;
          do
          {
            if ( v21 - 0.5 >= 0.5 )
            {
              v44 = v21 - 0.5;
              v28 = v21 - 0.5;
              v45 = v17 - v48 * -0.25;
              v24 = v45;
              v43 = v18 - v47 * 0.25;
              v25 = v43;
              v42 = v19 - v48 * -0.25;
              v26 = v42;
              v46 = v20 - v47 * 0.25;
              v27 = v46;
              sub_4243C0(&v24, a3, a4);
              v7 = v49;
              v17 = v45;
              v18 = v43;
              v19 = v42;
              v20 = v46;
              v21 = v44;
              v36 = result;
              if ( result > v49 )
              {
                a2[5] = v37;
                a2[6] = v39;
                a2[7] = v40;
                a2[8] = v47;
                a2[9] = v48;
                a2[10] = v38;
                a2[11] = v41;
                v7 = result;
                *a2 = v17;
                a2[1] = v18;
                a2[2] = v19;
                a2[3] = v20;
                a2[4] = v21;
                v49 = result;
              }
            }
            --v16;
          }
          while ( v16 );
          if ( v7 <= a5 )
          {
            v22 = 5;
            v37 = *a2;
            v24 = v37;
            v39 = a2[1];
            v25 = v39;
            v40 = a2[2];
            v26 = v40;
            v38 = a2[3];
            v27 = v38;
            v41 = a2[4];
            v28 = v41;
            v47 = a2[5];
            v29 = v47;
            v48 = a2[6];
            v30 = v48;
            v44 = a2[7];
            v31 = v44;
            v45 = a2[8];
            v32 = v45;
            v43 = a2[9];
            v33 = v43;
            v23 = a2[11];
            do
            {
              v50 = v23 * 0.5;
              v35 = v23 * 0.5;
              v42 = v23 * 0.5 * 3.141592653589793;
              v34 = v42;
              sub_4243C0(&v24, a3, a4);
              v36 = result;
              if ( result <= v49 )
              {
                v23 = v23 * 0.5;
              }
              else
              {
                v49 = result;
                *a2 = v37;
                a2[1] = v39;
                a2[2] = v40;
                a2[3] = v38;
                a2[4] = v41;
                a2[5] = v47;
                a2[6] = v48;
                a2[7] = v44;
                a2[8] = v45;
                a2[9] = v43;
                a2[10] = v42;
                v23 = v23 * 0.5;
                a2[11] = v50;
              }
              --v22;
            }
            while ( v22 );
          }
        }
      }
    }
    return v49;
  }
  return result;
}

//----- (004243C0) --------------------------------------------------------
void __cdecl sub_4243C0(double *a1, _DWORD *a2, double a3)
{
  int v3; // ebx
  double *v4; // esi
  int v5; // ecx
  int v6; // eax
  int v7; // [esp+1Ch] [ebp-4h]

  v7 = 0;
  v3 = 0;
  if ( !a1 )
    sub_422090("rect_nfa: invalid rectangle.");
  if ( !a2 )
    sub_422090("rect_nfa: invalid 'angles'.");
  v4 = sub_425200(a1);
  if ( !v4 )
    sub_422090("ri_end: NULL iterator.");
  while ( 1 )
  {
    v5 = *((_DWORD *)v4 + 20);
    if ( (double)v5 > v4[2] )
      break;
    if ( v5 >= 0 )
    {
      v6 = *((_DWORD *)v4 + 21);
      if ( v6 >= 0 && v5 < a2[1] && v6 < a2[2] )
      {
        ++v7;
        if ( sub_422D00(v5, v6, a2, a1[7], a1[10]) )
          ++v3;
      }
    }
    sub_425060((int)v4);
  }
  free(v4);
  sub_4236E0((int)v4, v7, v3, a1[11], a3);
}

//----- (004244C0) --------------------------------------------------------
int __cdecl sub_4244C0(
        int a1,
        int *a2,
        _DWORD *a3,
        double a4,
        double a5,
        __int64 a6,
        int a7,
        _DWORD *a8,
        _DWORD *a9,
        double a10)
{
  double v11; // xmm1_8
  double v12; // xmm0_8
  int v13; // esi
  int v14; // esi
  double v15; // xmm1_8
  int v16; // [esp+1Ch] [ebp-40h]
  int v17; // [esp+1Ch] [ebp-40h]
  int v18; // [esp+1Ch] [ebp-40h]
  int v19; // [esp+1Ch] [ebp-40h]
  int v20; // [esp+20h] [ebp-3Ch]
  int v21; // [esp+20h] [ebp-3Ch]
  int v22; // [esp+20h] [ebp-3Ch]
  int v23; // [esp+20h] [ebp-3Ch]
  int v24; // [esp+24h] [ebp-38h]
  int v25; // [esp+24h] [ebp-38h]
  int v26; // [esp+24h] [ebp-38h]
  int v27; // [esp+24h] [ebp-38h]
  int v28; // [esp+28h] [ebp-34h]
  int v29; // [esp+28h] [ebp-34h]
  int v30; // [esp+28h] [ebp-34h]
  int v31; // [esp+28h] [ebp-34h]
  double v32; // [esp+3Ch] [ebp-20h]
  double i; // [esp+3Ch] [ebp-20h]
  double v34; // [esp+44h] [ebp-18h]
  double v35; // [esp+44h] [ebp-18h]

  if ( !a1 )
    sub_422090("reduce_region_radius: invalid pointer 'reg'.");
  if ( !a2 )
    sub_422090("reduce_region_radius: invalid pointer 'reg_size'.");
  if ( a5 < 0.0 )
    sub_422090("reduce_region_radius: 'prec' must be positive.");
  if ( !a7 )
    sub_422090("reduce_region_radius: invalid pointer 'rec'.");
  if ( !a8 || !*a8 )
    sub_422090("reduce_region_radius: invalid image 'used'.");
  if ( !a9 || !*a9 )
    sub_422090("reduce_region_radius: invalid image 'angles'.");
  v34 = (double)*a2;
  v35 = v34 / (*(double *)libm_sse2_sqrt_precise(v16, v20, v24, v28).m128_u64 * *(double *)(a7 + 32));
  if ( v35 >= a10 )
    return 1;
  v32 = *(double *)libm_sse2_sqrt_precise(v17, v21, v25, v29).m128_u64;
  v11 = *(double *)libm_sse2_sqrt_precise(v18, v22, v26, v30).m128_u64;
  v12 = v32;
  if ( v32 <= v11 )
    v12 = v11;
  if ( a10 <= v35 )
    return 1;
  while ( 1 )
  {
    v13 = 0;
    for ( i = v12 * 0.75; v13 < *a2; ++v13 )
    {
      if ( *(double *)libm_sse2_sqrt_precise(v19, v23, v27, v31).m128_u64 > i )
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 8 * v13) + *(_DWORD *)(a1 + 8 * v13 + 4) * a8[1] + *a8) = 0;
        *(_DWORD *)(a1 + 8 * v13) = *(_DWORD *)(a1 + 8 * *a2 - 8);
        *(_DWORD *)(a1 + 8 * v13-- + 4) = *(_DWORD *)(a1 + 8 * (*a2)-- - 4);
      }
    }
    if ( *a2 < 2 )
      break;
    sub_424B60(a1, *a2, a3, a4, a5, a6, a7);
    v14 = *a2;
    v15 = (double)v14 / (*(double *)libm_sse2_sqrt_precise(v19, v23, v27, v31).m128_u64 * *(double *)(a7 + 32));
    v12 = i;
    if ( a10 <= v15 )
      return 1;
  }
  return 0;
}
// 424550: variable 'v16' is possibly undefined
// 424550: variable 'v20' is possibly undefined
// 424550: variable 'v24' is possibly undefined
// 424550: variable 'v28' is possibly undefined
// 4245BA: variable 'v17' is possibly undefined
// 4245BA: variable 'v21' is possibly undefined
// 4245BA: variable 'v25' is possibly undefined
// 4245BA: variable 'v29' is possibly undefined
// 4245E7: variable 'v18' is possibly undefined
// 4245E7: variable 'v22' is possibly undefined
// 4245E7: variable 'v26' is possibly undefined
// 4245E7: variable 'v30' is possibly undefined
// 42466B: variable 'v19' is possibly undefined
// 42466B: variable 'v23' is possibly undefined
// 42466B: variable 'v27' is possibly undefined
// 42466B: variable 'v31' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00424790) --------------------------------------------------------
int __cdecl sub_424790(
        int *a1,
        int *a2,
        _DWORD *a3,
        double a4,
        double a5,
        __int64 a6,
        int a7,
        _DWORD *a8,
        _DWORD *a9,
        double a10)
{
  _DWORD *v10; // ebx
  int v11; // esi
  int v12; // edi
  double v13; // xmm0_8
  double v15; // xmm0_8
  int v16; // esi
  int v17; // edi
  int v18; // ebx
  int v19; // ecx
  double i; // xmm1_8
  int *v21; // edi
  double v22; // xmm0_8
  double v23; // xmm1_8
  int v24; // [esp+2Ch] [ebp-80h]
  int v25; // [esp+2Ch] [ebp-80h]
  int v26; // [esp+2Ch] [ebp-80h]
  int v27; // [esp+30h] [ebp-7Ch]
  int v28; // [esp+30h] [ebp-7Ch]
  int v29; // [esp+30h] [ebp-7Ch]
  int v30; // [esp+34h] [ebp-78h]
  int v31; // [esp+34h] [ebp-78h]
  int v32; // [esp+34h] [ebp-78h]
  int v33; // [esp+38h] [ebp-74h]
  int v34; // [esp+38h] [ebp-74h]
  int v35; // [esp+38h] [ebp-74h]
  _DWORD *v36; // [esp+68h] [ebp-44h]
  int v37; // [esp+6Ch] [ebp-40h]
  int v38; // [esp+70h] [ebp-3Ch]
  _DWORD *v39; // [esp+7Ch] [ebp-30h]
  double v40; // [esp+84h] [ebp-28h]
  double v41; // [esp+8Ch] [ebp-20h]
  double v42; // [esp+94h] [ebp-18h]

  v37 = a7;
  v10 = a9;
  v39 = a9;
  v36 = a8;
  if ( !a1 )
    sub_422090("refine: invalid pointer 'reg'.");
  if ( !a2 )
    sub_422090("refine: invalid pointer 'reg_size'.");
  v40 = 0.0;
  if ( a5 < 0.0 )
    sub_422090("refine: 'prec' must be positive.");
  if ( !a7 )
    sub_422090("refine: invalid pointer 'rec'.");
  if ( !a8 || !*a8 )
    sub_422090("refine: invalid image 'used'.");
  if ( !a9 || (v11 = *a9) == 0 )
    sub_422090("refine: invalid image 'angles'.");
  v12 = *a2;
  v13 = *(double *)libm_sse2_sqrt_precise(v24, v27, v30, v33).m128_u64;
  if ( (double)v12 / (v13 * *(double *)(v37 + 32)) >= a10 )
    return 1;
  v15 = *(double *)(v11 + 8 * (*a1 + a1[1] * v10[1]));
  v16 = 0;
  v38 = 0;
  v42 = v15;
  v41 = 0.0;
  if ( v12 <= 0 )
  {
    v21 = a2;
  }
  else
  {
    do
    {
      *(_BYTE *)(a1[2 * v16] + a1[2 * v16 + 1] * v36[1] + *v36) = 0;
      v17 = a1[2 * v16];
      v18 = a1[2 * v16 + 1];
      if ( *(double *)(v37 + 32) <= *(double *)libm_sse2_sqrt_precise(v25, v28, v31, v34).m128_u64 )
      {
        v10 = v39;
      }
      else
      {
        v19 = v18 * v39[1];
        v10 = v39;
        for ( i = *(double *)(*v39 + 8 * (v17 + v19)) - v42; i <= -3.141592653589793; i = i + 6.28318530718 )
          ;
        for ( ; i > 3.141592653589793; i = i - 6.28318530718 )
          ;
        ++v38;
        v41 = i + v41;
        v40 = v40 + i * i;
      }
      v21 = a2;
      ++v16;
    }
    while ( v16 < *a2 );
  }
  v22 = *(double *)libm_sse2_sqrt_precise(v25, v28, v31, v34).m128_u64;
  sub_424E00(*a1, a1[1], v10, a1, v21, &a4, v36, v22 * 2.0);
  if ( *v21 < 2 )
    return 0;
  sub_424B60((int)a1, *v21, a3, a4, a5, a6, v37);
  v23 = (double)*a2 / (*(double *)libm_sse2_sqrt_precise(v26, v29, v32, v35).m128_u64 * *(double *)(v37 + 32));
  if ( a10 <= v23 )
    return 1;
  return sub_4244C0((int)a1, a2, a3, a4, a5, a6, v37, v36, v10, a10);
}
// 424836: variable 'v24' is possibly undefined
// 424836: variable 'v27' is possibly undefined
// 424836: variable 'v30' is possibly undefined
// 424836: variable 'v33' is possibly undefined
// 424904: variable 'v25' is possibly undefined
// 424904: variable 'v28' is possibly undefined
// 424904: variable 'v31' is possibly undefined
// 424904: variable 'v34' is possibly undefined
// 424AA2: variable 'v26' is possibly undefined
// 424AA2: variable 'v29' is possibly undefined
// 424AA2: variable 'v32' is possibly undefined
// 424AA2: variable 'v35' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00424B60) --------------------------------------------------------
int __cdecl sub_424B60(int a1, int a2, _DWORD *a3, double a4, double a5, __int64 a6, int a7)
{
  __int64 v7; // rdi
  double v8; // xmm5_8
  double v9; // xmm4_8
  double v10; // xmm3_8
  int v11; // edx
  int v12; // ecx
  double v13; // xmm1_8
  double v14; // xmm0_8
  double v15; // xmm6_8
  double v16; // xmm4_8
  double v17; // xmm5_8
  int v18; // eax
  double v19; // xmm2_8
  double v20; // xmm1_8
  double v21; // xmm3_8
  double v22; // xmm2_8
  double v23; // xmm1_8
  double v24; // xmm4_8
  int result; // eax
  int v26; // [esp+24h] [ebp-40h]
  int v27; // [esp+28h] [ebp-3Ch]
  double v28; // [esp+2Ch] [ebp-38h]
  double v29; // [esp+3Ch] [ebp-28h]
  double v30; // [esp+44h] [ebp-20h]
  double v31; // [esp+4Ch] [ebp-18h]
  double v32; // [esp+54h] [ebp-10h]
  double v33; // [esp+5Ch] [ebp-8h]

  LODWORD(v7) = a1;
  if ( !a1 )
    sub_422090("region2rect: invalid region.");
  if ( a2 <= 1 )
    sub_422090("region2rect: region size <= 1.");
  if ( !a3 || !*a3 )
    sub_422090("region2rect: invalid image 'modgrad'.");
  if ( !a7 )
    sub_422090("region2rect: invalid 'rec'.");
  HIDWORD(v7) = 0;
  v8 = 0.0;
  v9 = 0.0;
  v10 = 0.0;
  do
  {
    v11 = *(_DWORD *)(v7 + 8 * HIDWORD(v7) + 4);
    v12 = *(_DWORD *)(v7 + 8 * HIDWORD(v7)++);
    v13 = *(double *)(*a3 + 8 * (v12 + a3[1] * v11));
    LODWORD(v7) = a1;
    v8 = v8 + v13;
    v10 = v10 + (double)v12 * v13;
    v9 = v9 + (double)v11 * v13;
  }
  while ( SHIDWORD(v7) < a2 );
  if ( v8 <= 0.0 )
    sub_422090("region2rect: weights sum equal to zero.");
  v28 = v9 / v8;
  v30 = sub_422760(v7, a1, a2, v10 / v8, v9 / v8, a3, a4, a5);
  *(_QWORD *)&v31 = libm_sse2_cos_precise(v26, v27).m128_u64[0];
  *(_QWORD *)&v14 = libm_sse2_sin_precise().m128_u64[0];
  v15 = v10 / v8;
  v16 = 0.0;
  v17 = 0.0;
  v33 = v14;
  v18 = 0;
  v32 = 0.0;
  v29 = 0.0;
  while ( 1 )
  {
    v19 = (double)*(int *)(a1 + 8 * v18 + 4) - v28;
    v20 = (double)*(int *)(a1 + 8 * v18) - v15;
    v21 = v19 * v14 + v20 * v31;
    v22 = v19 * v31 - v20 * v33;
    v23 = v29;
    if ( v21 > v29 )
    {
      v23 = v21;
      v29 = v21;
    }
    if ( v17 > v21 )
      v17 = v21;
    if ( v22 > v16 )
      v16 = v22;
    if ( v32 <= v22 )
      v22 = v32;
    else
      v32 = v22;
    if ( ++v18 >= a2 )
      break;
    v14 = v33;
  }
  v24 = v16 - v22;
  result = a7;
  *(double *)(a7 + 32) = v24;
  *(double *)(a7 + 40) = v15;
  *(double *)(a7 + 48) = v28;
  *(double *)(a7 + 64) = v31;
  *(double *)a7 = v17 * v31 + v15;
  *(double *)(a7 + 8) = v17 * v33 + v28;
  *(double *)(a7 + 16) = v23 * v31 + v15;
  *(double *)(a7 + 72) = v33;
  *(double *)(a7 + 80) = a5;
  *(_QWORD *)(a7 + 88) = a6;
  *(double *)(a7 + 24) = v23 * v33 + v28;
  *(double *)(a7 + 56) = v30;
  if ( v24 < 1.0 )
    *(_QWORD *)(a7 + 32) = 0x3FF0000000000000i64;
  return result;
}
// 424BB2: conditional instruction was optimized away because %arg_4.4>=2
// 424C60: variable 'v26' is possibly undefined
// 424C60: variable 'v27' is possibly undefined
// 436A62: using guessed type __m128 __stdcall libm_sse2_cos_precise(_DWORD, _DWORD);
// 436A68: using guessed type __m128 libm_sse2_sin_precise(void);

//----- (00424E00) --------------------------------------------------------
int __cdecl sub_424E00(int a1, int a2, _DWORD *a3, int *a4, _DWORD *a5, double *a6, _DWORD *a7, double a8)
{
  int *v8; // ebx
  unsigned __int64 v9; // xmm0_8
  _DWORD *v10; // edi
  _DWORD *v11; // ecx
  int result; // eax
  int v13; // eax
  int v14; // esi
  int v15; // eax
  int v16; // ebx
  int v17; // ecx
  int v18; // eax
  int v19; // [esp+10h] [ebp-30h]
  int v20; // [esp+10h] [ebp-30h]
  int v21; // [esp+14h] [ebp-2Ch]
  int v22; // [esp+14h] [ebp-2Ch]
  double v23; // [esp+2Ch] [ebp-14h]
  double v24; // [esp+34h] [ebp-Ch]
  int v25; // [esp+3Ch] [ebp-4h]
  int i; // [esp+48h] [ebp+8h]

  if ( a1 < 0 || a2 < 0 || a1 >= a3[1] || a2 >= a3[2] )
    sub_422090("region_grow: (x,y) out of the image.");
  if ( !*a3 )
    sub_422090("region_grow: invalid image 'angles'.");
  v8 = a4;
  if ( !a4 )
    sub_422090("region_grow: invalid 'reg'.");
  if ( !a5 )
    sub_422090("region_grow: invalid pointer 'reg_size'.");
  if ( !a6 )
    sub_422090("region_grow: invalid pointer 'reg_angle'.");
  if ( !a7 || !*a7 )
    sub_422090("region_grow: invalid image 'used'.");
  *a5 = 1;
  a4[1] = a2;
  *a4 = a1;
  *a6 = *(double *)(*a3 + 8 * (a1 + a2 * a3[1]));
  *(_QWORD *)&v24 = libm_sse2_cos_precise(v19, v21).m128_u64[0];
  v9 = libm_sse2_sin_precise().m128_u64[0];
  v10 = a7;
  v11 = a5;
  v23 = *(double *)&v9;
  *(_BYTE *)(*a7 + a2 * a7[1] + a1) = 1;
  result = 0;
  for ( i = 0; result < *v11; i = result )
  {
    v13 = v8[2 * result];
    v14 = v13 - 1;
    v25 = v13 - 1;
    if ( v13 - 1 <= v13 + 1 )
    {
      do
      {
        v15 = v8[2 * i + 1];
        v16 = v15 - 1;
        if ( v15 - 1 <= v15 + 1 )
        {
          v17 = i;
          do
          {
            if ( v14 >= 0 && v16 >= 0 )
            {
              v18 = v10[1];
              if ( v14 < v18 && v16 < v10[2] && *(_BYTE *)(*v10 + v16 * v18 + v14) != 1 )
              {
                if ( sub_422D00(v14, v16, a3, *a6, a8) )
                {
                  *(_BYTE *)(*v10 + v16 * v10[1] + v14) = 1;
                  a4[2 * *a5] = v14;
                  a4[2 * (*a5)++ + 1] = v16;
                  v24 = *(double *)libm_sse2_cos_precise(v20, v22).m128_u64 + v24;
                  v23 = *(double *)libm_sse2_sin_precise().m128_u64 + v23;
                  v14 = v25;
                  v10 = a7;
                  *a6 = atan2(v23, v24);
                }
                v17 = i;
              }
            }
            ++v16;
          }
          while ( v16 <= a4[2 * v17 + 1] + 1 );
        }
        v8 = a4;
        v25 = ++v14;
      }
      while ( v14 <= a4[2 * i] + 1 );
      v11 = a5;
    }
    result = i + 1;
  }
  return result;
}
// 424E98: variable 'v19' is possibly undefined
// 424E98: variable 'v21' is possibly undefined
// 424F8F: variable 'v20' is possibly undefined
// 424F8F: variable 'v22' is possibly undefined
// 436A62: using guessed type __m128 __stdcall libm_sse2_cos_precise(_DWORD, _DWORD);
// 436A68: using guessed type __m128 libm_sse2_sin_precise(void);

//----- (00425060) --------------------------------------------------------
__int64 __usercall sub_425060@<xmm0>(int a1)
{
  __int64 result; // xmm0_8
  int v2; // ecx
  double v3; // xmm1_8
  double v4; // xmm3_8
  double v5; // xmm2_8
  double v6; // st7
  double v7; // xmm2_8
  double v8; // xmm1_8
  double v9; // st7
  int v10; // eax

  if ( !a1 )
    sub_422090("ri_inc: NULL iterator.");
  if ( (double)*(int *)(a1 + 80) <= *(double *)(a1 + 16) )
    ++*(_DWORD *)(a1 + 84);
  *(double *)&result = (double)*(int *)(a1 + 84);
  if ( *(double *)&result > *(double *)(a1 + 72) )
  {
    do
    {
      v2 = *(_DWORD *)(a1 + 80);
      *(double *)&result = (double)v2;
      if ( (double)v2 > *(double *)(a1 + 16) )
        break;
      v3 = (double)(v2 + 1);
      *(_DWORD *)(a1 + 80) = v2 + 1;
      v4 = *(double *)(a1 + 16);
      if ( v3 > v4 )
        break;
      v5 = *(double *)(a1 + 24);
      v6 = v5 <= v3
         ? sub_422BB0(v3, v5, *(double *)(a1 + 56), v4, *(double *)(a1 + 48))
         : sub_422BB0(v3, *(double *)a1, *(double *)(a1 + 32), v5, *(double *)(a1 + 56));
      v7 = (double)*(int *)(a1 + 80);
      *(double *)(a1 + 64) = v6;
      v8 = *(double *)(a1 + 8);
      v9 = v8 <= v7
         ? sub_422A60(v7, v8, *(double *)(a1 + 40), *(double *)(a1 + 16), *(double *)(a1 + 48))
         : sub_422A60(v7, *(double *)a1, *(double *)(a1 + 32), v8, *(double *)(a1 + 40));
      *(double *)(a1 + 72) = v9;
      v10 = (int)ceil(*(double *)(a1 + 64));
      *(_DWORD *)(a1 + 84) = v10;
      *(double *)&result = (double)v10;
    }
    while ( (double)v10 > *(double *)(a1 + 72) );
  }
  return result;
}

//----- (00425200) --------------------------------------------------------
double *__cdecl sub_425200(double *a1)
{
  double *v1; // edi
  double v2; // xmm6_8
  double v3; // xmm4_8
  double v4; // xmm2_8
  double v5; // xmm3_8
  double v6; // xmm5_8
  double v7; // xmm1_8
  int v8; // ecx
  int v9; // eax
  int v10; // eax
  int v11; // eax
  double v12; // st7
  double X; // [esp+0h] [ebp-58h]
  double v15[4]; // [esp+10h] [ebp-48h]
  double v16[4]; // [esp+30h] [ebp-28h]
  double v17; // [esp+50h] [ebp-8h]

  if ( !a1 )
    sub_422090("ri_ini: invalid rectangle.");
  v1 = (double *)malloc(0x58u);
  if ( !v1 )
    sub_422090("ri_ini: Not enough memory.");
  v2 = *a1;
  v3 = a1[9] * a1[4] * 0.5;
  v4 = a1[1];
  v5 = a1[8] * a1[4] * 0.5;
  v6 = a1[2];
  v7 = a1[3];
  v16[0] = *a1 - v3;
  v15[0] = v4 + v5;
  v16[1] = v6 - v3;
  v15[1] = v7 + v5;
  v16[2] = v6 + v3;
  v16[3] = v3 + v2;
  v15[2] = v7 - v5;
  v15[3] = v4 - v5;
  if ( v6 <= v2 || v7 < v4 )
  {
    if ( v2 < v6 )
      goto LABEL_11;
    if ( v7 > v4 )
    {
      v8 = 1;
      goto LABEL_12;
    }
    if ( v2 <= v6 || (v8 = 2, v4 < v7) )
LABEL_11:
      v8 = 3;
  }
  else
  {
    v8 = 0;
  }
LABEL_12:
  v17 = v16[v8];
  *v1 = v17;
  v1[4] = v15[v8];
  v9 = (v8 + 1) % 4;
  v1[1] = v16[v9];
  v1[5] = v15[v9];
  v10 = (v8 + 2) % 4;
  v1[2] = v16[v10];
  v1[6] = v15[v10];
  v11 = (v8 + 3) % 4;
  v12 = v17;
  v1[3] = v16[v11];
  v1[7] = v15[v11];
  v17 = ceil(v12);
  X = v1[4];
  *((_DWORD *)v1 + 20) = (int)v17 - 1;
  *((_DWORD *)v1 + 21) = (int)ceil(X);
  *((_OWORD *)v1 + 4) = xmmword_43A0E0;
  sub_425060((int)v1);
  return v1;
}
// 425303: conditional instruction was optimized away because ecx.4<4u
// 4252FE: mask 0x80000003 is shortened because ecx.4 <= 0x3
// 4252FE: masking with 0x3 was optimized away because ecx.4 <= 0x3
// 43A0E0: using guessed type __int128 xmmword_43A0E0;

//----- (00425400) --------------------------------------------------------
int __userpurge sub_425400@<eax>(int result@<eax>, int a2@<ecx>, int a3)
{
  int v3; // edx

  v3 = (*(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 8)) >> 5;
  if ( v3 > 0 )
  {
    result = 0;
    do
    {
      result += 32;
      *(_DWORD *)(result + *(_DWORD *)(a2 + 8) - 12) = a3;
      --v3;
    }
    while ( v3 );
  }
  return result;
}

//----- (00425440) --------------------------------------------------------
int __fastcall sub_425440(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // edi
  int v5; // esi
  int v6; // ebx
  int v7; // edx
  int v8; // ecx
  int v9; // edi
  int v10; // esi
  double v11; // xmm0_8
  int v12; // [esp+10h] [ebp-10h]
  int v13; // [esp+14h] [ebp-Ch]
  int v15; // [esp+1Ch] [ebp-4h]

  result = a1;
  v4 = (*(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 8)) >> 5;
  v15 = v4;
  if ( v4 > 0 )
  {
    v5 = *(_DWORD *)(a1 + 8);
    v6 = 0;
    do
    {
      v13 = 0;
      result = (*(_DWORD *)(v6 + v5 + 12) - *(_DWORD *)(v6 + v5 + 8)) / 40;
      if ( result > 0 )
      {
        v7 = 0;
        v12 = 0;
        do
        {
          v8 = *(_DWORD *)(v6 + *(_DWORD *)(a1 + 8) + 8);
          v9 = (int)*(double *)(v8 + v7 + 8);
          v10 = (int)*(double *)(v8 + v7 + 16);
          v11 = *(double *)libm_sse2_sqrt_precise(0, 0, 0, 1081073664).m128_u64;
          cvCircle(a3, v9, v10, (int)v11);
          v12 += 40;
          ++v13;
          v5 = *(_DWORD *)(a1 + 8);
          result = (*(_DWORD *)(v6 + v5 + 12) - *(_DWORD *)(v6 + v5 + 8)) / 40;
          v7 = v12;
        }
        while ( v13 < result );
        v4 = v15;
      }
      v6 += 32;
      v15 = --v4;
    }
    while ( v4 );
  }
  return result;
}
// 436854: using guessed type int __cdecl cvCircle(_DWORD, _DWORD, _DWORD, _DWORD);
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00425550) --------------------------------------------------------
void __cdecl sub_425550(
        int a1,
        int a2,
        int a3,
        int *a4,
        double a5,
        double a6,
        int a7,
        double a8,
        double a9,
        double a10)
{
  int v10; // ecx
  double v11; // xmm3_8
  double v12; // xmm4_8
  double v13; // xmm2_8
  double v14; // xmm1_8
  double v15; // xmm6_8
  int v16; // esi
  double v17; // xmm1_8
  double v18; // xmm7_8
  double v19; // xmm5_8
  double v20; // xmm2_8
  bool v21; // zf
  int v22; // eax
  double v23; // xmm4_8
  double v24; // xmm1_8
  float v25; // xmm0_4
  float v26; // xmm0_4
  double v27; // xmm2_8
  double v28; // xmm4_8
  double v29; // xmm1_8
  float v30; // xmm0_4
  float v31; // xmm0_4
  double v32; // xmm2_8
  float v33; // xmm0_4
  int v34; // edi
  int v35; // esi
  int v36; // eax
  int v37; // edi
  int v38; // ecx
  int v39; // edx
  double v40; // xmm7_8
  double v41; // xmm6_8
  int v42; // esi
  double v43; // xmm1_8
  double v44; // xmm7_8
  double v45; // xmm5_8
  int v46; // eax
  double v47; // xmm2_8
  double v48; // st7
  char v49; // al
  int v50; // eax
  double v51; // xmm0_8
  double v52; // [esp+34h] [ebp-2A0h]
  double v53; // [esp+34h] [ebp-2A0h]
  double v54; // [esp+4Ch] [ebp-288h]
  double v55; // [esp+54h] [ebp-280h]
  double v56; // [esp+5Ch] [ebp-278h]
  double v57; // [esp+64h] [ebp-270h] BYREF
  double v58; // [esp+6Ch] [ebp-268h]
  double v59; // [esp+74h] [ebp-260h]
  double v60; // [esp+7Ch] [ebp-258h]
  double v61; // [esp+84h] [ebp-250h]
  double v62; // [esp+8Ch] [ebp-248h]
  double v63; // [esp+94h] [ebp-240h]
  double v64; // [esp+9Ch] [ebp-238h]
  double v65; // [esp+A4h] [ebp-230h]
  double v66; // [esp+ACh] [ebp-228h]
  double v67; // [esp+B4h] [ebp-220h]
  double v68; // [esp+BCh] [ebp-218h]
  double v69; // [esp+C4h] [ebp-210h]
  int v70; // [esp+CCh] [ebp-208h]
  double v71; // [esp+D0h] [ebp-204h]
  double v72; // [esp+D8h] [ebp-1FCh]
  double v73; // [esp+E0h] [ebp-1F4h]
  double v74; // [esp+E8h] [ebp-1ECh]
  double v75; // [esp+F0h] [ebp-1E4h]
  double v76; // [esp+F8h] [ebp-1DCh]
  double v77; // [esp+100h] [ebp-1D4h]
  int v78; // [esp+108h] [ebp-1CCh]
  double v79; // [esp+10Ch] [ebp-1C8h]
  char v80[176]; // [esp+114h] [ebp-1C0h] BYREF
  _DWORD v81[60]; // [esp+1C4h] [ebp-110h] BYREF
  double v82; // [esp+2B4h] [ebp-20h] BYREF
  double v83; // [esp+2BCh] [ebp-18h] BYREF
  int v84; // [esp+2D0h] [ebp-4h]

  v70 = a3;
  v75 = a9;
  sub_406C30(*(_QWORD *)a7, *(double *)(a7 + 8), *(double *)(a7 + 16), &v57);
  sub_405EB0((int)v80, 4, a7 + 24, *(__int64 *)&v75);
  memset(v81, 0, sizeof(v81));
  sub_405E20((int)v81, 4, a7 + 24, *(__int64 *)&v75);
  v84 = 0;
  sub_406310((int)v81, (int)a4, a7 + 24);
  v10 = a4[1] - *a4;
  v11 = a8;
  v12 = v62;
  v13 = v59;
  v67 = a5 * a10;
  v66 = a6 * a10;
  v14 = v65;
  v78 = v10 / 40;
  if ( v10 / 40 > 0 )
  {
    v15 = v65 * COERCE_DOUBLE(*(_QWORD *)&a8 ^ 0x8000000000000000ui64);
    v16 = 0;
    v17 = v59 * COERCE_DOUBLE(*(_QWORD *)&a8 ^ 0x8000000000000000ui64);
    v18 = v65 * a8;
    v19 = v59 * a8;
    v68 = v15;
    v71 = v65 * a8;
    v75 = v17;
    v76 = v59 * a8;
    v77 = v62 * COERCE_DOUBLE(*(_QWORD *)&a8 ^ 0x8000000000000000ui64);
    v69 = v62 * a8;
    do
    {
      v20 = *(float *)(v16 + *a4 + 4) - a6;
      v79 = *(float *)(v16 + *a4) - a5;
      v72 = v20;
      v73 = v58 * v20 + v57 * v79 + v17;
      v74 = sub_406A70((int)v80, -4.0, 0.0, -1.0, 1.0e-10, v73, v19, v64 * v20 + v63 * v79 + v15, v18);
      v79 = (v61 * v72 + v60 * v79 + v77) * v74 - v69;
      v21 = sub_406170(v81, v73 * v74 - v76, &v83) == 0;
      v22 = *a4;
      if ( v21 )
        goto LABEL_4;
      v23 = v58;
      v24 = v64;
      v25 = v67 - v83;
      *(float *)(v16 + v22) = v25;
      v26 = v66 - v79;
      *(float *)(v16 + *a4 + 4) = v26;
      v27 = *(float *)(v16 + *a4 + 20) - a6;
      v73 = *(float *)(v16 + *a4 + 16) - a5;
      v72 = v27;
      v79 = v23 * v27 + v57 * v73 + v75;
      v74 = sub_406A70((int)v80, -4.0, 0.0, -1.0, 1.0e-10, v79, v76, v24 * v27 + v63 * v73 + v68, v71);
      v52 = v79 * v74 - v76;
      v79 = (v61 * v72 + v60 * v73 + v77) * v74 - v69;
      v21 = sub_406170(v81, v52, &v83) == 0;
      v22 = *a4;
      if ( v21 )
        goto LABEL_4;
      v28 = v58;
      v29 = v64;
      v30 = v67 - v83;
      *(float *)(v16 + v22 + 16) = v30;
      v31 = v66 - v79;
      *(float *)(v16 + *a4 + 20) = v31;
      v32 = *(float *)(v16 + *a4 + 12) - a6;
      v73 = *(float *)(v16 + *a4 + 8) - a5;
      v72 = v32;
      v79 = v28 * v32 + v57 * v73 + v75;
      v74 = sub_406A70((int)v80, -4.0, 0.0, -1.0, 1.0e-10, v79, v76, v29 * v32 + v63 * v73 + v68, v71);
      v53 = v79 * v74 - v76;
      v79 = (v61 * v72 + v60 * v73 + v77) * v74 - v69;
      v21 = sub_406170(v81, v53, &v83) == 0;
      v22 = *a4;
      if ( v21 )
      {
LABEL_4:
        *(_DWORD *)(v16 + v22) = 0;
        *(_DWORD *)(v16 + *a4 + 4) = 0;
        *(_DWORD *)(v16 + *a4 + 16) = 0;
        *(_DWORD *)(v16 + *a4 + 20) = 0;
        *(_DWORD *)(v16 + *a4 + 8) = 0;
        *(_DWORD *)(v16 + *a4 + 12) = 0;
      }
      else
      {
        v33 = v67 - v83;
        *(float *)(v16 + v22 + 8) = v33;
        *(float *)(v16 + *a4 + 12) = v66 - v79;
      }
      v19 = v76;
      v16 += 40;
      v21 = v78-- == 1;
      v15 = v68;
      v18 = v71;
      v17 = v75;
    }
    while ( !v21 );
    v11 = a8;
    v14 = v65;
    v12 = v62;
    v13 = v59;
  }
  v34 = (*(_DWORD *)(v70 + 12) - *(_DWORD *)(v70 + 8)) / 56;
  HIDWORD(v76) = v34;
  if ( v34 > 0 )
  {
    v35 = 0;
    HIDWORD(v77) = 0;
    do
    {
      v36 = *(_DWORD *)(v70 + 8);
      v78 = v36;
      HIDWORD(v74) = (*(_DWORD *)(v36 + v35 + 12) - *(_DWORD *)(v36 + v35 + 8)) >> 5;
      if ( SHIDWORD(v74) > 0 )
      {
        v37 = 0;
        do
        {
          HIDWORD(v83) = (*(_DWORD *)(*(_DWORD *)(v36 + v35 + 8) + v37 + 12)
                        - *(_DWORD *)(*(_DWORD *)(v36 + v35 + 8) + v37 + 8))
                       / 40;
          if ( SHIDWORD(v83) > 0 )
          {
            v38 = HIDWORD(v77);
            v39 = v78;
            v40 = v14;
            v41 = v14 * COERCE_DOUBLE(*(_QWORD *)&v11 ^ 0x8000000000000000ui64);
            v42 = 0;
            v43 = v13 * COERCE_DOUBLE(*(_QWORD *)&v11 ^ 0x8000000000000000ui64);
            v44 = v40 * v11;
            v45 = v13 * v11;
            v54 = v41;
            v56 = v44;
            v55 = v43;
            v75 = v13 * v11;
            v68 = v12 * COERCE_DOUBLE(*(_QWORD *)&v11 ^ 0x8000000000000000ui64);
            v69 = v12 * v11;
            do
            {
              v46 = *(_DWORD *)(*(_DWORD *)(v39 + v38 + 8) + v37 + 8);
              v47 = *(double *)(v46 + v42 + 16) - a6;
              v71 = *(double *)(v46 + v42 + 8) - a5;
              v73 = v47;
              v72 = v58 * v47 + v57 * v71 + v43;
              v48 = sub_406A70((int)v80, -4.0, 0.0, -1.0, 1.0e-10, v72, v45, v64 * v47 + v63 * v71 + v41, v44);
              v79 = (v61 * v73 + v60 * v71 + v68) * v48 - v69;
              v49 = sub_406170(v81, v72 * v48 - v75, &v82);
              v38 = HIDWORD(v77);
              v21 = v49 == 0;
              v39 = v78;
              v50 = *(_DWORD *)(*(_DWORD *)(v78 + HIDWORD(v77) + 8) + v37 + 8);
              if ( v21 )
              {
                v51 = 0.0;
                *(_QWORD *)(v50 + v42 + 8) = 0i64;
              }
              else
              {
                *(double *)(v50 + v42 + 8) = v67 - v82;
                v51 = v66 - v79;
              }
              v45 = v75;
              v41 = v54;
              v44 = v56;
              v43 = v55;
              *(double *)(*(_DWORD *)(*(_DWORD *)(v39 + v38 + 8) + v37 + 8) + v42 + 16) = v51;
              v42 += 40;
              --HIDWORD(v83);
            }
            while ( HIDWORD(v83) );
            v35 = HIDWORD(v77);
          }
          v11 = a8;
          v37 += 32;
          v21 = HIDWORD(v74)-- == 1;
          v14 = v65;
          v12 = v62;
          v13 = v59;
          v36 = v78;
        }
        while ( !v21 );
        v34 = HIDWORD(v76);
      }
      v11 = a8;
      v35 += 56;
      v14 = v65;
      --v34;
      v12 = v62;
      v13 = v59;
      HIDWORD(v77) = v35;
      HIDWORD(v76) = v34;
    }
    while ( v34 );
  }
  v84 = -1;
  sub_406030((int)v81);
}
// 425550: using guessed type _DWORD var_110[60];

//----- (00425F90) --------------------------------------------------------
void __cdecl sub_425F90(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        double a7,
        double a8,
        int a9,
        double a10,
        double a11,
        double a12)
{
  _DWORD *v12; // edi
  __int128 v13; // xmm0
  _DWORD *v14; // ebx
  int v15; // ecx
  double v16; // xmm1_8
  double v17; // xmm2_8
  int v18; // esi
  int v19; // eax
  int v20; // edx
  double v21; // xmm4_8
  unsigned int v22; // esi
  double *v23; // ecx
  double v24; // xmm4_8
  double v25; // xmm1_8
  double v26; // xmm5_8
  double v27; // xmm6_8
  double v28; // xmm0_8
  int v29; // edx
  int v30; // ecx
  int v31; // esi
  int v32; // edi
  int v33; // eax
  double v34; // xmm5_8
  double v35; // xmm6_8
  double v36; // xmm4_8
  double v37; // xmm3_8
  double v38; // xmm6_8
  double v39; // xmm2_8
  double v40; // xmm4_8
  int v41; // esi
  int v42; // eax
  double v43; // xmm1_8
  int v44; // ecx
  int v45; // edi
  double v46; // xmm1_8
  int v47; // eax
  double v48[9]; // [esp+2Ch] [ebp-188h] BYREF
  double v49; // [esp+74h] [ebp-140h]
  int v50; // [esp+7Ch] [ebp-138h]
  int v51; // [esp+80h] [ebp-134h]
  double v52; // [esp+84h] [ebp-130h]
  double v53; // [esp+8Ch] [ebp-128h]
  double v54; // [esp+94h] [ebp-120h]
  int v55; // [esp+9Ch] [ebp-118h]
  _DWORD *v56; // [esp+A0h] [ebp-114h]
  int v57; // [esp+A4h] [ebp-110h]
  int v58; // [esp+A8h] [ebp-10Ch]
  __int64 v59[30]; // [esp+ACh] [ebp-108h] BYREF
  double v60; // [esp+19Ch] [ebp-18h] BYREF
  int v61; // [esp+1B0h] [ebp-4h]

  v12 = (_DWORD *)a2;
  v54 = a11;
  v13 = *(_OWORD *)(a9 + 8);
  v56 = (_DWORD *)a2;
  sub_406C30(*(_QWORD *)a9, *(double *)&v13, *((double *)&v13 + 1), v48);
  memset(v59, 0, sizeof(v59));
  sub_405E20((int)v59, 4, a9 + 24, *(__int64 *)&v54);
  v61 = 0;
  sub_406310((int)v59, a2, a9);
  v51 = a2;
  v14 = (_DWORD *)a1;
  v50 = a1;
  LOBYTE(v61) = 2;
  cvSetZero(a2);
  v15 = 0;
  v16 = a7 * a12;
  v58 = 0;
  v17 = a8 * a12;
  v54 = a7 * a12;
  v52 = a8 * a12;
  if ( *(int *)(a2 + 44) > 0 )
  {
    do
    {
      v18 = 0;
      v19 = v14[10] - 1;
      v57 = 0;
      v53 = (double)v19;
      if ( (int)v12[10] > 0 )
      {
        v49 = (double)v15 - v17;
        do
        {
          if ( sub_406280(v59, (double)v18 - v16, &v60) )
          {
            v20 = v59[28];
            v21 = 0.0;
            if ( SLODWORD(v59[28]) >= 0 )
            {
              if ( LODWORD(v59[28]) + 1 >= 4 )
              {
                v22 = (unsigned int)(LODWORD(v59[28]) + 1) >> 2;
                v23 = (double *)&v59[LODWORD(v59[28]) + 6];
                v20 = LODWORD(v59[28]) - 4 * v22;
                do
                {
                  v21 = (((v21 * (*(double *)&v59[29] * v60) + v23[2]) * (*(double *)&v59[29] * v60) + v23[1])
                       * (*(double *)&v59[29]
                        * v60)
                       + *v23)
                      * (*(double *)&v59[29]
                       * v60)
                      + *(v23 - 1);
                  v23 -= 4;
                  --v22;
                }
                while ( v22 );
              }
              for ( ; v20 >= 0; --v20 )
                v21 = v21 * (*(double *)&v59[29] * v60) + *(double *)&v59[v20 + 8];
              v18 = v57;
            }
            v24 = v21 / *(double *)&v59[29];
            v25 = v48[2] * v60 + v48[5] * v49 + v48[8] * v24 + a10;
            v26 = a7 - (v48[0] * v60 + v48[3] * v49 + v48[6] * v24) * a10 / v25;
            v27 = a8 - (v48[1] * v60 + v48[4] * v49 + v48[7] * v24) * a10 / v25;
            v28 = v26 - v53;
            v53 = v26;
            if ( v28 <= 0.15 )
            {
              v29 = (int)v26;
              v30 = (int)v27;
              v55 = (int)v27;
              if ( (int)v26 >= 0 && v29 < v14[10] - 1 && v30 >= 0 && v30 < v14[11] - 1 )
              {
                v31 = v14[17];
                v32 = v30 + 1;
                v33 = v14[18];
                v34 = v26 - (double)v29;
                v35 = v27 - (double)v30;
                v36 = 1.0 - v35;
                v37 = (1.0 - v34) * v35;
                v38 = v35 * v34;
                v39 = (1.0 - v34) * v36;
                v40 = v36 * v34;
                *(_BYTE *)(3 * (v56[10] - v57) + v56[18] * (v56[11] - v58 - 1) + v56[17] - 1) = (int)((double)*(unsigned __int8 *)(3 * v29 + v33 * (v30 + 1) + v31 + 2) * v37 + (double)*(unsigned __int8 *)(3 * v29 + v30 * v33 + v31 + 2) * v39 + (double)*(unsigned __int8 *)(3 * v29 + v30 * v33 + v31 + 5) * v40 + (double)*(unsigned __int8 *)(3 * v29 + v33 * (v30 + 1) + v31 + 5) * v38);
                v41 = *(_DWORD *)(a1 + 68);
                v42 = *(unsigned __int8 *)(3 * v29 + *(_DWORD *)(a1 + 72) * (v30 + 1) + v41 + 4);
                v43 = (double)*(unsigned __int8 *)(3 * v29 + *(_DWORD *)(a1 + 72) * (v30 + 1) + v41 + 1) * v37
                    + (double)*(unsigned __int8 *)(3 * v29 + v55 * *(_DWORD *)(a1 + 72) + v41 + 1) * v39
                    + (double)*(unsigned __int8 *)(3 * v29 + v55 * *(_DWORD *)(a1 + 72) + v41 + 4) * v40;
                v18 = v57;
                *(_BYTE *)(3 * (v56[10] - v57) + v56[18] * (v56[11] - v58 - 1) + v56[17] - 2) = (int)(v43 + (double)v42 * v38);
                v44 = 3 * v29 + v55 * *(_DWORD *)(a1 + 72);
                v45 = 3 * v29 + *(_DWORD *)(a1 + 72) * v32;
                v14 = (_DWORD *)a1;
                v46 = (double)*(unsigned __int8 *)(v45 + *(_DWORD *)(a1 + 68)) * v37
                    + (double)*(unsigned __int8 *)(v44 + *(_DWORD *)(a1 + 68)) * v39;
                v47 = *(unsigned __int8 *)(v45 + *(_DWORD *)(a1 + 68) + 3);
                v12 = v56;
                *(_BYTE *)(3 * (v56[10] - v18 - 1) + v56[18] * (v56[11] - v58 - 1) + v56[17]) = (int)(v46 + (double)*(unsigned __int8 *)(v44 + *(_DWORD *)(a1 + 68) + 3) * v40 + (double)v47 * v38);
              }
            }
          }
          v16 = v54;
          v57 = ++v18;
        }
        while ( v18 < v12[10] );
        v17 = v52;
        v15 = v58;
      }
      v58 = ++v15;
    }
    while ( v15 < v12[11] );
  }
  v61 = -1;
  sub_406030((int)v59);
}
// 43685A: using guessed type int __cdecl cvSetZero(_DWORD);

//----- (00426520) --------------------------------------------------------
int __stdcall sub_426520(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  int result; // eax

  sub_42AD80(a1, a2);
  if ( result != -8 )
    *(_DWORD *)(result + 8) = *a3;
  return result;
}
// 426533: variable 'result' is possibly undefined

//----- (00426540) --------------------------------------------------------
_DWORD *__thiscall sub_426540(_DWORD *this, int a2, _DWORD **a3, int a4)
{
  _DWORD *result; // eax

  result = sub_42AE00(this);
  *((_WORD *)result + 6) = 0;
  if ( result != (_DWORD *)-16 )
  {
    result[4] = **a3;
    result[5] = 0;
  }
  return result;
}

//----- (00426570) --------------------------------------------------------
void __stdcall sub_426570(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax

  sub_42ADC0(a1, a2);
  if ( v3 != -8 )
  {
    *(_DWORD *)(v3 + 8) = *a3;
    *(_DWORD *)(v3 + 12) = a3[1];
  }
}
// 426584: variable 'v3' is possibly undefined

//----- (004265A0) --------------------------------------------------------
_DWORD *__thiscall sub_4265A0(_DWORD *this, _DWORD *a2, char a3, _DWORD *a4, int a5, void *a6)
{
  unsigned int v7; // eax
  _DWORD *v8; // eax
  int *v9; // ecx
  int *v10; // esi
  int *v11; // edx
  _DWORD *v12; // edx
  void **v13; // ecx
  _DWORD *v14; // edx
  _DWORD *v15; // esi
  int v16; // ecx
  _DWORD *v17; // ecx
  int v18; // edx
  int v19; // ecx
  _DWORD *v20; // ecx
  _DWORD *v21; // ecx
  _DWORD *result; // eax

  v7 = this[1];
  if ( v7 >= 0xAAAAAA9 )
  {
    operator delete(a6);
    std::_Xlength_error("map/set<T> too long");
  }
  this[1] = v7 + 1;
  *((_DWORD *)a6 + 1) = a4;
  if ( a4 == (_DWORD *)*this )
  {
    *(_DWORD *)(*this + 4) = a6;
    *(_DWORD *)*this = a6;
    *(_DWORD *)(*this + 8) = a6;
  }
  else if ( a3 )
  {
    *a4 = a6;
    if ( a4 == *(_DWORD **)*this )
      *(_DWORD *)*this = a6;
  }
  else
  {
    a4[2] = a6;
    if ( a4 == *(_DWORD **)(*this + 8) )
      *(_DWORD *)(*this + 8) = a6;
  }
  v8 = a6;
  if ( !*(_BYTE *)(*((_DWORD *)a6 + 1) + 12) )
  {
    do
    {
      v9 = (int *)v8[1];
      v10 = (int *)v9[1];
      v11 = (int *)*v10;
      if ( v9 == (int *)*v10 )
      {
        v11 = (int *)v10[2];
        if ( *((_BYTE *)v11 + 12) )
        {
          if ( v8 == (_DWORD *)v9[2] )
          {
            v8 = (_DWORD *)v8[1];
            v12 = (_DWORD *)v9[2];
            v9[2] = *v12;
            if ( !*(_BYTE *)(*v12 + 13) )
              *(_DWORD *)(*v12 + 4) = v9;
            v12[1] = v9[1];
            if ( v9 == *(int **)(*this + 4) )
            {
              *(_DWORD *)(*this + 4) = v12;
            }
            else
            {
              v13 = (void **)v9[1];
              if ( v8 == *v13 )
                *v13 = v12;
              else
                v13[2] = v12;
            }
            *v12 = v8;
            v8[1] = v12;
          }
          *(_BYTE *)(v8[1] + 12) = 1;
          *(_BYTE *)(*(_DWORD *)(v8[1] + 4) + 12) = 0;
          v14 = *(_DWORD **)(v8[1] + 4);
          v15 = (_DWORD *)*v14;
          *v14 = *(_DWORD *)(*v14 + 8);
          v16 = v15[2];
          if ( !*(_BYTE *)(v16 + 13) )
            *(_DWORD *)(v16 + 4) = v14;
          v15[1] = v14[1];
          if ( v14 == *(_DWORD **)(*this + 4) )
          {
            *(_DWORD *)(*this + 4) = v15;
            v15[2] = v14;
          }
          else
          {
            v17 = (_DWORD *)v14[1];
            if ( v14 == (_DWORD *)v17[2] )
              v17[2] = v15;
            else
              *v17 = v15;
            v15[2] = v14;
          }
LABEL_49:
          v14[1] = v15;
          continue;
        }
      }
      else if ( *((_BYTE *)v11 + 12) )
      {
        if ( v8 == (_DWORD *)*v9 )
        {
          v8 = (_DWORD *)v8[1];
          v18 = *v9;
          *v9 = *(_DWORD *)(*v9 + 8);
          v19 = *(_DWORD *)(v18 + 8);
          if ( !*(_BYTE *)(v19 + 13) )
            *(_DWORD *)(v19 + 4) = v8;
          *(_DWORD *)(v18 + 4) = v8[1];
          if ( v8 == *(_DWORD **)(*this + 4) )
          {
            *(_DWORD *)(*this + 4) = v18;
          }
          else
          {
            v20 = (_DWORD *)v8[1];
            if ( v8 == (_DWORD *)v20[2] )
              v20[2] = v18;
            else
              *v20 = v18;
          }
          *(_DWORD *)(v18 + 8) = v8;
          v8[1] = v18;
        }
        *(_BYTE *)(v8[1] + 12) = 1;
        *(_BYTE *)(*(_DWORD *)(v8[1] + 4) + 12) = 0;
        v14 = *(_DWORD **)(v8[1] + 4);
        v15 = (_DWORD *)v14[2];
        v14[2] = *v15;
        if ( !*(_BYTE *)(*v15 + 13) )
          *(_DWORD *)(*v15 + 4) = v14;
        v15[1] = v14[1];
        if ( v14 == *(_DWORD **)(*this + 4) )
        {
          *(_DWORD *)(*this + 4) = v15;
        }
        else
        {
          v21 = (_DWORD *)v14[1];
          if ( v14 == (_DWORD *)*v21 )
            *v21 = v15;
          else
            v21[2] = v15;
        }
        *v15 = v14;
        goto LABEL_49;
      }
      *((_BYTE *)v9 + 12) = 1;
      *((_BYTE *)v11 + 12) = 1;
      *(_BYTE *)(*(_DWORD *)(v8[1] + 4) + 12) = 0;
      v8 = *(_DWORD **)(v8[1] + 4);
    }
    while ( !*(_BYTE *)(v8[1] + 12) );
  }
  *(_BYTE *)(*(_DWORD *)(*this + 4) + 12) = 1;
  result = a2;
  *a2 = a6;
  return result;
}
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (004267B0) --------------------------------------------------------
_DWORD *__thiscall sub_4267B0(_DWORD **this, _DWORD *a2, _DWORD *a3, int *a4, void *a5)
{
  bool v5; // zf
  _DWORD *v6; // edi
  _DWORD *v7; // esi
  int v8; // ecx
  bool v9; // cc
  int v11; // [esp+0h] [ebp-38h] BYREF
  int v12[2]; // [esp+10h] [ebp-28h] BYREF
  int v13; // [esp+18h] [ebp-20h]
  int v14; // [esp+1Ch] [ebp-1Ch] BYREF
  _DWORD *v15; // [esp+20h] [ebp-18h]
  void *v16; // [esp+24h] [ebp-14h]
  int *v17; // [esp+28h] [ebp-10h]
  int v18; // [esp+34h] [ebp-4h]

  v17 = &v11;
  v15 = this;
  v5 = this[1] == 0;
  v16 = a5;
  v12[1] = (int)a5;
  v18 = 0;
  if ( v5 )
  {
    sub_4265A0(this, a2, 1, *this, (int)a4, a5);
    return a2;
  }
  v6 = *this;
  if ( a3 == (_DWORD *)**this )
  {
    if ( *a4 > a3[4] )
    {
      sub_4265A0(this, a2, 1, a3, (int)a4, v16);
      return a2;
    }
LABEL_21:
    v18 = -1;
    *a2 = *(_DWORD *)sub_426950(v15, (int)v12, 0, a4, v16);
    return a2;
  }
  if ( a3 == v6 )
  {
    v7 = (_DWORD *)v6[2];
    if ( v7[4] > *a4 )
    {
      sub_4265A0(this, a2, 0, v7, (int)a4, v16);
      return a2;
    }
    goto LABEL_21;
  }
  v8 = a3[4];
  v13 = *a4;
  v9 = v8 <= v13;
  if ( v8 < v13 )
  {
    v14 = (int)a3;
    sub_4274A0(&v14);
    if ( *(_DWORD *)(v14 + 16) > v13 )
    {
      if ( *(_BYTE *)(*(_DWORD *)(v14 + 8) + 13) )
        sub_4265A0(v15, a2, 0, (_DWORD *)v14, (int)a4, v16);
      else
        sub_4265A0(v15, a2, 1, a3, (int)a4, v16);
      return a2;
    }
    v9 = a3[4] <= v13;
  }
  if ( v9 )
    goto LABEL_21;
  v14 = (int)a3;
  sub_427450(&v14);
  if ( (_DWORD *)v14 != v6 && v13 <= *(_DWORD *)(v14 + 16) )
    goto LABEL_21;
  if ( *(_BYTE *)(a3[2] + 13) )
    sub_4265A0(v15, a2, 0, a3, (int)a4, v16);
  else
    sub_4265A0(v15, a2, 1, (_DWORD *)v14, (int)a4, v16);
  return a2;
}

//----- (00426950) --------------------------------------------------------
int __thiscall sub_426950(_DWORD *this, int a2, _DWORD *a3, _DWORD *a4, void *a5)
{
  _DWORD *v5; // ecx
  bool v6; // dl
  _DWORD *v7; // ebx
  _DWORD *v8; // edi
  int *v9; // eax
  int v10; // ecx
  int v11; // esi
  int *v12; // eax
  int v13; // ecx
  int result; // eax
  int v15; // [esp+0h] [ebp-2Ch] BYREF
  _DWORD *v16; // [esp+10h] [ebp-1Ch]
  _DWORD *v17; // [esp+14h] [ebp-18h]
  int v18; // [esp+18h] [ebp-14h]
  int *v19; // [esp+1Ch] [ebp-10h]
  int v20; // [esp+28h] [ebp-4h]

  v19 = &v15;
  v17 = this;
  v5 = (_DWORD *)*this;
  v6 = 1;
  v7 = a4;
  v8 = v5;
  v20 = 0;
  v16 = v5;
  v9 = (int *)v5[1];
  LOBYTE(v18) = 1;
  if ( !*((_BYTE *)v9 + 13) )
  {
    v10 = *a4;
    do
    {
      v8 = v9;
      if ( (_BYTE)a3 )
        v6 = v9[4] <= v10;
      else
        v6 = v10 > v9[4];
      LOBYTE(v18) = v6;
      if ( v6 )
        v9 = (int *)*v9;
      else
        v9 = (int *)v9[2];
    }
    while ( !*((_BYTE *)v9 + 13) );
    v5 = v16;
  }
  v11 = (int)v8;
  a3 = v8;
  if ( v6 )
  {
    if ( v8 == (_DWORD *)*v5 )
    {
      v12 = sub_4265A0(v17, &a3, 1, v8, (int)a4, a5);
LABEL_14:
      v13 = *v12;
      result = a2;
      *(_DWORD *)a2 = v13;
      *(_BYTE *)(a2 + 4) = 1;
      return result;
    }
    sub_4274A0(&a3);
    v11 = (int)a3;
  }
  if ( *(_DWORD *)(v11 + 16) > *v7 )
  {
    v12 = sub_4265A0(v17, &a3, v18, v8, (int)v7, a5);
    goto LABEL_14;
  }
  operator delete(a5);
  result = a2;
  *(_DWORD *)a2 = v11;
  *(_BYTE *)(a2 + 4) = 0;
  return result;
}

//----- (00426A70) --------------------------------------------------------
int __stdcall sub_426A70(int a1, int *a2)
{
  int result; // eax

  if ( a1 != -8 )
  {
    result = *a2;
    *(_DWORD *)(a1 + 8) = *a2;
  }
  return result;
}

//----- (00426A90) --------------------------------------------------------
int __stdcall sub_426A90(int a1, _DWORD *a2)
{
  int result; // eax

  if ( a1 != -8 )
  {
    *(_DWORD *)(a1 + 8) = *a2;
    result = a2[1];
    *(_DWORD *)(a1 + 12) = result;
  }
  return result;
}

//----- (00426AB0) --------------------------------------------------------
int __cdecl sub_426AB0(int a1, int a2, int a3)
{
  int v3; // esi
  _DWORD v6[6]; // [esp+0h] [ebp-24h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  v6[5] = v6;
  v3 = a3;
  v6[4] = a3;
  v7 = 0;
  while ( a1 != a2 )
  {
    LOBYTE(v7) = 1;
    if ( v3 )
    {
      *(_QWORD *)v3 = *(_QWORD *)a1;
      sub_404A00(v3 + 8, (const __m128i **)(a1 + 8));
      *(_DWORD *)(v3 + 20) = *(_DWORD *)(a1 + 20);
      *(_QWORD *)(v3 + 24) = *(_QWORD *)(a1 + 24);
    }
    v3 += 32;
    LOBYTE(v7) = 0;
    a1 += 32;
  }
  return v3;
}

//----- (00426B70) --------------------------------------------------------
void __cdecl sub_426B70(int a1, int a2)
{
  int i; // ecx

  for ( i = a2; i; --i )
  {
    if ( a1 )
    {
      *(_OWORD *)a1 = 0i64;
      *(_OWORD *)(a1 + 16) = 0i64;
      *(_QWORD *)(a1 + 32) = 0i64;
    }
    a1 += 40;
  }
}

//----- (00426BA0) --------------------------------------------------------
_DWORD *__usercall sub_426BA0@<eax>(_DWORD *result@<eax>, int a2, int a3)
{
  int v3; // edx

  v3 = a3;
  if ( a3 )
  {
    result = (_DWORD *)(a2 + 16);
    do
    {
      if ( result != (_DWORD *)16 )
      {
        *(result - 4) = &DwCParagraph::`vftable';
        *(result - 2) = 0;
        *(result - 1) = 0;
        *result = 0;
      }
      result += 14;
      --v3;
    }
    while ( v3 );
  }
  return result;
}
// 43A180: using guessed type void *DwCParagraph::`vftable';

//----- (00426BE0) --------------------------------------------------------
_DWORD *__usercall sub_426BE0@<eax>(_DWORD *result@<eax>, int a2, int a3)
{
  int v3; // edx

  v3 = a3;
  if ( a3 )
  {
    result = (_DWORD *)(a2 + 16);
    do
    {
      if ( result != (_DWORD *)16 )
      {
        *(result - 2) = 0;
        *(result - 1) = 0;
        *result = 0;
      }
      result += 8;
      --v3;
    }
    while ( v3 );
  }
  return result;
}

//----- (00426C20) --------------------------------------------------------
int __cdecl sub_426C20(int a1, int a2, int a3)
{
  int v3; // esi
  _DWORD v6[6]; // [esp+0h] [ebp-24h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  v6[5] = v6;
  v3 = a3;
  v6[4] = a3;
  v7 = 0;
  while ( a1 != a2 )
  {
    LOBYTE(v7) = 1;
    if ( v3 )
    {
      *(_DWORD *)v3 = &DwCParagraph::`vftable';
      sub_426EE0((int *)(v3 + 8), (int *)(a1 + 8));
      *(__m128i *)(v3 + 24) = _mm_loadu_si128((const __m128i *)(a1 + 24));
      *(__m128i *)(v3 + 40) = _mm_loadu_si128((const __m128i *)(a1 + 40));
    }
    v3 += 56;
    LOBYTE(v7) = 0;
    a1 += 56;
  }
  return v3;
}
// 43A180: using guessed type void *DwCParagraph::`vftable';

//----- (00426CE0) --------------------------------------------------------
_DWORD *__thiscall sub_426CE0(_DWORD *this, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v4; // esi
  _DWORD *v5; // eax
  _DWORD *v6; // ecx
  _DWORD *v7; // edi
  int v8; // edx
  int v9; // eax
  int v11; // [esp+0h] [ebp-28h] BYREF
  int v12[6]; // [esp+10h] [ebp-18h] BYREF

  v12[2] = (int)&v11;
  v4 = (_DWORD *)*this;
  v5 = a2;
  v12[0] = (int)this;
  v12[5] = 0;
  while ( 1 )
  {
    v6 = a3;
    v4 = (_DWORD *)*v4;
    if ( v5 == a3 )
      break;
    if ( v4 == (_DWORD *)*this )
    {
      while ( v5 != v6 )
      {
        v7 = (_DWORD *)*this;
        v8 = sub_426520((_DWORD *)*this, *(_DWORD **)(*this + 4), v5 + 2);
        v9 = this[1];
        if ( v9 == 357913940 )
          std::_Xlength_error("list<T> too long");
        this[1] = v9 + 1;
        v7[1] = v8;
        **(_DWORD **)(v8 + 4) = v8;
        v6 = a3;
        v5 = (_DWORD *)*a2;
        a2 = (_DWORD *)*a2;
      }
      return sub_42B8B0(this, v12, (_DWORD **)v4, (_DWORD **)*this);
    }
    sub_426A70((int)v4, v5 + 2);
    v5 = (_DWORD *)*a2;
    a2 = (_DWORD *)*a2;
  }
  return sub_42B8B0(this, v12, (_DWORD **)v4, (_DWORD **)*this);
}
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (00426DD0) --------------------------------------------------------
_DWORD *__thiscall sub_426DD0(_DWORD *this, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v4; // esi
  _DWORD *v5; // eax
  _DWORD *v6; // ecx
  _DWORD *v7; // edi
  int v8; // eax
  int v9; // edx
  int v10; // eax
  int v12; // [esp+0h] [ebp-28h] BYREF
  int v13[6]; // [esp+10h] [ebp-18h] BYREF

  v13[2] = (int)&v12;
  v4 = (_DWORD *)*this;
  v5 = a2;
  v13[0] = (int)this;
  v13[5] = 0;
  while ( 1 )
  {
    v6 = a3;
    v4 = (_DWORD *)*v4;
    if ( v5 == a3 )
      break;
    if ( v4 == (_DWORD *)*this )
    {
      while ( v5 != v6 )
      {
        v7 = (_DWORD *)*this;
        sub_426570((_DWORD *)*this, *(_DWORD **)(*this + 4), v5 + 2);
        v9 = v8;
        v10 = this[1];
        if ( v10 == 268435454 )
          std::_Xlength_error("list<T> too long");
        this[1] = v10 + 1;
        v7[1] = v9;
        **(_DWORD **)(v9 + 4) = v9;
        v6 = a3;
        v5 = (_DWORD *)*a2;
        a2 = (_DWORD *)*a2;
      }
      return sub_42B8B0(this, v13, (_DWORD **)v4, (_DWORD **)*this);
    }
    sub_426A90((int)v4, v5 + 2);
    v5 = (_DWORD *)*a2;
    a2 = (_DWORD *)*a2;
  }
  return sub_42B8B0(this, v13, (_DWORD **)v4, (_DWORD **)*this);
}
// 426E47: variable 'v8' is possibly undefined
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (00426EC0) --------------------------------------------------------
void __thiscall sub_426EC0(_DWORD *this)
{
  int v2; // eax

  *this = 0;
  this[1] = 0;
  sub_42AD80(0, 0);
  *this = v2;
}
// 426ED9: variable 'v2' is possibly undefined

//----- (00426EE0) --------------------------------------------------------
int *__thiscall sub_426EE0(int *this, int *a2)
{
  int v4; // [esp-4h] [ebp-2Ch]
  _DWORD v5[10]; // [esp+0h] [ebp-28h] BYREF

  v5[6] = v5;
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  v4 = (a2[1] - *a2) >> 5;
  v5[4] = this;
  if ( sub_405390(this, v4) )
  {
    v5[9] = 0;
    this[1] = sub_426AB0(*a2, a2[1], *this);
  }
  return this;
}

//----- (00426F90) --------------------------------------------------------
_DWORD *__thiscall sub_426F90(_DWORD *this)
{
  int v2; // eax
  _DWORD *v3; // eax
  _DWORD *v4; // esi
  _DWORD *result; // eax

  *this = &CConnectedAnalysis::`vftable';
  this[4] = &DwCTwoDimArray<float>::`vftable';
  this[5] = 0;
  this[6] = 0;
  this[8] = 0;
  this[7] = 0;
  this[9] = 0;
  this[10] = 0;
  this[11] = 0;
  this[12] = 0;
  this[15] = &DwCDelaunayTriangulation::`vftable';
  this[23] = 0;
  this[24] = 0;
  sub_42AD50();
  this[23] = v2;
  this[25] = 0;
  this[26] = 0;
  this[27] = 0;
  this[16] = 0;
  this[21] = 0;
  this[22] = 0;
  v3 = operator new[](0xC35004u);
  if ( v3 )
  {
    v4 = v3 + 1;
    *v3 = 200000;
    `eh vector constructor iterator'(
      v3 + 1,
      0x40u,
      200000,
      (void (__thiscall *)(void *))sub_427130,
      (void (__thiscall *)(void *))sub_427310);
  }
  else
  {
    v4 = 0;
  }
  this[3] = v4;
  this[14] = operator new[](0xC3500u);
  this[13] = 0;
  result = this;
  this[31] = 0;
  this[32] = 0;
  this[33] = 0;
  this[30] = 0;
  return result;
}
// 427025: variable 'v2' is possibly undefined
// 43A11C: using guessed type void *DwCDelaunayTriangulation::`vftable';
// 43A178: using guessed type void *DwCTwoDimArray<float>::`vftable';
// 43A188: using guessed type void *CConnectedAnalysis::`vftable';

//----- (004270F0) --------------------------------------------------------
_DWORD *__thiscall sub_4270F0(_DWORD *this, int a2, int a3)
{
  int Mat; // eax

  *this = &CMyMatrix::`vftable';
  this[2] = 0;
  sub_403EE0(this);
  this[3] = a2;
  this[4] = a3;
  Mat = cvCreateMat(a2, a3, 5);
  this[2] = Mat;
  this[1] = *(_DWORD *)(Mat + 16);
  return this;
}
// 436860: using guessed type int __cdecl cvCreateMat(_DWORD, _DWORD, _DWORD);
// 43931C: using guessed type void *CMyMatrix::`vftable';

//----- (00427130) --------------------------------------------------------
void __thiscall sub_427130(_DWORD *this)
{
  int v2; // eax
  int v3; // eax

  *this = 0;
  this[1] = 0;
  sub_42ADC0(0, 0);
  *this = v2;
  this[6] = 0;
  this[7] = 0;
  sub_42AD80(0, 0);
  this[6] = v3;
  *((_BYTE *)this + 12) = 0;
  this[4] = -1;
}
// 427170: variable 'v2' is possibly undefined
// 427193: variable 'v3' is possibly undefined

//----- (004271F0) --------------------------------------------------------
void __thiscall sub_4271F0(_DWORD *this)
{
  _DWORD *v2; // edx
  _DWORD *v3; // esi

  v2 = *(_DWORD **)*this;
  *(_DWORD *)*this = *this;
  *(_DWORD *)(*this + 4) = *this;
  this[1] = 0;
  if ( v2 != (_DWORD *)*this )
  {
    do
    {
      v3 = (_DWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while ( v3 != (_DWORD *)*this );
  }
  operator delete((void *)*this);
}

//----- (00427250) --------------------------------------------------------
void __thiscall sub_427250(int this)
{
  char *v2; // eax
  char *v3; // esi

  *(_DWORD *)this = &CConnectedAnalysis::`vftable';
  v2 = *(char **)(this + 12);
  if ( v2 )
  {
    v3 = v2 - 4;
    `eh vector destructor iterator'(v2, 0x40u, *((_DWORD *)v2 - 1), (void (__thiscall *)(void *))sub_427310);
    operator delete[](v3);
  }
  operator delete[](*(void **)(this + 56));
  sub_428080((int *)this);
  sub_42D7B0((char *)(this + 60));
  *(_DWORD *)(this + 16) = &DwCTwoDimArray<float>::`vftable';
  sub_431900(this + 16);
  if ( *(_DWORD *)(this + 44) )
    operator delete[](*(void **)(this + 44));
  if ( *(_DWORD *)(this + 48) )
    operator delete[](*(void **)(this + 48));
}
// 43A178: using guessed type void *DwCTwoDimArray<float>::`vftable';
// 43A188: using guessed type void *CConnectedAnalysis::`vftable';

//----- (00427310) --------------------------------------------------------
void __thiscall sub_427310(void **this)
{
  _DWORD *v2; // eax
  _DWORD *v3; // ecx
  _DWORD *v4; // esi
  _DWORD **v5; // eax
  _DWORD *v6; // ecx
  _DWORD *v7; // esi
  _DWORD *v8; // ecx
  _DWORD *v9; // esi

  v2 = *this;
  v3 = *(_DWORD **)*this;
  *v2 = v2;
  *((_DWORD *)*this + 1) = *this;
  this[1] = 0;
  if ( v3 != *this )
  {
    do
    {
      v4 = (_DWORD *)*v3;
      operator delete(v3);
      v3 = v4;
    }
    while ( v4 != *this );
  }
  v5 = (_DWORD **)this[6];
  v6 = *v5;
  *v5 = v5;
  *((_DWORD *)this[6] + 1) = this[6];
  this[7] = 0;
  if ( v6 != this[6] )
  {
    do
    {
      v7 = (_DWORD *)*v6;
      operator delete(v6);
      v6 = v7;
    }
    while ( v7 != this[6] );
  }
  operator delete(this[6]);
  v8 = *(_DWORD **)*this;
  *(_DWORD *)*this = *this;
  *((_DWORD *)*this + 1) = *this;
  this[1] = 0;
  if ( v8 != *this )
  {
    do
    {
      v9 = (_DWORD *)*v8;
      operator delete(v8);
      v8 = v9;
    }
    while ( v9 != *this );
  }
  operator delete(*this);
}

//----- (004273C0) --------------------------------------------------------
_DWORD *__thiscall sub_4273C0(_DWORD *this, _DWORD *a2)
{
  _DWORD *v3; // esi
  int *v4; // eax
  int *v6; // eax
  _DWORD *v7; // [esp+Ch] [ebp-4h] BYREF

  v3 = (_DWORD *)*this;
  v4 = *(int **)(*this + 4);
  while ( !*((_BYTE *)v4 + 13) )
  {
    if ( v4[4] <= *a2 )
    {
      v3 = v4;
      v4 = (int *)*v4;
    }
    else
    {
      v4 = (int *)v4[2];
    }
  }
  if ( v3 != (_DWORD *)*this && *a2 <= v3[4] )
    return v3 + 5;
  v7 = a2;
  v6 = sub_426540(this, (int)&unk_501983, &v7, (int)&a2 + 3);
  sub_4267B0((_DWORD **)this, &a2, v3, v6 + 4, v6);
  return a2 + 5;
}

//----- (00427450) --------------------------------------------------------
int *__thiscall sub_427450(int *this)
{
  int v2; // eax
  int **v3; // ecx
  int *j; // eax
  int i; // eax

  v2 = *this;
  if ( *(_BYTE *)(*this + 13) )
    return this;
  v3 = *(int ***)(v2 + 8);
  if ( *((_BYTE *)v3 + 13) )
  {
    for ( i = *(_DWORD *)(v2 + 4); !*(_BYTE *)(i + 13); i = *(_DWORD *)(i + 4) )
    {
      if ( *this != *(_DWORD *)(i + 8) )
        break;
      *this = i;
    }
    *this = i;
    return this;
  }
  for ( j = *v3; !*((_BYTE *)j + 13); j = (int *)*j )
    v3 = (int **)j;
  *this = (int)v3;
  return this;
}

//----- (004274A0) --------------------------------------------------------
void *__thiscall sub_4274A0(void *this)
{
  _DWORD *v2; // eax
  int i; // ecx
  int v5; // eax
  int v6; // ecx

  v2 = *(_DWORD **)this;
  if ( *(_BYTE *)(*(_DWORD *)this + 13) )
  {
    *(_DWORD *)this = v2[2];
    return this;
  }
  i = *v2;
  if ( *(_BYTE *)(*v2 + 13) )
  {
    for ( i = v2[1]; !*(_BYTE *)(i + 13); i = *(_DWORD *)(i + 4) )
    {
      if ( *(_DWORD *)this != *(_DWORD *)i )
        break;
      *(_DWORD *)this = i;
    }
    if ( *(_BYTE *)(*(_DWORD *)this + 13) )
      return this;
    goto LABEL_11;
  }
  v5 = *(_DWORD *)(i + 8);
  if ( *(_BYTE *)(v5 + 13) )
  {
LABEL_11:
    *(_DWORD *)this = i;
    return this;
  }
  do
  {
    v6 = v5;
    v5 = *(_DWORD *)(v5 + 8);
  }
  while ( !*(_BYTE *)(v5 + 13) );
  *(_DWORD *)this = v6;
  return this;
}

//----- (00427500) --------------------------------------------------------
char *__thiscall sub_427500(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(this, 0xA8u, *((_DWORD *)this - 1), sub_431480);
    if ( (a2 & 1) != 0 )
      operator delete[](this - 4);
    return this - 4;
  }
  else
  {
    sub_431480(this);
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}

//----- (00427560) --------------------------------------------------------
void **__thiscall sub_427560(void **this, char a2)
{
  *this = &DwCTwoDimArray<float>::`vftable';
  sub_431900((int)this);
  if ( this[7] )
    operator delete[](this[7]);
  if ( this[8] )
    operator delete[](this[8]);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 43A178: using guessed type void *DwCTwoDimArray<float>::`vftable';

//----- (004275B0) --------------------------------------------------------
void *__thiscall sub_4275B0(void *this, char a2)
{
  sub_427250((int)this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (004275E0) --------------------------------------------------------
char *__thiscall sub_4275E0(char *this, char a2)
{
  sub_42D7B0(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (00427610) --------------------------------------------------------
_DWORD *__thiscall sub_427610(_DWORD *this, char a2)
{
  int v3; // eax

  *this = &DwCParagraph::`vftable';
  sub_404130(this[2], this[3]);
  v3 = this[2];
  this[3] = v3;
  if ( v3 )
  {
    sub_404130(v3, v3);
    operator delete((void *)this[2]);
    this[2] = 0;
    this[3] = 0;
    this[4] = 0;
  }
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 43A180: using guessed type void *DwCParagraph::`vftable';

//----- (00427690) --------------------------------------------------------
void **__thiscall sub_427690(void **this, char a2)
{
  sub_42DB60(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (004276C0) --------------------------------------------------------
int __thiscall sub_4276C0(_DWORD *this)
{
  _DWORD *v1; // esi
  bool v2; // cc
  int v3; // edi
  int v4; // eax
  int v5; // edx
  _DWORD *v6; // ecx
  _DWORD *v7; // eax
  int v8; // esi
  int v9; // edx
  int v10; // esi
  double v11; // xmm7_8
  double v12; // xmm3_8
  double v13; // xmm4_8
  double v14; // xmm6_8
  double v15; // xmm5_8
  int v16; // ecx
  int v17; // edx
  double v18; // xmm1_8
  double v19; // xmm0_8
  double v20; // xmm3_8
  double v21; // xmm5_8
  float v22; // xmm0_4
  float v23; // xmm0_4
  int v24; // ecx
  int v26; // [esp+0h] [ebp-C3584h]
  int v27; // [esp+0h] [ebp-C3584h]
  int v28; // [esp+4h] [ebp-C3580h]
  int v29; // [esp+4h] [ebp-C3580h]
  int v30; // [esp+8h] [ebp-C357Ch]
  int v31; // [esp+8h] [ebp-C357Ch]
  int v32; // [esp+Ch] [ebp-C3578h]
  int v33; // [esp+Ch] [ebp-C3578h]
  int v34; // [esp+10h] [ebp-C3574h]
  int v36; // [esp+18h] [ebp-C356Ch]
  int v37[100000]; // [esp+1Ch] [ebp-C3568h]
  int v38[100001]; // [esp+61A9Ch] [ebp-61AE8h]
  __int128 v39; // [esp+C3520h] [ebp-64h] BYREF
  int v40; // [esp+C3530h] [ebp-54h]
  __int128 v41; // [esp+C3534h] [ebp-50h] BYREF
  int v42; // [esp+C3544h] [ebp-40h]
  __int128 v43; // [esp+C3548h] [ebp-3Ch] BYREF
  int v44; // [esp+C3558h] [ebp-2Ch]
  __int128 v45; // [esp+C355Ch] [ebp-28h] BYREF
  int v46; // [esp+C356Ch] [ebp-18h]
  int v47; // [esp+C3580h] [ebp-4h]

  v1 = this;
  v42 = 0;
  v41 = 0i64;
  LODWORD(v41) = &CMyMatrix::`vftable';
  DWORD2(v41) = 0;
  sub_403EE0(&v41);
  HIDWORD(v41) = 2;
  v42 = 2;
  DWORD2(v41) = cvCreateMat(2, 2, 5);
  DWORD1(v41) = *(_DWORD *)(DWORD2(v41) + 16);
  v47 = 0;
  v43 = 0i64;
  v44 = 0;
  LODWORD(v43) = &CMyMatrix::`vftable';
  DWORD2(v43) = 0;
  sub_403EE0(&v43);
  HIDWORD(v43) = 2;
  v44 = 1;
  DWORD2(v43) = cvCreateMat(2, 1, 5);
  DWORD1(v43) = *(_DWORD *)(DWORD2(v43) + 16);
  LOBYTE(v47) = 1;
  v39 = 0i64;
  v40 = 0;
  LODWORD(v39) = &CMyMatrix::`vftable';
  DWORD2(v39) = 0;
  sub_403EE0(&v39);
  HIDWORD(v39) = 2;
  v40 = 2;
  DWORD2(v39) = cvCreateMat(2, 2, 5);
  DWORD1(v39) = *(_DWORD *)(DWORD2(v39) + 16);
  LOBYTE(v47) = 2;
  v45 = 0i64;
  v46 = 0;
  LODWORD(v45) = &CMyMatrix::`vftable';
  DWORD2(v45) = 0;
  sub_403EE0(&v45);
  HIDWORD(v45) = 2;
  v46 = 2;
  DWORD2(v45) = cvCreateMat(2, 2, 5);
  v2 = v1[1] <= 0;
  v32 = 0;
  DWORD1(v45) = *(_DWORD *)(DWORD2(v45) + 16);
  if ( !v2 )
  {
    v3 = 0;
    do
    {
      v4 = v1[3];
      v36 = v4;
      v5 = *(_DWORD *)(v3 + v4 + 4);
      v34 = v5;
      if ( v5 <= 100000 )
      {
        v6 = *(_DWORD **)(v3 + v4);
        v7 = (_DWORD *)*v6;
        if ( (_DWORD *)*v6 != v6 )
        {
          v8 = 0;
          do
          {
            v37[++v8 + 99999] = v7[2];
            v9 = v7[3];
            v7 = (_DWORD *)*v7;
            v37[v8 - 1] = v9;
          }
          while ( v7 != v6 );
          v1 = this;
          v5 = v34;
        }
        if ( v5 > 5 )
        {
          v10 = 0;
          v11 = 0.0;
          v12 = 0.0;
          v13 = 0.0;
          v14 = 0.0;
          v15 = 0.0;
          do
          {
            v16 = v38[v10];
            v17 = v37[v10++];
            v11 = v11 + (double)v16;
            v12 = v12 + (double)v17;
            v15 = v15 + (double)(v16 * v17);
            v13 = v13 + (double)(v16 * v16);
            v14 = v14 + (double)(v17 * v17);
          }
          while ( v10 < v34 );
          v18 = (double)v34;
          v1 = this;
          v19 = v18 * v11 / v18 * v12;
          v20 = v12 / (double)v34;
          v21 = (v15 - v19 / v18) / v18;
          *(float *)&v19 = (v13 - v11 / v18 * (v11 / v18) * v18) / v18;
          *(_DWORD *)DWORD1(v41) = LODWORD(v19);
          *(float *)&v19 = v21;
          *(_DWORD *)(DWORD1(v41) + 4) = LODWORD(v19);
          *(_DWORD *)(DWORD1(v41) + 4 * v42) = LODWORD(v19);
          *(float *)&v19 = (v14 - v20 * v20 * v18) / v18;
          *(_DWORD *)(DWORD1(v41) + 4 * v42 + 4) = LODWORD(v19);
          *(float *)&v19 = v11 / (double)v34;
          *(_DWORD *)(v3 + this[3] + 32) = LODWORD(v19);
          *(float *)&v19 = v20;
          *(_DWORD *)(v3 + this[3] + 36) = LODWORD(v19);
          cvSVD(DWORD2(v41), DWORD2(v43), DWORD2(v39), DWORD2(v45), 0);
          v22 = *(double *)libm_sse2_sqrt_precise(v26, v28, v30, v32).m128_u64;
          *(float *)(v3 + this[3] + 40) = v22;
          v23 = *(double *)libm_sse2_sqrt_precise(v27, v29, v31, v33).m128_u64;
          *(float *)(v3 + this[3] + 44) = v23;
          v24 = this[3];
          if ( *(float *)(v3 + v24 + 44) > *(float *)(v3 + v24 + 40) )
            exit(0);
          *(_DWORD *)(v3 + v24 + 48) = *(_DWORD *)DWORD1(v39);
          *(_DWORD *)(v3 + this[3] + 52) = *(_DWORD *)(DWORD1(v39) + 4 * v40);
          *(_DWORD *)(v3 + this[3] + 56) = *(_DWORD *)(DWORD1(v39) + 4);
          *(_DWORD *)(v3 + this[3] + 60) = *(_DWORD *)(DWORD1(v39) + 4 * v40 + 4);
        }
        else
        {
          *(float *)(v3 + v36 + 32) = (float)v38[0];
          *(float *)(v3 + v1[3] + 36) = (float)v37[0];
          *(_DWORD *)(v3 + v1[3] + 40) = 1065353216;
          *(_DWORD *)(v3 + v1[3] + 44) = 1065353216;
          *(_DWORD *)(v3 + v1[3] + 48) = 1065353216;
          *(_DWORD *)(v3 + v1[3] + 52) = 0;
          *(_DWORD *)(v3 + v1[3] + 56) = 0;
          *(_DWORD *)(v3 + v1[3] + 60) = 1065353216;
        }
      }
      else
      {
        *(_BYTE *)(v3 + v4 + 12) = 1;
      }
      v3 += 64;
      ++v32;
    }
    while ( v32 < v1[1] );
  }
  sub_403E70(&v45);
  LOBYTE(v47) = 1;
  sub_403E70(&v39);
  LOBYTE(v47) = 0;
  sub_403E70(&v43);
  v47 = -1;
  return sub_403E70(&v41);
}
// 4279C9: conditional instruction was optimized away because edx.4>=6
// 427B2E: variable 'v26' is possibly undefined
// 427B2E: variable 'v28' is possibly undefined
// 427B2E: variable 'v30' is possibly undefined
// 427B56: variable 'v27' is possibly undefined
// 427B56: variable 'v29' is possibly undefined
// 427B56: variable 'v31' is possibly undefined
// 427B56: variable 'v33' is possibly undefined
// 427BD3: variable 'v32' is possibly undefined
// 436860: using guessed type int __cdecl cvCreateMat(_DWORD, _DWORD, _DWORD);
// 436872: using guessed type int __cdecl cvSVD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);
// 43931C: using guessed type void *CMyMatrix::`vftable';
// 4276C0: using guessed type int var_61AE8[100001];

//----- (00427C60) --------------------------------------------------------
void __thiscall sub_427C60(_DWORD *this, float a2)
{
  int v3; // esi
  int v4; // edi

  v3 = 0;
  if ( (int)this[2] > 0 )
  {
    v4 = 0;
    do
    {
      sub_431850((void *)(v4 + this[13]), a2);
      ++v3;
      v4 += 168;
    }
    while ( v3 < this[2] );
  }
}

//----- (00427CA0) --------------------------------------------------------
void __thiscall sub_427CA0(_DWORD *this, float a2)
{
  int v3; // esi
  int v4; // edi

  v3 = 0;
  if ( (int)this[2] > 0 )
  {
    v4 = 0;
    do
    {
      sub_431870(v4 + this[13], a2);
      ++v3;
      v4 += 168;
    }
    while ( v3 < this[2] );
  }
}

//----- (00427CE0) --------------------------------------------------------
int __thiscall sub_427CE0(_DWORD *this, int a2)
{
  unsigned int v3; // edi
  int v4; // ecx
  _BYTE *v5; // eax
  int *v6; // ebx
  void (__thiscall ***v7)(_DWORD, _DWORD); // esi
  void (__thiscall ***v8)(_DWORD, _DWORD); // ebx
  int result; // eax
  int v10; // ecx
  int v11; // esi
  int v12; // edi
  int v13; // edx
  int v14; // ecx
  int v15; // eax
  _DWORD *v16; // esi
  _DWORD *v17; // ebx
  void *v18; // eax
  signed int v19; // esi
  int v20; // ecx
  int *v21; // edx
  int v22; // ebx
  int v23; // esi
  int v24; // eax
  _DWORD *v25; // eax
  int v26; // edi
  int v27; // esi
  float v28; // xmm1_4
  double v29; // xmm0_8
  int v30; // ecx
  int v31; // esi
  int v32; // esi
  int v33; // eax
  __m128d v34; // xmm2
  __m128i v35; // xmm0
  __m128i v36; // xmm1
  int v37; // eax
  __m128i v38; // [esp+Ch] [ebp-34h] BYREF
  _DWORD *v39; // [esp+1Ch] [ebp-24h]
  int v40; // [esp+20h] [ebp-20h]
  int v41; // [esp+24h] [ebp-1Ch]
  int v42; // [esp+28h] [ebp-18h]
  int v43; // [esp+2Ch] [ebp-14h]
  int v44; // [esp+30h] [ebp-10h]
  int v45; // [esp+34h] [ebp-Ch]
  int v46; // [esp+38h] [ebp-8h]
  _DWORD *v47; // [esp+3Ch] [ebp-4h]
  int *v48; // [esp+48h] [ebp+8h]

  v3 = 0;
  v47 = this;
  v4 = this[2];
  if ( v4 > 0 )
  {
    v5 = (_BYTE *)(this[13] + 80);
    do
    {
      if ( *v5 == 1 )
        ++v3;
      v5 += 168;
      --v4;
    }
    while ( v4 );
  }
  v6 = (int *)(a2 + 8);
  v48 = v6;
  v7 = (void (__thiscall ***)(_DWORD, _DWORD))*v6;
  if ( *v6 != v6[1] )
  {
    v8 = (void (__thiscall ***)(_DWORD, _DWORD))v6[1];
    do
    {
      (**v7)(v7, 0);
      v7 += 14;
    }
    while ( v7 != v8 );
    v6 = v48;
  }
  v6[1] = *v6;
  result = sub_42BB40(v6, v3);
  v10 = (int)v47;
  v11 = 0;
  v45 = 0;
  v40 = 0;
  if ( (int)v47[2] > 0 )
  {
    v12 = 0;
    result = 0;
    v44 = 0;
    v46 = 0;
    do
    {
      v13 = *(_DWORD *)(v10 + 52);
      if ( *(_BYTE *)(result + v13 + 80) == 1 )
      {
        v14 = *v6;
        v41 = *(_DWORD *)(result + v13 + 8);
        v43 = v14;
        v15 = *(_DWORD *)(v12 + v14 + 12);
        v16 = *(_DWORD **)(v12 + v14 + 8);
        v42 = v15;
        if ( v16 != (_DWORD *)v15 )
        {
          v17 = (_DWORD *)v15;
          do
          {
            v18 = (void *)v16[2];
            v16[3] = v18;
            if ( v18 )
            {
              operator delete(v18);
              v16[2] = 0;
              v16[3] = 0;
              v16[4] = 0;
            }
            v16 += 8;
          }
          while ( v16 != v17 );
          v6 = v48;
          v14 = v43;
        }
        v19 = v41;
        *(_DWORD *)(v12 + v14 + 12) = *(_DWORD *)(v12 + v14 + 8);
        sub_42BC70((int *)(v12 + *v6 + 8), v19);
        v20 = 0;
        v42 = 0;
        if ( v19 > 0 )
        {
          v21 = v48;
          v22 = 0;
          do
          {
            v23 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v46 + v47[13] + 12) + 4 * v20) + 8);
            v24 = *v21;
            v39 = (_DWORD *)v23;
            sub_42BA60((_DWORD *)(v22 + *(_DWORD *)(v12 + v24 + 8) + 8), *(_DWORD *)(v23 + 4));
            v21 = v48;
            *(_DWORD *)(*(_DWORD *)(v12 + *v48 + 8) + v22 + 20) = v45;
            v25 = **(_DWORD ***)v23;
            if ( v25 != *(_DWORD **)v23 )
            {
              v43 = 0;
              do
              {
                v26 = v25[2] << 6;
                v27 = *(_DWORD *)(v46 + v47[13] + 16);
                v28 = *(float *)(v27 + v26 + 36);
                v29 = *(float *)(v27 + v26 + 32);
                v30 = *(_DWORD *)(v27 + v26 + 8);
                v31 = v43;
                v12 = v44;
                *(_DWORD *)(v43 + *(_DWORD *)(*(_DWORD *)(v44 + *v21 + 8) + v22 + 8)) = v30;
                v21 = v48;
                *(double *)(*(_DWORD *)(*(_DWORD *)(v12 + *v48 + 8) + v22 + 8) + v31 + 8) = v29;
                *(double *)(*(_DWORD *)(*(_DWORD *)(v12 + *v48 + 8) + v22 + 8) + v31 + 16) = v28;
                *(_QWORD *)(*(_DWORD *)(*(_DWORD *)(v12 + *v48 + 8) + v22 + 8) + v31 + 24) = 0i64;
                *(_QWORD *)(*(_DWORD *)(*(_DWORD *)(v12 + *v48 + 8) + v22 + 8) + v31 + 32) = 0i64;
                v25 = (_DWORD *)*v25;
                v43 = v31 + 40;
              }
              while ( v25 != (_DWORD *)*v39 );
            }
            v22 += 32;
            v20 = v42 + 1;
            v42 = v20;
          }
          while ( v20 < v41 );
          v6 = v48;
        }
        v38 = (__m128i)COERCE_UNSIGNED_INT64((double)(rand() % 128 + 128));
        v32 = rand() % 128;
        v33 = rand() % 128;
        v34 = (__m128d)_mm_loadu_si128(&v38);
        ++v45;
        v10 = (int)v47;
        v35 = _mm_cvtsi32_si128(v32 + 128);
        v11 = v40;
        v36 = _mm_cvtsi32_si128(v33 + 128);
        v37 = *v6;
        *(__m128d *)(v12 + v37 + 24) = _mm_unpacklo_pd(v34, _mm_cvtepi32_pd(v35));
        *(__m128d *)(v12 + v37 + 40) = _mm_unpacklo_pd(_mm_cvtepi32_pd(v36), (__m128d)0i64);
        result = v46;
        v12 += 56;
        v44 = v12;
      }
      ++v11;
      result += 168;
      v40 = v11;
      v46 = result;
    }
    while ( v11 < *(_DWORD *)(v10 + 8) );
  }
  return result;
}

//----- (00427FB0) --------------------------------------------------------
void __thiscall sub_427FB0(_DWORD *this)
{
  _DWORD *v1; // edi
  int i; // ebx
  int v3; // eax
  _DWORD **v4; // ecx
  _DWORD *v5; // edi
  _DWORD *v6; // eax
  _DWORD *v7; // esi
  char *v8; // eax
  char *v9; // esi

  v1 = this;
  for ( i = 0; i < this[1]; ++i )
  {
    v3 = v1[12];
    v4 = *(_DWORD ***)(v3 + 8 * i);
    v5 = (_DWORD *)(v3 + 8 * i);
    v6 = *v4;
    *v4 = v4;
    *(_DWORD *)(*v5 + 4) = *v5;
    v5[1] = 0;
    if ( v6 != (_DWORD *)*v5 )
    {
      do
      {
        v7 = (_DWORD *)*v6;
        operator delete(v6);
        v6 = v7;
      }
      while ( v7 != (_DWORD *)*v5 );
    }
    v1 = this;
  }
  v8 = (char *)v1[12];
  if ( v8 )
  {
    v9 = v8 - 4;
    `eh vector destructor iterator'(v8, 8u, *((_DWORD *)v8 - 1), (void (__thiscall *)(void *))sub_4271F0);
    operator delete[](v9);
  }
  v1[12] = 0;
  v1[1] = 0;
}

//----- (00428040) --------------------------------------------------------
void __thiscall sub_428040(int *this, int a2, int a3, int a4)
{
  int v5; // edi
  int v6; // ebx

  v5 = 0;
  if ( this[2] > 0 )
  {
    v6 = 0;
    do
    {
      sub_431970(v6 + this[13], this[3], this[1], this[14], a2, a3, a4);
      ++v5;
      v6 += 168;
    }
    while ( v5 < this[2] );
  }
}

//----- (00428080) --------------------------------------------------------
void __thiscall sub_428080(int *this)
{
  int *v1; // esi
  int v2; // eax
  int v3; // ecx
  int v4; // ebx
  int v5; // edi
  _DWORD *v6; // ecx
  _DWORD *v7; // esi
  void **v8; // esi
  _DWORD *v9; // ecx
  _DWORD *v10; // edi
  void (__thiscall ***v11)(_DWORD, int); // ecx
  int v13; // [esp+8h] [ebp-8h]
  int v14; // [esp+Ch] [ebp-4h]

  v1 = this;
  if ( this[13] )
  {
    v2 = 0;
    v14 = 0;
    if ( this[1] > 0 )
    {
      v3 = 0;
      v13 = 0;
      do
      {
        v4 = v3 + v1[13];
        v5 = *(_DWORD *)(v4 + 40);
        if ( v5 )
        {
          v6 = **(_DWORD ***)v5;
          **(_DWORD **)v5 = *(_DWORD *)v5;
          *(_DWORD *)(*(_DWORD *)v5 + 4) = *(_DWORD *)v5;
          *(_DWORD *)(v5 + 4) = 0;
          if ( v6 != *(_DWORD **)v5 )
          {
            do
            {
              v7 = (_DWORD *)*v6;
              operator delete(v6);
              v6 = v7;
            }
            while ( v7 != *(_DWORD **)v5 );
          }
          v8 = *(void ***)(v4 + 40);
          if ( v8 )
          {
            v9 = *(_DWORD **)*v8;
            *(_DWORD *)*v8 = *v8;
            *((_DWORD *)*v8 + 1) = *v8;
            v8[1] = 0;
            if ( v9 != *v8 )
            {
              do
              {
                v10 = (_DWORD *)*v9;
                operator delete(v9);
                v9 = v10;
              }
              while ( v10 != *v8 );
            }
            operator delete(*v8);
            operator delete(v8);
          }
          v1 = this;
          v2 = v14;
          v3 = v13;
          *(_DWORD *)(v4 + 40) = 0;
        }
        ++v2;
        v3 += 168;
        v14 = v2;
        v13 = v3;
      }
      while ( v2 < v1[1] );
    }
    v11 = (void (__thiscall ***)(_DWORD, int))v1[13];
    if ( v11 )
    {
      if ( *(v11 - 1) )
      {
        (**v11)(v11, 3);
        v1[13] = 0;
        v1[2] = 0;
        return;
      }
      operator delete[](v11 - 1);
    }
    v1[13] = 0;
  }
  v1[2] = 0;
}

//----- (00428190) --------------------------------------------------------
int __thiscall sub_428190(int *this)
{
  int result; // eax
  int v2; // ebx
  int v3; // esi
  int v4; // edi
  __m128i *v5; // ecx
  __int128 v6; // xmm0
  int v7; // eax
  __m128i v8; // [esp+Ch] [ebp-1Ch] BYREF
  unsigned __int64 v9; // [esp+1Ch] [ebp-Ch]
  int *v10; // [esp+24h] [ebp-4h]

  result = (int)this;
  v2 = 0;
  v3 = 0;
  v10 = this;
  if ( this[2] > 0 )
  {
    v4 = 0;
    do
    {
      v5 = (__m128i *)(v4 + *(_DWORD *)(result + 52));
      if ( v5[5].m128i_i8[0] == 1 )
      {
        switch ( v3 )
        {
          case 0:
            sub_433A80(v5, xmmword_43A2C0, xmmword_43A240);
            break;
          case 1:
            sub_433A80(v5, xmmword_43A300, xmmword_43A270);
            break;
          case 2:
            sub_433A80(v5, xmmword_43A2E0, xmmword_43A230);
            break;
          case 3:
            v6 = xmmword_43A320;
            goto LABEL_9;
          case 4:
            sub_433A80(v5, xmmword_43A2B0, xmmword_43A210);
            break;
          case 5:
            v6 = xmmword_43A2A0;
LABEL_9:
            sub_433A80(v5, v6, xmmword_43A250);
            break;
          case 6:
            sub_433A80(v5, 0i64, xmmword_43A260);
            break;
          case 7:
            sub_433A80(v5, xmmword_43A2D0, 0i64);
            break;
          case 8:
            sub_433A80(v5, xmmword_43A310, xmmword_43A280);
            break;
          case 9:
            sub_433A80(v5, xmmword_43A330, xmmword_43A220);
            break;
          case 10:
            sub_433A80(v5, xmmword_43A2F0, 0i64);
            break;
          default:
            v8 = (__m128i)COERCE_UNSIGNED_INT64((double)(rand() % 255));
            *(double *)&v9 = (double)(rand() % 255);
            v7 = rand();
            sub_433A80(
              (__m128i *)(v4 + v10[13]),
              *(_OWORD *)&_mm_unpacklo_pd((__m128d)_mm_loadu_si128(&v8), (__m128d)v9),
              *(_OWORD *)&_mm_unpacklo_pd((__m128d)COERCE_UNSIGNED_INT64((double)(v7 % 255)), (__m128d)0i64));
            break;
        }
        ++v3;
      }
      result = (int)v10;
      ++v2;
      v4 += 168;
    }
    while ( v2 < v10[2] );
  }
  return result;
}
// 43A210: using guessed type __int128 xmmword_43A210;
// 43A220: using guessed type __int128 xmmword_43A220;
// 43A230: using guessed type __int128 xmmword_43A230;
// 43A240: using guessed type __int128 xmmword_43A240;
// 43A250: using guessed type __int128 xmmword_43A250;
// 43A260: using guessed type __int128 xmmword_43A260;
// 43A270: using guessed type __int128 xmmword_43A270;
// 43A280: using guessed type __int128 xmmword_43A280;
// 43A2A0: using guessed type __int128 xmmword_43A2A0;
// 43A2B0: using guessed type __int128 xmmword_43A2B0;
// 43A2C0: using guessed type __int128 xmmword_43A2C0;
// 43A2D0: using guessed type __int128 xmmword_43A2D0;
// 43A2E0: using guessed type __int128 xmmword_43A2E0;
// 43A2F0: using guessed type __int128 xmmword_43A2F0;
// 43A300: using guessed type __int128 xmmword_43A300;
// 43A310: using guessed type __int128 xmmword_43A310;
// 43A320: using guessed type __int128 xmmword_43A320;
// 43A330: using guessed type __int128 xmmword_43A330;

//----- (004283B0) --------------------------------------------------------
void __thiscall sub_4283B0(_DWORD *this)
{
  _DWORD *v1; // esi
  char *v2; // edx
  int v3; // edi
  int v4; // edi
  int v5; // ecx
  int v6; // ecx
  int v7; // eax
  _DWORD *v8; // ecx
  _DWORD *v9; // eax
  int v10; // edx
  int v11; // edx
  int v12; // eax
  float v13; // xmm0_4
  int v15; // [esp+14h] [ebp-24h]
  int v16; // [esp+18h] [ebp-20h]
  int v17; // [esp+20h] [ebp-18h]
  int v18; // [esp+24h] [ebp-14h]
  int i; // [esp+28h] [ebp-10h]
  int v20; // [esp+2Ch] [ebp-Ch]
  int v21; // [esp+2Ch] [ebp-Ch]
  char *v22; // [esp+30h] [ebp-8h]
  int v23; // [esp+34h] [ebp-4h]

  v1 = this;
  v20 = 0;
  v2 = (char *)operator new[](0xFA0u);
  v22 = v2;
  if ( (int)v1[2] > 0 )
  {
    v3 = 0;
    do
    {
      sub_433070((_DWORD *)(v3 + v1[13]));
      v3 += 168;
      ++v20;
    }
    while ( v20 < v1[2] );
    v2 = v22;
  }
  v4 = 0;
  v21 = 0;
  if ( (int)v1[1] > 0 )
  {
    v5 = 0;
    v23 = 0;
    while ( 1 )
    {
      if ( *(_BYTE *)(v1[3] + v5 + 12) != 1 )
      {
        v6 = v1[27];
        v7 = *(_DWORD *)(v6 + 8 * v4 + 4);
        v8 = *(_DWORD **)(v6 + 8 * v4);
        v18 = v7;
        v9 = (_DWORD *)*v8;
        if ( (_DWORD *)*v8 != v8 )
        {
          do
          {
            v2 += 4;
            *((_DWORD *)v2 - 1) = v9[2];
            v9 = (_DWORD *)*v9;
          }
          while ( v9 != *(_DWORD **)(v1[27] + 8 * v4) );
        }
        v5 = v23;
        v10 = 0;
        for ( i = 0; v10 < v18; i = v10 )
        {
          v16 = v1[3];
          v4 = v21;
          v17 = *(_DWORD *)&v22[4 * v10];
          v11 = v16 + (v17 << 6);
          v12 = *(_DWORD *)(v5 + v16 + 16);
          if ( v12 >= 0 && v12 == *(_DWORD *)(v11 + 16) )
          {
            v15 = 168 * v12 + v1[13];
            if ( *(_BYTE *)(v15 + 80) == 1 && !*(_BYTE *)(v11 + 12) )
            {
              v13 = *(double *)libm_sse2_exp_precise().m128_u64;
              sub_4317A0(
                (_DWORD *)v15,
                *(_DWORD *)(v23 + v16 + 20),
                *(_DWORD *)(v16 + (v17 << 6) + 20),
                (float)(v13 * 4.0));
              v1 = this;
              v4 = v21;
            }
            v5 = v23;
          }
          v10 = i + 1;
        }
      }
      ++v4;
      v5 += 64;
      v21 = v4;
      v23 = v5;
      if ( v4 >= v1[1] )
        break;
      v2 = v22;
    }
  }
  operator delete[](v22);
}
// 43707C: using guessed type __m128 libm_sse2_exp_precise(void);
// 501974: using guessed type int dword_501974;
// 501978: using guessed type int dword_501978;

//----- (004285B0) --------------------------------------------------------
void __thiscall sub_4285B0(_DWORD *this)
{
  int v2; // edx
  int v3; // edi
  int v4; // eax
  int v5; // ecx
  int v6; // esi
  float v7; // xmm0_4
  float v8; // xmm2_4
  int v9; // eax
  float v10; // xmm1_4
  float v11; // xmm0_4
  int v12; // eax
  int v13; // ecx
  _DWORD *v14; // eax
  int v15; // ecx
  int v16; // edi
  int v17; // edx
  int v18; // eax
  int v19; // ecx
  _DWORD *v20; // eax
  int v21; // [esp+8h] [ebp-20h]
  int v22; // [esp+Ch] [ebp-1Ch]
  float v23; // [esp+10h] [ebp-18h]
  int v24; // [esp+14h] [ebp-14h]
  float v25; // [esp+18h] [ebp-10h]
  int v26; // [esp+1Ch] [ebp-Ch] BYREF
  _DWORD *v27; // [esp+20h] [ebp-8h]
  int v28; // [esp+24h] [ebp-4h] BYREF

  v2 = 0;
  v26 = 0;
  v3 = this[1];
  if ( v3 > 0 )
  {
    do
    {
      v4 = this[3];
      v5 = v2++ << 6;
      v6 = v2;
      v24 = v5;
      v21 = v2;
      v28 = v2;
      v7 = *(float *)(v5 + v4 + 32);
      v8 = *(float *)(v5 + v4 + 36);
      v23 = v7;
      v25 = v8;
      if ( v2 < v3 )
      {
        do
        {
          v9 = this[3];
          v10 = v7 - *(float *)(v9 + (v6 << 6) + 32);
          v11 = v8 - *(float *)(v9 + (v6 << 6) + 36);
          if ( (float)((float)(v11 * v11) + (float)(v10 * v10)) < 16384.0 )
          {
            v22 = v5 + v9 + 24;
            v27 = *(_DWORD **)v22;
            v28 = sub_426520(v27, (_DWORD *)v27[1], &v28);
            v12 = *(_DWORD *)(v22 + 4);
            if ( v12 == 357913940 )
              goto LABEL_11;
            v13 = v12 + 1;
            v14 = v27;
            *(_DWORD *)(v22 + 4) = v13;
            v15 = v28;
            v14[1] = v28;
            **(_DWORD **)(v15 + 4) = v15;
            v16 = this[3] + (v6 << 6);
            v27 = *(_DWORD **)(v16 + 24);
            v17 = sub_426520(v27, (_DWORD *)v27[1], &v26);
            v18 = *(_DWORD *)(v16 + 28);
            if ( v18 == 357913940 )
LABEL_11:
              std::_Xlength_error("list<T> too long");
            v8 = v25;
            v19 = v18 + 1;
            v20 = v27;
            *(_DWORD *)(v16 + 28) = v19;
            v5 = v24;
            v20[1] = v17;
            **(_DWORD **)(v17 + 4) = v17;
          }
          v7 = v23;
          v28 = ++v6;
        }
        while ( v6 < this[1] );
        v2 = v21;
      }
      v3 = this[1];
      v26 = v2;
    }
    while ( v2 < v3 );
  }
}
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (00428700) --------------------------------------------------------
int __thiscall sub_428700(int *this, int a2, int a3)
{
  int *v3; // edi
  int v4; // esi
  int v5; // edx
  int v6; // ecx
  _DWORD *v7; // eax
  _DWORD *v8; // edx
  float v9; // xmm0_4
  float v10; // xmm0_4
  float v11; // xmm0_4
  float *v12; // eax
  int v13; // ecx
  int v14; // ecx
  int v15; // eax
  int v16; // edx
  int v17; // ecx
  int v18; // ecx
  int v19; // edx
  int v20; // edx
  int v22; // edi
  _DWORD *v23; // esi
  int v24; // ecx
  char *v25; // edx
  int v26; // ecx
  int v27; // ecx
  char *v28; // edx
  int v29; // esi
  char *v30; // edx
  int v31; // esi
  double v32; // xmm2_8
  double v33; // xmm3_8
  double v34; // xmm4_8
  int v35; // esi
  float v36; // xmm0_4
  int v37; // esi
  int v38; // esi
  float v39; // xmm0_4
  int v40; // esi
  double v41; // xmm0_8
  int v42; // edx
  double v43; // xmm2_8
  double v44; // xmm3_8
  double v45; // xmm4_8
  int v46; // esi
  double v47; // xmm0_8
  int v48; // edx
  int v49; // eax
  int v50; // esi
  float v51; // xmm0_4
  int v52; // esi
  double v53; // xmm0_8
  double v54; // xmm2_8
  double v55; // xmm3_8
  double v56; // xmm5_8
  int v57; // esi
  double v58; // xmm0_8
  int v59; // esi
  double v60; // xmm0_8
  int v61; // esi
  double v62; // xmm0_8
  int v63; // esi
  double v64; // xmm0_8
  int v65; // [esp+20h] [ebp-10Ch]
  int v66; // [esp+24h] [ebp-108h]
  float v67; // [esp+34h] [ebp-F8h]
  float v68; // [esp+3Ch] [ebp-F0h]
  int v69; // [esp+44h] [ebp-E8h]
  _DWORD *v71; // [esp+4Ch] [ebp-E0h]
  int v72; // [esp+50h] [ebp-DCh]
  int v73; // [esp+54h] [ebp-D8h]
  int v74; // [esp+58h] [ebp-D4h]
  int v75; // [esp+5Ch] [ebp-D0h]
  double v76; // [esp+60h] [ebp-CCh]
  float v77; // [esp+64h] [ebp-C8h]
  int v78; // [esp+64h] [ebp-C8h]
  float *v79; // [esp+68h] [ebp-C4h]
  double v80; // [esp+6Ch] [ebp-C0h]
  double v81; // [esp+74h] [ebp-B8h]
  int v82; // [esp+80h] [ebp-ACh]
  int v83; // [esp+88h] [ebp-A4h]
  double v84; // [esp+8Ch] [ebp-A0h]
  double v85; // [esp+8Ch] [ebp-A0h]
  unsigned int v86; // [esp+90h] [ebp-9Ch]
  int v87; // [esp+94h] [ebp-98h]
  int v88; // [esp+98h] [ebp-94h]
  int v89; // [esp+A0h] [ebp-8Ch]
  __int128 v90; // [esp+A4h] [ebp-88h] BYREF
  int v91; // [esp+B4h] [ebp-78h]
  __int128 v92; // [esp+B8h] [ebp-74h] BYREF
  int v93; // [esp+C8h] [ebp-64h]
  __int128 v94; // [esp+CCh] [ebp-60h] BYREF
  int v95; // [esp+DCh] [ebp-50h]
  __int128 v96; // [esp+E0h] [ebp-4Ch] BYREF
  int v97; // [esp+F0h] [ebp-3Ch]
  __int128 v98; // [esp+F4h] [ebp-38h] BYREF
  int v99; // [esp+104h] [ebp-28h]
  __int128 v100; // [esp+108h] [ebp-24h] BYREF
  int v101; // [esp+118h] [ebp-14h]
  int v102; // [esp+128h] [ebp-4h]

  v3 = this;
  this[28] = a3;
  this[29] = a2;
  sub_4285B0(this);
  sub_431F70((int)(v3 + 4), a2 * a3, v3[1], 0);
  v71 = operator new[](0xFA0u);
  v79 = (float *)operator new[](0x404u);
  v99 = 0;
  v98 = 0i64;
  sub_403E60(&v98);
  v102 = 0;
  v97 = 0;
  v96 = 0i64;
  sub_403E60(&v96);
  LOBYTE(v102) = 1;
  v101 = 0;
  v100 = 0i64;
  sub_403E60(&v100);
  LOBYTE(v102) = 2;
  sub_403EE0(&v98);
  HIDWORD(v98) = 1;
  v99 = 64;
  DWORD2(v98) = cvCreateMat(1, 64, 5);
  DWORD1(v98) = *(_DWORD *)(DWORD2(v98) + 16);
  sub_403EE0(&v96);
  HIDWORD(v96) = 1;
  v97 = 128;
  DWORD2(v96) = cvCreateMat(1, 128, 5);
  DWORD1(v96) = *(_DWORD *)(DWORD2(v96) + 16);
  sub_403EE0(&v100);
  HIDWORD(v100) = 1;
  v101 = 256;
  DWORD2(v100) = cvCreateMat(1, 256, 5);
  DWORD1(v100) = *(_DWORD *)(DWORD2(v100) + 16);
  v94 = 0i64;
  v95 = 0;
  sub_403E60(&v94);
  LOBYTE(v102) = 3;
  v93 = 0;
  v92 = 0i64;
  sub_403E60(&v92);
  LOBYTE(v102) = 4;
  v91 = 0;
  v90 = 0i64;
  sub_403E60(&v90);
  LOBYTE(v102) = 5;
  sub_403EE0(&v94);
  HIDWORD(v94) = 1;
  v95 = 64;
  DWORD2(v94) = cvCreateMat(1, 64, 5);
  DWORD1(v94) = *(_DWORD *)(DWORD2(v94) + 16);
  sub_403EE0(&v92);
  HIDWORD(v92) = 1;
  v93 = 128;
  DWORD2(v92) = cvCreateMat(1, 128, 5);
  DWORD1(v92) = *(_DWORD *)(DWORD2(v92) + 16);
  sub_403EE0(&v90);
  HIDWORD(v90) = 1;
  v91 = 256;
  v4 = 0;
  DWORD2(v90) = cvCreateMat(1, 256, 5);
  v88 = 0;
  DWORD1(v90) = *(_DWORD *)(DWORD2(v90) + 16);
  if ( v3[1] > 0 )
  {
    v5 = 0;
    v72 = 0;
    do
    {
      v6 = v3[3];
      v69 = *(_DWORD *)(v5 + v6 + 28);
      v67 = *(float *)(v5 + v6 + 32);
      v68 = *(float *)(v5 + v6 + 36);
      v7 = **(_DWORD ***)(v5 + v6 + 24);
      if ( v7 != *(_DWORD **)(v5 + v6 + 24) )
      {
        v8 = v71;
        do
        {
          *v8++ = v3[3] + (v7[2] << 6);
          v7 = (_DWORD *)*v7;
        }
        while ( v7 != *(_DWORD **)(v72 + v3[3] + 24) );
        v4 = v88;
      }
      v89 = 0;
      if ( a3 > 0 )
      {
        v73 = 4 * a3;
        v75 = 4 * a3;
        do
        {
          v9 = *(double *)libm_sse2_cos_precise(v65, v66).m128_u64;
          v77 = v9;
          v10 = *(double *)libm_sse2_sin_precise().m128_u64;
          memset(v79, 0, 0x404u);
          sub_429F10(v67, v68, v77, v10, v69, (int)v71, (int)(v79 + 128), 128);
          v11 = 0.0;
          v12 = v79 + 2;
          v13 = 64;
          do
          {
            if ( *(v12 - 2) > v11 )
              v11 = *(v12 - 2);
            if ( *(v12 - 1) > v11 )
              v11 = *(v12 - 1);
            if ( *v12 > v11 )
              v11 = *v12;
            if ( v12[1] > v11 )
              v11 = v12[1];
            v12 += 4;
            --v13;
          }
          while ( v13 );
          if ( v11 >= 3.0 )
          {
            v22 = 8;
            v23 = v79 + 2;
            v24 = -8 - (_DWORD)v79;
            do
            {
              *(_QWORD *)((char *)v23 + v24 + DWORD1(v100)) = *((_QWORD *)v23 - 1);
              *(_DWORD *)(v22 + DWORD1(v100)) = *v23;
              v22 += 32;
              *(_DWORD *)((char *)v23 + 4 - (_DWORD)v79 + DWORD1(v100)) = v23[1];
              *(_DWORD *)((char *)v23 + 8 - (_DWORD)v79 + DWORD1(v100)) = v23[2];
              *(_DWORD *)((char *)v23 + 12 - (_DWORD)v79 + DWORD1(v100)) = v23[3];
              *(_DWORD *)((char *)v23 + 16 - (_DWORD)v79 + DWORD1(v100)) = v23[4];
              v25 = (char *)v23 + 20 - (_DWORD)v79;
              v26 = v23[5];
              v23 += 8;
              *(_DWORD *)&v25[DWORD1(v100)] = v26;
              v24 = -8 - (_DWORD)v79;
            }
            while ( v22 < 1032 );
            v27 = -264 - (_DWORD)v79;
            v28 = (char *)(v79 + 66);
            v29 = 16;
            do
            {
              v28 += 32;
              *(_DWORD *)&v28[DWORD1(v96) - 32 + v27] = *((_DWORD *)v28 - 10);
              *(_DWORD *)&v28[DWORD1(v96) - 32 + -260 - (_DWORD)v79] = *((_DWORD *)v28 - 9);
              *(_DWORD *)&v28[DWORD1(v96) - 32 + -256 - (_DWORD)v79] = *((_DWORD *)v28 - 8);
              *(_DWORD *)&v28[DWORD1(v96) - 32 + -252 - (_DWORD)v79] = *((_DWORD *)v28 - 7);
              *(_DWORD *)&v28[DWORD1(v96) - 32 + -248 - (_DWORD)v79] = *((_DWORD *)v28 - 6);
              *(_DWORD *)&v28[DWORD1(v96) - 32 + -244 - (_DWORD)v79] = *((_DWORD *)v28 - 5);
              *(_DWORD *)&v28[DWORD1(v96) - 32 + -240 - (_DWORD)v79] = *((_DWORD *)v28 - 4);
              *(_DWORD *)&v28[DWORD1(v96) - 32 + -236 - (_DWORD)v79] = *((_DWORD *)v28 - 3);
              v27 = -264 - (_DWORD)v79;
              --v29;
            }
            while ( v29 );
            v30 = (char *)(v79 + 98);
            v31 = 8;
            do
            {
              v30 += 32;
              *(_DWORD *)&v30[-392 - (_DWORD)v79 - 32 + DWORD1(v98)] = *((_DWORD *)v30 - 10);
              *(_DWORD *)&v30[DWORD1(v98) - 32 + -388 - (_DWORD)v79] = *((_DWORD *)v30 - 9);
              *(_DWORD *)&v30[DWORD1(v98) - 32 + -384 - (_DWORD)v79] = *((_DWORD *)v30 - 8);
              *(_DWORD *)&v30[DWORD1(v98) - 32 + -380 - (_DWORD)v79] = *((_DWORD *)v30 - 7);
              *(_DWORD *)&v30[DWORD1(v98) - 32 + -376 - (_DWORD)v79] = *((_DWORD *)v30 - 6);
              *(_DWORD *)&v30[DWORD1(v98) - 32 + -372 - (_DWORD)v79] = *((_DWORD *)v30 - 5);
              *(_DWORD *)&v30[DWORD1(v98) - 32 + -368 - (_DWORD)v79] = *((_DWORD *)v30 - 4);
              *(_DWORD *)&v30[DWORD1(v98) - 32 + -364 - (_DWORD)v79] = *((_DWORD *)v30 - 3);
              --v31;
            }
            while ( v31 );
            cvDFT(DWORD2(v98), DWORD2(v94), 0, 64);
            cvDFT(DWORD2(v96), DWORD2(v92), 0, 128);
            cvDFT(DWORD2(v100), DWORD2(v90), 0, 256);
            v3 = this;
            v84 = (float)((float)((float)(*(float *)(DWORD1(v94) + 16) * *(float *)(DWORD1(v94) + 16))
                                + (float)(*(float *)(DWORD1(v94) + 12) * *(float *)(DWORD1(v94) + 12)))
                        + 1.0);
            v32 = (float)((float)((float)(*(float *)(DWORD1(v94) + 24) * *(float *)(DWORD1(v94) + 24))
                                + (float)(*(float *)(DWORD1(v94) + 20) * *(float *)(DWORD1(v94) + 20)))
                        + 1.0);
            v80 = v32;
            v33 = (float)((float)((float)(*(float *)(DWORD1(v94) + 32) * *(float *)(DWORD1(v94) + 32))
                                + (float)(*(float *)(DWORD1(v94) + 28) * *(float *)(DWORD1(v94) + 28)))
                        + 1.0);
            v34 = (float)((float)((float)(*(float *)(DWORD1(v94) + 40) * *(float *)(DWORD1(v94) + 40))
                                + (float)(*(float *)(DWORD1(v94) + 36) * *(float *)(DWORD1(v94) + 36)))
                        + 1.0);
            if ( v33 >= v34
              || (float)((float)((float)(*(float *)(DWORD1(v94) + 48) * *(float *)(DWORD1(v94) + 48))
                               + (float)(*(float *)(DWORD1(v94) + 44) * *(float *)(DWORD1(v94) + 44)))
                       + 1.0) >= v34 )
            {
              v37 = v88;
              *(_DWORD *)(*(_DWORD *)(this[11] + 4 * v88) + 4 * v89) = 1077097267;
            }
            else
            {
              v35 = *(_DWORD *)(this[11] + 4 * v88);
              v32 = (float)((float)((float)(*(float *)(DWORD1(v94) + 24) * *(float *)(DWORD1(v94) + 24))
                                  + (float)(*(float *)(DWORD1(v94) + 20) * *(float *)(DWORD1(v94) + 20)))
                          + 1.0);
              v36 = -*(double *)libm_sse2_log_precise(v65).m128_u64;
              *(float *)(v35 + 4 * v89) = v36;
              v37 = v88;
            }
            if ( v32 >= v33 || v34 >= v33 )
            {
              *(_DWORD *)(*(_DWORD *)(this[11] + 4 * v37) + v75) = 1077097267;
            }
            else
            {
              v38 = *(_DWORD *)(this[11] + 4 * v37);
              v32 = v80;
              v39 = -*(double *)libm_sse2_log_precise(v65).m128_u64;
              *(float *)(v38 + v75) = v39;
              v37 = v88;
            }
            if ( v33 >= v32 || v84 >= v32 )
            {
              v42 = a3;
              *(_DWORD *)(*(_DWORD *)(this[11] + 4 * v37) + 4 * (v89 + 2 * a3)) = 1077097267;
            }
            else
            {
              v40 = *(_DWORD *)(this[11] + 4 * v37);
              v41 = *(double *)libm_sse2_log_precise(v65).m128_u64;
              v42 = a3;
              *(float *)&v41 = -v41;
              *(_DWORD *)(v40 + 4 * (v89 + 2 * a3)) = LODWORD(v41);
              v37 = v88;
            }
            v85 = (float)((float)((float)(*(float *)(DWORD1(v92) + 16) * *(float *)(DWORD1(v92) + 16))
                                + (float)(*(float *)(DWORD1(v92) + 12) * *(float *)(DWORD1(v92) + 12)))
                        + 1.0);
            v43 = (float)((float)((float)(*(float *)(DWORD1(v92) + 24) * *(float *)(DWORD1(v92) + 24))
                                + (float)(*(float *)(DWORD1(v92) + 20) * *(float *)(DWORD1(v92) + 20)))
                        + 1.0);
            v44 = (float)((float)((float)(*(float *)(DWORD1(v92) + 32) * *(float *)(DWORD1(v92) + 32))
                                + (float)(*(float *)(DWORD1(v92) + 28) * *(float *)(DWORD1(v92) + 28)))
                        + 1.0);
            v45 = (float)((float)((float)(*(float *)(DWORD1(v92) + 40) * *(float *)(DWORD1(v92) + 40))
                                + (float)(*(float *)(DWORD1(v92) + 36) * *(float *)(DWORD1(v92) + 36)))
                        + 1.0);
            if ( v44 >= v45
              || (float)((float)((float)(*(float *)(DWORD1(v92) + 48) * *(float *)(DWORD1(v92) + 48))
                               + (float)(*(float *)(DWORD1(v92) + 44) * *(float *)(DWORD1(v92) + 44)))
                       + 1.0) >= v45 )
            {
              v49 = v42 + v89 + 2 * v42;
              v48 = v89;
              *(_DWORD *)(*(_DWORD *)(this[11] + 4 * v37) + 4 * v49) = 1077097267;
            }
            else
            {
              v46 = *(_DWORD *)(this[11] + 4 * v37);
              v47 = *(double *)libm_sse2_log_precise(v65).m128_u64;
              v48 = v89;
              *(float *)&v47 = -v47;
              *(_DWORD *)(v46 + 4 * (a3 + v89 + 2 * a3)) = LODWORD(v47);
              v37 = v88;
            }
            if ( v43 >= v44 || v45 >= v44 )
            {
              *(_DWORD *)(*(_DWORD *)(this[11] + 4 * v37) + 4 * (v48 + v73)) = 1077097267;
            }
            else
            {
              v50 = *(_DWORD *)(this[11] + 4 * v37);
              v51 = -*(double *)libm_sse2_log_precise(v65).m128_u64;
              *(float *)(v50 + 4 * (v73 + v89)) = v51;
              v37 = v88;
            }
            if ( v44 >= v43 || v85 >= v43 )
            {
              v20 = a3;
              *(_DWORD *)(*(_DWORD *)(this[11] + 4 * v37) + 4 * (a3 + v89 + 4 * a3)) = 1077097267;
            }
            else
            {
              v52 = *(_DWORD *)(this[11] + 4 * v37);
              v53 = *(double *)libm_sse2_log_precise(v65).m128_u64;
              v20 = a3;
              *(float *)&v53 = -v53;
              *(_DWORD *)(v52 + 4 * (a3 + v89 + 4 * a3)) = LODWORD(v53);
              v37 = v88;
            }
            v76 = (float)((float)((float)(*(float *)(DWORD1(v90) + 8) * *(float *)(DWORD1(v90) + 8))
                                + (float)(*(float *)(DWORD1(v90) + 4) * *(float *)(DWORD1(v90) + 4)))
                        + 1.0);
            v81 = (float)((float)((float)(*(float *)(DWORD1(v90) + 16) * *(float *)(DWORD1(v90) + 16))
                                + (float)(*(float *)(DWORD1(v90) + 12) * *(float *)(DWORD1(v90) + 12)))
                        + 1.0);
            v54 = (float)((float)((float)(*(float *)(DWORD1(v90) + 24) * *(float *)(DWORD1(v90) + 24))
                                + (float)(*(float *)(DWORD1(v90) + 20) * *(float *)(DWORD1(v90) + 20)))
                        + 1.0);
            v55 = (float)((float)((float)(*(float *)(DWORD1(v90) + 32) * *(float *)(DWORD1(v90) + 32))
                                + (float)(*(float *)(DWORD1(v90) + 28) * *(float *)(DWORD1(v90) + 28)))
                        + 1.0);
            v56 = (float)((float)((float)(*(float *)(DWORD1(v90) + 40) * *(float *)(DWORD1(v90) + 40))
                                + (float)(*(float *)(DWORD1(v90) + 36) * *(float *)(DWORD1(v90) + 36)))
                        + 1.0);
            if ( v55 >= v56
              || (float)((float)((float)(*(float *)(DWORD1(v90) + 48) * *(float *)(DWORD1(v90) + 48))
                               + (float)(*(float *)(DWORD1(v90) + 44) * *(float *)(DWORD1(v90) + 44)))
                       + 1.0) >= v56 )
            {
              *(_DWORD *)(*(_DWORD *)(this[11] + 4 * v37) + 4 * (v89 + 6 * v20)) = 1077097267;
            }
            else
            {
              v57 = *(_DWORD *)(this[11] + 4 * v37);
              v58 = *(double *)libm_sse2_log_precise(v65).m128_u64;
              v20 = a3;
              *(float *)&v58 = -v58;
              *(_DWORD *)(v57 + 4 * (v89 + 6 * a3)) = LODWORD(v58);
            }
            v4 = v88;
            if ( v54 >= v55 || v56 >= v55 )
            {
              *(_DWORD *)(*(_DWORD *)(this[11] + 4 * v88) + 4 * (v89 + 7 * v20)) = 1077097267;
            }
            else
            {
              v59 = *(_DWORD *)(this[11] + 4 * v88);
              v60 = *(double *)libm_sse2_log_precise(v65).m128_u64;
              v20 = a3;
              *(float *)&v60 = -v60;
              *(_DWORD *)(v59 + 4 * (v89 + 7 * a3)) = LODWORD(v60);
              v4 = v88;
            }
            if ( v55 >= v54 || v81 >= v54 )
            {
              *(_DWORD *)(*(_DWORD *)(this[11] + 4 * v4) + 4 * (v89 + 8 * v20)) = 1077097267;
            }
            else
            {
              v61 = *(_DWORD *)(this[11] + 4 * v4);
              v62 = *(double *)libm_sse2_log_precise(v65).m128_u64;
              v20 = a3;
              *(float *)&v62 = -v62;
              *(_DWORD *)(v61 + 4 * (v89 + 8 * a3)) = LODWORD(v62);
              v4 = v88;
            }
            if ( v54 >= v81 || v76 >= v81 )
            {
              *(_DWORD *)(*(_DWORD *)(this[11] + 4 * v4) + 4 * (v20 + v89 + 8 * v20)) = 1077097267;
            }
            else
            {
              v63 = *(_DWORD *)(this[11] + 4 * v4);
              v64 = *(double *)libm_sse2_log_precise(v65).m128_u64;
              v20 = a3;
              *(float *)&v64 = -v64;
              *(_DWORD *)(v63 + 4 * (a3 + v89 + 8 * a3)) = LODWORD(v64);
              v4 = v88;
            }
          }
          else
          {
            v14 = a3;
            v15 = 0;
            v16 = v89;
            if ( a2 >= 4 )
            {
              v82 = 16 * a3;
              v74 = 4 * v89;
              v78 = 4 * (v89 + 2 * a3);
              v87 = v75;
              v17 = 4 * (a3 + v89 + 2 * a3);
              v86 = ((unsigned int)(a2 - 4) >> 2) + 1;
              v83 = 4 * v86;
              do
              {
                *(_DWORD *)(v74 + *(_DWORD *)(v3[11] + 4 * v4)) = 1077097267;
                *(_DWORD *)(v87 + *(_DWORD *)(v3[11] + 4 * v4)) = 1077097267;
                *(_DWORD *)(v78 + *(_DWORD *)(v3[11] + 4 * v4)) = 1077097267;
                v74 += v82;
                v87 += v82;
                v78 += v82;
                *(_DWORD *)(v17 + *(_DWORD *)(v3[11] + 4 * v4)) = 1077097267;
                v17 += v82;
                --v86;
              }
              while ( v86 );
              v14 = a3;
              v16 = v89;
              v15 = v83;
            }
            if ( v15 < a2 )
            {
              v18 = 4 * (v16 + v15 * v14);
              v19 = a2 - v15;
              do
              {
                *(_DWORD *)(v18 + *(_DWORD *)(v3[11] + 4 * v4)) = 1077097267;
                v18 += v73;
                --v19;
              }
              while ( v19 );
            }
            v20 = a3;
          }
          v75 += 4;
          ++v89;
        }
        while ( v89 < v20 );
      }
      ++v4;
      v5 = v72 + 64;
      v88 = v4;
      v72 += 64;
    }
    while ( v4 < v3[1] );
  }
  operator delete[](v71);
  operator delete[](v79);
  LOBYTE(v102) = 4;
  sub_403E70(&v90);
  LOBYTE(v102) = 3;
  sub_403E70(&v92);
  LOBYTE(v102) = 2;
  sub_403E70(&v94);
  LOBYTE(v102) = 1;
  sub_403E70(&v100);
  LOBYTE(v102) = 0;
  sub_403E70(&v96);
  v102 = -1;
  return sub_403E70(&v98);
}
// 428A4B: variable 'v65' is possibly undefined
// 428A4B: variable 'v66' is possibly undefined
// 436860: using guessed type int __cdecl cvCreateMat(_DWORD, _DWORD, _DWORD);
// 436878: using guessed type int __cdecl cvDFT(_DWORD, _DWORD, _DWORD, _DWORD);
// 436A62: using guessed type __m128 __stdcall libm_sse2_cos_precise(_DWORD, _DWORD);
// 436A68: using guessed type __m128 libm_sse2_sin_precise(void);
// 437088: using guessed type __m128 __stdcall libm_sse2_log_precise(_DWORD);

//----- (00429780) --------------------------------------------------------
double __thiscall sub_429780(_DWORD *this, int a2, int a3)
{
  int v3; // eax
  int v4; // ecx
  int v5; // esi
  int v6; // edi
  double v7; // xmm2_8
  double v8; // xmm3_8
  double v9; // xmm4_8
  double v10; // xmm5_8
  int v11; // ecx
  unsigned int v12; // eax
  float v14; // xmm0_4
  float *v15; // ecx
  float v16; // xmm0_4
  float v17; // xmm0_4
  float v18; // xmm0_4
  float v19; // xmm0_4
  float v20; // xmm0_4
  float v21; // xmm0_4
  float v22; // xmm0_4
  float v23; // xmm2_4
  float v24; // xmm0_4
  float v25; // xmm0_4
  double v26; // xmm1_8
  int v27; // [esp+0h] [ebp-30h]
  int v28; // [esp+0h] [ebp-30h]
  int v29; // [esp+0h] [ebp-30h]
  int v30; // [esp+0h] [ebp-30h]
  int v31; // [esp+4h] [ebp-2Ch]
  int v32; // [esp+4h] [ebp-2Ch]
  int v33; // [esp+4h] [ebp-2Ch]
  int v34; // [esp+4h] [ebp-2Ch]
  int v35; // [esp+8h] [ebp-28h]
  int v36; // [esp+8h] [ebp-28h]
  int v37; // [esp+Ch] [ebp-24h]
  float v38; // [esp+Ch] [ebp-24h]
  float v39; // [esp+Ch] [ebp-24h]
  float v40; // [esp+14h] [ebp-1Ch]
  int v41; // [esp+18h] [ebp-18h]
  float v42; // [esp+1Ch] [ebp-14h]
  float v43; // [esp+1Ch] [ebp-14h]
  float v44; // [esp+1Ch] [ebp-14h]
  float v45; // [esp+1Ch] [ebp-14h]
  double v46; // [esp+20h] [ebp-10h]
  double v47; // [esp+28h] [ebp-8h]
  int v48; // [esp+38h] [ebp+8h]
  int v49; // [esp+3Ch] [ebp+Ch]

  v3 = this[14];
  v4 = this[3];
  v5 = *(_DWORD *)(v3 + 4 * a2);
  v48 = a2 << 6;
  v6 = *(_DWORD *)(v3 + 4 * a3);
  v49 = a3 << 6;
  v7 = *(float *)(v4 + v48 + 32);
  v8 = *(float *)(v4 + v48 + 36);
  v9 = *(float *)(v4 + v49 + 32);
  v37 = (v5 - v5 % dword_501978) / dword_501978;
  v10 = *(float *)(v4 + v49 + 36);
  v41 = (v6 - v6 % dword_501978) / dword_501978;
  v11 = abs32(v5 % dword_501978 - v6 % dword_501978);
  v12 = abs32(v37 - v41);
  if ( v11 == 31 )
    v11 = 1;
  if ( (int)(v11 + v12) >= 4 || v11 >= 3 )
    return 0.0;
  v15 = &dword_43E070[v37];
  v46 = v7 - v9;
  v47 = v8 - v10;
  if ( *v15 > dword_43E070[v41] )
    v15 = &dword_43E070[v41];
  v14 = *(float *)(v48 + dword_501974 + 32) - *(float *)(v49 + dword_501974 + 32);
  v40 = (float)((float)(*(float *)(v48 + dword_501974 + 36) - *(float *)(v49 + dword_501974 + 36))
              * (float)(*(float *)(v48 + dword_501974 + 36) - *(float *)(v49 + dword_501974 + 36)))
      + (float)(v14 * v14);
  v16 = *v15 + 0.1;
  v38 = v16;
  v17 = *(double *)libm_sse2_sin_precise().m128_u64;
  v42 = (float)-v17 * (float)v46;
  v18 = *(double *)libm_sse2_cos_precise(v27, v31).m128_u64;
  v19 = fabs((float)(v42 + (float)(v18 * (float)v47)));
  v43 = v19;
  v20 = *(double *)libm_sse2_sqrt_precise(v28, v32, v35, LODWORD(v38)).m128_u64;
  if ( (float)((float)(v43 / v20) >= 0.4) <= 0.0
    || (v21 = *(double *)libm_sse2_sin_precise().m128_u64,
        v44 = (float)-v21 * (float)v46,
        v22 = *(double *)libm_sse2_cos_precise(v29, v33).m128_u64,
        v23 = v47,
        v24 = fabs((float)(v44 + (float)(v22 * v23))),
        v45 = v24,
        v25 = *(double *)libm_sse2_sqrt_precise(v30, v34, v36, LODWORD(v39)).m128_u64,
        (float)((float)(v45 / v25) >= 0.4) <= 0.0) )
  {
    v26 = v39 * 1.44;
  }
  else
  {
    v26 = v39 * 0.8100000000000001;
  }
  if ( v40 > v26 )
    return 0.0;
  else
    return 100.0;
}
// 42993E: variable 'v27' is possibly undefined
// 42993E: variable 'v31' is possibly undefined
// 429997: variable 'v28' is possibly undefined
// 429997: variable 'v32' is possibly undefined
// 429997: variable 'v35' is possibly undefined
// 429A07: variable 'v29' is possibly undefined
// 429A07: variable 'v33' is possibly undefined
// 429A56: variable 'v30' is possibly undefined
// 429A56: variable 'v34' is possibly undefined
// 429A56: variable 'v36' is possibly undefined
// 429A56: variable 'v39' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);
// 436A62: using guessed type __m128 __stdcall libm_sse2_cos_precise(_DWORD, _DWORD);
// 436A68: using guessed type __m128 libm_sse2_sin_precise(void);
// 43E070: using guessed type float dword_43E070[14];
// 501974: using guessed type int dword_501974;
// 501978: using guessed type int dword_501978;

//----- (00429AE0) --------------------------------------------------------
double __cdecl sub_429AE0(int a1, int a2, int a3, int a4)
{
  float v5; // xmm0_4
  float v6; // xmm2_4
  float v7; // xmm0_4

  if ( a3 == a4 )
    return 0.0;
  v5 = fabs((float)(a3 % dword_501978 - a4 % dword_501978));
  v6 = (float)fabs((float)((a3 - a3 % dword_501978) / dword_501978 - (a4 - a4 % dword_501978) / dword_501978)) + v5;
  v7 = *(double *)libm_sse2_exp_precise().m128_u64;
  if ( v6 >= 4.0 )
    return (float)(v7 * 5.0);
  return (float)(v7 * 0.4);
}
// 43707C: using guessed type __m128 libm_sse2_exp_precise(void);
// 501974: using guessed type int dword_501974;
// 501978: using guessed type int dword_501978;

//----- (00429C20) --------------------------------------------------------
void __thiscall sub_429C20(int this)
{
  _DWORD *v2; // eax
  _OWORD *v3; // eax
  _DWORD *v4; // eax
  int v5; // edx
  int *v6; // eax
  int *v7; // esi
  int v8; // edx
  int v9; // ecx
  int v10; // eax
  _DWORD *v11; // ecx
  _DWORD *v12; // eax
  _DWORD *v13; // esi
  int v14; // eax
  int v15; // esi
  _DWORD *v16; // ecx
  int v17; // esi
  void (__thiscall ***v18)(_DWORD, int); // ecx
  int v19; // [esp+14h] [ebp-20h]
  int v20; // [esp+14h] [ebp-20h]
  _DWORD *v21; // [esp+18h] [ebp-1Ch]
  void *v22; // [esp+1Ch] [ebp-18h]
  void *i; // [esp+1Ch] [ebp-18h]
  float v24; // [esp+20h] [ebp-14h] BYREF
  int v25; // [esp+30h] [ebp-4h]

  dword_501978 = *(_DWORD *)(this + 112);
  dword_50197C = *(_DWORD *)(this + 116);
  dword_501974 = *(_DWORD *)(this + 12);
  v22 = *(void **)(this + 4);
  v19 = *(_DWORD *)(this + 112) * *(_DWORD *)(this + 116);
  v2 = operator new(0xCu);
  if ( v2 )
  {
    *(_QWORD *)v2 = 0i64;
    v2[2] = 0;
    *v2 = *(_DWORD *)(this + 40);
    v2[2] = 1;
  }
  else
  {
    v2 = 0;
  }
  *(_DWORD *)(this + 124) = v2;
  v3 = operator new(0x28u);
  if ( v3 )
  {
    *v3 = 0i64;
    v3[1] = 0i64;
    *((_QWORD *)v3 + 4) = 0i64;
    *((_DWORD *)v3 + 3) = sub_429AE0;
    *((_DWORD *)v3 + 4) = 0;
    *((_BYTE *)v3 + 32) = 0;
  }
  else
  {
    v3 = 0;
  }
  *(_DWORD *)(this + 128) = v3;
  v4 = operator new(8u);
  if ( v4 )
  {
    *(_QWORD *)v4 = 0i64;
    v5 = *(_DWORD *)(this + 128);
    *v4 = *(_DWORD *)(this + 124);
    v4[1] = v5;
  }
  else
  {
    v4 = 0;
  }
  *(_DWORD *)(this + 132) = v4;
  v21 = operator new[](0xFA0u);
  v6 = (int *)operator new(0x58u);
  v7 = v6;
  v25 = 0;
  if ( v6 )
  {
    memset(v6, 0, 0x58u);
    sub_42DA70((int)v7, v22, v19, *(_DWORD **)(this + 132));
    *v7 = (int)&Expansion::`vftable';
  }
  else
  {
    v7 = 0;
  }
  v25 = -1;
  *(_DWORD *)(this + 120) = v7;
  sub_431090(v7);
  (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(this + 120) + 36))(*(_DWORD *)(this + 120));
  v8 = 0;
  for ( i = 0; v8 < *(_DWORD *)(this + 4); i = (void *)v8 )
  {
    v9 = *(_DWORD *)(this + 108);
    v10 = *(_DWORD *)(v9 + 8 * v8 + 4);
    v11 = *(_DWORD **)(v9 + 8 * v8);
    v20 = v10;
    v12 = (_DWORD *)*v11;
    if ( (_DWORD *)*v11 != v11 )
    {
      v13 = v21;
      do
      {
        *v13++ = v12[2];
        v12 = (_DWORD *)*v12;
      }
      while ( v12 != *(_DWORD **)(*(_DWORD *)(this + 108) + 8 * v8) );
    }
    v14 = v20;
    v15 = 0;
    if ( v20 > 0 )
    {
      v16 = v21;
      do
      {
        if ( v16[v15] > v8 )
        {
          (*(void (__thiscall **)(_DWORD, void *, _DWORD, int))(**(_DWORD **)(this + 120) + 16))(
            *(_DWORD *)(this + 120),
            i,
            v21[v15],
            1065353216);
          v8 = (int)i;
          v14 = v20;
          v16 = v21;
        }
        ++v15;
      }
      while ( v15 < v14 );
    }
    ++v8;
  }
  sub_4311F0(*(_BYTE **)(this + 120));
  v17 = 3;
  do
  {
    sub_431170(*(_BYTE **)(this + 120), 1, &v24);
    sub_4311F0(*(_BYTE **)(this + 120));
    --v17;
  }
  while ( v17 );
  if ( *(int *)(this + 4) > 0 )
  {
    do
    {
      *(_DWORD *)(*(_DWORD *)(this + 56) + 4 * v17) = (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(this + 120) + 28))(
                                                        *(_DWORD *)(this + 120),
                                                        v17);
      ++v17;
    }
    while ( v17 < *(_DWORD *)(this + 4) );
  }
  operator delete(*(void **)(this + 124));
  operator delete(*(void **)(this + 128));
  operator delete(*(void **)(this + 132));
  v18 = *(void (__thiscall ****)(_DWORD, int))(this + 120);
  if ( v18 )
    (**v18)(v18, 1);
  *(_DWORD *)(this + 124) = 0;
  *(_DWORD *)(this + 128) = 0;
  *(_DWORD *)(this + 132) = 0;
  *(_DWORD *)(this + 120) = 0;
  operator delete[](v21);
}
// 43A124: using guessed type void *Expansion::`vftable';
// 501974: using guessed type int dword_501974;
// 501978: using guessed type int dword_501978;
// 50197C: using guessed type int dword_50197C;
// 429C20: using guessed type float var_14;

//----- (00429EB0) --------------------------------------------------------
void __userpurge sub_429EB0(int *a1@<ecx>, __m128d a2@<xmm5>, __int64 a3, unsigned int a4)
{
  int v5; // edi
  int v6; // ebx

  v5 = 0;
  if ( a1[2] > 0 )
  {
    v6 = 0;
    do
    {
      sub_433090(v6 + a1[13], a2, a1[3], a1[1], a1[14], a3, a4);
      ++v5;
      v6 += 168;
    }
    while ( v5 < a1[2] );
  }
}

//----- (00429F10) --------------------------------------------------------
void __stdcall sub_429F10(float a1, float a2, float a3, float a4, int a5, int a6, int a7, int a8)
{
  int v8; // ebx
  float v9; // xmm3_4
  float v10; // xmm4_4
  double v11; // xmm0_8
  double v12; // xmm2_8
  double v13; // xmm0_8
  double v14; // xmm1_8
  int v15; // ecx
  int v16; // esi
  int v17; // eax
  int v18; // edx
  __m128 *v19; // eax
  int v20; // eax
  unsigned int v21; // edx
  int v22; // [esp+0h] [ebp-18h]
  int v23; // [esp+4h] [ebp-14h]
  int v24; // [esp+8h] [ebp-10h]
  int v25; // [esp+Ch] [ebp-Ch]
  double v26; // [esp+10h] [ebp-8h]

  v8 = 0;
  if ( a5 > 0 )
  {
    v9 = a4;
    v10 = a3;
    do
    {
      v26 = (a1 - *(float *)(*(_DWORD *)(a6 + 4 * v8) + 32)) * v10
          + (a2 - *(float *)(*(_DWORD *)(a6 + 4 * v8) + 36)) * v9;
      v11 = *(double *)libm_sse2_sqrt_precise(v22, v23, v24, v25).m128_u64;
      v12 = v26 - v11;
      if ( v26 - v11 <= (double)a8 )
      {
        v13 = v11 + v26;
        v14 = (double)-a8;
        if ( v14 <= v13 )
        {
          if ( v14 <= v12 )
            v14 = v12;
          v15 = (int)v14;
          if ( v13 > (double)a8 )
            v13 = (double)a8;
          v16 = (int)v13;
          v17 = (int)v13 - v15 + 1;
          if ( v15 <= (int)v13 )
          {
            if ( (unsigned int)v17 >= 8 )
            {
              v18 = v16 - v17 % 8;
              v19 = (__m128 *)(a7 + 4 * v15);
              do
              {
                v15 += 8;
                *v19 = _mm_add_ps(*v19, (__m128)xmmword_43A290);
                v19[1] = _mm_add_ps(v19[1], (__m128)xmmword_43A290);
                v19 += 2;
              }
              while ( v15 <= v18 );
            }
            if ( v15 <= v16 )
            {
              if ( v16 - v15 + 1 >= 4 )
              {
                v20 = a7 + 8 + 4 * v15;
                v21 = ((unsigned int)(v16 - v15 - 3) >> 2) + 1;
                v15 += 4 * v21;
                do
                {
                  *(__m128 *)(v20 - 8) = _mm_add_ps(*(__m128 *)(v20 - 8), (__m128)xmmword_43A290);
                  v20 += 16;
                  --v21;
                }
                while ( v21 );
              }
              for ( ; v15 <= v16; ++v15 )
                *(float *)(a7 + 4 * v15) = *(float *)(a7 + 4 * v15) + 1.0;
            }
          }
        }
      }
      v9 = a4;
      ++v8;
      v10 = a3;
    }
    while ( v8 < a5 );
  }
}
// 429FCE: variable 'v22' is possibly undefined
// 429FCE: variable 'v23' is possibly undefined
// 429FCE: variable 'v24' is possibly undefined
// 429FCE: variable 'v25' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);
// 43A290: using guessed type __int128 xmmword_43A290;

//----- (0042A0F0) --------------------------------------------------------
_DWORD *__thiscall sub_42A0F0(_DWORD *this, int a2, int a3)
{
  _DWORD *result; // eax
  int v4; // edi
  int v5; // ebx
  int v6; // ecx
  int v7; // edx
  int v8; // eax
  _DWORD **v9; // esi
  int v10; // edi
  int v12; // [esp+Ch] [ebp-Ch]
  int v13; // [esp+10h] [ebp-8h]
  int v14; // [esp+14h] [ebp-4h]

  result = this;
  v4 = 0;
  v5 = 0;
  v13 = 0;
  if ( (int)this[1] > 0 )
  {
    v6 = 0;
    v14 = 0;
    v12 = 0;
    do
    {
      v7 = result[3];
      v8 = *(_DWORD *)(v6 + v7 + 8);
      v9 = (_DWORD **)(v6 + v7);
      if ( v8 > a2 && v8 < a3 )
      {
        v10 = v7 + v14;
        if ( (_DWORD **)(v7 + v14) != v9 )
          sub_426DD0((_DWORD *)(v7 + v14), (_DWORD *)**v9, *v9);
        *(_DWORD *)(v10 + 8) = v9[2];
        *(_BYTE *)(v10 + 12) = *((_BYTE *)v9 + 12);
        *(_DWORD *)(v10 + 16) = v9[4];
        *(_DWORD *)(v10 + 20) = v9[5];
        if ( (_DWORD **)(v10 + 24) != v9 + 6 )
          sub_426CE0((_DWORD *)(v10 + 24), (_DWORD *)*v9[6], v9[6]);
        v6 = v12;
        *(_DWORD *)(v10 + 32) = v9[8];
        *(_DWORD *)(v10 + 36) = v9[9];
        *(_DWORD *)(v10 + 40) = v9[10];
        *(_DWORD *)(v10 + 44) = v9[11];
        *(_DWORD *)(v10 + 48) = v9[12];
        *(_DWORD *)(v10 + 52) = v9[13];
        *(_DWORD *)(v10 + 56) = v9[14];
        *(_DWORD *)(v10 + 60) = v9[15];
        v4 = v13 + 1;
        v14 += 64;
        ++v13;
      }
      result = this;
      ++v5;
      v6 += 64;
      v12 = v6;
    }
    while ( v5 < this[1] );
  }
  result[1] = v4;
  return result;
}

//----- (0042A1D0) --------------------------------------------------------
void __thiscall sub_42A1D0(_DWORD *this, int a2)
{
  int v3; // edi
  int v4; // ecx
  int Size; // eax
  int v6; // esi
  _DWORD *v7; // eax
  int v8; // eax
  int v9; // edx
  int v10; // ecx
  int v11; // edi
  int v12; // edx
  int v13; // edi
  _DWORD *v14; // edx
  _DWORD *v15; // eax
  unsigned int v16; // edx
  int v17; // ecx
  unsigned int v18; // eax
  int v19; // edx
  int v20; // eax
  int v21; // ecx
  __int16 v22; // ax
  int v23; // ecx
  int v24; // edi
  int v25; // eax
  int v26; // eax
  int v27; // ecx
  int v28; // eax
  int v29; // ecx
  int v30; // eax
  int v31; // ecx
  int v32; // ecx
  int v33; // eax
  _DWORD *v34; // eax
  int *v35; // esi
  _DWORD *v36; // edi
  int v37; // ecx
  char *v38; // esi
  _DWORD *v39; // eax
  void *v40; // ecx
  _DWORD v41[4]; // [esp+Ch] [ebp-B4h] BYREF
  int v42[2]; // [esp+1Ch] [ebp-A4h] BYREF
  int v43[2]; // [esp+24h] [ebp-9Ch] BYREF
  int v44[2]; // [esp+2Ch] [ebp-94h] BYREF
  int v45[2]; // [esp+34h] [ebp-8Ch] BYREF
  int v46[2]; // [esp+3Ch] [ebp-84h] BYREF
  int v47[2]; // [esp+44h] [ebp-7Ch] BYREF
  int v48[2]; // [esp+4Ch] [ebp-74h] BYREF
  int v49[2]; // [esp+54h] [ebp-6Ch] BYREF
  int v50[2]; // [esp+5Ch] [ebp-64h] BYREF
  int v51[2]; // [esp+64h] [ebp-5Ch] BYREF
  int v52; // [esp+6Ch] [ebp-54h]
  _DWORD *v53; // [esp+70h] [ebp-50h]
  int v54; // [esp+74h] [ebp-4Ch]
  int v55; // [esp+78h] [ebp-48h]
  int v56; // [esp+7Ch] [ebp-44h]
  int *v57; // [esp+80h] [ebp-40h]
  int v58; // [esp+84h] [ebp-3Ch]
  int v59; // [esp+88h] [ebp-38h]
  int v60; // [esp+8Ch] [ebp-34h]
  int v61; // [esp+90h] [ebp-30h]
  int v62; // [esp+94h] [ebp-2Ch]
  int Image; // [esp+98h] [ebp-28h] BYREF
  void *v64[4]; // [esp+9Ch] [ebp-24h] BYREF
  int v65; // [esp+ACh] [ebp-14h]
  int v66; // [esp+BCh] [ebp-4h]

  v53 = this;
  v4 = *(_DWORD *)(a2 + 44);
  v54 = *(_DWORD *)(a2 + 40);
  v3 = v54;
  v55 = v4;
  v53[17] = 0;
  this[18] = 0;
  this[19] = v3;
  this[20] = v4;
  Size = cvGetSize(a2);
  Image = cvCreateImage(Size);
  cvCopy(a2, Image, 0);
  v6 = Image;
  v52 = Image;
  v41[3] = Image;
  v66 = 0;
  memset(v64, 0, sizeof(v64));
  v65 = 0;
  v7 = operator new(8u);
  if ( !v7 )
    std::_Xbad_alloc();
  v64[0] = v7;
  *v7 = 0;
  v7[1] = 0;
  *(_DWORD *)v64[0] = v64;
  v8 = 0;
  LOBYTE(v66) = 1;
  v9 = 0;
  v60 = 0;
  v59 = 0;
  if ( v55 <= 0 )
    goto LABEL_44;
  do
  {
    v10 = 0;
    v56 = 0;
    if ( v3 <= 0 )
      goto LABEL_43;
    v11 = v8 << 6;
    v58 = v8 << 6;
    do
    {
      if ( *(_BYTE *)(*(_DWORD *)(v6 + 68) + v9 * *(_DWORD *)(v6 + 72) + v10) == 0xFF )
      {
        v43[0] = v10;
        v43[1] = v9;
        sub_42B970(v64, v43);
        v12 = v11 + v53[3];
        v13 = v65;
        v57 = (int *)v12;
        if ( v65 )
        {
          do
          {
            v14 = sub_42B4D0((int *)v64, v41);
            v15 = (_DWORD *)*v14;
            if ( *v14 )
              v15 = (_DWORD *)*v15;
            v16 = v14[2];
            v17 = v15[2] - 1;
            v62 = (int)v15;
            v18 = v16 >> 1;
            v19 = v16 & 1;
            v20 = *(_DWORD *)(*(_DWORD *)(v62 + 4) + 4 * (v18 & v17));
            v21 = *(unsigned __int16 *)(v20 + 8 * v19);
            v22 = *(_WORD *)(v20 + 8 * v19 + 4);
            v61 = v21;
            v65 = v13 - 1;
            if ( v13 == 1 )
              v64[3] = 0;
            else
              ++v64[3];
            v23 = v22;
            v24 = (__int16)v61;
            v25 = v22 * *(_DWORD *)(v6 + 72);
            v62 = v23;
            if ( *(_BYTE *)(*(_DWORD *)(v6 + 68) + v25 + (__int16)v61) )
            {
              v49[1] = v23;
              v49[0] = (__int16)v61;
              v61 = *v57;
              sub_426570((_DWORD *)v61, *(_DWORD **)(v61 + 4), v49);
              if ( v57[1] == 268435454 )
                std::_Xlength_error("list<T> too long");
              ++v57[1];
              v27 = v62;
              *(_DWORD *)(v61 + 4) = v26;
              **(_DWORD **)(v26 + 4) = v26;
              *(_BYTE *)(*(_DWORD *)(v6 + 68) + v27 * *(_DWORD *)(v6 + 72) + v24) = 0;
              if ( *(_BYTE *)(*(_DWORD *)(v6 + 68) + v27 * *(_DWORD *)(v6 + 72) + v24 - 1) == 0xFF )
              {
                v45[1] = v27;
                v45[0] = v24 - 1;
                sub_42B970(v64, v45);
                v27 = v62;
              }
              if ( *(_BYTE *)(*(_DWORD *)(v6 + 68) + v27 * *(_DWORD *)(v6 + 72) + v24 + 1) == 0xFF )
              {
                v47[1] = v27;
                v47[0] = v24 + 1;
                sub_42B970(v64, v47);
                v27 = v62;
              }
              v28 = (v27 - 1) * *(_DWORD *)(v6 + 72);
              v61 = v27 - 1;
              if ( *(_BYTE *)(*(_DWORD *)(v6 + 68) + v28 + v24) == 0xFF )
              {
                v51[0] = v24;
                v51[1] = v27 - 1;
                sub_42B970(v64, v51);
                v27 = v62;
              }
              v29 = v27 + 1;
              v30 = v29 * *(_DWORD *)(v6 + 72);
              v62 = v29;
              if ( *(_BYTE *)(*(_DWORD *)(v6 + 68) + v30 + v24) == 0xFF )
              {
                v50[1] = v29;
                v50[0] = v24;
                sub_42B970(v64, v50);
              }
              v31 = v61;
              if ( *(_BYTE *)(*(_DWORD *)(v6 + 68) + v61 * *(_DWORD *)(v6 + 72) + v24 - 1) == 0xFF )
              {
                v48[1] = v61;
                v48[0] = v24 - 1;
                sub_42B970(v64, v48);
                v31 = v61;
              }
              if ( *(_BYTE *)(*(_DWORD *)(v6 + 68) + v31 * *(_DWORD *)(v6 + 72) + v24 + 1) == 0xFF )
              {
                v46[1] = v31;
                v46[0] = v24 + 1;
                sub_42B970(v64, v46);
              }
              v32 = v62;
              if ( *(_BYTE *)(*(_DWORD *)(v6 + 68) + v62 * *(_DWORD *)(v6 + 72) + v24 - 1) == 0xFF )
              {
                v44[1] = v62;
                v44[0] = v24 - 1;
                sub_42B970(v64, v44);
                v32 = v62;
              }
              if ( *(_BYTE *)(*(_DWORD *)(v6 + 68) + v32 * *(_DWORD *)(v6 + 72) + v24 + 1) == 0xFF )
              {
                v42[1] = v32;
                v42[0] = v24 + 1;
                sub_42B970(v64, v42);
              }
            }
            v13 = v65;
          }
          while ( v65 );
          v12 = (int)v57;
        }
        v33 = *(_DWORD *)(v12 + 4);
        *(_DWORD *)(v12 + 8) = v33;
        if ( v33 < 100000 )
        {
          v8 = v60 + 1;
          v10 = v56;
          v11 = v58 + 64;
          v9 = v59;
          ++v60;
          v58 += 64;
          goto LABEL_41;
        }
        v34 = **(_DWORD ***)v12;
        **(_DWORD **)v12 = *(_DWORD *)v12;
        *(_DWORD *)(*(_DWORD *)v12 + 4) = *(_DWORD *)v12;
        *(_DWORD *)(v12 + 4) = 0;
        if ( v34 != *(_DWORD **)v12 )
        {
          v35 = v57;
          do
          {
            v36 = (_DWORD *)*v34;
            operator delete(v34);
            v34 = v36;
          }
          while ( v36 != (_DWORD *)*v35 );
          v6 = v52;
        }
        v9 = v59;
        v11 = v58;
        v10 = v56;
      }
      v8 = v60;
LABEL_41:
      v56 = ++v10;
    }
    while ( v10 < v54 );
    v3 = v54;
LABEL_43:
    v59 = ++v9;
  }
  while ( v9 < v55 );
LABEL_44:
  v53[1] = v8;
  cvReleaseImage(&Image);
  v37 = v65;
  if ( v65 )
  {
    do
      --v37;
    while ( v37 );
    v64[3] = 0;
    v65 = 0;
  }
  v38 = (char *)v64[2];
  v39 = v64[1];
  if ( v64[2] )
  {
    do
    {
      v40 = (void *)v39[(_DWORD)v38-- - 1];
      if ( v40 )
      {
        operator delete(v40);
        v39 = v64[1];
      }
    }
    while ( v38 );
  }
  if ( v39 )
    operator delete(v39);
  v64[2] = 0;
  v64[1] = 0;
  operator delete(v64[0]);
}
// 42A29B: variable 'v7' is possibly undefined
// 42A3DC: variable 'v26' is possibly undefined
// 436848: using guessed type int __cdecl cvCreateImage(_DWORD);
// 43684E: using guessed type int __cdecl cvReleaseImage(_DWORD);
// 436866: using guessed type __int64 __cdecl cvGetSize(_DWORD);
// 43686C: using guessed type int __cdecl cvCopy(_DWORD, _DWORD, _DWORD);
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);
// 43903C: using guessed type void __cdecl std::_Xbad_alloc();

//----- (0042A690) --------------------------------------------------------
int __thiscall sub_42A690(_DWORD *this)
{
  int v2; // ebx
  _DWORD *v3; // edx
  char *v4; // ecx
  int v5; // ecx
  _DWORD *v6; // eax
  int i; // edi
  int v8; // edx
  int v9; // ebx
  int v10; // eax
  int v11; // ebx
  int v12; // ecx
  int *v13; // eax
  _DWORD *v14; // edi
  int v15; // ecx
  int v16; // ebx
  int v17; // ecx
  _DWORD *v18; // eax
  _DWORD *v19; // edi
  int v20; // eax
  int v21; // eax
  int v22; // edi
  int v23; // edx
  int v24; // eax
  int v25; // edi
  int v26; // ebx
  int v27; // ecx
  int v28; // edx
  int v29; // eax
  _DWORD *v30; // ecx
  _DWORD **v31; // ebx
  _DWORD *j; // eax
  void *v33; // eax
  unsigned int v35; // [esp-4h] [ebp-44h]
  int v36; // [esp+10h] [ebp-30h]
  char *v37; // [esp+14h] [ebp-2Ch]
  int v38; // [esp+14h] [ebp-2Ch]
  float v39; // [esp+18h] [ebp-28h]
  char *v40; // [esp+18h] [ebp-28h]
  _DWORD **v41; // [esp+18h] [ebp-28h]
  int v42; // [esp+1Ch] [ebp-24h] BYREF
  _DWORD *v43; // [esp+20h] [ebp-20h]
  void *v44[2]; // [esp+24h] [ebp-1Ch] BYREF
  int v45; // [esp+2Ch] [ebp-14h]
  int v46; // [esp+3Ch] [ebp-4h]

  v35 = this[1];
  v45 = 0;
  *(_QWORD *)v44 = 0i64;
  sub_403D10((int *)v44, v35);
  v46 = 0;
  v2 = 0;
  v3 = operator new[](0xFA0u);
  v36 = 0;
  v43 = v3;
  if ( (int)this[1] > 0 )
  {
    v4 = 0;
    v37 = 0;
    do
    {
      if ( v4[this[3] + 12] != 1 )
      {
        v5 = this[27];
        v42 = *(_DWORD *)(8 * v2 + v5 + 4);
        v6 = **(_DWORD ***)(8 * v2 + v5);
        if ( v6 != *(_DWORD **)(8 * v2 + v5) )
        {
          do
          {
            *v3++ = v6[2];
            v6 = (_DWORD *)*v6;
          }
          while ( v6 != *(_DWORD **)(this[27] + 8 * v2) );
          v3 = v43;
        }
        for ( i = 0; i < v42; ++i )
        {
          v8 = v3[i];
          if ( *(_BYTE *)((v8 << 6) + this[3] + 12) != 1 )
          {
            v39 = sub_429780(this, v2, v8);
            if ( v39 > 1.0 )
            {
              v9 = sub_403DF0(v44, v2);
              v10 = sub_403DF0(v44, v43[i]);
              if ( v9 != v10 )
                sub_403E20((int *)v44, v9, v10);
              v2 = v36;
            }
          }
          v3 = v43;
        }
        v4 = v37;
      }
      v3 = v43;
      ++v2;
      v4 += 64;
      v36 = v2;
      v37 = v4;
    }
    while ( v2 < this[1] );
  }
  operator delete[](v3);
  v11 = this[1];
  v12 = (168 * (unsigned __int64)(unsigned int)v11) >> 32 != 0 ? -1 : 168 * v11;
  v13 = (int *)operator new[](__CFADD__(v12, 4) ? -1 : v12 + 4);
  LOBYTE(v46) = 1;
  if ( v13 )
  {
    v14 = v13 + 1;
    *v13 = v11;
    `eh vector constructor iterator'(v13 + 1, 0xA8u, v11, (void (__thiscall *)(void *))sub_431250, sub_431480);
  }
  else
  {
    v14 = 0;
  }
  v15 = 0;
  LOBYTE(v46) = 0;
  v16 = 0;
  this[13] = v14;
  v43 = 0;
  v42 = 0;
  if ( (int)this[1] > 0 )
  {
    do
    {
      v17 = 168 * sub_403DF0(v44, v16);
      v40 = (char *)v17;
      if ( !*(_DWORD *)(v17 + this[13] + 40) )
      {
        v18 = operator new(8u);
        v19 = v18;
        LOBYTE(v46) = 2;
        if ( v18 )
        {
          *(_QWORD *)v18 = 0i64;
          *v18 = 0;
          v18[1] = 0;
          sub_42AD80(0, 0);
          *v19 = v20;
        }
        else
        {
          v19 = 0;
        }
        v21 = this[13];
        v17 = (int)v40;
        v43 = (_DWORD *)((char *)v43 + 1);
        LOBYTE(v46) = 0;
        *(_DWORD *)&v40[v21 + 40] = v19;
      }
      v22 = *(_DWORD *)(v17 + this[13] + 40);
      v41 = *(_DWORD ***)v22;
      v23 = sub_426520(v41, v41[1], &v42);
      v24 = *(_DWORD *)(v22 + 4);
      if ( v24 == 357913940 )
        std::_Xlength_error("list<T> too long");
      ++v16;
      *(_DWORD *)(v22 + 4) = v24 + 1;
      v42 = v16;
      v41[1] = (_DWORD *)v23;
      **(_DWORD **)(v23 + 4) = v23;
    }
    while ( v16 < this[1] );
    v15 = (int)v43;
  }
  v25 = 0;
  if ( v15 > 0 )
  {
    v26 = 0;
    v42 = 0;
    do
    {
      v27 = this[13];
      if ( !*(_DWORD *)(v27 + v26 + 40) )
      {
        v28 = this[1];
        v29 = v25 + 1;
        if ( v25 + 1 < v28 )
        {
          v30 = (_DWORD *)(v26 + v27 + 208);
          while ( !*v30 )
          {
            ++v29;
            v30 += 42;
            if ( v29 >= v28 )
              goto LABEL_40;
          }
          v38 = 168 * v29;
          *(_DWORD *)(this[13] + v26 + 40) = *(_DWORD *)(168 * v29 + this[13] + 40);
          v31 = *(_DWORD ***)(this[13] + v26 + 40);
          for ( j = (_DWORD *)**v31; j != *v31; j = (_DWORD *)*j )
            *(_DWORD *)((j[2] << 6) + this[3] + 16) = v25;
          v26 = v42;
          *(_DWORD *)(v38 + this[13] + 40) = 0;
        }
      }
LABEL_40:
      v15 = (int)v43;
      ++v25;
      v26 += 168;
      v42 = v26;
    }
    while ( v25 < (int)v43 );
  }
  v33 = v44[0];
  this[2] = v15;
  if ( v33 )
  {
    operator delete(v33);
    return (int)v43;
  }
  return v15;
}
// 42A8A2: variable 'v20' is possibly undefined
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (0042A9E0) --------------------------------------------------------
int __usercall sub_42A9E0@<eax>(int a1@<ecx>, int a2@<edi>)
{
  int result; // eax
  int v3; // esi
  int i; // edi
  double v5; // xmm0_8
  double v6; // xmm0_8
  int v7; // [esp-4h] [ebp-24h]
  int v8; // [esp+0h] [ebp-20h]
  int v10; // [esp+10h] [ebp-10h]
  int v11; // [esp+14h] [ebp-Ch] BYREF
  float v12; // [esp+18h] [ebp-8h] BYREF

  result = a1;
  v3 = 0;
  if ( *(int *)(a1 + 4) > 0 )
  {
    v7 = a2;
    for ( i = 0; ; i += 64 )
    {
      v10 = i + *(_DWORD *)(result + 12);
      sub_432060(*(_DWORD *)(*(_DWORD *)(result + 56) + 4 * v3), (int *)&v12, (float *)&v11);
      libm_sse2_atan_precise();
      v5 = *(double *)libm_sse2_cos_precise(v7, v8).m128_u64;
      if ( fabs(v5 * *(float *)(v10 + 40)) > v12 )
        break;
      v6 = *(double *)libm_sse2_sin_precise().m128_u64;
      result = a1;
      if ( fabs(v6 * *(float *)(v10 + 44)) > v12 )
        goto LABEL_8;
      if ( ++v3 >= *(_DWORD *)(a1 + 4) )
        return result;
    }
    result = a1;
LABEL_8:
    result = *(_DWORD *)(result + 12);
    *(_BYTE *)((v3 << 6) + result + 12) = 1;
  }
  return result;
}
// 42A9E0: could not find valid save-restore pair for edi
// 42AA54: variable 'v7' is possibly undefined
// 42AA54: variable 'v8' is possibly undefined
// 436A62: using guessed type __m128 __stdcall libm_sse2_cos_precise(_DWORD, _DWORD);
// 436A68: using guessed type __m128 libm_sse2_sin_precise(void);
// 4371FC: using guessed type __m128 libm_sse2_atan_precise(void);

//----- (0042AAF0) --------------------------------------------------------
void __thiscall sub_42AAF0(int *this)
{
  int v2; // edi
  int v3; // ebx

  v2 = 0;
  if ( this[2] > 0 )
  {
    v3 = 0;
    do
    {
      sub_433AA0(v3 + this[13], this[3], this[1], this[14]);
      ++v2;
      v3 += 168;
    }
    while ( v2 < this[2] );
  }
}

//----- (0042AB30) --------------------------------------------------------
int __userpurge sub_42AB30@<eax>(int a1@<ecx>, __m128d a2@<xmm5>, int a3)
{
  int v4; // esi
  int v5; // edi
  int result; // eax

  v4 = 0;
  if ( *(int *)(a1 + 8) > 0 )
  {
    v5 = 0;
    do
    {
      result = sub_433D90(v5 + *(_DWORD *)(a1 + 52), a2, a3);
      ++v4;
      v5 += 168;
    }
    while ( v4 < *(_DWORD *)(a1 + 8) );
  }
  return result;
}

//----- (0042AB70) --------------------------------------------------------
float *__thiscall sub_42AB70(_DWORD *this)
{
  int v2; // esi
  int v3; // edi
  float *result; // eax

  v2 = 0;
  if ( (int)this[2] > 0 )
  {
    v3 = 0;
    do
    {
      result = sub_434030((_DWORD *)(v3 + this[13]));
      ++v2;
      v3 += 168;
    }
    while ( v2 < this[2] );
  }
  return result;
}

//----- (0042ABA0) --------------------------------------------------------
void __thiscall sub_42ABA0(int this)
{
  float *v2; // eax
  int v3; // ecx
  float *v4; // edi
  int v5; // edx
  unsigned int v6; // ebx
  int v7; // ecx
  unsigned int *v8; // eax
  _DWORD *v9; // ebx
  int v10; // ebx
  int Subdiv2D; // eax
  __m128i v12; // xmm0
  float *v13; // ebx
  _DWORD *v14; // ecx
  int v15; // edi
  int MemStorage; // [esp-8h] [ebp-38h]
  float *v17; // [esp+18h] [ebp-18h]
  void *v18; // [esp+1Ch] [ebp-14h] BYREF
  int v19; // [esp+20h] [ebp-10h]
  int v20; // [esp+2Ch] [ebp-4h]

  v2 = (float *)operator new[](8 * (*(_DWORD *)(this + 4) + 1));
  v3 = 0;
  v4 = v2;
  v17 = v2;
  if ( *(int *)(this + 4) > 0 )
  {
    v5 = 0;
    do
    {
      v5 += 64;
      v2[2 * v3] = *(float *)(*(_DWORD *)(this + 12) + v5 - 32);
      v2[2 * v3++ + 1] = *(float *)(*(_DWORD *)(this + 12) + v5 - 28);
    }
    while ( v3 < *(_DWORD *)(this + 4) );
  }
  v19 = *(_DWORD *)(this + 4);
  sub_427FB0((_DWORD *)(this + 60));
  v6 = v19 + 1;
  v7 = (unsigned __int64)v6 >> 29 != 0 ? -1 : 8 * v6;
  v8 = (unsigned int *)operator new[](__CFADD__(v7, 4) ? -1 : v7 + 4);
  v18 = v8;
  v20 = 0;
  if ( v8 )
  {
    *v8 = v6;
    v9 = v8 + 1;
    `eh vector constructor iterator'(
      v8 + 1,
      8u,
      v19 + 1,
      (void (__thiscall *)(void *))sub_426EC0,
      (void (__thiscall *)(void *))sub_4271F0);
  }
  else
  {
    v9 = 0;
  }
  *(_DWORD *)(this + 108) = v9;
  v10 = v19;
  v20 = -1;
  *(_DWORD *)(this + 64) = v19;
  MemStorage = cvCreateMemStorage(0);
  *(_DWORD *)(this + 84) = MemStorage;
  Subdiv2D = cvCreateSubdiv2D(2048, 96, 20, 36, MemStorage);
  v12 = _mm_loadu_si128((const __m128i *)(this + 68));
  *(_DWORD *)(this + 88) = Subdiv2D;
  cvInitSubdivDelaunay2D(Subdiv2D, v12.m128i_i32[0], v12.m128i_i32[1], v12.m128i_i32[2], v12.m128i_i32[3]);
  if ( v10 > 0 )
  {
    v13 = v4;
    v14 = (_DWORD *)(this + 92);
    v15 = 0;
    do
    {
      v18 = (void *)(int)(float)((float)(v13[1] * 10.0) + (float)(*v13 * 100000.0));
      *sub_4273C0(v14, &v18) = v15;
      cvSubdivDelaunay2DInsert(*(_DWORD *)(this + 88), *(_DWORD *)v13, *((_DWORD *)v13 + 1));
      ++v15;
      v14 = (_DWORD *)(this + 92);
      v13 += 2;
    }
    while ( v15 < v19 );
    v4 = v17;
  }
  sub_42D810((int *)(this + 60));
  operator delete[](v4);
}
// 436824: using guessed type int __cdecl cvInitSubdivDelaunay2D(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 43682A: using guessed type int __cdecl cvCreateSubdiv2D(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 436830: using guessed type int __cdecl cvSubdivDelaunay2DInsert(_DWORD, _DWORD, _DWORD);
// 43687E: using guessed type int __cdecl cvCreateMemStorage(_DWORD);

//----- (0042AD50) --------------------------------------------------------
void sub_42AD50()
{
  _DWORD *v0; // eax

  v0 = operator new(0x18u);
  if ( v0 )
  {
    *v0 = v0;
    if ( v0 != (_DWORD *)-4 )
      v0[1] = v0;
    if ( v0 != (_DWORD *)-8 )
      v0[2] = v0;
    *((_WORD *)v0 + 6) = 257;
  }
  else
  {
    std::_Xbad_alloc();
  }
}
// 43903C: using guessed type void __cdecl std::_Xbad_alloc();

//----- (0042AD80) --------------------------------------------------------
void __stdcall sub_42AD80(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // eax
  _DWORD *v3; // ecx
  _DWORD *v4; // edx

  v2 = operator new(0xCu);
  if ( !v2 )
    std::_Xbad_alloc();
  v3 = a1;
  if ( a1 )
  {
    v4 = a2;
  }
  else
  {
    v3 = v2;
    v4 = v2;
  }
  *v2 = v3;
  if ( v2 != (_DWORD *)-4 )
    v2[1] = v4;
}
// 42AD9E: variable 'v2' is possibly undefined
// 43903C: using guessed type void __cdecl std::_Xbad_alloc();

//----- (0042ADC0) --------------------------------------------------------
void __stdcall sub_42ADC0(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // eax
  _DWORD *v3; // ecx
  _DWORD *v4; // edx

  v2 = operator new(0x10u);
  if ( !v2 )
    std::_Xbad_alloc();
  v3 = a1;
  if ( a1 )
  {
    v4 = a2;
  }
  else
  {
    v3 = v2;
    v4 = v2;
  }
  *v2 = v3;
  if ( v2 != (_DWORD *)-4 )
    v2[1] = v4;
}
// 42ADDE: variable 'v2' is possibly undefined
// 43903C: using guessed type void __cdecl std::_Xbad_alloc();

//----- (0042AE00) --------------------------------------------------------
_DWORD *__thiscall sub_42AE00(_DWORD *this)
{
  _DWORD *v2; // edx

  v2 = operator new(0x18u);
  if ( !v2 )
    std::_Xbad_alloc();
  *v2 = *this;
  if ( v2 != (_DWORD *)-4 )
    v2[1] = *this;
  if ( v2 != (_DWORD *)-8 )
    v2[2] = *this;
  return v2;
}
// 42AE1E: variable 'v2' is possibly undefined
// 43903C: using guessed type void __cdecl std::_Xbad_alloc();

//----- (0042AE40) --------------------------------------------------------
void __stdcall sub_42AE40(void **a1)
{
  void **v1; // edi
  void **i; // esi

  v1 = a1;
  for ( i = a1; !*((_BYTE *)i + 13); v1 = i )
  {
    sub_42AE40(i[2]);
    i = (void **)*i;
    operator delete(v1);
  }
}

//----- (0042AE80) --------------------------------------------------------
unsigned int __thiscall sub_42AE80(_DWORD *this, unsigned int a2)
{
  unsigned int v2; // esi
  int v3; // esi
  unsigned int v5; // esi

  v2 = (this[2] - *this) / 56;
  if ( 76695844 - (v2 >> 1) >= v2 )
  {
    v5 = (v2 >> 1) + v2;
    if ( v5 < a2 )
      return a2;
    return v5;
  }
  else
  {
    v3 = 0;
    if ( a2 )
      return a2;
    return v3;
  }
}

//----- (0042AED0) --------------------------------------------------------
void __thiscall sub_42AED0(int this, unsigned int a2)
{
  unsigned int v3; // esi
  int v4; // edx
  unsigned int v5; // esi
  unsigned int v6; // edi
  unsigned int v7; // eax
  const void *v8; // edx
  size_t v9; // edi
  char *v10; // eax
  const void *v11; // ecx
  char *v12; // edx
  unsigned int v13; // edi
  char *v14; // eax
  char *v15; // ebx
  unsigned int v16; // ecx
  char *v17; // edi
  unsigned int v19; // [esp+14h] [ebp-Ch]
  int v20; // [esp+18h] [ebp-8h]
  char *v21; // [esp+1Ch] [ebp-4h]

  v3 = 1;
  v4 = *(_DWORD *)(this + 8);
  if ( v4 )
    v3 = *(_DWORD *)(this + 8);
  while ( v3 - v4 < a2 || v3 < 8 )
  {
    if ( 0xFFFFFFF - v3 < v3 )
      std::_Xlength_error("deque<T> too long");
    v3 *= 2;
  }
  v5 = v3 - v4;
  v6 = *(_DWORD *)(this + 12) >> 1;
  v19 = v6;
  v21 = 0;
  v7 = v4 + v5;
  if ( v4 + v5 )
  {
    if ( v7 > 0x3FFFFFFF || (v21 = (char *)operator new(4 * v7)) == 0 )
      std::_Xbad_alloc();
  }
  v20 = 4 * v6;
  v8 = (const void *)(4 * v6 + *(_DWORD *)(this + 4));
  v9 = 4 * ((int)(4 * *(_DWORD *)(this + 8) - 4 * v6) >> 2);
  v10 = (char *)memmove(&v21[v20], v8, v9);
  v11 = *(const void **)(this + 4);
  v12 = &v10[v9];
  v13 = v19;
  if ( v19 > v5 )
  {
    memmove(v12, v11, 4 * v5);
    v17 = (char *)memmove(v21, (const void *)(4 * v5 + *(_DWORD *)(this + 4)), 4 * ((int)(v20 - 4 * v5) >> 2))
        + 4 * ((int)(v20 - 4 * v5) >> 2);
    v15 = v21;
    if ( !v5 )
      goto LABEL_19;
    v16 = v5;
    goto LABEL_18;
  }
  v14 = (char *)memmove(v12, v11, 4 * ((int)(4 * v19) >> 2));
  if ( v5 != v19 )
  {
    memset(&v14[4 * ((int)(4 * v19) >> 2)], 0, 4 * (v5 - v19));
    v13 = v19;
  }
  v15 = v21;
  if ( v13 )
  {
    v16 = v13;
    v17 = v21;
LABEL_18:
    memset(v17, 0, 4 * v16);
  }
LABEL_19:
  if ( *(_DWORD *)(this + 4) )
    operator delete(*(void **)(this + 4));
  *(_DWORD *)(this + 8) += v5;
  *(_DWORD *)(this + 4) = v15;
}
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);
// 43903C: using guessed type void __cdecl std::_Xbad_alloc();

//----- (0042B050) --------------------------------------------------------
_DWORD *__thiscall sub_42B050(void *this, int a2)
{
  _DWORD *v2; // esi
  _DWORD *result; // eax

  v2 = *(_DWORD **)(a2 + 8);
  *(_DWORD *)(a2 + 8) = *v2;
  if ( !*(_BYTE *)(*v2 + 13) )
    *(_DWORD *)(*v2 + 4) = a2;
  v2[1] = *(_DWORD *)(a2 + 4);
  result = *(_DWORD **)this;
  if ( a2 == *(_DWORD *)(*(_DWORD *)this + 4) )
  {
    result[1] = v2;
    *v2 = a2;
    *(_DWORD *)(a2 + 4) = v2;
  }
  else
  {
    result = *(_DWORD **)(a2 + 4);
    if ( a2 == *result )
      *result = v2;
    else
      result[2] = v2;
    *v2 = a2;
    *(_DWORD *)(a2 + 4) = v2;
  }
  return result;
}

//----- (0042B0B0) --------------------------------------------------------
char *__thiscall sub_42B0B0(int *this, unsigned int a2)
{
  char *v3; // edi
  void *v4; // eax
  char *v5; // esi
  int v6; // ecx
  void **v7; // esi
  char *result; // eax
  int v9; // [esp+0h] [ebp-30h] BYREF
  int v10; // [esp+10h] [ebp-20h]
  void **v11; // [esp+14h] [ebp-1Ch]
  void *v12; // [esp+1Ch] [ebp-14h]
  int *v13; // [esp+20h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-4h]

  v13 = &v9;
  v11 = (void **)this;
  v3 = 0;
  v12 = 0;
  if ( a2 )
  {
    if ( a2 > 0x4924924 || (v3 = (char *)operator new(56 * a2), (v12 = v3) == 0) )
      std::_Xbad_alloc();
  }
  v14 = 0;
  sub_426C20(*this, this[1], (int)v3);
  v4 = (void *)this[1];
  v5 = (char *)*this;
  v12 = v4;
  v14 = -1;
  v6 = ((_BYTE *)v4 - v5) / 56;
  v10 = v6;
  if ( v5 )
  {
    for ( ; v5 != v12; v5 += 56 )
      (**(void (__thiscall ***)(void *, _DWORD))v5)(v5, 0);
    v7 = v11;
    operator delete(*v11);
    v6 = v10;
  }
  else
  {
    v7 = v11;
  }
  *v7 = v3;
  v7[2] = &v3[56 * a2];
  result = &v3[56 * v6];
  v7[1] = result;
  return result;
}
// 43903C: using guessed type void __cdecl std::_Xbad_alloc();

//----- (0042B1E0) --------------------------------------------------------
int *__thiscall sub_42B1E0(int *this, unsigned int a2)
{
  char *v3; // edi
  int v4; // eax
  int v5; // ecx
  int v6; // ebx
  int *result; // eax
  int v8; // [esp+0h] [ebp-2Ch] BYREF
  int *v9; // [esp+10h] [ebp-1Ch]
  void *v10; // [esp+14h] [ebp-18h]
  int *v11; // [esp+1Ch] [ebp-10h]
  int v12; // [esp+28h] [ebp-4h]

  v11 = &v8;
  v9 = this;
  v3 = 0;
  v10 = 0;
  if ( a2 )
  {
    if ( a2 > 0x7FFFFFF || (v3 = (char *)operator new(32 * a2), (v10 = v3) == 0) )
      std::_Xbad_alloc();
  }
  v12 = 0;
  sub_426AB0(*this, this[1], (int)v3);
  v4 = *this;
  v5 = this[1];
  v6 = v5 - *this;
  if ( v4 )
  {
    sub_404130(v4, v5);
    operator delete((void *)*v9);
  }
  result = v9;
  v9[2] = (int)&v3[32 * a2];
  result[1] = (int)&v3[v6 & 0xFFFFFFE0];
  *result = (int)v3;
  return result;
}
// 43903C: using guessed type void __cdecl std::_Xbad_alloc();

//----- (0042B2D0) --------------------------------------------------------
char *__thiscall sub_42B2D0(int *this, unsigned int a2)
{
  int v3; // ebx
  char *result; // eax
  int v5; // ecx
  unsigned int v6; // eax

  v3 = this[1];
  result = (char *)(-1840700269 * (this[2] - v3));
  if ( (this[2] - v3) / 56 < a2 )
  {
    v5 = (v3 - *this) / 56;
    if ( 76695844 - v5 < a2 )
      std::_Xlength_error("vector<T> too long");
    v6 = sub_42AE80(this, v5 + a2);
    return sub_42B0B0(this, v6);
  }
  return result;
}
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (0042B340) --------------------------------------------------------
unsigned int __thiscall sub_42B340(int *this, unsigned int a2)
{
  int v2; // esi
  unsigned int result; // eax
  int v4; // esi
  unsigned int v5; // esi
  unsigned int v6; // edx
  unsigned int v7; // edx

  v2 = this[1];
  result = (this[2] - v2) >> 5;
  if ( result < a2 )
  {
    v4 = (v2 - *this) >> 5;
    if ( 0x7FFFFFF - v4 < a2 )
      std::_Xlength_error("vector<T> too long");
    v5 = a2 + v4;
    v6 = (this[2] - *this) >> 5;
    if ( 0x7FFFFFF - (v6 >> 1) >= v6 )
    {
      v7 = (v6 >> 1) + v6;
      if ( v7 < v5 )
        v7 = v5;
    }
    else
    {
      v7 = 0;
      if ( v5 )
        v7 = v5;
    }
    return (unsigned int)sub_42B1E0(this, v7);
  }
  return result;
}
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (0042B3C0) --------------------------------------------------------
_DWORD *__thiscall sub_42B3C0(void *this, _DWORD *a2)
{
  int v2; // esi
  int v3; // eax
  _DWORD *result; // eax

  v2 = *a2;
  *a2 = *(_DWORD *)(*a2 + 8);
  v3 = *(_DWORD *)(v2 + 8);
  if ( !*(_BYTE *)(v3 + 13) )
    *(_DWORD *)(v3 + 4) = a2;
  *(_DWORD *)(v2 + 4) = a2[1];
  result = *(_DWORD **)this;
  if ( a2 == *(_DWORD **)(*(_DWORD *)this + 4) )
  {
    result[1] = v2;
    *(_DWORD *)(v2 + 8) = a2;
    a2[1] = v2;
  }
  else
  {
    result = (_DWORD *)a2[1];
    if ( a2 == (_DWORD *)result[2] )
      result[2] = v2;
    else
      *result = v2;
    *(_DWORD *)(v2 + 8) = a2;
    a2[1] = v2;
  }
  return result;
}

//----- (0042B420) --------------------------------------------------------
void __thiscall sub_42B420(int this)
{
  int v2; // eax
  int v3; // edi

  v2 = *(_DWORD *)(this + 16);
  if ( v2 )
  {
    do
      --v2;
    while ( v2 );
    *(_DWORD *)(this + 12) = 0;
    *(_DWORD *)(this + 16) = 0;
  }
  v3 = *(_DWORD *)(this + 8);
  while ( v3 )
  {
    --v3;
    if ( *(_DWORD *)(*(_DWORD *)(this + 4) + 4 * v3) )
      operator delete(*(void **)(*(_DWORD *)(this + 4) + 4 * v3));
  }
  if ( *(_DWORD *)(this + 4) )
    operator delete(*(void **)(this + 4));
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
}

//----- (0042B480) --------------------------------------------------------
void __thiscall sub_42B480(int this)
{
  void (__thiscall ***v2)(void *, _DWORD); // esi
  void (__thiscall ***i)(void *, _DWORD); // ebx

  v2 = *(void (__thiscall ****)(void *, _DWORD))this;
  if ( *(_DWORD *)this )
  {
    for ( i = *(void (__thiscall ****)(void *, _DWORD))(this + 4); v2 != i; v2 += 14 )
      (**v2)(v2, 0);
    operator delete(*(void **)this);
    *(_DWORD *)this = 0;
    *(_DWORD *)(this + 4) = 0;
    *(_DWORD *)(this + 8) = 0;
  }
}

//----- (0042B4D0) --------------------------------------------------------
_DWORD *__thiscall sub_42B4D0(int *this, _DWORD *a2)
{
  _DWORD *result; // eax
  int v3; // edx
  int v4; // ecx

  result = a2;
  v3 = this[3];
  v4 = *this;
  a2[1] = 0;
  *a2 = v4;
  a2[2] = v3;
  return result;
}

//----- (0042B4F0) --------------------------------------------------------
int __thiscall sub_42B4F0(_DWORD *this)
{
  _DWORD *v2; // ebx
  _DWORD *i; // esi
  int result; // eax

  v2 = *(_DWORD **)(*this + 4);
  for ( i = v2; !*((_BYTE *)i + 13); v2 = i )
  {
    sub_42AE40((void **)i[2]);
    i = (_DWORD *)*i;
    operator delete(v2);
  }
  *(_DWORD *)(*this + 4) = *this;
  *(_DWORD *)*this = *this;
  result = *this;
  *(_DWORD *)(*this + 8) = *this;
  this[1] = 0;
  return result;
}

//----- (0042B540) --------------------------------------------------------
_DWORD *__thiscall sub_42B540(_DWORD *this)
{
  _DWORD *result; // eax
  _DWORD *v3; // esi

  result = *(_DWORD **)*this;
  *(_DWORD *)*this = *this;
  *(_DWORD *)(*this + 4) = *this;
  this[1] = 0;
  if ( result != (_DWORD *)*this )
  {
    do
    {
      v3 = (_DWORD *)*result;
      operator delete(result);
      result = v3;
    }
    while ( v3 != (_DWORD *)*this );
  }
  return result;
}

//----- (0042B580) --------------------------------------------------------
int *__thiscall sub_42B580(int **this, int *a2, int *a3, int *a4)
{
  int *v4; // edx
  int *result; // eax
  int *v7; // eax
  int *v8; // esi
  int *v9; // ecx
  int *i; // ecx
  int v11; // [esp+Ch] [ebp-8h] BYREF
  int *v12; // [esp+10h] [ebp-4h]

  v4 = a3;
  result = a2;
  v12 = a2;
  if ( a3 == (int *)**this && a4 == *this )
  {
    sub_42B4F0(this);
    result = v12;
    *v12 = **this;
  }
  else
  {
    if ( a3 != a4 )
    {
      do
      {
        v7 = v4;
        if ( !*((_BYTE *)v4 + 13) )
        {
          v8 = (int *)v4[2];
          if ( *((_BYTE *)v8 + 13) )
          {
            for ( i = (int *)v4[1]; !*((_BYTE *)i + 13); i = (int *)i[1] )
            {
              if ( v4 != (int *)i[2] )
                break;
              v4 = i;
            }
            a3 = i;
          }
          else
          {
            v9 = (int *)*v8;
            if ( !*(_BYTE *)(*v8 + 13) )
            {
              do
              {
                v8 = v9;
                v9 = (int *)*v9;
              }
              while ( !*((_BYTE *)v9 + 13) );
            }
            a3 = v8;
          }
        }
        sub_42B630(this, &v11, v7);
        v4 = a3;
      }
      while ( a3 != a4 );
      result = v12;
    }
    *result = (int)v4;
  }
  return result;
}

//----- (0042B630) --------------------------------------------------------
_DWORD *__thiscall sub_42B630(int **this, _DWORD *a2, _DWORD *a3)
{
  _BYTE *v4; // ecx
  int v5; // edi
  int v6; // edx
  int v7; // esi
  int *v8; // eax
  int i; // edx
  int v10; // eax
  int v11; // eax
  int j; // edx
  void **v13; // eax
  char v14; // cl
  _BYTE *v15; // ecx
  int *v16; // ecx
  _DWORD *result; // eax
  _DWORD *v18; // [esp+14h] [ebp-4h]

  v18 = a3;
  sub_427450((int *)&a3);
  v4 = v18;
  if ( *(_BYTE *)(*v18 + 13) )
  {
    v5 = v18[2];
  }
  else if ( *(_BYTE *)(v18[2] + 13) )
  {
    v5 = *v18;
  }
  else
  {
    v6 = (int)a3;
    v5 = a3[2];
    if ( a3 != v18 )
    {
      *(_DWORD *)(*v18 + 4) = a3;
      *(_DWORD *)v6 = *v18;
      if ( v6 == v18[2] )
      {
        v7 = v6;
      }
      else
      {
        v7 = *(_DWORD *)(v6 + 4);
        if ( !*(_BYTE *)(v5 + 13) )
          *(_DWORD *)(v5 + 4) = v7;
        *(_DWORD *)v7 = v5;
        *(_DWORD *)(v6 + 8) = v18[2];
        *(_DWORD *)(v18[2] + 4) = v6;
      }
      if ( (_DWORD *)(*this)[1] == v18 )
      {
        (*this)[1] = v6;
      }
      else
      {
        v13 = (void **)v18[1];
        if ( *v13 == v18 )
          *v13 = (void *)v6;
        else
          v13[2] = (void *)v6;
      }
      *(_DWORD *)(v6 + 4) = v18[1];
      v14 = *(_BYTE *)(v6 + 12);
      *(_BYTE *)(v6 + 12) = *((_BYTE *)v18 + 12);
      *((_BYTE *)v18 + 12) = v14;
      v4 = v18;
      goto LABEL_37;
    }
  }
  v7 = v18[1];
  if ( !*(_BYTE *)(v5 + 13) )
    *(_DWORD *)(v5 + 4) = v7;
  if ( (_DWORD *)(*this)[1] == v18 )
  {
    (*this)[1] = v5;
  }
  else if ( *(_DWORD **)v7 == v18 )
  {
    *(_DWORD *)v7 = v5;
  }
  else
  {
    *(_DWORD *)(v7 + 8) = v5;
  }
  v8 = *this;
  if ( (_DWORD *)**this == v18 )
  {
    if ( *(_BYTE *)(v5 + 13) )
    {
      i = v7;
    }
    else
    {
      v10 = *(_DWORD *)v5;
      for ( i = v5; !*(_BYTE *)(v10 + 13); v10 = *(_DWORD *)v10 )
        i = v10;
      v8 = *this;
    }
    *v8 = i;
  }
  if ( (_DWORD *)(*this)[2] == v18 )
  {
    if ( *(_BYTE *)(v5 + 13) )
    {
      (*this)[2] = v7;
    }
    else
    {
      v11 = *(_DWORD *)(v5 + 8);
      for ( j = v5; !*(_BYTE *)(v11 + 13); v11 = *(_DWORD *)(v11 + 8) )
        j = v11;
      (*this)[2] = j;
    }
  }
LABEL_37:
  if ( v4[12] != 1 )
    goto LABEL_62;
  if ( v5 == (*this)[1] )
    goto LABEL_61;
  while ( *(_BYTE *)(v5 + 12) == 1 )
  {
    v15 = *(_BYTE **)v7;
    if ( v5 == *(_DWORD *)v7 )
    {
      v15 = *(_BYTE **)(v7 + 8);
      if ( !v15[12] )
      {
        v15[12] = 1;
        *(_BYTE *)(v7 + 12) = 0;
        sub_42B050(this, v7);
        v15 = *(_BYTE **)(v7 + 8);
      }
      if ( v15[13] )
        goto LABEL_55;
      if ( *(_BYTE *)(*(_DWORD *)v15 + 12) != 1 || *(_BYTE *)(*((_DWORD *)v15 + 2) + 12) != 1 )
      {
        if ( *(_BYTE *)(*((_DWORD *)v15 + 2) + 12) == 1 )
        {
          *(_BYTE *)(*(_DWORD *)v15 + 12) = 1;
          v15[12] = 0;
          sub_42B3C0(this, v15);
          v15 = *(_BYTE **)(v7 + 8);
        }
        v15[12] = *(_BYTE *)(v7 + 12);
        *(_BYTE *)(v7 + 12) = 1;
        *(_BYTE *)(*((_DWORD *)v15 + 2) + 12) = 1;
        sub_42B050(this, v7);
        break;
      }
    }
    else
    {
      if ( !v15[12] )
      {
        v15[12] = 1;
        *(_BYTE *)(v7 + 12) = 0;
        sub_42B3C0(this, (_DWORD *)v7);
        v15 = *(_BYTE **)v7;
      }
      if ( v15[13] )
        goto LABEL_55;
      if ( *(_BYTE *)(*((_DWORD *)v15 + 2) + 12) != 1 || *(_BYTE *)(*(_DWORD *)v15 + 12) != 1 )
      {
        if ( *(_BYTE *)(*(_DWORD *)v15 + 12) == 1 )
        {
          *(_BYTE *)(*((_DWORD *)v15 + 2) + 12) = 1;
          v15[12] = 0;
          sub_42B050(this, (int)v15);
          v15 = *(_BYTE **)v7;
        }
        v15[12] = *(_BYTE *)(v7 + 12);
        *(_BYTE *)(v7 + 12) = 1;
        *(_BYTE *)(*(_DWORD *)v15 + 12) = 1;
        sub_42B3C0(this, (_DWORD *)v7);
        break;
      }
    }
    v15[12] = 0;
LABEL_55:
    v5 = v7;
    v7 = *(_DWORD *)(v7 + 4);
    if ( v5 == (*this)[1] )
      break;
  }
  v4 = v18;
LABEL_61:
  *(_BYTE *)(v5 + 12) = 1;
LABEL_62:
  operator delete(v4);
  v16 = this[1];
  if ( v16 )
  {
    result = a2;
    this[1] = (int *)((char *)v16 - 1);
    *a2 = a3;
  }
  else
  {
    *a2 = a3;
    return a2;
  }
  return result;
}

//----- (0042B8B0) --------------------------------------------------------
_DWORD *__thiscall sub_42B8B0(_DWORD *this, _DWORD *a2, _DWORD **a3, _DWORD **a4)
{
  void *v4; // edx
  _DWORD *v6; // esi
  _DWORD **v7; // edi
  _DWORD *result; // eax
  _DWORD **v9; // esi

  v4 = a4;
  v6 = a2;
  v7 = a3;
  if ( a3 == *(_DWORD ***)*this && a4 == (_DWORD **)*this )
  {
    sub_42B540(this);
    result = a2;
    *a2 = *this;
  }
  else
  {
    if ( a3 != a4 )
    {
      do
      {
        v9 = (_DWORD **)*v7;
        *v7[1] = *v7;
        (*v7)[1] = v7[1];
        --this[1];
        operator delete(v7);
        v4 = a4;
        v7 = v9;
      }
      while ( v9 != a4 );
      v6 = a2;
    }
    *v6 = v4;
    return v6;
  }
  return result;
}

//----- (0042B920) --------------------------------------------------------
int __thiscall sub_42B920(_DWORD *this)
{
  return this[10];
}

//----- (0042B930) --------------------------------------------------------
int __thiscall sub_42B930(_DWORD *this, int a2)
{
  return *(_DWORD *)(this[10] + 4 * a2);
}

//----- (0042B950) --------------------------------------------------------
int sub_42B950()
{
  return 1;
}

//----- (0042B960) --------------------------------------------------------
double sub_42B960()
{
  return 0.0;
}

//----- (0042B970) --------------------------------------------------------
int __thiscall sub_42B970(_DWORD *this, _DWORD *a2)
{
  int v3; // eax
  int v4; // ecx
  int v5; // ecx
  int v6; // edi
  unsigned int v7; // edi
  int v8; // ebx
  void *v9; // ecx
  int result; // eax
  _DWORD *v11; // edx

  v3 = this[3];
  v4 = this[4];
  if ( (((_BYTE)v4 + (_BYTE)v3) & 1) == 0 && this[2] <= (unsigned int)(v4 + 2) >> 1 )
    sub_42AED0((int)this, 1u);
  v5 = this[2];
  v6 = this[4];
  this[3] &= 2 * v5 - 1;
  v7 = this[3] + v6;
  v8 = 4 * ((v7 >> 1) & (v5 - 1));
  if ( !*(_DWORD *)(v8 + this[1]) )
  {
    v9 = operator new(0x10u);
    if ( !v9 )
      std::_Xbad_alloc();
    *(_DWORD *)(v8 + this[1]) = v9;
  }
  result = *(_DWORD *)(this[1] + v8);
  v11 = (_DWORD *)(result + 8 * (v7 & 1));
  if ( v11 )
  {
    *v11 = *a2;
    result = a2[1];
    v11[1] = result;
  }
  ++this[4];
  return result;
}
// 42B9DA: variable 'v9' is possibly undefined
// 43903C: using guessed type void __cdecl std::_Xbad_alloc();

//----- (0042BA10) --------------------------------------------------------
int *__thiscall sub_42BA10(_DWORD *this, _DWORD *a2)
{
  _DWORD *v3; // edi
  int v4; // edx
  int v5; // eax
  int *result; // eax

  v3 = (_DWORD *)*this;
  v4 = sub_426520((_DWORD *)*this, *(_DWORD **)(*this + 4), a2);
  v5 = this[1];
  if ( v5 == 357913940 )
    std::_Xlength_error("list<T> too long");
  this[1] = v5 + 1;
  v3[1] = v4;
  result = *(int **)(v4 + 4);
  *result = v4;
  return result;
}
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (0042BA60) --------------------------------------------------------
int __thiscall sub_42BA60(_DWORD *this, unsigned int a2)
{
  int v3; // esi
  int result; // eax
  unsigned int v5; // ecx
  unsigned int v6; // edi
  int v7; // esi
  _DWORD v8[9]; // [esp+0h] [ebp-24h] BYREF

  v8[5] = v8;
  v8[4] = this;
  v3 = this[1];
  result = 1717986919 * (v3 - *this);
  v5 = (v3 - *this) / 40;
  if ( v5 > a2 )
  {
    v6 = a2 - v5;
LABEL_3:
    result = v3 + 40 * v6;
    this[1] = result;
    return result;
  }
  if ( v5 < a2 )
  {
    sub_4211E0(this, a2 - v5);
    v7 = this[1];
    v8[8] = 0;
    sub_426B70(v7, a2 - (v7 - *this) / 40);
    v3 = this[1];
    v6 = a2 - (v3 - *this) / 40;
    goto LABEL_3;
  }
  return result;
}

//----- (0042BB40) --------------------------------------------------------
int __thiscall sub_42BB40(int *this, unsigned int a2)
{
  void (__thiscall ***v2)(_DWORD, _DWORD); // ebx
  unsigned int v3; // edi
  int result; // eax
  unsigned int v5; // ecx
  int v6; // edi
  void (__thiscall ***i)(_DWORD, _DWORD); // esi
  int *v8; // ebx
  int v9; // esi
  int v10; // [esp+0h] [ebp-24h] BYREF
  int *v11; // [esp+10h] [ebp-14h]
  int *v12; // [esp+14h] [ebp-10h]
  int v13; // [esp+20h] [ebp-4h]

  v12 = &v10;
  v11 = this;
  v2 = (void (__thiscall ***)(_DWORD, _DWORD))this[1];
  v3 = a2;
  result = -1840700269 * ((_DWORD)v2 - *this);
  v5 = ((int)v2 - *this) / 56;
  if ( v5 <= a2 )
  {
    if ( v5 < a2 )
    {
      v8 = v11;
      sub_42B2D0(v11, a2 - v5);
      v9 = v8[1];
      v13 = 0;
      sub_426BA0((unsigned int *)((char *)&a2 + 3), v9, v3 - (v9 - *v8) / 56);
      result = v8[1] + 56 * (v3 - (v8[1] - *v8) / 56);
      v8[1] = result;
    }
  }
  else
  {
    v6 = (int)&v2[14 * (a2 - v5)];
    for ( i = (void (__thiscall ***)(_DWORD, _DWORD))v6; i != v2; i += 14 )
      (**i)(i, 0);
    result = (int)v11;
    v11[1] = v6;
  }
  return result;
}

//----- (0042BC70) --------------------------------------------------------
void __thiscall sub_42BC70(int *this, unsigned int a2)
{
  int v3; // eax
  unsigned int v4; // esi
  unsigned int v5; // ecx
  int v6; // esi
  int v7; // edx
  _DWORD v8[9]; // [esp+0h] [ebp-24h] BYREF

  v8[5] = v8;
  v8[4] = this;
  v3 = this[1];
  v4 = a2;
  v5 = (v3 - *this) >> 5;
  if ( v5 <= a2 )
  {
    if ( v5 < a2 )
    {
      sub_42B340(this, a2 - v5);
      v7 = this[1];
      v8[8] = 0;
      sub_426BE0((unsigned int *)((char *)&a2 + 3), v7, v4 - ((v7 - *this) >> 5));
      this[1] += 32 * (v4 - ((this[1] - *this) >> 5));
    }
  }
  else
  {
    v6 = v3 + 32 * (a2 - v5);
    sub_404130(v6, v3);
    this[1] = v6;
  }
}

//----- (0042BD50) --------------------------------------------------------
int __thiscall sub_42BD50(_DWORD *this, int a2, int a3)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(this[10] + 4 * a2) = a3;
  return result;
}

//----- (0042BD70) --------------------------------------------------------
_DWORD *__thiscall sub_42BD70(_DWORD *this)
{
  *this = &CCurveFit::`vftable';
  this[2] = 0;
  this[3] = 0;
  memset(this + 14, 0, 0x320u);
  return this;
}
// 43A354: using guessed type void *CCurveFit::`vftable';

//----- (0042BDA0) --------------------------------------------------------
void __thiscall sub_42BDA0(void *this)
{
  void *v2; // [esp-4h] [ebp-8h]

  v2 = (void *)*((_DWORD *)this + 2);
  *(_DWORD *)this = &CCurveFit::`vftable';
  operator delete[](v2);
  operator delete[](*((void **)this + 3));
}
// 43A354: using guessed type void *CCurveFit::`vftable';

//----- (0042BDC0) --------------------------------------------------------
void *__thiscall sub_42BDC0(void *this, char a2)
{
  void *v4; // [esp-4h] [ebp-8h]

  v4 = (void *)*((_DWORD *)this + 2);
  *(_DWORD *)this = &CCurveFit::`vftable';
  operator delete[](v4);
  operator delete[](*((void **)this + 3));
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 43A354: using guessed type void *CCurveFit::`vftable';

//----- (0042BE00) --------------------------------------------------------
void __thiscall sub_42BE00(int this, double a2, __int64 a3, int a4)
{
  double v5; // xmm0_8
  int v6; // esi
  int v7; // esi
  int v8; // esi
  int Mat; // eax
  int v10; // edx
  int v11; // eax
  float v12; // xmm1_4
  int v13; // xmm2_4
  int v14; // ecx
  double v15; // xmm5_8
  double v16; // xmm7_8
  float v17; // xmm6_4
  double v18; // xmm2_8
  __int128 *v19; // ecx
  double v20; // xmm2_8
  int v21; // esi
  double v22; // xmm3_8
  int v23; // esi
  int v24; // esi
  int v25; // eax
  int v26; // edx
  int v27; // eax
  float v28; // xmm1_4
  int v29; // xmm2_4
  int v30; // ecx
  float v31; // xmm0_4
  float v32; // xmm1_4
  double v33; // xmm5_8
  double v34; // xmm7_8
  float v35; // xmm6_4
  double v36; // xmm4_8
  double v37; // xmm2_8
  double v38; // xmm0_8
  int i; // edx
  int v40; // eax
  float v41; // xmm1_4
  int v42; // xmm2_4
  int v43; // ecx
  float v44; // xmm3_4
  float v45; // xmm2_4
  double v46; // xmm4_8
  double v47; // xmm3_8
  double v48; // xmm0_8
  int v49; // esi
  int v50; // esi
  int v51; // esi
  int v52; // eax
  int v53; // edx
  int v54; // eax
  int v55; // xmm0_4
  int v56; // xmm1_4
  int v57; // ecx
  float v58; // xmm1_4
  double v59; // xmm2_8
  int v60; // [esp+14h] [ebp-15Ch]
  int v61; // [esp+14h] [ebp-15Ch]
  int v62; // [esp+18h] [ebp-158h]
  int v63; // [esp+1Ch] [ebp-154h]
  int v64; // [esp+20h] [ebp-150h]
  double v65; // [esp+28h] [ebp-148h]
  double v66; // [esp+30h] [ebp-140h]
  double v67; // [esp+30h] [ebp-140h]
  double v68; // [esp+38h] [ebp-138h]
  double v69; // [esp+38h] [ebp-138h]
  double v70; // [esp+40h] [ebp-130h]
  double v71; // [esp+40h] [ebp-130h]
  double v72; // [esp+48h] [ebp-128h]
  double v73; // [esp+48h] [ebp-128h]
  double v74; // [esp+48h] [ebp-128h]
  double v75; // [esp+48h] [ebp-128h]
  double v76; // [esp+50h] [ebp-120h]
  double v77; // [esp+50h] [ebp-120h]
  double v78; // [esp+50h] [ebp-120h]
  double v79; // [esp+50h] [ebp-120h]
  double v80; // [esp+58h] [ebp-118h]
  double v81; // [esp+58h] [ebp-118h]
  double v82; // [esp+60h] [ebp-110h]
  __int128 v83; // [esp+70h] [ebp-100h] BYREF
  int v84; // [esp+80h] [ebp-F0h]
  __int128 v85; // [esp+84h] [ebp-ECh] BYREF
  int v86; // [esp+94h] [ebp-DCh]
  __int128 v87; // [esp+98h] [ebp-D8h] BYREF
  int v88; // [esp+A8h] [ebp-C8h]
  __int128 v89; // [esp+ACh] [ebp-C4h] BYREF
  int v90; // [esp+BCh] [ebp-B4h]
  __int128 v91; // [esp+C0h] [ebp-B0h] BYREF
  int v92; // [esp+D0h] [ebp-A0h]
  __int128 v93; // [esp+D4h] [ebp-9Ch] BYREF
  int v94; // [esp+E4h] [ebp-8Ch]
  __int128 v95; // [esp+E8h] [ebp-88h] BYREF
  int v96; // [esp+F8h] [ebp-78h]
  __int128 v97; // [esp+FCh] [ebp-74h] BYREF
  int v98; // [esp+10Ch] [ebp-64h]
  __int128 v99; // [esp+110h] [ebp-60h] BYREF
  int v100; // [esp+120h] [ebp-50h]
  __int128 v101; // [esp+124h] [ebp-4Ch] BYREF
  int v102; // [esp+134h] [ebp-3Ch]
  __int128 v103; // [esp+138h] [ebp-38h] BYREF
  int v104; // [esp+148h] [ebp-28h]
  __int128 v105; // [esp+14Ch] [ebp-24h] BYREF
  int v106; // [esp+15Ch] [ebp-14h]
  int v107; // [esp+16Ch] [ebp-4h]

  *(_QWORD *)(this + 872) = a3;
  sub_42D580(this, this, a4);
  *(_QWORD *)(this + 16) = libm_sse2_cos_precise(v63, v64).m128_u64[0];
  *(_QWORD *)(this + 24) = libm_sse2_sin_precise().m128_u64[0];
  *(_DWORD *)(this + 36) = a4;
  switch ( a4 )
  {
    case 4:
      v5 = *(float *)(this + 40);
      v6 = *(_DWORD *)(this + 32);
      v106 = 0;
      v72 = *(float *)(this + 48);
      v80 = *(float *)(this + 44);
      v105 = 0i64;
      LODWORD(v105) = &CMyMatrix::`vftable';
      DWORD2(v105) = 0;
      sub_403EE0(&v105);
      HIDWORD(v105) = v6;
      v106 = 5;
      DWORD2(v105) = cvCreateMat(v6, 5, 5);
      DWORD1(v105) = *(_DWORD *)(DWORD2(v105) + 16);
      v7 = *(_DWORD *)(this + 32);
      v107 = 0;
      v99 = 0i64;
      v100 = 0;
      LODWORD(v99) = &CMyMatrix::`vftable';
      DWORD2(v99) = 0;
      sub_403EE0(&v99);
      HIDWORD(v99) = v7;
      v100 = 1;
      DWORD2(v99) = cvCreateMat(v7, 1, 5);
      DWORD1(v99) = *(_DWORD *)(DWORD2(v99) + 16);
      LOBYTE(v107) = 1;
      v101 = 0i64;
      v102 = 0;
      LODWORD(v101) = &CMyMatrix::`vftable';
      DWORD2(v101) = 0;
      sub_403EE0(&v101);
      HIDWORD(v101) = 5;
      v102 = 5;
      DWORD2(v101) = cvCreateMat(5, 5, 5);
      DWORD1(v101) = *(_DWORD *)(DWORD2(v101) + 16);
      LOBYTE(v107) = 2;
      v95 = 0i64;
      v96 = 0;
      LODWORD(v95) = &CMyMatrix::`vftable';
      DWORD2(v95) = 0;
      sub_403EE0(&v95);
      HIDWORD(v95) = 5;
      v96 = 5;
      DWORD2(v95) = cvCreateMat(5, 5, 5);
      DWORD1(v95) = *(_DWORD *)(DWORD2(v95) + 16);
      v8 = *(_DWORD *)(this + 32);
      LOBYTE(v107) = 3;
      v97 = 0i64;
      v98 = 0;
      LODWORD(v97) = &CMyMatrix::`vftable';
      DWORD2(v97) = 0;
      sub_403EE0(&v97);
      HIDWORD(v97) = 5;
      v98 = v8;
      DWORD2(v97) = cvCreateMat(5, v8, 5);
      DWORD1(v97) = *(_DWORD *)(DWORD2(v97) + 16);
      LOBYTE(v107) = 4;
      v103 = 0i64;
      v104 = 0;
      LODWORD(v103) = &CMyMatrix::`vftable';
      DWORD2(v103) = 0;
      sub_403EE0(&v103);
      HIDWORD(v103) = 5;
      v104 = 1;
      Mat = cvCreateMat(5, 1, 5);
      v10 = 0;
      DWORD2(v103) = Mat;
      for ( DWORD1(v103) = *(_DWORD *)(Mat + 16); v10 < *(_DWORD *)(this + 32); *(_DWORD *)(DWORD1(v99) + 4 * v14) = v13 )
      {
        v11 = *(_DWORD *)(this + 8);
        v12 = *(float *)(v11 + 8 * v10);
        v13 = *(_DWORD *)(v11 + 8 * v10 + 4);
        *(_DWORD *)(DWORD1(v105) + 4 * v10 * v106 + 16) = 1065353216;
        *(float *)(DWORD1(v105) + 4 * v10 * v106 + 12) = v12;
        *(float *)(DWORD1(v105) + 4 * v10 * v106 + 8) = v12 * v12;
        *(float *)(DWORD1(v105) + 4 * v10 * v106 + 4) = *(float *)(DWORD1(v105) + 4 * v10 * v106 + 8) * v12;
        *(float *)(DWORD1(v105) + 4 * v10 * v106) = *(float *)(DWORD1(v105) + 4 * v10 * v106 + 4) * v12;
        v14 = v10 * v100;
        ++v10;
      }
      cvGEMM(DWORD2(v105), DWORD2(v105), 0, 1072693248, 0, 0, 0, DWORD2(v101), 1);
      cvInvert(DWORD2(v101), DWORD2(v95), 0);
      cvGEMM(DWORD2(v95), DWORD2(v105), 0, 1072693248, 0, 0, 0, DWORD2(v97), 2);
      cvGEMM(DWORD2(v97), DWORD2(v99), 0, 1072693248, 0, 0, 0, DWORD2(v103), 0);
      v65 = *(float *)(DWORD1(v103) + 8 * v104);
      v15 = v5 * v5 * v5;
      v76 = *(float *)(DWORD1(v103) + 12 * v104);
      v16 = v80 * v80 * v80;
      v17 = *(float *)(DWORD1(v103) + 16 * v104);
      v66 = *(float *)DWORD1(v103);
      v70 = *(float *)(DWORD1(v103) + 4 * v104);
      *(double *)(this + 88) = v66 * v80 / (v16 * v80);
      v18 = v70 * 3.0 * v5;
      *(double *)(this + 80) = v70 * v80 / v16 - v66 * 4.0 * v5 * v80 / (v16 * v80);
      *(double *)(this + 72) = v65 * v80 / v80 / v80 - v18 * v80 / v16 + v66 * 6.0 * v5 * v5 * v80 / (v16 * v80);
      *(double *)(this + 64) = v76 * v80 / v80
                             - v65 * 2.0 * v5 * v80 / v80 / v80
                             + v18 * v5 * v80 / v16
                             - v66 * 4.0 * v15 * v80 / (v16 * v80);
      *(double *)(this + 56) = v15 * v5 * v66 * v80 / (v16 * v80)
                             + v17 * v80
                             + v72
                             - v15 * v70 * v80 / v16
                             + v65 * v5 * v5 * v80 / v80 / v80
                             - v76 * v5 * v80 / v80;
      sub_403E70(&v103);
      LOBYTE(v107) = 3;
      sub_403E70(&v97);
      LOBYTE(v107) = 2;
      sub_403E70(&v95);
      LOBYTE(v107) = 1;
      sub_403E70(&v101);
      LOBYTE(v107) = 0;
      sub_403E70(&v99);
      v19 = &v105;
      break;
    case 3:
      v20 = *(double *)(this + 864) * 1.2;
      v21 = *(_DWORD *)(this + 32);
      v22 = *(double *)(this + 856) * 1.2;
      v106 = 0;
      v68 = (v20 - v22) * 4.0;
      v82 = *(float *)(this + 40);
      v71 = (v22 * v20 + v20 * v20 + v22 * v22) * (v68 * 3.0);
      v67 = *(float *)(this + 48);
      v73 = (v22 + v20) * (v68 * 3.0);
      v81 = *(float *)(this + 44);
      v105 = 0i64;
      LODWORD(v105) = &CMyMatrix::`vftable';
      DWORD2(v105) = 0;
      sub_403EE0(&v105);
      HIDWORD(v105) = v21;
      v106 = 4;
      DWORD2(v105) = cvCreateMat(v21, 4, 5);
      DWORD1(v105) = *(_DWORD *)(DWORD2(v105) + 16);
      v23 = *(_DWORD *)(this + 32);
      v107 = 5;
      v97 = 0i64;
      v98 = 0;
      LODWORD(v97) = &CMyMatrix::`vftable';
      DWORD2(v97) = 0;
      sub_403EE0(&v97);
      HIDWORD(v97) = v23;
      v98 = 1;
      DWORD2(v97) = cvCreateMat(v23, 1, 5);
      DWORD1(v97) = *(_DWORD *)(DWORD2(v97) + 16);
      LOBYTE(v107) = 6;
      v103 = 0i64;
      v104 = 0;
      LODWORD(v103) = &CMyMatrix::`vftable';
      DWORD2(v103) = 0;
      sub_403EE0(&v103);
      HIDWORD(v103) = 4;
      v104 = 4;
      DWORD2(v103) = cvCreateMat(4, 4, 5);
      DWORD1(v103) = *(_DWORD *)(DWORD2(v103) + 16);
      LOBYTE(v107) = 7;
      v95 = 0i64;
      v96 = 0;
      LODWORD(v95) = &CMyMatrix::`vftable';
      DWORD2(v95) = 0;
      sub_403EE0(&v95);
      HIDWORD(v95) = 4;
      v96 = 4;
      DWORD2(v95) = cvCreateMat(4, 4, 5);
      DWORD1(v95) = *(_DWORD *)(DWORD2(v95) + 16);
      v24 = *(_DWORD *)(this + 32);
      LOBYTE(v107) = 8;
      v101 = 0i64;
      v102 = 0;
      LODWORD(v101) = &CMyMatrix::`vftable';
      DWORD2(v101) = 0;
      sub_403EE0(&v101);
      HIDWORD(v101) = 4;
      v102 = v24;
      DWORD2(v101) = cvCreateMat(4, v24, 5);
      DWORD1(v101) = *(_DWORD *)(DWORD2(v101) + 16);
      LOBYTE(v107) = 9;
      v99 = 0i64;
      v100 = 0;
      LODWORD(v99) = &CMyMatrix::`vftable';
      DWORD2(v99) = 0;
      sub_403EE0(&v99);
      HIDWORD(v99) = 4;
      v100 = 1;
      v25 = cvCreateMat(4, 1, 5);
      v26 = 0;
      DWORD2(v99) = v25;
      for ( DWORD1(v99) = *(_DWORD *)(v25 + 16); v26 < *(_DWORD *)(this + 32); *(_DWORD *)(DWORD1(v97) + 4 * v30) = v29 )
      {
        v27 = *(_DWORD *)(this + 8);
        v28 = *(float *)(v27 + 8 * v26);
        v29 = *(_DWORD *)(v27 + 8 * v26 + 4);
        *(_DWORD *)(DWORD1(v105) + 4 * v26 * v106 + 12) = 1065353216;
        *(float *)(DWORD1(v105) + 4 * v26 * v106 + 8) = v28;
        *(float *)(DWORD1(v105) + 4 * v26 * v106 + 4) = v28 * v28;
        *(float *)(DWORD1(v105) + 4 * v26 * v106) = *(float *)(DWORD1(v105) + 4 * v26 * v106 + 4) * v28;
        v30 = v26 * v98;
        ++v26;
      }
      cvGEMM(DWORD2(v105), DWORD2(v105), 0, 1072693248, 0, 0, 0, DWORD2(v103), 1);
      v31 = v71 * a2;
      *(float *)DWORD1(v103) = v31 + *(float *)DWORD1(v103);
      v32 = v73 * a2 * 0.5;
      *(float *)(DWORD1(v103) + 4) = v32 + *(float *)(DWORD1(v103) + 4);
      *(float *)(DWORD1(v103) + 4 * v104) = v32 + *(float *)(DWORD1(v103) + 4 * v104);
      *(float *)(DWORD1(v103) + 4 * v104 + 4) = (float)(v68 * a2) + *(float *)(DWORD1(v103) + 4 * v104 + 4);
      cvInvert(DWORD2(v103), DWORD2(v95), 0);
      cvGEMM(DWORD2(v95), DWORD2(v105), 0, 1072693248, 0, 0, 0, DWORD2(v101), 2);
      cvGEMM(DWORD2(v101), DWORD2(v97), 0, 1072693248, 0, 0, 0, DWORD2(v99), 0);
      v33 = *(float *)DWORD1(v99);
      v34 = *(float *)(DWORD1(v99) + 4 * v100);
      v77 = *(float *)(DWORD1(v99) + 8 * v100);
      v35 = *(float *)(DWORD1(v99) + 12 * v100);
      v36 = v81 * v81 * v81;
      *(_QWORD *)(this + 88) = 0i64;
      v37 = v33 * 3.0 * v82;
      *(double *)(this + 80) = v33 * v81 / v36;
      *(double *)(this + 72) = v34 * v81 / v81 / v81 - v81 * v37 / v36;
      *(double *)(this + 64) = v77 * v81 / v81 - v34 * 2.0 * v82 * v81 / v81 / v81 + v82 * v37 * v81 / v36;
      *(double *)(this + 56) = v35 * v81
                             + v67
                             - v82 * v82 * v82 * v33 * v81 / v36
                             + v34 * v82 * v82 * v81 / v81 / v81
                             - v77 * v82 * v81 / v81;
      sub_403E70(&v99);
      LOBYTE(v107) = 8;
      sub_403E70(&v101);
      LOBYTE(v107) = 7;
      sub_403E70(&v95);
      LOBYTE(v107) = 6;
      sub_403E70(&v103);
      LOBYTE(v107) = 5;
      sub_403E70(&v97);
      v19 = &v105;
      break;
    case 2:
      v38 = *(float *)(this + 40);
      v102 = 0;
      v60 = *(_DWORD *)(this + 32);
      v78 = *(float *)(this + 48);
      v74 = *(float *)(this + 44);
      v101 = 0i64;
      sub_4270F0(&v101, v60, 3);
      v61 = *(_DWORD *)(this + 32);
      v107 = 10;
      v98 = 0;
      v97 = 0i64;
      sub_4270F0(&v97, v61, 1);
      LOBYTE(v107) = 11;
      v106 = 0;
      v105 = 0i64;
      sub_4270F0(&v105, 3, 3);
      LOBYTE(v107) = 12;
      v104 = 0;
      v103 = 0i64;
      sub_4270F0(&v103, 3, 3);
      v62 = *(_DWORD *)(this + 32);
      LOBYTE(v107) = 13;
      v100 = 0;
      v99 = 0i64;
      sub_4270F0(&v99, 3, v62);
      LOBYTE(v107) = 14;
      v96 = 0;
      v95 = 0i64;
      sub_4270F0(&v95, 3, 1);
      for ( i = 0; i < *(_DWORD *)(this + 32); *(_DWORD *)(DWORD1(v97) + 4 * v43) = v42 )
      {
        v40 = *(_DWORD *)(this + 8);
        v41 = *(float *)(v40 + 8 * i);
        v42 = *(_DWORD *)(v40 + 8 * i + 4);
        *(_DWORD *)(DWORD1(v101) + 4 * i * v102 + 8) = 1065353216;
        *(float *)(DWORD1(v101) + 4 * i * v102 + 4) = v41;
        *(float *)(DWORD1(v101) + 4 * i * v102) = *(float *)(DWORD1(v101) + 4 * i * v102 + 4) * v41;
        v43 = i * v98;
        ++i;
      }
      cvGEMM(DWORD2(v101), DWORD2(v101), 0, 1072693248, 0, 0, 0, DWORD2(v105), 1);
      cvInvert(DWORD2(v105), DWORD2(v103), 0);
      cvGEMM(DWORD2(v103), DWORD2(v101), 0, 1072693248, 0, 0, 0, DWORD2(v99), 2);
      cvGEMM(DWORD2(v99), DWORD2(v97), 0, 1072693248, 0, 0, 0, DWORD2(v95), 0);
      v44 = *(float *)(DWORD1(v95) + 4 * v96);
      v45 = *(float *)(DWORD1(v95) + 8 * v96);
      v46 = *(float *)DWORD1(v95);
      *(_OWORD *)(this + 80) = 0i64;
      v47 = v44;
      *(double *)(this + 72) = v46 * v74 / v74 / v74;
      *(double *)(this + 64) = v47 * v74 / v74 - v46 * 2.0 * v38 * v74 / v74 / v74;
      *(double *)(this + 56) = v46 * v38 * v38 * v74 / v74 / v74 + v45 * v74 + v78 - v47 * v38 * v74 / v74;
      sub_403E70(&v95);
      LOBYTE(v107) = 13;
      sub_403E70(&v99);
      LOBYTE(v107) = 12;
      sub_403E70(&v103);
      LOBYTE(v107) = 11;
      sub_403E70(&v105);
      LOBYTE(v107) = 10;
      sub_403E70(&v97);
      v19 = &v101;
      break;
    case 1:
      v48 = *(float *)(this + 40);
      v49 = *(_DWORD *)(this + 32);
      v94 = 0;
      v79 = v48;
      v69 = *(float *)(this + 48);
      v75 = *(float *)(this + 44);
      v93 = 0i64;
      LODWORD(v93) = &CMyMatrix::`vftable';
      DWORD2(v93) = 0;
      sub_403EE0(&v93);
      HIDWORD(v93) = v49;
      v94 = 2;
      DWORD2(v93) = cvCreateMat(v49, 2, 5);
      DWORD1(v93) = *(_DWORD *)(DWORD2(v93) + 16);
      v50 = *(_DWORD *)(this + 32);
      v107 = 15;
      v91 = 0i64;
      v92 = 0;
      LODWORD(v91) = &CMyMatrix::`vftable';
      DWORD2(v91) = 0;
      sub_403EE0(&v91);
      HIDWORD(v91) = v50;
      v92 = 1;
      DWORD2(v91) = cvCreateMat(v50, 1, 5);
      DWORD1(v91) = *(_DWORD *)(DWORD2(v91) + 16);
      LOBYTE(v107) = 16;
      v87 = 0i64;
      v88 = 0;
      LODWORD(v87) = &CMyMatrix::`vftable';
      DWORD2(v87) = 0;
      sub_403EE0(&v87);
      HIDWORD(v87) = 2;
      v88 = 2;
      DWORD2(v87) = cvCreateMat(2, 2, 5);
      DWORD1(v87) = *(_DWORD *)(DWORD2(v87) + 16);
      LOBYTE(v107) = 17;
      v83 = 0i64;
      v84 = 0;
      LODWORD(v83) = &CMyMatrix::`vftable';
      DWORD2(v83) = 0;
      sub_403EE0(&v83);
      HIDWORD(v83) = 2;
      v84 = 2;
      DWORD2(v83) = cvCreateMat(2, 2, 5);
      DWORD1(v83) = *(_DWORD *)(DWORD2(v83) + 16);
      v51 = *(_DWORD *)(this + 32);
      LOBYTE(v107) = 18;
      v85 = 0i64;
      v86 = 0;
      LODWORD(v85) = &CMyMatrix::`vftable';
      DWORD2(v85) = 0;
      sub_403EE0(&v85);
      HIDWORD(v85) = 2;
      v86 = v51;
      DWORD2(v85) = cvCreateMat(2, v51, 5);
      DWORD1(v85) = *(_DWORD *)(DWORD2(v85) + 16);
      LOBYTE(v107) = 19;
      v89 = 0i64;
      v90 = 0;
      LODWORD(v89) = &CMyMatrix::`vftable';
      DWORD2(v89) = 0;
      sub_403EE0(&v89);
      HIDWORD(v89) = 2;
      v90 = 1;
      v52 = cvCreateMat(2, 1, 5);
      v53 = 0;
      DWORD2(v89) = v52;
      for ( DWORD1(v89) = *(_DWORD *)(v52 + 16); v53 < *(_DWORD *)(this + 32); *(_DWORD *)(DWORD1(v91) + 4 * v57) = v56 )
      {
        v54 = *(_DWORD *)(this + 8);
        v55 = *(_DWORD *)(v54 + 8 * v53);
        v56 = *(_DWORD *)(v54 + 8 * v53 + 4);
        *(_DWORD *)(DWORD1(v93) + 4 * v53 * v94 + 4) = 1065353216;
        *(_DWORD *)(DWORD1(v93) + 4 * v53 * v94) = v55;
        v57 = v53 * v92;
        ++v53;
      }
      cvGEMM(DWORD2(v93), DWORD2(v93), 0, 1072693248, 0, 0, 0, DWORD2(v87), 1);
      cvInvert(DWORD2(v87), DWORD2(v83), 0);
      cvGEMM(DWORD2(v83), DWORD2(v93), 0, 1072693248, 0, 0, 0, DWORD2(v85), 2);
      cvGEMM(DWORD2(v85), DWORD2(v91), 0, 1072693248, 0, 0, 0, DWORD2(v89), 0);
      v58 = *(float *)(DWORD1(v89) + 4 * v90);
      v59 = *(float *)DWORD1(v89);
      *(_OWORD *)(this + 80) = 0i64;
      *(_QWORD *)(this + 72) = 0i64;
      *(double *)(this + 64) = v59 * v75 / v75;
      *(double *)(this + 56) = v58 * v75 + v69 - v59 * v79 * v75 / v75;
      sub_403E70(&v89);
      LOBYTE(v107) = 18;
      sub_403E70(&v85);
      LOBYTE(v107) = 17;
      sub_403E70(&v83);
      LOBYTE(v107) = 16;
      sub_403E70(&v87);
      LOBYTE(v107) = 15;
      sub_403E70(&v91);
      v19 = &v93;
      break;
    default:
      return;
  }
  v107 = -1;
  sub_403E70(v19);
}
// 42BE4C: variable 'v63' is possibly undefined
// 42BE4C: variable 'v64' is possibly undefined
// 436860: using guessed type int __cdecl cvCreateMat(_DWORD, _DWORD, _DWORD);
// 436884: using guessed type int __cdecl cvGEMM(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 43688A: using guessed type double __cdecl cvInvert(_DWORD, _DWORD, _DWORD);
// 436A62: using guessed type __m128 __stdcall libm_sse2_cos_precise(_DWORD, _DWORD);
// 436A68: using guessed type __m128 libm_sse2_sin_precise(void);
// 43931C: using guessed type void *CMyMatrix::`vftable';

//----- (0042D210) --------------------------------------------------------
double __usercall sub_42D210@<st0>(int a1@<ecx>, int a2@<esi>)
{
  int v2; // edx
  int v3; // eax
  double v4; // xmm3_8
  int v5; // esi
  double v6; // xmm1_8
  float v7; // xmm2_4
  double v8; // xmm0_8
  int v11; // [esp+0h] [ebp-Ch]
  int v12; // [esp+4h] [ebp-8h]
  int v13; // [esp+8h] [ebp-4h]

  v2 = *(_DWORD *)(a1 + 32);
  if ( v2 > 6000 || !v2 )
    return 0.0;
  v3 = 0;
  v4 = 0.0;
  if ( v2 > 0 )
  {
    v5 = *(_DWORD *)(a1 + 12);
    do
    {
      v6 = *(float *)(v5 + 8 * v3);
      v7 = *(float *)(v5 + 8 * v3++ + 4);
      v8 = (((v6 * *(double *)(a1 + 88) + *(double *)(a1 + 80)) * v6 + *(double *)(a1 + 72)) * v6 + *(double *)(a1 + 64))
         * v6
         + *(double *)(a1 + 56);
      v4 = v4 + (v7 - v8) * (v7 - v8);
    }
    while ( v3 < v2 );
  }
  return *(double *)libm_sse2_sqrt_precise(a2, v11, v12, v13).m128_u64;
}
// 42D210: could not find valid save-restore pair for esi
// 42D2A7: variable 'v11' is possibly undefined
// 42D2A7: variable 'v12' is possibly undefined
// 42D2A7: variable 'v13' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0042D2D0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __userpurge sub_42D2D0@<st0>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, int a4, _DWORD **a5)
{
  _DWORD *v5; // esi
  float *v6; // eax
  int v7; // edi
  double v8; // xmm3_8
  double v9; // xmm0_8
  double v10; // xmm6_8
  double v11; // xmm4_8
  double v12; // xmm1_8
  double v13; // xmm2_8
  double v14; // xmm0_8
  double v15; // xmm6_8
  double v16; // xmm5_8
  double v17; // xmm3_8
  double v18; // xmm4_8
  double v19; // xmm3_8
  double v20; // xmm2_8
  float v21; // xmm1_4
  double v22; // xmm2_8
  double v23; // xmm1_8
  int v25; // [esp+0h] [ebp-70h]
  int v26; // [esp+4h] [ebp-6Ch]
  _DWORD *v28; // [esp+Ch] [ebp-64h]
  int v29; // [esp+10h] [ebp-60h]
  _DWORD *v30; // [esp+14h] [ebp-5Ch]
  double v31; // [esp+18h] [ebp-58h]
  double v32; // [esp+20h] [ebp-50h]
  double v33; // [esp+28h] [ebp-48h]
  double v34; // [esp+30h] [ebp-40h]
  double v35; // [esp+38h] [ebp-38h]
  double v36; // [esp+40h] [ebp-30h]
  double v37; // [esp+48h] [ebp-28h]
  double v38; // [esp+50h] [ebp-20h]
  double v39; // [esp+58h] [ebp-18h]
  double v40; // [esp+60h] [ebp-10h]
  double v41; // [esp+68h] [ebp-8h]
  int _70; // [esp+70h] [ebp+0h] OVERLAPPED

  *(_QWORD *)&v33 = libm_sse2_cos_precise(a2, a3).m128_u64[0];
  *(_QWORD *)&v31 = libm_sse2_sin_precise().m128_u64[0];
  v35 = 0.0;
  v30 = *a5;
  v5 = (_DWORD *)**a5;
  v28 = v5;
  if ( v5 != *a5 )
  {
    do
    {
      v6 = (float *)(a4 + (v5[2] << 6));
      v7 = 0;
      v8 = v6[13];
      v9 = (float)(v6[8] - *(float *)(v29 + 40));
      v10 = v6[12];
      v11 = v6[15];
      v38 = (float)(v6[9] - *(float *)(v29 + 48)) * v31 + v9 * v33 + *(float *)(v29 + 40);
      v12 = v11 * v31;
      v41 = v9 * v31 - (float)(v6[9] - *(float *)(v29 + 48)) * v33 + *(float *)(v29 + 48);
      v13 = v8 * v31 + v10 * v33;
      v14 = v6[14];
      v15 = v10 * v31 - v8 * v33;
      v16 = v14 * v31 - v11 * v33;
      v17 = v6[10];
      v18 = v6[11];
      v34 = 0.0;
      v32 = 0.0;
      v36 = v17 * v13;
      v39 = v18 * (v12 + v14 * v33);
      v40 = v17 * v15;
      *(double *)&_70 = v18 * v16;
      do
      {
        v37 = *(double *)libm_sse2_cos_precise(v25, v26).m128_u64;
        v19 = *(double *)libm_sse2_sin_precise().m128_u64;
        ++v7;
        v20 = (float)(v36 * v37 + v38 + v39 * v19);
        v21 = v40 * v37 + v41 + *(double *)&_70 * v19;
        v22 = (((v20 * *(double *)(v29 + 88) + *(double *)(v29 + 80)) * v20 + *(double *)(v29 + 72)) * v20
             + *(double *)(v29 + 64))
            * v20
            + *(double *)(v29 + 56)
            - v21;
        v32 = v32 + 0.1;
        v23 = v22 * v22 + v34;
        v34 = v23;
      }
      while ( v32 < 6.283185307179586 );
      v5 = (_DWORD *)*v28;
      v28 = v5;
      v35 = v23 / (double)v7 + v35;
    }
    while ( v5 != v30 );
  }
  return *(double *)libm_sse2_sqrt_precise(v25, v26, a1, v28).m128_u64;
}
// 42D2D0: variables would overlap: ^78.4 and ^78.8
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);
// 436A62: using guessed type __m128 __stdcall libm_sse2_cos_precise(_DWORD, _DWORD);
// 436A68: using guessed type __m128 libm_sse2_sin_precise(void);

//----- (0042D580) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __usercall sub_42D580(int a1@<ecx>, int a2@<edi>, int a3@<esi>)
{
  float v3; // xmm2_4
  int v4; // eax
  float v5; // xmm1_4
  int v7; // edi
  int v8; // ecx
  double v9; // xmm0_8
  unsigned __int64 v10; // xmm0_8
  int v11; // ecx
  double v12; // xmm7_8
  int v13; // eax
  double v14; // xmm3_8
  double v15; // xmm2_8
  float v16; // xmm0_4
  float v17; // xmm3_4
  int v18; // edi
  int v19; // eax
  float v20; // xmm5_4
  float v21; // xmm4_4
  int v22; // ecx
  float v23; // xmm2_4
  float v24; // xmm1_4
  float v25; // xmm0_4
  float v26; // xmm0_4
  int v27; // ecx
  double v30; // [esp+0h] [ebp-20h]
  double v31; // [esp+8h] [ebp-18h]
  double v32; // [esp+10h] [ebp-10h]
  double v33; // [esp+18h] [ebp-8h]
  int _20; // [esp+20h] [ebp+0h] OVERLAPPED

  v3 = 0.0;
  v4 = 0;
  v5 = 0.0;
  v7 = *(_DWORD *)(a1 + 32);
  if ( v7 > 0 )
  {
    v8 = *(_DWORD *)(a1 + 8);
    do
    {
      v5 = v5 + *(float *)(v8 + 8 * v4);
      v3 = v3 + *(float *)(v8 + 8 * v4++ + 4);
    }
    while ( v4 < v7 );
  }
  v32 = (float)(v3 / (float)v7);
  *(double *)(a1 + 888) = v32;
  v9 = -*(double *)(a1 + 872);
  v31 = (float)(v5 / (float)v7);
  *(double *)(a1 + 880) = v31;
  v30 = v9;
  *(_QWORD *)&_20 = libm_sse2_cos_precise(a2, a3).m128_u64[0];
  v10 = libm_sse2_sin_precise().m128_u64[0];
  v11 = 0;
  v12 = *(double *)&v10;
  if ( v7 > 0 )
  {
    do
    {
      v13 = *(_DWORD *)(a1 + 8);
      v14 = *(float *)(v13 + 8 * v11) - v32;
      v15 = *(float *)(v13 + 8 * v11 + 4) - v33;
      v16 = v14 * *(double *)&_20 - v15 * v12 + v32;
      *(float *)(v13 + 8 * v11) = v16;
      *(float *)(*(_DWORD *)(a1 + 8) + 8 * v11++ + 4) = v14 * v12 + v15 * *(double *)&_20 + v33;
    }
    while ( v11 < *(_DWORD *)(a1 + 32) );
  }
  memcpy(*(void **)(a1 + 12), *(const void **)(a1 + 8), 8 * *(_DWORD *)(a1 + 32));
  v17 = 0.0;
  v18 = *(_DWORD *)(a1 + 32);
  v19 = 0;
  v20 = 0.0;
  v21 = 0.0;
  *(_OWORD *)(a1 + 856) = xmmword_43A370;
  if ( v18 > 0 )
  {
    v22 = *(_DWORD *)(a1 + 8);
    do
    {
      v23 = *(float *)(v22 + 8 * v19);
      if ( *(double *)(a1 + 856) > v23 )
        *(double *)(a1 + 856) = v23;
      v24 = *(float *)(v22 + 8 * v19);
      if ( v24 > *(double *)(a1 + 864) )
        *(double *)(a1 + 864) = v24;
      v20 = v20 + *(float *)(v22 + 8 * v19 + 4);
      v25 = *(float *)(v22 + 8 * v19++);
      v17 = v17 + v25;
      v21 = v21 + (float)(v25 * v25);
    }
    while ( v19 < v18 );
  }
  *(float *)(a1 + 40) = v17 / (float)v18;
  *(float *)(a1 + 48) = v20 / (float)v18;
  v26 = *(double *)libm_sse2_sqrt_precise(LODWORD(v30), HIDWORD(v30), LODWORD(v31), HIDWORD(v31)).m128_u64;
  v27 = 0;
  *(float *)(a1 + 44) = v26;
  if ( v18 > 0 )
  {
    do
    {
      *(float *)(*(_DWORD *)(a1 + 8) + 8 * v27) = (float)(*(float *)(*(_DWORD *)(a1 + 8) + 8 * v27) - *(float *)(a1 + 40))
                                                / *(float *)(a1 + 44);
      *(float *)(*(_DWORD *)(a1 + 8) + 8 * v27 + 4) = (float)(*(float *)(*(_DWORD *)(a1 + 8) + 8 * v27 + 4)
                                                            - *(float *)(a1 + 48))
                                                    / *(float *)(a1 + 44);
      ++v27;
    }
    while ( v27 < *(_DWORD *)(a1 + 32) );
  }
}
// 42D580: could not find valid save-restore pair for edi
// 42D580: could not find valid save-restore pair for esi
// 42D580: variables would overlap: ^2C.4 and ^2C.8
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);
// 436A62: using guessed type __m128 __stdcall libm_sse2_cos_precise(_DWORD, _DWORD);
// 436A68: using guessed type __m128 libm_sse2_sin_precise(void);
// 43A370: using guessed type __int128 xmmword_43A370;

//----- (0042D7B0) --------------------------------------------------------
void __thiscall sub_42D7B0(char *this)
{
  char *v2; // eax
  char *v3; // esi
  int v4; // [esp+8h] [ebp-4h] BYREF

  v2 = (char *)*((_DWORD *)this + 12);
  *(_DWORD *)this = &DwCDelaunayTriangulation::`vftable';
  if ( v2 )
  {
    v3 = v2 - 4;
    `eh vector destructor iterator'(v2, 8u, *((_DWORD *)v2 - 1), (void (__thiscall *)(void *))sub_4271F0);
    operator delete[](v3);
  }
  cvReleaseMemStorage(this + 24);
  sub_42B580((int **)this + 8, &v4, **((int ***)this + 8), *((int **)this + 8));
  operator delete(*((void **)this + 8));
}
// 436890: using guessed type int __cdecl cvReleaseMemStorage(_DWORD);
// 43A11C: using guessed type void *DwCDelaunayTriangulation::`vftable';

//----- (0042D810) --------------------------------------------------------
int __thiscall sub_42D810(int *this)
{
  int v2; // eax
  int v3; // esi
  int result; // eax
  unsigned int v5; // edi
  int v6; // edx
  int v7; // ecx
  float v8; // xmm2_4
  float v9; // xmm3_4
  float v10; // xmm4_4
  float v11; // xmm5_4
  int *v12; // eax
  float v13; // xmm1_4
  float v14; // xmm0_4
  int *v15; // eax
  int v16; // edx
  int v17; // ecx
  int v18; // ecx
  int v19; // edx
  int v20; // eax
  int v21; // [esp+8h] [ebp-4Ch] BYREF
  int v22; // [esp+Ch] [ebp-48h] BYREF
  float v23; // [esp+10h] [ebp-44h]
  float v24; // [esp+14h] [ebp-40h]
  int v25; // [esp+18h] [ebp-3Ch] BYREF
  float v26; // [esp+1Ch] [ebp-38h]
  float v27; // [esp+20h] [ebp-34h]
  int v28; // [esp+24h] [ebp-30h]
  int v29; // [esp+28h] [ebp-2Ch] BYREF
  int v30; // [esp+2Ch] [ebp-28h]
  char v31[12]; // [esp+30h] [ebp-24h] BYREF
  unsigned int v32; // [esp+3Ch] [ebp-18h]
  unsigned int v33; // [esp+44h] [ebp-10h]

  v2 = *(_DWORD *)(this[7] + 64);
  v3 = *(_DWORD *)(v2 + 24);
  v28 = *(_DWORD *)(v2 + 28);
  v30 = v3;
  result = cvStartReadSeq(v2, v31, 0);
  if ( v3 > 0 )
  {
    v5 = v32;
    do
    {
      if ( *(int *)v5 >= 0 )
      {
        v6 = *(_DWORD *)((v5 & 0xFFFFFFFC) + 4 * (v5 & 3) + 4);
        result = ((_BYTE)v5 - 2) & 3;
        v7 = *(_DWORD *)((v5 & 0xFFFFFFFC) + 4 * result + 4);
        if ( v6 )
        {
          if ( v7 )
          {
            v8 = *(float *)(v6 + 8);
            if ( v8 < 5000.0 )
            {
              v9 = *(float *)(v6 + 12);
              if ( v9 < 5000.0 )
              {
                v10 = *(float *)(v7 + 8);
                if ( v10 < 5000.0 )
                {
                  v11 = *(float *)(v7 + 12);
                  if ( v11 < 5000.0 && v8 > -5000.0 && v9 > -5000.0 && v10 > -5000.0 && v11 > -5000.0 )
                  {
                    v23 = *(float *)(v7 + 8);
                    v24 = *(float *)(v7 + 12);
                    v26 = *(float *)(v6 + 8);
                    v27 = *(float *)(v6 + 12);
                    v29 = (int)(float)((float)(v27 * 10.0) + (float)(v26 * 100000.0));
                    v12 = sub_42DA20(this + 8, &v22, &v29);
                    v13 = v23 * 100000.0;
                    v14 = v24 * 10.0;
                    this[10] = *v12;
                    v29 = (int)(float)(v13 + v14);
                    v15 = sub_42DA20(this + 8, &v21, &v29);
                    v16 = this[10];
                    v17 = this[8];
                    result = *v15;
                    this[11] = result;
                    if ( v16 != v17 && result != v17 )
                    {
                      v18 = *(_DWORD *)(v16 + 20);
                      if ( v18 >= 1 )
                      {
                        v19 = this[1];
                        if ( v18 < v19 )
                        {
                          result = *(_DWORD *)(result + 20);
                          if ( result >= 1 && result < v19 )
                          {
                            v29 = result;
                            v20 = this[12];
                            v25 = v18;
                            sub_42BA10((_DWORD *)(v20 + 8 * v18), &v29);
                            result = (int)sub_42BA10((_DWORD *)(this[12] + 8 * v29), &v25);
                            v5 = v32;
                          }
                        }
                      }
                    }
                    v3 = v30;
                  }
                }
              }
            }
          }
        }
      }
      v5 += v28;
      v32 = v5;
      if ( v5 >= v33 )
      {
        result = cvChangeSeqBlock(v31, 1);
        v5 = v32;
      }
      v30 = --v3;
    }
    while ( v3 );
  }
  return result;
}
// 436896: using guessed type int __cdecl cvStartReadSeq(_DWORD, _DWORD, _DWORD);
// 43689C: using guessed type int __cdecl cvChangeSeqBlock(_DWORD, _DWORD);

//----- (0042DA20) --------------------------------------------------------
_DWORD *__thiscall sub_42DA20(int *this, _DWORD *a2, int *a3)
{
  int *v3; // esi
  int *v4; // ecx
  int *v5; // eax
  int v6; // eax
  _DWORD *result; // eax
  int *v8; // [esp+14h] [ebp+Ch]

  v3 = (int *)*this;
  v4 = v3;
  v5 = (int *)v3[1];
  while ( !*((_BYTE *)v5 + 13) )
  {
    if ( v5[4] <= *a3 )
    {
      v4 = v5;
      v5 = (int *)*v5;
    }
    else
    {
      v5 = (int *)v5[2];
    }
  }
  if ( v4 == v3 || (v6 = *a3, v8 = v4, v6 > v4[4]) )
    v8 = v3;
  result = a2;
  *a2 = v8;
  return result;
}

//----- (0042DA70) --------------------------------------------------------
int __thiscall sub_42DA70(int this, void *a2, int a3, _DWORD *a4)
{
  void *v5; // eax
  FILE *v6; // eax
  int i; // eax

  sub_430F80((_DWORD *)this, (int)a2, a3, a4);
  *(_DWORD *)this = &GCoptimization::`vftable';
  sub_42DE90(this, (int)a2, a3);
  v5 = operator new(4 * *(_DWORD *)(this + 12));
  *(_DWORD *)(this + 40) = v5;
  if ( !v5 )
  {
    v6 = _iob_func();
    fprintf(v6 + 2, "\n %s \n", "out of memory");
    exit(1);
  }
  for ( i = 0; i < (int)a2; ++i )
    *(_DWORD *)(*(_DWORD *)(this + 40) + 4 * i) = 0;
  *(_WORD *)(this + 44) = 1;
  sub_42E4B0((_DWORD *)this);
  return this;
}
// 43A3E0: using guessed type void *GCoptimization::`vftable';

//----- (0042DB50) --------------------------------------------------------
void __thiscall sub_42DB50(_BYTE *this)
{
  *(_DWORD *)this = 0;
  this[4] = 4;
}

//----- (0042DB60) --------------------------------------------------------
void __thiscall sub_42DB60(void **this)
{
  char *v2; // eax
  char *v3; // esi

  *this = &GCoptimization::`vftable';
  operator delete(this[10]);
  if ( !*((_BYTE *)this + 20) )
  {
    v2 = (char *)this[16];
    if ( v2 )
    {
      v3 = v2 - 4;
      `eh vector destructor iterator'(v2, 0xCu, *((_DWORD *)v2 - 1), (void (__thiscall *)(void *))sub_42FE20);
      operator delete(v3);
    }
  }
  operator delete(this[17]);
  operator delete(this[18]);
  if ( *((_BYTE *)this + 45) )
    operator delete(this[13]);
  *this = &MRF::`vftable';
}
// 43A38C: using guessed type void *MRF::`vftable';
// 43A3E0: using guessed type void *GCoptimization::`vftable';

//----- (0042DC20) --------------------------------------------------------
_DWORD *__thiscall sub_42DC20(_DWORD *this, char a2)
{
  *this = &MRF::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 43A38C: using guessed type void *MRF::`vftable';

//----- (0042DC50) --------------------------------------------------------
int __thiscall sub_42DC50(_DWORD *this, float *a2, int a3, int a4, int a5)
{
  int i; // edi
  int v7; // esi
  int result; // eax
  float v9; // [esp+14h] [ebp-8h]
  float v10; // [esp+18h] [ebp-4h]

  for ( i = 0; i < a4; ++i )
  {
    v7 = *(_DWORD *)(a3 + 4 * i);
    v10 = ((double (__cdecl *)(_DWORD, int))this[20])(*(_DWORD *)(this[18] + 4 * i), a5);
    v9 = ((double (__cdecl *)(_DWORD, _DWORD))this[20])(
           *(_DWORD *)(this[18] + 4 * i),
           *(_DWORD *)(this[10] + 4 * *(_DWORD *)(this[18] + 4 * i)));
    result = sub_42F910(a2, v7, v9, v10);
  }
  return result;
}

//----- (0042DCC0) --------------------------------------------------------
_DWORD *__thiscall sub_42DCC0(float *this, _DWORD *a2, int a3, float a4, float a5, float a6, float a7)
{
  float v7; // xmm5_4
  float v9; // xmm3_4
  int v10; // xmm0_4
  int v11; // xmm1_4
  bool v12; // cc
  float v14; // [esp+24h] [ebp+14h]
  float v15; // [esp+28h] [ebp+18h]

  v7 = a4;
  if ( (float)(a4 + a7) > (float)(a5 + a6) )
  {
    v9 = (float)((float)(a4 + a7) - a6) - a5;
    v7 = a4 - (float)(v9 / 3.0);
    a4 = v7;
    a6 = (float)(v9 / 3.0) + a6;
    a5 = a5 + (float)(v9 - (float)((float)(v9 / 3.0) * 2.0));
  }
  sub_42F910(this, (int)a2, a7, v7);
  *(float *)&v10 = a5 - a4;
  *(float *)&v11 = a6 - a7;
  v12 = (float)(a5 - a4) >= 0.0;
  v14 = a5 - a4;
  v15 = a6 - a7;
  if ( v12 )
  {
    if ( *(float *)&v11 >= 0.0 )
    {
      return sub_42F770(this, a2, a3, v10, v11);
    }
    else
    {
      sub_42F910(this, (int)a2, 0.0, -*(float *)&v11);
      sub_42F910(this, a3, 0.0, v15);
      return sub_42F770(this, a2, a3, COERCE_INT(v14 + v15), 0);
    }
  }
  else
  {
    sub_42F910(this, (int)a2, 0.0, *(float *)&v10);
    sub_42F910(this, a3, 0.0, -v14);
    return sub_42F770(this, a2, a3, 0, COERCE_INT(v14 + v15));
  }
}

//----- (0042DE60) --------------------------------------------------------
void *__thiscall sub_42DE60(_DWORD *this)
{
  void *v1; // edx

  v1 = (void *)this[10];
  if ( !v1 )
  {
    printf("First initialize algorithm");
    exit(0);
  }
  return memset(v1, 0, 4 * this[3]);
}

//----- (0042DE90) --------------------------------------------------------
void __thiscall sub_42DE90(int this, int a2, int a3)
{
  int v4; // ecx
  int *v5; // eax
  _DWORD *v6; // esi
  FILE *v7; // eax
  const char *v8; // [esp-4h] [ebp-20h]

  if ( a2 < 0 || a3 < 0 )
  {
    v8 = "Illegal negative parameters";
LABEL_8:
    v7 = _iob_func();
    fprintf(v7 + 2, "\n %s \n", v8);
    exit(1);
  }
  *(_DWORD *)(this + 16) = a3;
  *(_DWORD *)(this + 12) = a2;
  *(_BYTE *)(this + 20) = 0;
  v4 = (12 * (unsigned __int64)(unsigned int)a2) >> 32 != 0 ? -1 : 12 * a2;
  v5 = (int *)operator new(__CFADD__(v4, 4) ? -1 : v4 + 4);
  if ( v5 )
  {
    v6 = v5 + 1;
    *v5 = a2;
    `eh vector constructor iterator'(
      v5 + 1,
      0xCu,
      a2,
      (void (__thiscall *)(void *))sub_42DB50,
      (void (__thiscall *)(void *))sub_42FE20);
  }
  else
  {
    v6 = 0;
  }
  *(_DWORD *)(this + 64) = v6;
  if ( !v6 )
  {
    v8 = "Not enough memory";
    goto LABEL_8;
  }
}

//----- (0042DF70) --------------------------------------------------------
double __thiscall sub_42DF70(_DWORD *this)
{
  int v3; // edi
  double v4; // st7
  float i; // [esp+4h] [ebp-4h]

  if ( this[7] == 1 )
    return sub_42DFC0(this);
  v3 = 0;
  for ( i = 0.0; v3 < this[3]; i = v4 + i )
  {
    v4 = ((double (__cdecl *)(int, _DWORD))this[20])(v3, *(_DWORD *)(this[10] + 4 * v3));
    ++v3;
  }
  return i;
}

//----- (0042DFC0) --------------------------------------------------------
double __fastcall sub_42DFC0(_DWORD *a1)
{
  int v1; // edx
  float v2; // xmm1_4
  int v3; // esi
  int v4; // ebx
  int v5; // esi
  _DWORD *v6; // ecx
  int v7; // edi
  int v8; // edx
  int v9; // eax
  float v10; // xmm1_4
  int v11; // eax
  float v12; // xmm1_4
  int v13; // eax
  float v14; // xmm1_4
  int v15; // eax
  int v16; // eax
  bool v17; // zf
  int v18; // eax
  int v19; // edi
  int v20; // ebx
  int v21; // ecx
  int v22; // edx
  int *v23; // esi
  int v24; // eax
  int v25; // eax
  _DWORD *v27; // [esp+0h] [ebp-18h]
  int v28; // [esp+4h] [ebp-14h]
  unsigned int v29; // [esp+8h] [ebp-10h]
  int v30; // [esp+Ch] [ebp-Ch]
  int v31; // [esp+10h] [ebp-8h]
  float v32; // [esp+14h] [ebp-4h]
  int v33; // [esp+14h] [ebp-4h]

  v1 = a1[3];
  v2 = 0.0;
  v3 = 0;
  v27 = a1;
  v32 = 0.0;
  v28 = v1;
  v30 = 0;
  if ( v1 >= 4 )
  {
    v4 = a1[4];
    v5 = a1[12];
    v6 = (_DWORD *)(a1[10] + 8);
    v31 = 3 * v4;
    v7 = 4 * v4;
    v33 = 2 * v4;
    v29 = ((unsigned int)(v1 - 4) >> 2) + 1;
    v8 = 0;
    v30 = 4 * v29;
    do
    {
      v9 = v8 + *(v6 - 2);
      v8 += v7;
      v10 = v2 + *(float *)(v5 + 4 * v9);
      v11 = v4 + *(v6 - 1);
      v4 += v7;
      v12 = v10 + *(float *)(v5 + 4 * v11);
      v13 = v33 + *v6;
      v33 += v7;
      v14 = v12 + *(float *)(v5 + 4 * v13);
      v15 = v6[1];
      v6 += 4;
      v16 = v31 + v15;
      v31 += v7;
      v17 = v29-- == 1;
      v2 = v14 + *(float *)(v5 + 4 * v16);
    }
    while ( !v17 );
    v1 = v28;
    a1 = v27;
    v3 = v30;
    v32 = v2;
  }
  if ( v3 < v1 )
  {
    v18 = a1[10];
    v19 = a1[4];
    v20 = a1[12];
    v21 = v3 * v19;
    v22 = v1 - v30;
    v23 = (int *)(v18 + 4 * v3);
    do
    {
      v24 = *v23++;
      v25 = v21 + v24;
      v21 += v19;
      v2 = v2 + *(float *)(v20 + 4 * v25);
      --v22;
    }
    while ( v22 );
    return v2;
  }
  return v32;
}

//----- (0042E0A0) --------------------------------------------------------
double __fastcall sub_42E0A0(_DWORD *a1)
{
  int v1; // eax
  float v2; // xmm1_4
  int v3; // edi
  int v4; // esi
  int v5; // edx
  int v6; // ebx
  int v7; // eax
  int v8; // esi
  int v9; // ecx
  int v10; // eax
  int v11; // ebx
  int v12; // edi
  int v13; // esi
  int v14; // edx
  int v15; // ecx
  int v16; // eax
  int v17; // eax
  int v19; // [esp+0h] [ebp-18h]
  int v20; // [esp+4h] [ebp-14h]
  int v21; // [esp+4h] [ebp-14h]
  int v22; // [esp+8h] [ebp-10h]
  int v23; // [esp+Ch] [ebp-Ch]
  int v24; // [esp+Ch] [ebp-Ch]
  _DWORD *v25; // [esp+10h] [ebp-8h]
  float v26; // [esp+14h] [ebp-4h]
  int v27; // [esp+14h] [ebp-4h]

  v1 = a1[2];
  v2 = 0.0;
  v3 = 0;
  v25 = a1;
  v26 = 0.0;
  v22 = v1;
  v23 = 0;
  if ( v1 > 0 )
  {
    v4 = a1[1];
    v20 = v4;
    do
    {
      if ( v4 > 1 )
      {
        v5 = a1[10];
        v6 = a1[4];
        v27 = a1[13];
        v7 = v3 * v4;
        v8 = v4 - 1;
        v9 = 4 * v7 + 4;
        do
        {
          v10 = *(_DWORD *)(v9 + v5) + v6 * *(_DWORD *)(v9 + v5 - 4);
          v9 += 4;
          v2 = v2 + *(float *)(v27 + 4 * v10);
          --v8;
        }
        while ( v8 );
        v3 = v23;
        a1 = v25;
        v4 = v20;
        v1 = v22;
        v26 = v2;
      }
      v23 = ++v3;
    }
    while ( v3 < v1 );
  }
  v11 = 1;
  v24 = 1;
  if ( v1 > 1 )
  {
    v12 = a1[1];
    v19 = v12;
    do
    {
      if ( v12 > 0 )
      {
        v13 = a1[10];
        v21 = a1[13];
        v14 = 4 * v11 * v12;
        v15 = 4 * (v11 * v12 - v12);
        do
        {
          v16 = *(_DWORD *)(v15 + v13);
          v15 += 4;
          v17 = *(_DWORD *)(v14 + v13) + v25[4] * v16;
          v14 += 4;
          v2 = v2 + *(float *)(v21 + 4 * v17);
          --v12;
        }
        while ( v12 );
        v11 = v24;
        v12 = v19;
        a1 = v25;
        v1 = v22;
        v26 = v2;
      }
      v24 = ++v11;
    }
    while ( v11 < v1 );
  }
  return v26;
}

//----- (0042E1A0) --------------------------------------------------------
double __thiscall sub_42E1A0(_DWORD *this)
{
  _DWORD *v1; // edx
  float v2; // xmm1_4
  int v3; // ebx
  int v4; // eax
  int v5; // edi
  int v6; // esi
  int v7; // eax
  float *v8; // edx
  int v9; // edi
  int v10; // ecx
  int v11; // eax
  float v12; // xmm0_4
  int v13; // ebx
  int v14; // ecx
  int v15; // edi
  int v16; // esi
  int v17; // eax
  int v18; // ecx
  int v19; // edx
  int v20; // eax
  float v21; // xmm0_4
  bool v22; // zf
  int v24; // [esp+0h] [ebp-1Ch]
  int v25; // [esp+4h] [ebp-18h]
  int v26; // [esp+4h] [ebp-18h]
  int v27; // [esp+8h] [ebp-14h]
  int v28; // [esp+8h] [ebp-14h]
  int v29; // [esp+Ch] [ebp-10h]
  int v30; // [esp+10h] [ebp-Ch]
  int v31; // [esp+10h] [ebp-Ch]
  float v32; // [esp+14h] [ebp-8h]
  int v33; // [esp+14h] [ebp-8h]

  v1 = this;
  v2 = 0.0;
  v3 = 0;
  v4 = this[2];
  v32 = 0.0;
  v29 = v4;
  v30 = 0;
  if ( v4 > 0 )
  {
    v5 = this[1];
    v27 = v5;
    do
    {
      if ( v5 > 1 )
      {
        v6 = v1[10];
        v25 = v1[13];
        v7 = 4 * v3 * v5;
        v8 = (float *)(v7 + v1[15]);
        v9 = v5 - 1;
        v10 = v7 + 4;
        do
        {
          v11 = *(_DWORD *)(v10 + v6) + this[4] * *(_DWORD *)(v10 + v6 - 4);
          v10 += 4;
          v12 = *(float *)(v25 + 4 * v11) * *v8++;
          v2 = v2 + v12;
          --v9;
        }
        while ( v9 );
        v3 = v30;
        v1 = this;
        v5 = v27;
        v4 = v29;
        v32 = v2;
      }
      v30 = ++v3;
    }
    while ( v3 < v4 );
  }
  v13 = 1;
  v26 = 1;
  if ( v4 > 1 )
  {
    v14 = v1[1];
    v15 = v14;
    v24 = v14;
    do
    {
      if ( v15 > 0 )
      {
        v16 = v1[10];
        v17 = v13 * v14;
        v28 = v1[1];
        v33 = v1[13];
        v31 = v15;
        v18 = 4 * (v13 * v14 - v28);
        v19 = 4 * v17;
        do
        {
          v20 = *(_DWORD *)(v19 + v16) + this[4] * *(_DWORD *)(v18 + v16);
          v19 += 4;
          v21 = *(float *)(v33 + 4 * v20) * *(float *)(v18 + this[14]);
          v18 += 4;
          v22 = v31-- == 1;
          v2 = v2 + v21;
        }
        while ( !v22 );
        v13 = v26;
        v1 = this;
        v4 = v29;
        v15 = v24;
        v14 = v28;
        v32 = v2;
      }
      v26 = ++v13;
    }
    while ( v13 < v4 );
  }
  return v32;
}

//----- (0042E2C0) --------------------------------------------------------
double __thiscall sub_42E2C0(_DWORD *this)
{
  int v2; // ebx
  int v3; // ecx
  int i; // edi
  double v5; // st7
  int v6; // ebx
  int v7; // eax
  int j; // edi
  double v9; // st7
  float v11; // [esp+Ch] [ebp-4h]

  v11 = 0.0;
  v2 = 0;
  if ( (int)this[2] > 0 )
  {
    v3 = this[1];
    do
    {
      for ( i = 1; i < v3; v11 = v5 + v11 )
      {
        v5 = ((double (__cdecl *)(int, int, _DWORD, _DWORD))this[21])(
               i + v2 * v3,
               i + v2 * v3 - 1,
               *(_DWORD *)(this[10] + 4 * (i + v2 * v3)),
               *(_DWORD *)(this[10] + 4 * (i + v2 * v3) - 4));
        v3 = this[1];
        ++i;
      }
      ++v2;
    }
    while ( v2 < this[2] );
  }
  v6 = 1;
  if ( (int)this[2] > 1 )
  {
    v7 = this[1];
    do
    {
      for ( j = 0; j < v7; v11 = v9 + v11 )
      {
        v9 = ((double (__cdecl *)(int, int, _DWORD, _DWORD))this[21])(
               j + v6 * this[1],
               j + v6 * this[1] - this[1],
               *(_DWORD *)(this[10] + 4 * (j + v6 * this[1])),
               *(_DWORD *)(this[10] + 4 * (j + v6 * this[1] - this[1])));
        v7 = this[1];
        ++j;
      }
      ++v6;
    }
    while ( v6 < this[2] );
  }
  return v11;
}

//----- (0042E380) --------------------------------------------------------
double __thiscall sub_42E380(_DWORD *this)
{
  int v2; // ebx
  int v3; // edi
  int v4; // ecx
  int v5; // eax
  float v7; // [esp+8h] [ebp-4h]

  v2 = 0;
  v7 = 0.0;
  if ( (int)this[3] > 0 )
  {
    v3 = 0;
    do
    {
      v4 = this[16];
      if ( *(_DWORD *)(v3 + v4) )
      {
        *(_DWORD *)(v3 + v4 + 8) = *(_DWORD *)(v3 + v4);
        *(_BYTE *)(v3 + v4 + 5) = 0;
        while ( sub_42FED0((_DWORD *)(v3 + this[16])) )
        {
          v5 = sub_42FEE0((_BYTE *)(v3 + this[16]));
          if ( v2 < *(_DWORD *)v5 )
            v7 = (float)(*(float *)(this[13]
                                  + 4
                                  * (*(_DWORD *)(this[10] + 4 * v2) + this[4]
                                                                    * *(_DWORD *)(this[10] + 4 * *(_DWORD *)v5)))
                       * *(float *)(v5 + 4))
               + v7;
        }
      }
      ++v2;
      v3 += 12;
    }
    while ( v2 < this[3] );
  }
  return v7;
}

//----- (0042E420) --------------------------------------------------------
double __thiscall sub_42E420(_DWORD *this)
{
  int v2; // ebx
  int v3; // edi
  int v4; // ecx
  int v5; // ecx
  float v7; // [esp+8h] [ebp-4h]

  v7 = 0.0;
  v2 = 0;
  if ( (int)this[3] > 0 )
  {
    v3 = 0;
    do
    {
      v4 = this[16];
      if ( *(_DWORD *)(v3 + v4) )
      {
        *(_DWORD *)(v3 + v4 + 8) = *(_DWORD *)(v3 + v4);
        *(_BYTE *)(v3 + v4 + 5) = 0;
        while ( sub_42FED0((_DWORD *)(v3 + this[16])) )
        {
          v5 = *(_DWORD *)sub_42FEE0((_BYTE *)(v3 + this[16]));
          if ( v2 < v5 )
            v7 = ((double (__cdecl *)(int, int, _DWORD, _DWORD))this[21])(
                   v2,
                   v5,
                   *(_DWORD *)(this[10] + 4 * v2),
                   *(_DWORD *)(this[10] + 4 * v5))
               + v7;
        }
      }
      ++v2;
      v3 += 12;
    }
    while ( v2 < this[3] );
  }
  return v7;
}

//----- (0042E4B0) --------------------------------------------------------
int __thiscall sub_42E4B0(_DWORD *this)
{
  void *v2; // eax
  int result; // eax
  FILE *v4; // eax

  this[18] = operator new(4 * this[3]);
  v2 = operator new(4 * this[4]);
  this[17] = v2;
  if ( !this[18] || !v2 )
  {
    v4 = _iob_func();
    fprintf(v4 + 2, "\n %s \n", "Not enough memory");
    exit(1);
  }
  for ( result = 0; result < this[4]; ++result )
    *(_DWORD *)(this[17] + 4 * result) = result;
  return result;
}

//----- (0042E540) --------------------------------------------------------
void __thiscall sub_42E540(_DWORD *this, int a2)
{
  sub_42F590(this, a2);
}

//----- (0042E560) --------------------------------------------------------
void __thiscall sub_42E560(_DWORD *this, int a2)
{
  int v3; // ebx
  float *v4; // eax
  float *v5; // esi
  int v6; // ecx
  int i; // edi
  _DWORD *v8; // edi
  int v9; // ecx
  int v10; // esi
  int v11; // ecx
  int v12; // edx
  float v13; // xmm0_4
  int v14; // ebx
  int *v15; // edx
  int v16; // ecx
  BOOL v17; // eax
  float v18; // [esp+4h] [ebp-2Ch]
  float *v19; // [esp+18h] [ebp-18h]
  int *v20; // [esp+18h] [ebp-18h]
  int v22; // [esp+1Ch] [ebp-14h]
  int *v23; // [esp+20h] [ebp-10h]

  v3 = 0;
  v4 = (float *)operator new(0x3Cu);
  v5 = v4;
  v19 = v4;
  if ( v4 )
  {
    memset(v4, 0, 0x3Cu);
    sub_42F6D0(v5, 0);
    v5[13] = 0.0;
    v5[14] = 0.0;
  }
  else
  {
    v5 = 0;
    v19 = 0;
  }
  v6 = 0;
  if ( (int)this[3] > 0 )
  {
    do
    {
      if ( *(_DWORD *)(this[10] + 4 * v6) != a2 )
        *(_DWORD *)(this[18] + 4 * v3++) = v6;
      ++v6;
    }
    while ( v6 < this[3] );
    if ( v3 > 0 )
    {
      v23 = (int *)operator new(4 * v3);
      if ( !v23 )
      {
        printf("\nOut of memory, exiting");
        exit(1);
      }
      for ( i = 0; i < v3; ++i )
        v23[i] = (int)sub_42F890((_DWORD **)v5);
      v8 = this;
      if ( this[7] == 1 )
      {
        v9 = 0;
        v22 = 0;
        do
        {
          v10 = v8[12];
          v11 = *(_DWORD *)(v8[18] + 4 * v9);
          v12 = v11 * v8[4];
          v18 = *(float *)(v10 + 4 * (v12 + a2));
          v13 = *(float *)(v10 + 4 * (v12 + *(_DWORD *)(v8[10] + 4 * v11)));
          v5 = v19;
          sub_42F910(v19, v23[v22], v13, v18);
          v9 = v22 + 1;
          v22 = v9;
        }
        while ( v9 < v3 );
      }
      else
      {
        sub_42DC50(this, v5, (int)v23, v3, a2);
      }
      if ( *((_BYTE *)v8 + 20) )
      {
        if ( v8[8] )
        {
          if ( *((_BYTE *)v8 + 21) )
            sub_42EC30(v8, v3, a2, v5, (int)v23);
          else
            sub_42E960(v8, v3, a2, v5, (int)v23);
        }
        else
        {
          sub_42EF70(v8, v3, a2, v5, (int)v23);
        }
      }
      else if ( v8[8] )
      {
        sub_42F260(v8, v3, a2, v5, (int)v23);
      }
      else
      {
        sub_42F3F0(v8, v3, a2, v5, (int)v23);
      }
      sub_4302B0((int)v5);
      v14 = 0;
      if ( (int)v8[3] > 0 )
      {
        v15 = v23;
        v16 = a2;
        v20 = v23;
        do
        {
          if ( *(_DWORD *)(v8[10] + 4 * v14) != v16 )
          {
            v17 = sub_430F50(*v15);
            v16 = a2;
            if ( !v17 )
              *(_DWORD *)(v8[10] + 4 * v14) = a2;
            v15 = ++v20;
          }
          ++v14;
        }
        while ( v14 < v8[3] );
      }
      operator delete(v23);
    }
  }
  if ( v5 )
  {
    sub_42F700((int)v5);
    operator delete(v5);
  }
}
// 42E637: conditional instruction was optimized away because ebx.4>=1
// 42E664: conditional instruction was optimized away because ebx.4>=1

//----- (0042E790) --------------------------------------------------------
int __thiscall sub_42E790(_DWORD *this, int a2, int a3)
{
  int result; // eax

  this[15] = a2;
  result = a3;
  this[14] = a3;
  return result;
}

//----- (0042E7B0) --------------------------------------------------------
int __thiscall sub_42E7B0(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[20] = a2;
  return result;
}

//----- (0042E7C0) --------------------------------------------------------
int __thiscall sub_42E7C0(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[12] = a2;
  return result;
}

//----- (0042E7D0) --------------------------------------------------------
int __thiscall sub_42E7D0(_DWORD *this, int a2, int a3, int a4)
{
  _DWORD *v4; // esi
  _DWORD *v5; // ebx

  v4 = operator new(8u);
  v5 = operator new(8u);
  v4[1] = a4;
  *v4 = a3;
  *v5 = a2;
  v5[1] = a4;
  sub_42FE90((_BYTE *)(this[16] + 12 * a2), (int)v4);
  return sub_42FE90((_BYTE *)(this[16] + 12 * a3), (int)v5);
}

//----- (0042E840) --------------------------------------------------------
char __thiscall sub_42E840(_BYTE *this, int a2, char *a3)
{
  char result; // al

  if ( a2 != 1 )
    return printf("\nInvalid number of parameters, can only set one parameter\\that is boolean label order\n");
  result = *a3;
  this[44] = *a3;
  return result;
}

//----- (0042E870) --------------------------------------------------------
float *__thiscall sub_42E870(int this, int a2, float a3, float a4)
{
  int v5; // eax
  float *result; // eax
  FILE *v7; // eax
  int i; // edi
  int v9; // ebx
  int v10; // edx
  int v11; // eax
  float v12; // xmm0_4
  float v13; // xmm0_4
  int v14; // ecx

  v5 = *(_DWORD *)(this + 16) * *(_DWORD *)(this + 16);
  *(_BYTE *)(this + 45) = 1;
  result = (float *)operator new(4 * v5);
  *(_DWORD *)(this + 52) = result;
  if ( !result )
  {
    v7 = _iob_func();
    fprintf(v7 + 2, "Not enough memory!\n");
    exit(1);
  }
  for ( i = 0; i < *(_DWORD *)(this + 16); ++i )
  {
    v9 = i;
    if ( i < *(_DWORD *)(this + 16) )
    {
      v10 = 0;
      do
      {
        v11 = v10;
        if ( a2 != 1 )
          v11 = v10 * v10;
        v12 = (float)v11;
        if ( (float)v11 > a3 )
          v12 = a3;
        ++v10;
        v13 = v12 * a4;
        *(float *)(*(_DWORD *)(this + 52) + 4 * (i + v9 * *(_DWORD *)(this + 16))) = v13;
        result = *(float **)(this + 52);
        v14 = v9 + i * *(_DWORD *)(this + 16);
        ++v9;
        result[v14] = v13;
      }
      while ( v9 < *(_DWORD *)(this + 16) );
    }
  }
  return result;
}

//----- (0042E940) --------------------------------------------------------
int __thiscall sub_42E940(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[21] = a2;
  return result;
}

//----- (0042E960) --------------------------------------------------------
int __thiscall sub_42E960(_DWORD *this, int a2, int a3, float *a4, int a5)
{
  bool v5; // sf
  int result; // eax
  int v8; // edi
  int v9; // esi
  int v10; // ecx
  int v11; // edx
  int v12; // esi
  int v13; // ecx
  int v14; // edx
  int v15; // ecx
  int v16; // esi
  float v17; // xmm0_4
  int v18; // esi
  int v19; // edx
  int v20; // ecx
  int v21; // eax
  int v22; // esi
  int v23; // edx
  int v24; // ecx
  float v25; // xmm0_4
  int v26; // eax
  float v27; // [esp+4h] [ebp-30h]
  float v28; // [esp+4h] [ebp-30h]
  float v29; // [esp+8h] [ebp-2Ch]
  float v30; // [esp+8h] [ebp-2Ch]
  float v31; // [esp+Ch] [ebp-28h]
  float v32; // [esp+Ch] [ebp-28h]
  int v33; // [esp+1Ch] [ebp-18h]
  int v34; // [esp+20h] [ebp-14h]
  int v35; // [esp+24h] [ebp-10h]
  int v36; // [esp+28h] [ebp-Ch]
  int v37; // [esp+30h] [ebp-4h]
  int v38; // [esp+3Ch] [ebp+8h]

  result = a2 - 1;
  v5 = a2 - 1 < 0;
  v38 = a2 - 1;
  if ( !v5 )
  {
    v8 = a3;
    do
    {
      v9 = this[18];
      v10 = this[1];
      v37 = *(_DWORD *)(v9 + 4 * result);
      v11 = v37;
      v35 = v37 / v10;
      v36 = v37 % v10;
      *(_DWORD *)(4 * v37 + v9) = v38;
      if ( v37 % v10 >= this[1] - 1 )
      {
        v18 = v38;
      }
      else
      {
        v12 = this[10];
        v13 = *(_DWORD *)(v12 + 4 * v37 + 4);
        if ( v13 == v8 )
        {
          v19 = *(_DWORD *)(v12 + 4 * v37) + v8 * this[4];
          v18 = v38;
          sub_42F910(
            a4,
            *(_DWORD *)(a5 + 4 * v38),
            *(float *)(this[13] + 4 * v19),
            *(float *)(this[13] + 4 * (v8 + v13 * this[4])));
        }
        else
        {
          v14 = v13 * this[4];
          v15 = *(_DWORD *)(v12 + 4 * v37);
          v16 = this[13];
          v31 = *(float *)(v16 + 4 * (v15 + v14));
          v29 = *(float *)(v16 + 4 * (v15 + a3 * this[4]));
          v8 = a3;
          v27 = *(float *)(v16 + 4 * (v14 + a3));
          v17 = *(float *)(v16 + 4 * a3 * (this[4] + 1));
          v18 = v38;
          sub_42DCC0(
            a4,
            *(_DWORD **)(a5 + 4 * v38),
            *(_DWORD *)(a5 + 4 * *(_DWORD *)(this[18] + 4 * v37 + 4)),
            v17,
            v27,
            v29,
            v31);
        }
        v11 = v37;
      }
      if ( v35 < this[2] - 1 )
      {
        v20 = this[10];
        v34 = v11 + this[1];
        v21 = *(_DWORD *)(v20 + 4 * v34);
        if ( v21 == v8 )
        {
          v18 = v38;
          sub_42F910(
            a4,
            *(_DWORD *)(a5 + 4 * v38),
            *(float *)(this[13] + 4 * (*(_DWORD *)(this[10] + 4 * v37) + v8 * this[4])),
            *(float *)(this[13] + 4 * (v8 + v21 * this[4])));
        }
        else
        {
          v22 = this[13];
          v23 = v21 * this[4];
          v24 = *(_DWORD *)(v20 + 4 * v37);
          v32 = *(float *)(v22 + 4 * (v24 + v23));
          v30 = *(float *)(v22 + 4 * (v24 + a3 * this[4]));
          v8 = a3;
          v28 = *(float *)(v22 + 4 * (v23 + a3));
          v25 = *(float *)(v22 + 4 * a3 * (this[4] + 1));
          v18 = v38;
          sub_42DCC0(
            a4,
            *(_DWORD **)(a5 + 4 * v38),
            *(_DWORD *)(a5 + 4 * *(_DWORD *)(this[18] + 4 * v34)),
            v25,
            v28,
            v30,
            v32);
        }
      }
      v26 = v37;
      if ( v36 > 0 )
      {
        v33 = *(_DWORD *)(this[10] + 4 * v37 - 4);
        if ( v33 == v8 )
        {
          v18 = v38;
          sub_42F910(
            a4,
            *(_DWORD *)(a5 + 4 * v38),
            *(float *)(this[13] + 4 * (*(_DWORD *)(this[10] + 4 * v37) + v8 * this[4])),
            *(float *)(this[13] + 4 * (v8 + v33 * this[4])));
          v26 = v37;
        }
      }
      if ( v35 > 0 && *(_DWORD *)(this[10] + 4 * (v26 - this[1])) == v8 )
      {
        v18 = v38;
        sub_42F910(
          a4,
          *(_DWORD *)(a5 + 4 * v38),
          *(float *)(this[13] + 4 * (*(_DWORD *)(this[10] + 4 * v37) + v8 * this[4])),
          *(float *)(this[13] + 4 * v8 * (this[4] + 1)));
      }
      v38 = v18 - 1;
      result = v18 - 1;
    }
    while ( v18 - 1 >= 0 );
  }
  return result;
}

//----- (0042EC30) --------------------------------------------------------
int __thiscall sub_42EC30(_DWORD *this, int a2, int a3, float *a4, int a5)
{
  bool v5; // sf
  int result; // eax
  int v8; // edi
  int v9; // esi
  int v10; // ecx
  int v11; // edx
  float v12; // xmm1_4
  int v13; // eax
  int v14; // ecx
  int v15; // edx
  int v16; // ecx
  int v17; // esi
  float v18; // xmm0_4
  int v19; // esi
  float v20; // xmm1_4
  int v21; // eax
  int v22; // esi
  float v23; // xmm1_4
  int v24; // esi
  float v25; // xmm1_4
  float v26; // [esp+4h] [ebp-30h]
  float v27; // [esp+8h] [ebp-2Ch]
  float v28; // [esp+Ch] [ebp-28h]
  int v29; // [esp+1Ch] [ebp-18h]
  int v30; // [esp+20h] [ebp-14h]
  int v31; // [esp+24h] [ebp-10h]
  int v32; // [esp+28h] [ebp-Ch]
  int v33; // [esp+2Ch] [ebp-8h]
  int v34; // [esp+30h] [ebp-4h]
  int v35; // [esp+3Ch] [ebp+8h]

  result = a2 - 1;
  v5 = a2 - 1 < 0;
  v35 = a2 - 1;
  if ( !v5 )
  {
    v8 = a3;
    do
    {
      v9 = this[18];
      v10 = this[1];
      v34 = *(_DWORD *)(v9 + 4 * result);
      v11 = v34;
      v30 = v34 / v10;
      v31 = v34 % v10;
      *(_DWORD *)(4 * v34 + v9) = v35;
      v33 = 4 * v34;
      if ( v34 % v10 >= this[1] - 1 )
      {
        v19 = v35;
      }
      else
      {
        v12 = *(float *)(v33 + this[15]);
        v13 = this[10];
        v14 = *(_DWORD *)(v13 + 4 * v34 + 4);
        if ( v14 == v8 )
        {
          v19 = v35;
          sub_42F910(
            a4,
            *(_DWORD *)(a5 + 4 * v35),
            *(float *)(this[13] + 4 * (*(_DWORD *)(this[10] + 4 * v34) + v8 * this[4])) * v12,
            *(float *)(this[13] + 4 * (v8 + v14 * this[4])) * v12);
        }
        else
        {
          v15 = v14 * this[4];
          v16 = *(_DWORD *)(v13 + 4 * v34);
          v17 = this[13];
          v28 = *(float *)(v17 + 4 * (v16 + v15)) * v12;
          v27 = *(float *)(v17 + 4 * (v16 + a3 * this[4])) * v12;
          v8 = a3;
          v26 = *(float *)(v17 + 4 * (v15 + a3)) * v12;
          v18 = *(float *)(v17 + 4 * a3 * (this[4] + 1));
          v19 = v35;
          sub_42DCC0(
            a4,
            *(_DWORD **)(a5 + 4 * v35),
            *(_DWORD *)(a5 + 4 * *(_DWORD *)(this[18] + 4 * v34 + 4)),
            v18 * v12,
            v26,
            v27,
            v28);
        }
        v11 = v34;
      }
      if ( v30 < this[2] - 1 )
      {
        v32 = v11 + this[1];
        v20 = *(float *)(v33 + this[14]);
        v21 = *(_DWORD *)(this[10] + 4 * v32);
        if ( v21 == v8 )
        {
          sub_42F910(
            a4,
            *(_DWORD *)(a5 + 4 * v19),
            *(float *)(this[13] + 4 * (*(_DWORD *)(this[10] + 4 * v34) + v8 * this[4])) * v20,
            *(float *)(this[13] + 4 * (v8 + v21 * this[4])) * v20);
          v8 = a3;
        }
        else
        {
          v22 = this[13];
          v8 = a3;
          sub_42DCC0(
            a4,
            *(_DWORD **)(a5 + 4 * v35),
            *(_DWORD *)(a5 + 4 * *(_DWORD *)(this[18] + 4 * v32)),
            *(float *)(v22 + 4 * a3 * (this[4] + 1)) * v20,
            *(float *)(v22 + 4 * (v21 * this[4] + a3)) * v20,
            *(float *)(v22 + 4 * (*(_DWORD *)(this[10] + 4 * v34) + a3 * this[4])) * v20,
            *(float *)(v22 + 4 * (*(_DWORD *)(this[10] + 4 * v34) + v21 * this[4])) * v20);
        }
      }
      if ( v31 > 0 )
      {
        v29 = *(_DWORD *)(this[10] + 4 * v34 - 4);
        if ( v29 == v8 )
        {
          v23 = *(float *)(this[15] + 4 * v34 - 4);
          sub_42F910(
            a4,
            *(_DWORD *)(a5 + 4 * v35),
            *(float *)(this[13] + 4 * (*(_DWORD *)(this[10] + 4 * v34) + v8 * this[4])) * v23,
            *(float *)(this[13] + 4 * (v8 + v29 * this[4])) * v23);
          v8 = a3;
        }
      }
      if ( v30 > 0 )
      {
        v24 = v34 - this[1];
        if ( *(_DWORD *)(this[10] + 4 * v24) == v8 )
        {
          v25 = *(float *)(this[14] + 4 * v24);
          sub_42F910(
            a4,
            *(_DWORD *)(a5 + 4 * v35),
            *(float *)(this[13] + 4 * (*(_DWORD *)(this[10] + 4 * v34) + v8 * this[4])) * v25,
            *(float *)(this[13] + 4 * v8 * (this[4] + 1)) * v25);
        }
      }
      result = --v35;
    }
    while ( v35 >= 0 );
  }
  return result;
}

//----- (0042EF70) --------------------------------------------------------
int __thiscall sub_42EF70(_DWORD *this, int a2, int a3, float *a4, int a5)
{
  bool v5; // sf
  int result; // eax
  int v8; // esi
  int v9; // ecx
  int v10; // ebx
  int v11; // edx
  int v12; // esi
  int v13; // esi
  int v14; // eax
  double v15; // st7
  int v16; // esi
  int v17; // esi
  int v18; // ecx
  int v19; // esi
  int v20; // edx
  int v21; // esi
  float v22; // [esp+0h] [ebp-2Ch]
  float v23; // [esp+0h] [ebp-2Ch]
  float v24; // [esp+4h] [ebp-28h]
  float v25; // [esp+4h] [ebp-28h]
  float v26; // [esp+8h] [ebp-24h]
  float v27; // [esp+8h] [ebp-24h]
  float v28; // [esp+Ch] [ebp-20h]
  float v29; // [esp+Ch] [ebp-20h]
  int v30; // [esp+1Ch] [ebp-10h]
  int v31; // [esp+1Ch] [ebp-10h]
  float v32; // [esp+1Ch] [ebp-10h]
  int v33; // [esp+1Ch] [ebp-10h]
  float v34; // [esp+1Ch] [ebp-10h]
  float v35; // [esp+20h] [ebp-Ch]
  float v36; // [esp+20h] [ebp-Ch]
  float v37; // [esp+20h] [ebp-Ch]
  float v38; // [esp+20h] [ebp-Ch]
  int v39; // [esp+24h] [ebp-8h]
  float v40; // [esp+28h] [ebp-4h]
  int v41; // [esp+28h] [ebp-4h]
  float v42; // [esp+28h] [ebp-4h]
  int v43; // [esp+34h] [ebp+8h]

  result = a2 - 1;
  v5 = a2 - 1 < 0;
  v43 = a2 - 1;
  if ( !v5 )
  {
    do
    {
      v8 = this[18];
      v9 = this[1];
      v10 = *(_DWORD *)(v8 + 4 * result);
      v11 = v43;
      v39 = v10 / v9;
      *(_DWORD *)(v8 + 4 * v10) = v43;
      v12 = a3;
      v30 = v10 % v9;
      if ( v10 % v9 < this[1] - 1 )
      {
        if ( *(_DWORD *)(this[10] + 4 * (v10 + 1)) == a3 )
        {
          v13 = *(_DWORD *)(a5 + 4 * v43);
          v40 = ((double (__cdecl *)(int, int, int, _DWORD))this[21])(
                  v10,
                  v10 + 1,
                  a3,
                  *(_DWORD *)(this[10] + 4 * (v10 + 1)));
          v35 = ((double (__cdecl *)(int, int, _DWORD, int))this[21])(v10, v10 + 1, *(_DWORD *)(this[10] + 4 * v10), a3);
          sub_42F910(a4, v13, v35, v40);
          v12 = a3;
        }
        else
        {
          v28 = ((double (__cdecl *)(int, int, _DWORD, _DWORD))this[21])(
                  v10,
                  v10 + 1,
                  *(_DWORD *)(this[10] + 4 * v10),
                  *(_DWORD *)(this[10] + 4 * (v10 + 1)));
          v26 = ((double (__cdecl *)(int, int, _DWORD, int))this[21])(v10, v10 + 1, *(_DWORD *)(this[10] + 4 * v10), a3);
          v24 = ((double (__cdecl *)(int, int, int))this[21])(v10, v10 + 1, a3);
          v22 = ((double (__cdecl *)(int, int, int))this[21])(v10, v10 + 1, a3);
          sub_42DCC0(
            a4,
            *(_DWORD **)(a5 + 4 * v43),
            *(_DWORD *)(a5 + 4 * *(_DWORD *)(this[18] + 4 * v10 + 4)),
            v22,
            v24,
            v26,
            v28);
        }
        v11 = v43;
      }
      if ( v39 < this[2] - 1 )
      {
        v14 = v10 + this[1];
        v41 = v14;
        if ( *(_DWORD *)(this[10] + 4 * v14) != v12 )
        {
          v29 = ((double (__cdecl *)(int, int, _DWORD))this[21])(v10, v14, *(_DWORD *)(this[10] + 4 * v10));
          v27 = ((double (__cdecl *)(int, int, _DWORD))this[21])(v10, v41, *(_DWORD *)(this[10] + 4 * v10));
          v25 = ((double (__cdecl *)(int, int, int))this[21])(v10, v41, v12);
          v15 = ((double (__cdecl *)(int, int, int))this[21])(v10, v41, v12);
          v16 = v43;
          v23 = v15;
          sub_42DCC0(
            a4,
            *(_DWORD **)(a5 + 4 * v43),
            *(_DWORD *)(a5 + 4 * *(_DWORD *)(this[18] + 4 * v41)),
            v23,
            v25,
            v27,
            v29);
          goto LABEL_12;
        }
        v17 = *(_DWORD *)(a5 + 4 * v11);
        v36 = ((double (__cdecl *)(int, int, int, _DWORD))this[21])(v10, v14, a3, *(_DWORD *)(this[10] + 4 * v14));
        v42 = ((double (__cdecl *)(int, int, _DWORD, int))this[21])(v10, v41, *(_DWORD *)(this[10] + 4 * v10), a3);
        sub_42F910(a4, v17, v42, v36);
      }
      v16 = v43;
LABEL_12:
      v18 = a3;
      if ( v30 > 0 )
      {
        v31 = *(_DWORD *)(this[10] + 4 * (v10 - 1));
        if ( v31 == a3 )
        {
          v19 = *(_DWORD *)(a5 + 4 * v16);
          v32 = ((double (__cdecl *)(int, int, int, int))this[21])(v10, v10 - 1, a3, v31);
          v37 = ((double (__cdecl *)(int, int, _DWORD, int))this[21])(v10, v10 - 1, *(_DWORD *)(this[10] + 4 * v10), a3);
          sub_42F910(a4, v19, v37, v32);
          v18 = a3;
        }
      }
      if ( v39 > 0 )
      {
        v20 = v10 - this[1];
        v33 = v20;
        if ( *(_DWORD *)(this[10] + 4 * v20) == v18 )
        {
          v21 = *(_DWORD *)(a5 + 4 * v43);
          v38 = ((double (__cdecl *)(int, int, int, int))this[21])(v10, v20, v18, v18);
          v34 = ((double (__cdecl *)(int, int, _DWORD, int))this[21])(v10, v33, *(_DWORD *)(this[10] + 4 * v10), a3);
          sub_42F910(a4, v21, v34, v38);
        }
      }
      result = --v43;
    }
    while ( v43 >= 0 );
  }
  return result;
}

//----- (0042F260) --------------------------------------------------------
void __thiscall sub_42F260(_DWORD *this, int a2, int a3, float *a4, int a5)
{
  int v6; // esi
  int v7; // eax
  int v8; // edi
  int v9; // ecx
  int v10; // esi
  int v11; // eax
  int v12; // ecx
  float v13; // xmm1_4
  int v14; // eax
  int v15; // esi
  int v16; // edx
  int v17; // [esp+1Ch] [ebp-Ch]
  int v18; // [esp+24h] [ebp-4h]
  int i; // [esp+30h] [ebp+8h]

  v6 = a2 - 1;
  for ( i = a2 - 1; i >= 0; --i )
  {
    v7 = this[18];
    v8 = *(_DWORD *)(v7 + 4 * v6);
    v18 = v8;
    *(_DWORD *)(v7 + 4 * v8) = v6;
    v9 = this[16];
    v10 = 12 * v8;
    v17 = 12 * v8;
    if ( *(_DWORD *)(12 * v8 + v9) )
    {
      *(_DWORD *)(v10 + v9 + 8) = *(_DWORD *)(v10 + v9);
      *(_BYTE *)(v10 + v9 + 5) = 0;
      while ( sub_42FED0((_DWORD *)(v10 + this[16])) )
      {
        v11 = sub_42FEE0((_BYTE *)(v10 + this[16]));
        v12 = *(_DWORD *)v11;
        v13 = *(float *)(v11 + 4);
        v14 = this[10];
        if ( *(_DWORD *)(v14 + 4 * v12) == a3 )
        {
          sub_42F910(
            a4,
            *(_DWORD *)(a5 + 4 * i),
            *(float *)(this[13] + 4 * (*(_DWORD *)(this[10] + 4 * v8) + a3 * this[4])) * v13,
            *(float *)(this[13] + 4 * a3 * (this[4] + 1)) * v13);
        }
        else if ( v8 < v12 )
        {
          v15 = this[13];
          v16 = *(_DWORD *)(v14 + 4 * v12) * this[4];
          sub_42DCC0(
            a4,
            *(_DWORD **)(a5 + 4 * i),
            *(_DWORD *)(a5 + 4 * *(_DWORD *)(this[18] + 4 * v12)),
            *(float *)(v15 + 4 * a3 * (this[4] + 1)) * v13,
            *(float *)(v15 + 4 * (v16 + a3)) * v13,
            *(float *)(v15 + 4 * (*(_DWORD *)(v14 + 4 * v18) + a3 * this[4])) * v13,
            *(float *)(v15 + 4 * (*(_DWORD *)(v14 + 4 * v18) + v16)) * v13);
          v10 = v17;
          v8 = v18;
        }
      }
    }
    v6 = i - 1;
  }
}

//----- (0042F3F0) --------------------------------------------------------
void __thiscall sub_42F3F0(_DWORD *this, int a2, int a3, float *a4, int a5)
{
  bool v5; // sf
  int v6; // ebx
  int v8; // eax
  int v9; // esi
  int v10; // ecx
  int v11; // ebx
  int *v12; // eax
  int v13; // edx
  int v14; // ebx
  int v15; // ecx
  int v16; // esi
  float v17; // [esp+0h] [ebp-2Ch]
  float v18; // [esp+4h] [ebp-28h]
  float v19; // [esp+8h] [ebp-24h]
  float v20; // [esp+Ch] [ebp-20h]
  int v21; // [esp+1Ch] [ebp-10h]
  float v22; // [esp+20h] [ebp-Ch]
  float v23; // [esp+24h] [ebp-8h]
  int v24; // [esp+28h] [ebp-4h]
  int v25; // [esp+34h] [ebp+8h]

  v6 = a2 - 1;
  v5 = a2 - 1 < 0;
  v25 = a2 - 1;
  if ( !v5 )
  {
    do
    {
      v8 = this[18];
      v9 = *(_DWORD *)(v8 + 4 * v6);
      v24 = v9;
      *(_DWORD *)(v8 + 4 * v9) = v6;
      v10 = this[16];
      v11 = 12 * v9;
      v21 = 12 * v9;
      if ( *(_DWORD *)(12 * v9 + v10) )
      {
        *(_DWORD *)(v11 + v10 + 8) = *(_DWORD *)(v11 + v10);
        *(_BYTE *)(v11 + v10 + 5) = 0;
        if ( sub_42FED0((_DWORD *)(v11 + this[16])) )
        {
          do
          {
            v12 = (int *)sub_42FEE0((_BYTE *)(v11 + this[16]));
            v13 = this[10];
            v14 = *v12;
            v15 = *(_DWORD *)(v13 + 4 * *v12);
            if ( v15 == a3 )
            {
              v16 = *(_DWORD *)(a5 + 4 * v25);
              v23 = ((double (__cdecl *)(int, int, int, int))this[21])(v24, v14, a3, v15);
              v22 = ((double (__cdecl *)(int, int, _DWORD, int))this[21])(v24, v14, *(_DWORD *)(this[10] + 4 * v24), a3);
              sub_42F910(a4, v16, v22, v23);
              v9 = v24;
            }
            else if ( v9 < v14 )
            {
              v20 = ((double (__cdecl *)(int, int, _DWORD))this[21])(v9, v14, *(_DWORD *)(v13 + 4 * v9));
              v19 = ((double (__cdecl *)(int, int, _DWORD))this[21])(v9, v14, *(_DWORD *)(this[10] + 4 * v9));
              v18 = ((double (__cdecl *)(int, int, int))this[21])(v9, v14, a3);
              v17 = ((double (__cdecl *)(int, int, int))this[21])(v9, v14, a3);
              sub_42DCC0(
                a4,
                *(_DWORD **)(a5 + 4 * v25),
                *(_DWORD *)(a5 + 4 * *(_DWORD *)(this[18] + 4 * v14)),
                v17,
                v18,
                v19,
                v20);
            }
            v11 = v21;
          }
          while ( sub_42FED0((_DWORD *)(v21 + this[16])) );
        }
      }
      v6 = --v25;
    }
    while ( v25 >= 0 );
  }
}

//----- (0042F560) --------------------------------------------------------
double __thiscall sub_42F560(_DWORD *a1)
{
  if ( *((_BYTE *)a1 + 20) )
  {
    if ( a1[8] )
    {
      if ( *((_BYTE *)a1 + 21) )
        return sub_42E1A0(a1);
      else
        return sub_42E0A0(a1);
    }
    else
    {
      return sub_42E2C0(a1);
    }
  }
  else if ( a1[8] )
  {
    return sub_42E380(a1);
  }
  else
  {
    return sub_42E420(a1);
  }
}

//----- (0042F590) --------------------------------------------------------
double __thiscall sub_42F590(_DWORD *this, int a2)
{
  int v3; // edi
  double v4; // st7
  float i; // xmm1_4
  int (__cdecl *v6)(); // esi
  float v7; // xmm0_4
  int v8; // edi
  int v9; // edx
  bool v10; // zf
  int v11; // ecx
  int v12; // esi
  int j; // esi
  FILE *v15; // eax
  const char *v16; // [esp-4h] [ebp-1Ch]
  int v17; // [esp+10h] [ebp-8h]
  float v18; // [esp+10h] [ebp-8h]
  float v19; // [esp+14h] [ebp-4h]
  float v20; // [esp+14h] [ebp-4h]
  int v21; // [esp+14h] [ebp-4h]

  v3 = 1;
  v17 = 1;
  v19 = ((double (__thiscall *)(_DWORD *))*(_DWORD *)(*this + 12))(this);
  v4 = ((double (__thiscall *)(_DWORD *))*(_DWORD *)(*this + 8))(this) + v19;
  for ( i = -1.0; ; i = v7 )
  {
    v6 = rand;
    v20 = v4;
    v7 = v20;
    if ( i >= 0.0 && (i <= v20 || v3 > a2) )
      break;
    if ( this[7] == 3 )
    {
      v16 = "You have to set up the data cost before running optimization";
LABEL_16:
      v15 = _iob_func();
      fprintf(v15 + 2, "\n %s \n", v16);
      exit(1);
    }
    if ( this[8] == 3 )
    {
      v16 = "You have to set up the smoothness cost before running optimization";
      goto LABEL_16;
    }
    if ( *((_BYTE *)this + 44) )
    {
      v21 = 2 * this[4];
      if ( v21 > 0 )
      {
        do
        {
          v8 = v6() % this[4];
          v9 = v6() % this[4];
          v10 = v21-- == 1;
          v11 = this[17];
          v12 = *(_DWORD *)(v11 + 4 * v8);
          *(_DWORD *)(v11 + 4 * v8) = *(_DWORD *)(v11 + 4 * v9);
          *(_DWORD *)(this[17] + 4 * v9) = v12;
          v6 = rand;
        }
        while ( !v10 );
        v3 = v17;
      }
    }
    for ( j = 0; j < this[4]; ++j )
      sub_42E560(this, *(_DWORD *)(this[17] + 4 * j));
    v18 = ((double (__thiscall *)(_DWORD *))*(_DWORD *)(*this + 12))(this);
    v4 = ((double (__thiscall *)(_DWORD *))*(_DWORD *)(*this + 8))(this) + v18;
    v17 = ++v3;
  }
  return v20;
}

//----- (0042F6D0) --------------------------------------------------------
_DWORD *__thiscall sub_42F6D0(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  this[4] = a2;
  result = this;
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  this[5] = 0;
  return result;
}

//----- (0042F700) --------------------------------------------------------
void __thiscall sub_42F700(int this)
{
  int v2; // edi
  int v3; // eax
  int v4; // edi
  int v5; // eax
  int v6; // edi

  if ( *(_DWORD *)this )
  {
    do
    {
      v2 = *(_DWORD *)(*(_DWORD *)this + 4);
      operator delete(*(void **)this);
      *(_DWORD *)this = v2;
    }
    while ( v2 );
  }
  if ( *(_DWORD *)(this + 4) )
  {
    do
    {
      v3 = *(_DWORD *)(this + 4);
      v4 = *(_DWORD *)(v3 + 8);
      operator delete(*(void **)v3);
      *(_DWORD *)(this + 4) = v4;
    }
    while ( v4 );
  }
  if ( *(_DWORD *)(this + 8) )
  {
    do
    {
      v5 = *(_DWORD *)(this + 8);
      v6 = *(_DWORD *)(v5 + 8);
      operator delete(*(void **)v5);
      *(_DWORD *)(this + 8) = v6;
    }
    while ( v6 );
  }
}

//----- (0042F770) --------------------------------------------------------
_DWORD *__thiscall sub_42F770(_DWORD *this, _DWORD *a2, int a3, int a4, int a5)
{
  int v6; // esi
  char *v7; // eax
  void (__cdecl *v8)(const char *); // eax
  int v9; // esi
  char *v10; // eax
  void (__cdecl *v11)(const char *); // eax
  int v12; // ecx
  _DWORD *v13; // esi
  int v14; // ecx
  _DWORD *v15; // edx
  _DWORD *result; // eax

  v6 = this[1];
  if ( !v6 || *(_DWORD *)(v6 + 4) + 12 > (unsigned int)(v6 + 12300) )
  {
    v7 = (char *)operator new(0x3019u);
    if ( !v7 )
    {
      v8 = (void (__cdecl *)(const char *))this[4];
      if ( v8 )
        v8("Not enough memory!");
      exit(1);
    }
    if ( ((unsigned __int8)v7 & 1) != 0 )
      this[1] = v7 + 1;
    else
      this[1] = v7;
    *(_DWORD *)this[1] = v7;
    *(_DWORD *)(this[1] + 4) = this[1] + 12;
    *(_DWORD *)(this[1] + 8) = v6;
  }
  v9 = this[2];
  if ( !v9 || *(_DWORD *)(v9 + 4) + 4 > (unsigned int)(v9 + 4108) )
  {
    v10 = (char *)operator new(0x1011u);
    if ( !v10 )
    {
      v11 = (void (__cdecl *)(const char *))this[4];
      if ( v11 )
        v11("Not enough memory!");
      exit(1);
    }
    if ( ((unsigned __int8)v10 & 1) != 0 )
      this[2] = v10 + 1;
    else
      this[2] = v10;
    *(_DWORD *)this[2] = v10;
    *(_DWORD *)(this[2] + 4) = this[2] + 12;
    *(_DWORD *)(this[2] + 8) = v9;
  }
  v12 = this[1];
  v13 = *(_DWORD **)(v12 + 4);
  *(_DWORD *)(v12 + 4) = v13 + 3;
  v14 = this[2];
  v15 = *(_DWORD **)(v14 + 4);
  *(_DWORD *)(v14 + 4) = v15 + 1;
  result = a2;
  *v15 = a2;
  v13[1] = a4;
  *v13 = a3;
  v13[2] = a5;
  ++*a2;
  ++*(_DWORD *)(a3 + 4);
  return result;
}

//----- (0042F890) --------------------------------------------------------
_DWORD *__thiscall sub_42F890(_DWORD **this)
{
  _DWORD *v2; // edi
  _DWORD *v3; // eax
  void (__cdecl *v4)(const char *); // eax
  _DWORD *result; // eax

  v2 = *this;
  if ( !*this || *v2 + 32 > (unsigned int)(v2 + 4090) )
  {
    v3 = operator new(0x4008u);
    *this = v3;
    if ( !v3 )
    {
      v4 = (void (__cdecl *)(const char *))this[4];
      if ( v4 )
        v4("Not enough memory!");
      exit(1);
    }
    *v3 = v3 + 2;
    (*this)[1] = v2;
  }
  result = (_DWORD *)**this;
  **this = result + 8;
  *result = 0;
  result[1] = 0;
  result[7] = 0;
  return result;
}

//----- (0042F910) --------------------------------------------------------
int __thiscall sub_42F910(float *this, int a2, float a3, float a4)
{
  int result; // eax
  float v5; // xmm2_4
  float v6; // xmm1_4
  float v7; // xmm1_4
  float v8; // xmm3_4

  result = a2;
  v5 = a4;
  v6 = *(float *)(a2 + 28);
  if ( v6 <= 0.0 )
  {
    v5 = a4 - v6;
    v7 = a3;
  }
  else
  {
    v7 = v6 + a3;
  }
  if ( v5 <= v7 )
    v8 = v5;
  else
    v8 = v7;
  this[5] = this[5] + v8;
  *(float *)(a2 + 28) = v7 - v5;
  return result;
}

//----- (0042F970) --------------------------------------------------------
_DWORD *__thiscall sub_42F970(int this)
{
  _DWORD *v2; // esi
  _DWORD *v3; // eax
  int v4; // eax
  _DWORD *v5; // ecx
  _DWORD *v6; // esi
  _DWORD *v7; // ebx
  _DWORD *v8; // edi
  int v9; // ecx
  _DWORD *result; // eax
  _DWORD *v11; // edx
  int *v12; // esi
  int v13; // edx
  _DWORD *v14; // eax
  _DWORD *v15; // eax
  char *v16; // eax
  int *v17; // ecx
  _DWORD *v18; // eax
  int v19; // edx
  char *v20; // eax
  _DWORD *v21; // ecx
  int v22; // ebx
  int i; // ecx
  int *v24; // edx
  int *v25; // ecx
  int **v26; // eax
  int v27; // ebx
  int v28; // xmm0_4
  int v29; // xmm1_4
  int v30; // xmm2_4
  int v31; // edi
  int v32; // xmm3_4
  int *v33; // esi
  int k; // edi
  _DWORD **v35; // esi
  _DWORD *v36; // edx
  _DWORD *m; // ecx
  _DWORD *v38; // edi
  _DWORD *n; // edx
  _DWORD *v40; // ecx
  unsigned int v41; // esi
  void (__cdecl *v42)(const char *); // eax
  void (__cdecl *v43)(const char *); // eax
  void (__cdecl *v44)(const char *); // eax
  void (__cdecl *v45)(const char *); // eax
  int v46; // eax
  int ii; // edi
  int v48; // esi
  _DWORD *v49; // edx
  _DWORD *v50; // [esp+14h] [ebp-34h]
  int *v51; // [esp+18h] [ebp-30h]
  _DWORD *v52; // [esp+1Ch] [ebp-2Ch]
  _DWORD *v53; // [esp+20h] [ebp-28h]
  _DWORD *v54; // [esp+24h] [ebp-24h]
  _DWORD *v55; // [esp+28h] [ebp-20h]
  int *j; // [esp+28h] [ebp-20h]
  int v57; // [esp+2Ch] [ebp-1Ch]
  int v58; // [esp+2Ch] [ebp-1Ch]
  _DWORD *v59; // [esp+30h] [ebp-18h]
  int v60; // [esp+30h] [ebp-18h]
  int v61; // [esp+34h] [ebp-14h]
  int v62; // [esp+34h] [ebp-14h]
  int *v63; // [esp+34h] [ebp-14h]
  char v65; // [esp+3Eh] [ebp-Ah]
  char v66; // [esp+3Fh] [ebp-9h]
  int v67; // [esp+40h] [ebp-8h] BYREF

  v65 = 0;
  v66 = 0;
  if ( !*(_DWORD *)(this + 8) )
  {
    v2 = sub_42F890((_DWORD **)this);
    v3 = sub_42F890((_DWORD **)this);
    sub_42F770((_DWORD *)this, v2, (int)v3, 1065353216, 0);
  }
  v4 = *(_DWORD *)(this + 8);
  v67 = 0;
  v5 = *(_DWORD **)(v4 + 4);
  if ( (unsigned int)v5 < v4 + 4108 )
  {
    do
      *v5++ = 0;
    while ( (unsigned int)v5 < *(_DWORD *)(this + 8) + 4108 );
  }
  v6 = *(_DWORD **)(this + 4);
  v7 = v6;
  v8 = *(_DWORD **)(this + 8);
  v53 = v8;
  v50 = v8;
  v9 = (int)(v8 + 3);
  v52 = v6;
  v59 = v6 + 3;
  result = (_DWORD *)this;
  v51 = v8 + 3;
  v54 = v8 + 3;
  v11 = *(_DWORD **)this;
  v55 = *(_DWORD **)this;
  if ( *(_DWORD *)this )
  {
    result = v6 + 3;
    do
    {
      v12 = v11 + 2;
      if ( (unsigned int)(v11 + 2) < *v11 )
      {
        do
        {
          v13 = *v12;
          v57 = *v12;
          v61 = 3 * *v12;
          if ( &result[v61] <= v7 + 3075 )
          {
            v15 = v59;
          }
          else
          {
            if ( v13 > 1024 )
            {
              v43 = *(void (__cdecl **)(const char *))(this + 16);
              if ( v43 )
                v43("# of arcs per node exceeds block size!");
              exit(1);
            }
            if ( v65 || (v7 = (_DWORD *)v7[2], v14 = (_DWORD *)v53[2], v53 = v14, !v7) )
            {
              v60 = *(_DWORD *)(this + 4);
              v16 = (char *)operator new(0x3019u);
              if ( !v16 )
              {
                v42 = *(void (__cdecl **)(const char *))(this + 16);
                if ( v42 )
                  v42("Not enough memory!");
                exit(1);
              }
              if ( ((unsigned __int8)v16 & 1) != 0 )
                *(_DWORD *)(this + 4) = v16 + 1;
              else
                *(_DWORD *)(this + 4) = v16;
              v65 = 1;
              **(_DWORD **)(this + 4) = v16;
              v13 = v57;
              *(_DWORD *)(*(_DWORD *)(this + 4) + 4) = *(_DWORD *)(this + 4) + 12;
              *(_DWORD *)(*(_DWORD *)(this + 4) + 8) = v60;
              v7 = *(_DWORD **)(this + 4);
              v15 = v7 + 3;
            }
            else
            {
              v51 = v14 + 3;
              v15 = v7 + 3;
            }
          }
          if ( v53 )
          {
            v17 = &v51[v13];
            v51 = v17;
          }
          else
          {
            v17 = &v67;
          }
          v18 = &v15[v61];
          v12[2] = (int)v17;
          *v12 = (int)v18;
          v7[3075] = v12;
          v19 = v12[1];
          v59 = v18;
          v58 = v19;
          if ( &v54[v19] <= v8 + 1027 )
          {
            v21 = v54;
          }
          else
          {
            if ( v19 > 1024 )
            {
              v45 = *(void (__cdecl **)(const char *))(this + 16);
              if ( v45 )
                v45("# of arcs per node exceeds block size!");
              exit(1);
            }
            if ( v66 || (v8 = (_DWORD *)v8[2]) == 0 )
            {
              v62 = *(_DWORD *)(this + 8);
              v20 = (char *)operator new(0x1011u);
              if ( !v20 )
              {
                v44 = *(void (__cdecl **)(const char *))(this + 16);
                if ( v44 )
                  v44("Not enough memory!");
                exit(1);
              }
              if ( ((unsigned __int8)v20 & 1) != 0 )
                *(_DWORD *)(this + 8) = v20 + 1;
              else
                *(_DWORD *)(this + 8) = v20;
              v66 = 1;
              **(_DWORD **)(this + 8) = v20;
              *(_DWORD *)(*(_DWORD *)(this + 8) + 4) = *(_DWORD *)(this + 8) + 12;
              *(_DWORD *)(*(_DWORD *)(this + 8) + 8) = v62;
              v8 = *(_DWORD **)(this + 8);
            }
            v21 = v8 + 3;
          }
          v9 = (int)&v21[v58];
          v11 = v55;
          result = v59;
          v12[1] = v9;
          v8[1027] = v12;
          v12 += 8;
          v54 = (_DWORD *)v9;
        }
        while ( (unsigned int)v12 < *v55 );
      }
      *v12 = (int)result;
      v12[1] = v9;
      v11 = (_DWORD *)v11[1];
      v55 = v11;
    }
    while ( v11 );
    v6 = v52;
  }
  v22 = this;
  for ( i = *(_DWORD *)(this + 4); i; i = *(_DWORD *)(i + 8) )
  {
    result = **(_DWORD ***)(i + 12300);
    *(_DWORD *)(i + 4) = result;
  }
  if ( v6 )
  {
    result = v50;
    do
    {
      v24 = result + 3;
      v25 = v6 + 3;
      v63 = result + 3;
      for ( j = v6 + 3; v25 < v6 + 3075; v63 = v24 )
      {
        v26 = (int **)*v24;
        v27 = 0;
        v28 = 0;
        v29 = 0;
        if ( *v24 )
        {
          do
          {
            *v24 = 0;
            v30 = v25[1];
            v31 = *v25 - (_DWORD)v26;
            v32 = v25[2];
            if ( v27 )
            {
              *v25 = v27;
              v25[1] = v28;
              v25[2] = v29;
            }
            *v26 -= 3;
            v27 = v31;
            v33 = v26[2];
            v25 = *v26;
            v28 = v30;
            v29 = v32;
            if ( v33 != &v67 )
            {
              v24 = v33 - 1;
              v26[2] = v33 - 1;
            }
            v26 = (int **)*v24;
          }
          while ( *v24 );
          v24 = v63;
          v6 = v52;
          *v25 = v31;
          v25[1] = v30;
          v25[2] = v32;
          v25 = j;
        }
        v25 += 3;
        ++v24;
        j = v25;
      }
      v6 = (_DWORD *)v6[2];
      v52 = v6;
      result = (_DWORD *)v50[2];
      v50 = result;
    }
    while ( v6 );
    v22 = this;
  }
  for ( k = *(_DWORD *)(v22 + 4); k; k = *(_DWORD *)(k + 8) )
  {
    v35 = *(_DWORD ***)(k + 12300);
    v36 = *v35;
    **(_DWORD **)(k + 4) = **v35;
    *(_DWORD *)(*(_DWORD *)(k + 4) + 4) = v36[1];
    *(_DWORD *)(*(_DWORD *)(k + 4) + 8) = v36[2];
    *v36 = *(_DWORD *)(k + 4) + 12;
    result = (_DWORD *)((char *)v36 - 1);
    *v35 = (_DWORD *)((char *)v36 - 1);
  }
  for ( m = *(_DWORD **)(v22 + 8); m; m = (_DWORD *)m[2] )
  {
    result = *(_DWORD **)(m[1027] + 4);
    m[1] = result;
  }
  v38 = *(_DWORD **)v22;
  if ( *(_DWORD *)v22 )
  {
    do
    {
      for ( n = v38 + 2; (unsigned int)n < *v38; n += 8 )
      {
        v40 = (_DWORD *)*n;
        if ( (*n & 1) != 0 )
        {
          v41 = *(_DWORD *)((char *)v40 + 1);
          v40 = (_DWORD *)((char *)v40 + 13);
        }
        else
        {
          v41 = n[8];
        }
        for ( ; (unsigned int)v40 < v41; v40 += 3 )
        {
          v46 = *v40;
          *(_DWORD *)((char *)n + v46 + 4) -= 4;
          result = *(_DWORD **)((char *)n + v46 + 4);
          *result = v40;
        }
      }
      v38 = (_DWORD *)v38[1];
    }
    while ( v38 );
  }
  for ( ii = *(_DWORD *)(v22 + 8); ii; ii = *(_DWORD *)(ii + 8) )
  {
    v48 = *(_DWORD *)(ii + 4108);
    v49 = *(_DWORD **)(v48 + 4);
    **(_DWORD **)(ii + 4) = *v49;
    *v49 = *(_DWORD *)(ii + 4) + 4;
    result = (_DWORD *)((char *)v49 - 1);
    *(_DWORD *)(v48 + 4) = (char *)v49 - 1;
  }
  return result;
}

//----- (0042FE20) --------------------------------------------------------
void __thiscall sub_42FE20(unsigned __int8 *this)
{
  unsigned __int8 *v1; // ebx
  char i; // al
  void **v3; // ecx
  int v4; // edi
  int v5; // esi
  void **v7; // [esp+8h] [ebp-8h]

  v1 = this;
  for ( i = 1; *(_DWORD *)v1; i = 0 )
  {
    v3 = *(void ***)v1;
    v7 = *(void ***)v1;
    if ( i == 1 )
      v4 = v1[4];
    else
      v4 = 4;
    v5 = 0;
    if ( v4 > 0 )
    {
      do
        operator delete(v7[v5++]);
      while ( v5 < v4 );
      v1 = this;
      v3 = v7;
    }
    *(_DWORD *)v1 = *(_DWORD *)(*(_DWORD *)v1 + 16);
    operator delete(v3);
  }
}

//----- (0042FE90) --------------------------------------------------------
int __thiscall sub_42FE90(_BYTE *this, int a2)
{
  _DWORD *v3; // eax
  int result; // eax

  if ( this[4] == 4 )
  {
    v3 = operator new(0x14u);
    v3[4] = *(_DWORD *)this;
    *(_DWORD *)this = v3;
    this[4] = 0;
  }
  result = a2;
  *(_DWORD *)(*(_DWORD *)this + 4 * (unsigned __int8)this[4]++) = a2;
  return result;
}

//----- (0042FED0) --------------------------------------------------------
bool __thiscall sub_42FED0(_DWORD *this)
{
  return this[2] != 0;
}

//----- (0042FEE0) --------------------------------------------------------
int __thiscall sub_42FEE0(_BYTE *this)
{
  unsigned __int8 v2; // cl
  int v3; // edi
  int v4; // eax
  unsigned __int8 v5; // cl
  int v6; // esi
  int result; // eax

  v2 = this[5];
  v3 = *((_DWORD *)this + 2);
  v4 = v2;
  v5 = v2 + 1;
  v6 = *(_DWORD *)(v3 + 4 * v4);
  this[5] = v5;
  if ( v3 == *(_DWORD *)this && v5 >= this[4] )
  {
    result = v6;
    *((_DWORD *)this + 2) = *(_DWORD *)(v3 + 16);
    this[5] = 0;
  }
  else
  {
    if ( v5 == 4 )
    {
      *((_DWORD *)this + 2) = *(_DWORD *)(v3 + 16);
      this[5] = 0;
    }
    return v6;
  }
  return result;
}

//----- (0042FF30) --------------------------------------------------------
_DWORD *__thiscall sub_42FF30(_DWORD *this)
{
  int v2; // edi
  char *v3; // eax
  void (__cdecl *v4)(const char *); // eax
  _DWORD *v5; // edx
  int v6; // eax
  _DWORD *result; // eax

  if ( !this[2] )
  {
    v2 = this[1];
    v3 = (char *)operator new(8 * *this + 4);
    this[1] = v3;
    if ( !v3 )
    {
      v4 = (void (__cdecl *)(const char *))this[3];
      if ( v4 )
        v4("Not enough memory!");
      exit(1);
    }
    v5 = v3 + 4;
    v6 = *this - 1;
    this[2] = v5;
    if ( v5 < &v5[2 * v6] )
    {
      do
      {
        *v5 = v5 + 2;
        v5 += 2;
      }
      while ( (unsigned int)v5 < this[2] + 8 * *this - 8 );
    }
    *v5 = 0;
    *(_DWORD *)this[1] = v2;
  }
  result = (_DWORD *)this[2];
  this[2] = *result;
  return result;
}

//----- (0042FFB0) --------------------------------------------------------
unsigned int __userpurge sub_42FFB0@<eax>(int a1@<ecx>, char a2@<efl>, int a3, int a4, float *a5, float *a6)
{
  int v7; // ecx
  float v8; // xmm1_4
  int v9; // edx
  int v10; // eax
  unsigned int v11; // eax
  int v12; // esi
  int v13; // edx
  int v14; // eax
  unsigned int v15; // eax
  int v16; // eax
  int v17; // esi
  float v18; // xmm0_4
  _DWORD *v19; // eax
  float v20; // xmm0_4
  _DWORD *v21; // eax
  float v22; // xmm0_4
  _DWORD *v23; // eax
  unsigned int result; // eax
  float v25; // xmm0_4
  _DWORD *v26; // eax
  float v27; // xmm0_4
  _DWORD *v28; // eax
  float v29; // xmm0_4
  bool v30; // cf
  bool v31; // zf
  char v32; // sf
  char v33; // of
  char v34; // pf
  float v35; // [esp+8h] [ebp-4h]
  _DWORD *i; // [esp+14h] [ebp+8h]
  unsigned int v37; // [esp+14h] [ebp+8h]
  _DWORD *v38; // [esp+1Ch] [ebp+10h]
  unsigned int v39; // [esp+1Ch] [ebp+10h]

  v7 = a3;
  v8 = *a5;
  v9 = a3;
  v35 = *a5;
  v10 = *(_DWORD *)(a3 + 8);
  if ( v10 != 1 )
  {
    do
    {
      if ( (v10 & 1) != 0 )
      {
        v11 = v10 & 0xFFFFFFFE;
        if ( v8 > *(float *)(v11 + 4) )
          v8 = *(float *)(v11 + 4);
        v9 -= *(_DWORD *)v11;
      }
      else
      {
        if ( v8 > *(float *)(v10 + 8) )
          v8 = *(float *)(v10 + 8);
        v9 += *(_DWORD *)v10;
      }
      v10 = *(_DWORD *)(v9 + 8);
    }
    while ( v10 != 1 );
    v35 = v8;
  }
  if ( v8 > *(float *)(v9 + 28) )
  {
    v8 = *(float *)(v9 + 28);
    v35 = v8;
  }
  v12 = a4;
  v13 = a4;
  v14 = *(_DWORD *)(a4 + 8);
  if ( v14 != 1 )
  {
    do
    {
      if ( (v14 & 1) != 0 )
      {
        v15 = v14 & 0xFFFFFFFE;
        if ( v8 > *(float *)(v15 + 8) )
          v8 = *(float *)(v15 + 8);
        v13 -= *(_DWORD *)v15;
      }
      else
      {
        if ( v8 > *(float *)(v14 + 4) )
          v8 = *(float *)(v14 + 4);
        v13 += *(_DWORD *)v14;
      }
      v14 = *(_DWORD *)(v13 + 8);
    }
    while ( v14 != 1 );
    v35 = v8;
  }
  if ( v8 > (float)-*(float *)(v13 + 28) )
  {
    v8 = -*(float *)(v13 + 28);
    v35 = v8;
  }
  *a6 = *a6 + v8;
  *a5 = *a5 - v8;
  v16 = *(_DWORD *)(a3 + 8);
  v38 = (_DWORD *)v16;
  if ( v16 != 1 )
  {
    v17 = a3;
    do
    {
      if ( (v16 & 1) != 0 )
      {
        v39 = v16 & 0xFFFFFFFE;
        *(float *)(v39 + 8) = v8 + *(float *)(v39 + 8);
        v18 = *(float *)((v16 & 0xFFFFFFFE) + 4) - v8;
        *(float *)(v39 + 4) = v18;
        if ( v18 == 0.0 )
        {
          *(_DWORD *)(v17 + 8) = 2;
          v19 = sub_42FF30(*(_DWORD **)(a1 + 12));
          v8 = v35;
          *v19 = v17;
          v19[1] = *(_DWORD *)(a1 + 40);
          *(_DWORD *)(a1 + 40) = v19;
        }
        v17 -= *(_DWORD *)v39;
      }
      else
      {
        *(float *)(v16 + 4) = *(float *)(v16 + 4) + v8;
        v20 = *(float *)(v16 + 8) - v8;
        *(float *)(v16 + 8) = v20;
        if ( v20 == 0.0 )
        {
          *(_DWORD *)(v17 + 8) = 2;
          v21 = sub_42FF30(*(_DWORD **)(a1 + 12));
          v8 = v35;
          *v21 = v17;
          v21[1] = *(_DWORD *)(a1 + 40);
          *(_DWORD *)(a1 + 40) = v21;
        }
        v17 += *v38;
      }
      v16 = *(_DWORD *)(v17 + 8);
      v38 = (_DWORD *)v16;
    }
    while ( v16 != 1 );
    a3 = v17;
    v12 = a4;
    v7 = a3;
  }
  v22 = *(float *)(v7 + 28) - v8;
  *(float *)(v7 + 28) = v22;
  if ( v22 == 0.0 )
  {
    *(_DWORD *)(v7 + 8) = 2;
    v23 = sub_42FF30(*(_DWORD **)(a1 + 12));
    v8 = v35;
    *v23 = a3;
    v23[1] = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(a1 + 40) = v23;
  }
  result = *(_DWORD *)(v12 + 8);
  for ( i = (_DWORD *)result; result != 1; i = (_DWORD *)result )
  {
    if ( (result & 1) != 0 )
    {
      v37 = result & 0xFFFFFFFE;
      *(float *)(v37 + 4) = *(float *)(v37 + 4) + v8;
      v25 = *(float *)((result & 0xFFFFFFFE) + 8) - v8;
      *(float *)(v37 + 8) = v25;
      if ( v25 == 0.0 )
      {
        *(_DWORD *)(v12 + 8) = 2;
        v26 = sub_42FF30(*(_DWORD **)(a1 + 12));
        v8 = v35;
        *v26 = v12;
        v26[1] = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(a1 + 40) = v26;
      }
      v12 -= *(_DWORD *)v37;
    }
    else
    {
      *(float *)(result + 8) = v8 + *(float *)(result + 8);
      v27 = *(float *)(result + 4) - v8;
      *(float *)(result + 4) = v27;
      if ( v27 == 0.0 )
      {
        *(_DWORD *)(v12 + 8) = 2;
        v28 = sub_42FF30(*(_DWORD **)(a1 + 12));
        v8 = v35;
        *v28 = v12;
        v28[1] = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(a1 + 40) = v28;
      }
      v12 += *i;
    }
    result = *(_DWORD *)(v12 + 8);
  }
  v29 = *(float *)(v12 + 28) + v8;
  v30 = v29 < 0.0;
  v34 = 0;
  v31 = v29 == 0.0;
  v32 = 0;
  v33 = 0;
  *(float *)(v12 + 28) = v29;
  BYTE1(result) = a2;
  if ( v29 == 0.0 )
  {
    *(_DWORD *)(v12 + 8) = 2;
    result = (unsigned int)sub_42FF30(*(_DWORD **)(a1 + 12));
    v8 = v35;
    *(_DWORD *)result = v12;
    *(_DWORD *)(result + 4) = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(a1 + 40) = result;
  }
  *(float *)(a1 + 20) = *(float *)(a1 + 20) + v8;
  return result;
}

//----- (004302B0) --------------------------------------------------------
double __thiscall sub_4302B0(int this)
{
  int v1; // ebx
  _DWORD *v3; // eax
  char v4; // fl
  int v5; // ecx
  unsigned int v6; // edx
  unsigned int v7; // esi
  unsigned int v8; // eax
  unsigned int v9; // ecx
  int v10; // ecx
  int v11; // eax
  _DWORD *v12; // edx
  int v13; // eax
  float *v14; // esi
  float *v15; // edx
  int v16; // eax
  char v17; // cf
  bool v18; // zf
  bool v19; // sf
  char v20; // of
  bool v21; // pf
  int i; // ecx
  _DWORD *v23; // eax
  int *v24; // edx
  int v25; // ecx
  int v26; // esi
  char v27; // cf
  bool v28; // zf
  bool v29; // sf
  char v30; // of
  bool v31; // pf
  int v32; // ecx
  int v33; // eax
  _DWORD *v34; // edx
  int v35; // ecx
  int v36; // eax
  _DWORD *v37; // ebx
  int v38; // esi
  int *v40; // [esp-4h] [ebp-28h]
  unsigned int v41; // [esp+Ch] [ebp-18h]
  int v42; // [esp+Ch] [ebp-18h]
  int v43; // [esp+10h] [ebp-14h]
  float *v44; // [esp+14h] [ebp-10h]
  unsigned int v45; // [esp+18h] [ebp-Ch]
  float *v46; // [esp+1Ch] [ebp-8h]
  int v47; // [esp+20h] [ebp-4h]

  v1 = 0;
  v47 = 0;
  v44 = 0;
  v46 = 0;
  sub_42F970(this);
  sub_430740((_DWORD *)this);
  v3 = operator new(0x10u);
  if ( v3 )
  {
    *(_OWORD *)v3 = 0i64;
    v5 = *(_DWORD *)(this + 16);
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 128;
    v3[3] = v5;
  }
  else
  {
    v3 = 0;
  }
  *(_DWORD *)(this + 12) = v3;
  while ( 1 )
  {
    if ( !v1 || (v18 = *(_DWORD *)(v1 + 8) == 0, *(_DWORD *)(v1 + 12) = 0, v18) )
    {
      v1 = sub_4307F0((_DWORD *)this);
      if ( !v1 )
        break;
    }
    v6 = *(_DWORD *)v1;
    v43 = 0;
    if ( (*(_DWORD *)v1 & 1) != 0 )
    {
      v7 = *(_DWORD *)(v6 + 1);
      v6 += 13;
    }
    else
    {
      v7 = *(_DWORD *)(v1 + 32);
    }
    v8 = *(_DWORD *)(v1 + 4);
    v45 = v8;
    if ( (v8 & 1) != 0 )
    {
      v9 = *(_DWORD *)(v8 + 1);
      v8 += 5;
      v45 = v8;
    }
    else
    {
      v9 = *(_DWORD *)(v1 + 36);
    }
    v41 = v9;
    if ( *(_WORD *)(v1 + 24) )
    {
      if ( v6 >= v7 )
        goto LABEL_67;
      do
      {
        if ( *(float *)(v6 + 8) != 0.0 )
        {
          v32 = v1 + *(_DWORD *)v6;
          if ( *(_DWORD *)(v32 + 8) )
          {
            if ( !*(_WORD *)(v32 + 24) )
            {
              v43 = v1 + *(_DWORD *)v6;
              v10 = v1;
              v44 = (float *)(v6 + 8);
              v8 = v45;
              v15 = (float *)(v6 + 4);
              v47 = v1;
              v46 = v15;
              goto LABEL_68;
            }
            if ( *(_DWORD *)(v32 + 16) <= *(_DWORD *)(v1 + 16) && *(_DWORD *)(v32 + 20) > *(_DWORD *)(v1 + 20) )
            {
              *(_DWORD *)(v32 + 8) = v6 | 1;
              *(_DWORD *)(v32 + 16) = *(_DWORD *)(v1 + 16);
              *(_DWORD *)(v32 + 20) = *(_DWORD *)(v1 + 20) + 1;
            }
          }
          else
          {
            *(_WORD *)(v32 + 24) = 1;
            *(_DWORD *)(v32 + 8) = v6 | 1;
            *(_DWORD *)(v32 + 16) = *(_DWORD *)(v1 + 16);
            v18 = *(_DWORD *)(v32 + 12) == 0;
            *(_DWORD *)(v32 + 20) = *(_DWORD *)(v1 + 20) + 1;
            if ( v18 )
            {
              v33 = *(_DWORD *)(this + 36);
              if ( v33 )
                *(_DWORD *)(v33 + 12) = v32;
              else
                *(_DWORD *)(this + 28) = v32;
              *(_DWORD *)(this + 36) = v32;
              *(_DWORD *)(v32 + 12) = v32;
            }
          }
        }
        v6 += 12;
      }
      while ( v6 < v7 );
      v8 = v45;
LABEL_67:
      v15 = v46;
      v10 = v47;
LABEL_68:
      if ( v8 < v41 )
      {
        do
        {
          v34 = *(_DWORD **)v8;
          if ( *(float *)(*(_DWORD *)v8 + 4) != 0.0 )
          {
            v35 = v1 - *v34;
            if ( *(_DWORD *)(v35 + 8) )
            {
              if ( !*(_WORD *)(v35 + 24) )
              {
                v14 = (float *)(v34 + 1);
                v16 = v1 - *v34;
                v10 = v1;
                v44 = (float *)(v34 + 1);
                v15 = (float *)(v34 + 2);
                v47 = v1;
                v46 = v15;
                goto LABEL_45;
              }
              if ( *(_DWORD *)(v35 + 16) <= *(_DWORD *)(v1 + 16) && *(_DWORD *)(v35 + 20) > *(_DWORD *)(v1 + 20) )
              {
                *(_DWORD *)(v35 + 8) = v34;
                *(_DWORD *)(v35 + 16) = *(_DWORD *)(v1 + 16);
                *(_DWORD *)(v35 + 20) = *(_DWORD *)(v1 + 20) + 1;
              }
            }
            else
            {
              *(_DWORD *)(v35 + 8) = v34;
              *(_WORD *)(v35 + 24) = 1;
              *(_DWORD *)(v35 + 16) = *(_DWORD *)(v1 + 16);
              v18 = *(_DWORD *)(v35 + 12) == 0;
              *(_DWORD *)(v35 + 20) = *(_DWORD *)(v1 + 20) + 1;
              if ( v18 )
              {
                v36 = *(_DWORD *)(this + 36);
                if ( v36 )
                  *(_DWORD *)(v36 + 12) = v35;
                else
                  *(_DWORD *)(this + 28) = v35;
                *(_DWORD *)(this + 36) = v35;
                *(_DWORD *)(v35 + 12) = v35;
              }
            }
          }
          v8 = v45 + 4;
          v45 = v8;
        }
        while ( v8 < v41 );
        goto LABEL_43;
      }
LABEL_44:
      v14 = v44;
      v16 = v43;
      goto LABEL_45;
    }
    if ( v6 >= v7 )
    {
LABEL_29:
      while ( v8 < v41 )
      {
        v12 = *(_DWORD **)v8;
        if ( *(float *)(*(_DWORD *)v8 + 8) != 0.0 )
        {
          v10 = v1 - *v12;
          if ( *(_DWORD *)(v10 + 8) )
          {
            if ( *(_WORD *)(v10 + 24) )
            {
              v14 = (float *)(v12 + 2);
              v47 = v1 - *v12;
              v15 = (float *)(v12 + 1);
              v44 = v14;
              v16 = v1;
              v46 = v15;
              goto LABEL_45;
            }
            if ( *(_DWORD *)(v10 + 16) <= *(_DWORD *)(v1 + 16) && *(_DWORD *)(v10 + 20) > *(_DWORD *)(v1 + 20) )
            {
              *(_DWORD *)(v10 + 8) = v12;
              *(_DWORD *)(v10 + 16) = *(_DWORD *)(v1 + 16);
              *(_DWORD *)(v10 + 20) = *(_DWORD *)(v1 + 20) + 1;
            }
          }
          else
          {
            *(_DWORD *)(v10 + 8) = v12;
            *(_WORD *)(v10 + 24) = 0;
            *(_DWORD *)(v10 + 16) = *(_DWORD *)(v1 + 16);
            v18 = *(_DWORD *)(v10 + 12) == 0;
            *(_DWORD *)(v10 + 20) = *(_DWORD *)(v1 + 20) + 1;
            if ( v18 )
            {
              v13 = *(_DWORD *)(this + 36);
              if ( v13 )
                *(_DWORD *)(v13 + 12) = v10;
              else
                *(_DWORD *)(this + 28) = v10;
              *(_DWORD *)(this + 36) = v10;
              *(_DWORD *)(v10 + 12) = v10;
            }
          }
        }
        v8 = v45 + 4;
        v45 = v8;
      }
LABEL_43:
      v10 = v47;
      v15 = v46;
      goto LABEL_44;
    }
    while ( *(float *)(v6 + 4) == 0.0 )
    {
LABEL_27:
      v6 += 12;
      if ( v6 >= v7 )
      {
        v8 = v45;
        goto LABEL_29;
      }
    }
    v10 = v1 + *(_DWORD *)v6;
    if ( !*(_DWORD *)(v10 + 8) )
    {
      *(_WORD *)(v10 + 24) = 0;
      *(_DWORD *)(v10 + 8) = v6 | 1;
      *(_DWORD *)(v10 + 16) = *(_DWORD *)(v1 + 16);
      v18 = *(_DWORD *)(v10 + 12) == 0;
      *(_DWORD *)(v10 + 20) = *(_DWORD *)(v1 + 20) + 1;
      if ( v18 )
      {
        v11 = *(_DWORD *)(this + 36);
        if ( v11 )
          *(_DWORD *)(v11 + 12) = v10;
        else
          *(_DWORD *)(this + 28) = v10;
        *(_DWORD *)(this + 36) = v10;
        *(_DWORD *)(v10 + 12) = v10;
      }
      goto LABEL_27;
    }
    if ( !*(_WORD *)(v10 + 24) )
    {
      if ( *(_DWORD *)(v10 + 16) <= *(_DWORD *)(v1 + 16) && *(_DWORD *)(v10 + 20) > *(_DWORD *)(v1 + 20) )
      {
        *(_DWORD *)(v10 + 8) = v6 | 1;
        *(_DWORD *)(v10 + 16) = *(_DWORD *)(v1 + 16);
        *(_DWORD *)(v10 + 20) = *(_DWORD *)(v1 + 20) + 1;
      }
      goto LABEL_27;
    }
    v14 = (float *)(v6 + 4);
    v47 = v1 + *(_DWORD *)v6;
    v15 = (float *)(v6 + 8);
    v44 = v14;
    v16 = v1;
    v46 = v15;
LABEL_45:
    ++*(_DWORD *)(this + 48);
    v17 = 0;
    v20 = 0;
    v18 = v16 == 0;
    v21 = __SETP__(v16, 0);
    v19 = v16 < 0;
    if ( v16 )
    {
      *(_DWORD *)(v1 + 12) = v1;
      sub_42FFB0(this, v4, v16, v10, v14, v15);
      for ( i = *(_DWORD *)(this + 40); i; *(_DWORD *)(this + 40) = i )
      {
        v23 = (_DWORD *)(i + 4);
        i = *(_DWORD *)(i + 4);
        *v23 = 0;
        v24 = *(int **)(this + 40);
        v42 = i;
        if ( v24 )
        {
          do
          {
            v25 = *(_DWORD *)(this + 12);
            *(_DWORD *)(this + 40) = v24[1];
            v26 = *v24;
            *v24 = *(_DWORD *)(v25 + 8);
            *(_DWORD *)(v25 + 8) = v24;
            if ( !*(_DWORD *)(this + 40) )
              *(_DWORD *)(this + 44) = 0;
            v27 = 0;
            v30 = 0;
            v28 = *(_WORD *)(v26 + 24) == 0;
            v31 = __SETP__(*(_WORD *)(v26 + 24), 0);
            v29 = *(__int16 *)(v26 + 24) < 0;
            if ( *(_WORD *)(v26 + 24) )
              sub_430850(this, v4, (_DWORD *)v26);
            else
              sub_430BD0(this, v4, (_DWORD *)v26);
            v24 = *(int **)(this + 40);
          }
          while ( v24 );
          i = v42;
        }
      }
    }
    else
    {
      v1 = 0;
    }
  }
  v37 = *(_DWORD **)(this + 12);
  if ( v37 )
  {
    if ( v37[1] )
    {
      do
      {
        v40 = (int *)v37[1];
        v38 = *v40;
        operator delete(v40);
        v37[1] = v38;
      }
      while ( v38 );
    }
    operator delete(v37);
  }
  return *(float *)(this + 20);
}

//----- (00430740) --------------------------------------------------------
void __thiscall sub_430740(_DWORD *this)
{
  _DWORD *v1; // esi
  float *v2; // eax
  float v3; // xmm0_4
  int v4; // edx

  v1 = (_DWORD *)*this;
  this[8] = 0;
  this[6] = 0;
  this[9] = 0;
  this[7] = 0;
  this[10] = 0;
  if ( v1 )
  {
    while ( 1 )
    {
      v2 = (float *)(v1 + 2);
      if ( (unsigned int)(v1 + 2) < *v1 )
        break;
LABEL_13:
      v1 = (_DWORD *)v1[1];
      if ( !v1 )
        goto LABEL_14;
    }
    while ( 1 )
    {
      v3 = v2[7];
      v2[3] = 0.0;
      v2[4] = 0.0;
      if ( v3 > 0.0 )
        break;
      if ( v3 < 0.0 )
      {
        *((_WORD *)v2 + 12) = 1;
        goto LABEL_7;
      }
      v2[2] = 0.0;
LABEL_12:
      v2 += 8;
      if ( (unsigned int)v2 >= *v1 )
        goto LABEL_13;
    }
    *((_WORD *)v2 + 12) = 0;
LABEL_7:
    *((_DWORD *)v2 + 2) = 1;
    v4 = this[9];
    if ( v4 )
      *(_DWORD *)(v4 + 12) = v2;
    else
      this[7] = v2;
    this[9] = v2;
    *((_DWORD *)v2 + 3) = v2;
    v2[4] = 0.0;
    *((_DWORD *)v2 + 5) = 1;
    goto LABEL_12;
  }
LABEL_14:
  this[12] = 0;
}

//----- (004307F0) --------------------------------------------------------
int __thiscall sub_4307F0(_DWORD *this)
{
  int result; // eax
  int v3; // ecx
  int v4; // ecx
  bool v5; // zf

  while ( 1 )
  {
    result = this[6];
    if ( !result )
    {
      result = this[7];
      v3 = this[9];
      this[6] = result;
      this[8] = v3;
      this[7] = 0;
      this[9] = 0;
      if ( !result )
        break;
    }
    v4 = *(_DWORD *)(result + 12);
    if ( v4 == result )
    {
      this[8] = 0;
      this[6] = 0;
    }
    else
    {
      this[6] = v4;
    }
    v5 = *(_DWORD *)(result + 8) == 0;
    *(_DWORD *)(result + 12) = 0;
    if ( !v5 )
      return result;
  }
  return 0;
}

//----- (00430850) --------------------------------------------------------
float *__userpurge sub_430850@<eax>(int a1@<ecx>, char a2@<efl>, _DWORD *a3)
{
  _DWORD *v4; // ecx
  int v5; // esi
  unsigned int v6; // eax
  unsigned int v7; // ebx
  _DWORD *v8; // edx
  unsigned int v9; // ebx
  unsigned int v10; // ebx
  char *v11; // eax
  int v12; // esi
  int v13; // edx
  unsigned int v14; // ecx
  _DWORD *v15; // ecx
  unsigned int v16; // eax
  float *result; // eax
  unsigned int v18; // ebx
  char *v19; // eax
  int v20; // esi
  int v21; // edx
  unsigned int v22; // ecx
  _DWORD *v23; // ecx
  unsigned int v24; // eax
  float *v25; // edx
  unsigned int v26; // ebx
  char *v27; // esi
  int v28; // ecx
  float v29; // xmm0_4
  bool v30; // cf
  bool v31; // zf
  char v32; // sf
  char v33; // of
  char v34; // pf
  int v35; // ecx
  float **v36; // ebx
  char *v37; // esi
  _DWORD *v38; // ecx
  float v39; // xmm0_4
  int v40; // ecx
  unsigned int v41; // [esp+Ch] [ebp-1Ch]
  float *v42; // [esp+10h] [ebp-18h]
  _DWORD **v43; // [esp+14h] [ebp-14h]
  int v44; // [esp+18h] [ebp-10h]
  unsigned int v45; // [esp+1Ch] [ebp-Ch]
  unsigned int v46; // [esp+20h] [ebp-8h]
  int v47; // [esp+24h] [ebp-4h]

  v47 = 1000000000;
  v4 = a3;
  v5 = 0;
  v44 = 0;
  v6 = *a3;
  v41 = *a3;
  if ( (*a3 & 1) != 0 )
  {
    v7 = *(_DWORD *)(v6 + 1);
    v6 += 13;
    v46 = v7;
    v41 = v6;
  }
  else
  {
    v46 = a3[8];
  }
  v8 = (_DWORD *)a3[1];
  v43 = (_DWORD **)v8;
  if ( ((unsigned __int8)v8 & 1) != 0 )
  {
    v9 = *(_DWORD *)((char *)v8 + 1);
    v8 = (_DWORD *)((char *)v8 + 5);
    v43 = (_DWORD **)v8;
  }
  else
  {
    v9 = a3[9];
  }
  v45 = v9;
  v10 = v6;
  if ( v6 < v46 )
  {
    do
    {
      if ( *(float *)(v10 + 4) != 0.0 )
      {
        v11 = (char *)v4 + *(_DWORD *)v10;
        if ( *((_WORD *)v11 + 12) )
        {
          if ( *((_DWORD *)v11 + 2) )
          {
            v12 = *(_DWORD *)(a1 + 48);
            v13 = 0;
            if ( *((_DWORD *)v11 + 4) == v12 )
            {
LABEL_18:
              v13 += *((_DWORD *)v11 + 5);
            }
            else
            {
              while ( 1 )
              {
                v14 = *((_DWORD *)v11 + 2);
                ++v13;
                if ( v14 == 1 )
                  break;
                if ( v14 == 2 )
                  goto LABEL_28;
                if ( (v14 & 1) != 0 )
                  v11 -= *(_DWORD *)(v14 & 0xFFFFFFFE);
                else
                  v11 += *(_DWORD *)v14;
                if ( *((_DWORD *)v11 + 4) == v12 )
                  goto LABEL_18;
              }
              *((_DWORD *)v11 + 4) = v12;
              *((_DWORD *)v11 + 5) = 1;
            }
            if ( v13 < 1000000000 )
            {
              if ( v13 < v47 )
              {
                v44 = v10;
                v47 = v13;
              }
              v15 = (_DWORD *)((char *)a3 + *(_DWORD *)v10);
              while ( v15[4] != *(_DWORD *)(a1 + 48) )
              {
                v15[4] = *(_DWORD *)(a1 + 48);
                v16 = v15[2];
                v15[5] = v13--;
                if ( (v16 & 1) != 0 )
                  v15 = (_DWORD *)((char *)v15 - *(_DWORD *)(v16 & 0xFFFFFFFE));
                else
                  v15 = (_DWORD *)((char *)v15 + *(_DWORD *)v16);
              }
            }
LABEL_28:
            v4 = a3;
          }
        }
      }
      v10 += 12;
    }
    while ( v10 < v46 );
    v8 = v43;
    v5 = v44;
  }
  result = (float *)v8;
  v42 = (float *)v8;
  if ( (unsigned int)v8 < v45 )
  {
    do
    {
      v18 = *(_DWORD *)result;
      if ( *(float *)(*(_DWORD *)result + 8) != 0.0 )
      {
        v19 = (char *)v4 - *(_DWORD *)v18;
        if ( *((_WORD *)v19 + 12) )
        {
          if ( *((_DWORD *)v19 + 2) )
          {
            v20 = *(_DWORD *)(a1 + 48);
            v21 = 0;
            if ( *((_DWORD *)v19 + 4) == v20 )
            {
LABEL_42:
              v21 += *((_DWORD *)v19 + 5);
            }
            else
            {
              while ( 1 )
              {
                v22 = *((_DWORD *)v19 + 2);
                ++v21;
                if ( v22 == 1 )
                  break;
                if ( v22 == 2 )
                  goto LABEL_52;
                if ( (v22 & 1) != 0 )
                  v19 -= *(_DWORD *)(v22 & 0xFFFFFFFE);
                else
                  v19 += *(_DWORD *)v22;
                if ( *((_DWORD *)v19 + 4) == v20 )
                  goto LABEL_42;
              }
              *((_DWORD *)v19 + 4) = v20;
              *((_DWORD *)v19 + 5) = 1;
            }
            if ( v21 < 1000000000 )
            {
              if ( v21 < v47 )
              {
                v47 = v21;
                v44 = v18 | 1;
              }
              v23 = (_DWORD *)((char *)a3 - *(_DWORD *)v18);
              while ( v23[4] != *(_DWORD *)(a1 + 48) )
              {
                v23[4] = *(_DWORD *)(a1 + 48);
                v24 = v23[2];
                v23[5] = v21--;
                if ( (v24 & 1) != 0 )
                  v23 = (_DWORD *)((char *)v23 - *(_DWORD *)(v24 & 0xFFFFFFFE));
                else
                  v23 = (_DWORD *)((char *)v23 + *(_DWORD *)v24);
              }
            }
          }
        }
      }
LABEL_52:
      v4 = a3;
      result = v42 + 1;
      v42 = result;
    }
    while ( (unsigned int)result < v45 );
    v5 = v44;
  }
  v25 = (float *)a3;
  a3[2] = v5;
  if ( v5 )
  {
    a3[4] = *(_DWORD *)(a1 + 48);
    result = (float *)(v47 + 1);
    a3[5] = v47 + 1;
  }
  else
  {
    v26 = v41;
    for ( a3[4] = 0; v26 < v46; v26 += 12 )
    {
      v27 = (char *)v25 + *(_DWORD *)v26;
      if ( *((_WORD *)v27 + 12) )
      {
        v28 = *((_DWORD *)v27 + 2);
        if ( v28 )
        {
          v29 = *(float *)(v26 + 4);
          v30 = v29 < 0.0;
          v34 = 0;
          v31 = v29 == 0.0;
          v32 = 0;
          v33 = 0;
          BYTE1(result) = a2;
          if ( v29 != 0.0 && !*((_DWORD *)v27 + 3) )
          {
            result = *(float **)(a1 + 36);
            if ( result )
              *((_DWORD *)result + 3) = v27;
            else
              *(_DWORD *)(a1 + 28) = v27;
            *(_DWORD *)(a1 + 36) = v27;
            *((_DWORD *)v27 + 3) = v27;
          }
          if ( v28 != 1 && v28 != 2 && (v28 & 1) != 0 )
          {
            result = (float *)&v27[-*(_DWORD *)(v28 & 0xFFFFFFFE)];
            if ( result == v25 )
            {
              *((_DWORD *)v27 + 2) = 2;
              result = (float *)sub_42FF30(*(_DWORD **)(a1 + 12));
              *(_DWORD *)result = v27;
              v35 = *(_DWORD *)(a1 + 44);
              if ( v35 )
                *(_DWORD *)(v35 + 4) = result;
              else
                *(_DWORD *)(a1 + 40) = result;
              v25 = (float *)a3;
              *(_DWORD *)(a1 + 44) = result;
              result[1] = 0.0;
            }
          }
        }
      }
    }
    v36 = (float **)v43;
    if ( (unsigned int)v43 < v45 )
    {
      do
      {
        result = *v36;
        v37 = (char *)v25 - *(_DWORD *)*v36;
        if ( *((_WORD *)v37 + 12) )
        {
          v38 = (_DWORD *)*((_DWORD *)v37 + 2);
          if ( v38 )
          {
            v39 = result[2];
            v30 = v39 < 0.0;
            v34 = 0;
            v31 = v39 == 0.0;
            v32 = 0;
            v33 = 0;
            BYTE1(result) = a2;
            if ( v39 != 0.0 && !*((_DWORD *)v37 + 3) )
            {
              result = *(float **)(a1 + 36);
              if ( result )
                *((_DWORD *)result + 3) = v37;
              else
                *(_DWORD *)(a1 + 28) = v37;
              *(_DWORD *)(a1 + 36) = v37;
              *((_DWORD *)v37 + 3) = v37;
            }
            if ( v38 != (_DWORD *)1 && v38 != (_DWORD *)2 && ((unsigned __int8)v38 & 1) == 0 )
            {
              result = (float *)&v37[*v38];
              if ( result == v25 )
              {
                *((_DWORD *)v37 + 2) = 2;
                result = (float *)sub_42FF30(*(_DWORD **)(a1 + 12));
                *(_DWORD *)result = v37;
                v40 = *(_DWORD *)(a1 + 44);
                if ( v40 )
                  *(_DWORD *)(v40 + 4) = result;
                else
                  *(_DWORD *)(a1 + 40) = result;
                v25 = (float *)a3;
                *(_DWORD *)(a1 + 44) = result;
                result[1] = 0.0;
              }
            }
          }
        }
        ++v36;
      }
      while ( (unsigned int)v36 < v45 );
    }
  }
  return result;
}

//----- (00430BD0) --------------------------------------------------------
float *__userpurge sub_430BD0@<eax>(int a1@<ecx>, char a2@<efl>, _DWORD *a3)
{
  _DWORD *v4; // ecx
  int v5; // esi
  unsigned int v6; // eax
  unsigned int v7; // ebx
  _DWORD *v8; // edx
  unsigned int v9; // ebx
  unsigned int v10; // ebx
  char *v11; // eax
  int v12; // esi
  int v13; // edx
  unsigned int v14; // ecx
  _DWORD *v15; // ecx
  unsigned int v16; // eax
  float *result; // eax
  unsigned int v18; // ebx
  char *v19; // eax
  int v20; // esi
  int v21; // edx
  unsigned int v22; // ecx
  _DWORD *v23; // ecx
  unsigned int v24; // eax
  float *v25; // edx
  unsigned int v26; // ebx
  char *v27; // esi
  int v28; // ecx
  float v29; // xmm0_4
  bool v30; // cf
  bool v31; // zf
  char v32; // sf
  char v33; // of
  char v34; // pf
  int v35; // ecx
  float **v36; // ebx
  char *v37; // esi
  _DWORD *v38; // ecx
  float v39; // xmm0_4
  int v40; // ecx
  unsigned int v41; // [esp+Ch] [ebp-1Ch]
  float *v42; // [esp+10h] [ebp-18h]
  _DWORD **v43; // [esp+14h] [ebp-14h]
  int v44; // [esp+18h] [ebp-10h]
  unsigned int v45; // [esp+1Ch] [ebp-Ch]
  unsigned int v46; // [esp+20h] [ebp-8h]
  int v47; // [esp+24h] [ebp-4h]

  v47 = 1000000000;
  v4 = a3;
  v5 = 0;
  v44 = 0;
  v6 = *a3;
  v41 = *a3;
  if ( (*a3 & 1) != 0 )
  {
    v7 = *(_DWORD *)(v6 + 1);
    v6 += 13;
    v46 = v7;
    v41 = v6;
  }
  else
  {
    v46 = a3[8];
  }
  v8 = (_DWORD *)a3[1];
  v43 = (_DWORD **)v8;
  if ( ((unsigned __int8)v8 & 1) != 0 )
  {
    v9 = *(_DWORD *)((char *)v8 + 1);
    v8 = (_DWORD *)((char *)v8 + 5);
    v43 = (_DWORD **)v8;
  }
  else
  {
    v9 = a3[9];
  }
  v45 = v9;
  v10 = v6;
  if ( v6 < v46 )
  {
    do
    {
      if ( *(float *)(v10 + 8) != 0.0 )
      {
        v11 = (char *)v4 + *(_DWORD *)v10;
        if ( !*((_WORD *)v11 + 12) )
        {
          if ( *((_DWORD *)v11 + 2) )
          {
            v12 = *(_DWORD *)(a1 + 48);
            v13 = 0;
            if ( *((_DWORD *)v11 + 4) == v12 )
            {
LABEL_18:
              v13 += *((_DWORD *)v11 + 5);
            }
            else
            {
              while ( 1 )
              {
                v14 = *((_DWORD *)v11 + 2);
                ++v13;
                if ( v14 == 1 )
                  break;
                if ( v14 == 2 )
                  goto LABEL_28;
                if ( (v14 & 1) != 0 )
                  v11 -= *(_DWORD *)(v14 & 0xFFFFFFFE);
                else
                  v11 += *(_DWORD *)v14;
                if ( *((_DWORD *)v11 + 4) == v12 )
                  goto LABEL_18;
              }
              *((_DWORD *)v11 + 4) = v12;
              *((_DWORD *)v11 + 5) = 1;
            }
            if ( v13 < 1000000000 )
            {
              if ( v13 < v47 )
              {
                v44 = v10;
                v47 = v13;
              }
              v15 = (_DWORD *)((char *)a3 + *(_DWORD *)v10);
              while ( v15[4] != *(_DWORD *)(a1 + 48) )
              {
                v15[4] = *(_DWORD *)(a1 + 48);
                v16 = v15[2];
                v15[5] = v13--;
                if ( (v16 & 1) != 0 )
                  v15 = (_DWORD *)((char *)v15 - *(_DWORD *)(v16 & 0xFFFFFFFE));
                else
                  v15 = (_DWORD *)((char *)v15 + *(_DWORD *)v16);
              }
            }
LABEL_28:
            v4 = a3;
          }
        }
      }
      v10 += 12;
    }
    while ( v10 < v46 );
    v8 = v43;
    v5 = v44;
  }
  result = (float *)v8;
  v42 = (float *)v8;
  if ( (unsigned int)v8 < v45 )
  {
    do
    {
      v18 = *(_DWORD *)result;
      if ( *(float *)(*(_DWORD *)result + 4) != 0.0 )
      {
        v19 = (char *)v4 - *(_DWORD *)v18;
        if ( !*((_WORD *)v19 + 12) )
        {
          if ( *((_DWORD *)v19 + 2) )
          {
            v20 = *(_DWORD *)(a1 + 48);
            v21 = 0;
            if ( *((_DWORD *)v19 + 4) == v20 )
            {
LABEL_42:
              v21 += *((_DWORD *)v19 + 5);
            }
            else
            {
              while ( 1 )
              {
                v22 = *((_DWORD *)v19 + 2);
                ++v21;
                if ( v22 == 1 )
                  break;
                if ( v22 == 2 )
                  goto LABEL_52;
                if ( (v22 & 1) != 0 )
                  v19 -= *(_DWORD *)(v22 & 0xFFFFFFFE);
                else
                  v19 += *(_DWORD *)v22;
                if ( *((_DWORD *)v19 + 4) == v20 )
                  goto LABEL_42;
              }
              *((_DWORD *)v19 + 4) = v20;
              *((_DWORD *)v19 + 5) = 1;
            }
            if ( v21 < 1000000000 )
            {
              if ( v21 < v47 )
              {
                v47 = v21;
                v44 = v18 | 1;
              }
              v23 = (_DWORD *)((char *)a3 - *(_DWORD *)v18);
              while ( v23[4] != *(_DWORD *)(a1 + 48) )
              {
                v23[4] = *(_DWORD *)(a1 + 48);
                v24 = v23[2];
                v23[5] = v21--;
                if ( (v24 & 1) != 0 )
                  v23 = (_DWORD *)((char *)v23 - *(_DWORD *)(v24 & 0xFFFFFFFE));
                else
                  v23 = (_DWORD *)((char *)v23 + *(_DWORD *)v24);
              }
            }
          }
        }
      }
LABEL_52:
      v4 = a3;
      result = v42 + 1;
      v42 = result;
    }
    while ( (unsigned int)result < v45 );
    v5 = v44;
  }
  v25 = (float *)a3;
  a3[2] = v5;
  if ( v5 )
  {
    a3[4] = *(_DWORD *)(a1 + 48);
    result = (float *)(v47 + 1);
    a3[5] = v47 + 1;
  }
  else
  {
    v26 = v41;
    for ( a3[4] = 0; v26 < v46; v26 += 12 )
    {
      v27 = (char *)v25 + *(_DWORD *)v26;
      if ( !*((_WORD *)v27 + 12) )
      {
        v28 = *((_DWORD *)v27 + 2);
        if ( v28 )
        {
          v29 = *(float *)(v26 + 8);
          v30 = v29 < 0.0;
          v34 = 0;
          v31 = v29 == 0.0;
          v32 = 0;
          v33 = 0;
          BYTE1(result) = a2;
          if ( v29 != 0.0 && !*((_DWORD *)v27 + 3) )
          {
            result = *(float **)(a1 + 36);
            if ( result )
              *((_DWORD *)result + 3) = v27;
            else
              *(_DWORD *)(a1 + 28) = v27;
            *(_DWORD *)(a1 + 36) = v27;
            *((_DWORD *)v27 + 3) = v27;
          }
          if ( v28 != 1 && v28 != 2 && (v28 & 1) != 0 )
          {
            result = (float *)&v27[-*(_DWORD *)(v28 & 0xFFFFFFFE)];
            if ( result == v25 )
            {
              *((_DWORD *)v27 + 2) = 2;
              result = (float *)sub_42FF30(*(_DWORD **)(a1 + 12));
              *(_DWORD *)result = v27;
              v35 = *(_DWORD *)(a1 + 44);
              if ( v35 )
                *(_DWORD *)(v35 + 4) = result;
              else
                *(_DWORD *)(a1 + 40) = result;
              v25 = (float *)a3;
              *(_DWORD *)(a1 + 44) = result;
              result[1] = 0.0;
            }
          }
        }
      }
    }
    v36 = (float **)v43;
    if ( (unsigned int)v43 < v45 )
    {
      do
      {
        result = *v36;
        v37 = (char *)v25 - *(_DWORD *)*v36;
        if ( !*((_WORD *)v37 + 12) )
        {
          v38 = (_DWORD *)*((_DWORD *)v37 + 2);
          if ( v38 )
          {
            v39 = result[1];
            v30 = v39 < 0.0;
            v34 = 0;
            v31 = v39 == 0.0;
            v32 = 0;
            v33 = 0;
            BYTE1(result) = a2;
            if ( v39 != 0.0 && !*((_DWORD *)v37 + 3) )
            {
              result = *(float **)(a1 + 36);
              if ( result )
                *((_DWORD *)result + 3) = v37;
              else
                *(_DWORD *)(a1 + 28) = v37;
              *(_DWORD *)(a1 + 36) = v37;
              *((_DWORD *)v37 + 3) = v37;
            }
            if ( v38 != (_DWORD *)1 && v38 != (_DWORD *)2 && ((unsigned __int8)v38 & 1) == 0 )
            {
              result = (float *)&v37[*v38];
              if ( result == v25 )
              {
                *((_DWORD *)v37 + 2) = 2;
                result = (float *)sub_42FF30(*(_DWORD **)(a1 + 12));
                *(_DWORD *)result = v37;
                v40 = *(_DWORD *)(a1 + 44);
                if ( v40 )
                  *(_DWORD *)(v40 + 4) = result;
                else
                  *(_DWORD *)(a1 + 40) = result;
                v25 = (float *)a3;
                *(_DWORD *)(a1 + 44) = result;
                result[1] = 0.0;
              }
            }
          }
        }
        ++v36;
      }
      while ( (unsigned int)v36 < v45 );
    }
  }
  return result;
}

//----- (00430F50) --------------------------------------------------------
BOOL __stdcall sub_430F50(int a1)
{
  return !*(_DWORD *)(a1 + 8) || *(_WORD *)(a1 + 24);
}

//----- (00430F80) --------------------------------------------------------
_DWORD *__thiscall sub_430F80(_DWORD *this, int a2, int a3, _DWORD *a4)
{
  _DWORD *result; // eax

  this[4] = a3;
  this[3] = a2;
  *this = &MRF::`vftable';
  *((_BYTE *)this + 20) = 0;
  this[7] = *(_DWORD *)(*a4 + 8);
  this[8] = *(_DWORD *)(a4[1] + 16);
  *((_BYTE *)this + 21) = *(_BYTE *)(a4[1] + 32);
  result = this;
  *((_BYTE *)this + 22) = 0;
  this[6] = a4;
  *((_BYTE *)this + 36) = 1;
  return result;
}
// 43A38C: using guessed type void *MRF::`vftable';

//----- (00430FD0) --------------------------------------------------------
_DWORD *__thiscall sub_430FD0(_DWORD *this, int a2)
{
  _DWORD *result; // eax
  int v3; // esi
  int v4; // edi
  int v5; // ecx
  int v6; // ebx
  float *v7; // edx
  FILE *v8; // eax
  int v10; // [esp+Ch] [ebp-4h]

  result = this;
  v3 = 0;
  v4 = this[4];
  v10 = v4;
  if ( v4 > 0 )
  {
    do
    {
      v5 = v3;
      if ( v3 < v4 )
      {
        v6 = result[4];
        v7 = (float *)(a2 + 4 * v3 * (v6 + 1));
        do
        {
          v4 = v10;
          if ( *v7 != *(float *)(a2 + 4 * (v3 + v5 * v6)) )
          {
            v8 = _iob_func();
            fprintf(v8 + 2, "Error in setSmoothness(): V is not symmetric!\n");
            exit(1);
          }
          ++v5;
          ++v7;
        }
        while ( v5 < v10 );
        result = this;
      }
      ++v3;
    }
    while ( v3 < v4 );
  }
  return result;
}

//----- (00431060) --------------------------------------------------------
char __thiscall sub_431060(_BYTE *this)
{
  FILE *v1; // eax

  if ( !this[22] )
  {
    v1 = _iob_func();
    fprintf(v1 + 2, "Call initialize() first,exiting!");
    exit(1);
  }
  return 2;
}

//----- (00431090) --------------------------------------------------------
int __thiscall sub_431090(int *this)
{
  bool v2; // zf
  _DWORD *v3; // eax
  int v4; // edx
  _DWORD *v5; // eax
  int v6; // eax
  int v7; // eax
  _DWORD *v8; // edx
  int v9; // ecx
  FILE *v10; // eax
  int v11; // ecx
  const char *v13; // [esp+8h] [ebp-8h]

  v2 = this[7] == 1;
  v3 = (_DWORD *)this[6];
  v4 = *this;
  *((_BYTE *)this + 22) = 1;
  v5 = (_DWORD *)*v3;
  if ( v2 )
    (*(void (__stdcall **)(_DWORD))(v4 + 52))(*v5);
  else
    (*(void (__stdcall **)(_DWORD))(v4 + 56))(v5[1]);
  v6 = this[8];
  if ( v6 )
  {
    v2 = v6 == 1;
    v7 = this[6];
    if ( v2 )
    {
      sub_430FD0(this, **(_DWORD **)(v7 + 4));
      (*(void (__thiscall **)(int *, _DWORD))(*this + 68))(this, **(_DWORD **)(this[6] + 4));
    }
    else
    {
      v8 = *(_DWORD **)(v7 + 4);
      v9 = v8[5];
      if ( v9 != 1 && v9 != 2 )
      {
        v13 = "Wrong exponent in setSmoothness()!\n";
        goto LABEL_11;
      }
      (*(void (__thiscall **)(int *, int, _DWORD, _DWORD))(*this + 60))(this, v9, v8[6], v8[7]);
    }
    v11 = *(_DWORD *)(this[6] + 4);
    if ( !*(_BYTE *)(v11 + 32) )
      return (*(int (__thiscall **)(int *))(*this + 76))(this);
    if ( *((_BYTE *)this + 20) )
    {
      (*(void (__thiscall **)(int *, _DWORD, _DWORD))(*this + 72))(this, *(_DWORD *)(v11 + 4), *(_DWORD *)(v11 + 8));
      return (*(int (__thiscall **)(int *))(*this + 76))(this);
    }
    v13 = "Edge multiplier cannot be used with non-grid graphs\n";
LABEL_11:
    v10 = _iob_func();
    fprintf(v10 + 2, v13);
    exit(1);
  }
  (*(void (__thiscall **)(int *, _DWORD))(*this + 64))(this, *(_DWORD *)(*(_DWORD *)(this[6] + 4) + 12));
  return (*(int (__thiscall **)(int *))(*this + 76))(this);
}

//----- (00431170) --------------------------------------------------------
float *__thiscall sub_431170(_BYTE *this, int a2, float *a3)
{
  FILE *v4; // eax
  clock_t v5; // edi
  double v6; // xmm0_8
  float *result; // eax
  const char *v8; // [esp-4h] [ebp-Ch]

  if ( !(*(int (__thiscall **)(_BYTE *))(*(_DWORD *)this + 4))(this) )
  {
    v8 = "optimize() cannot be called for invalid energy!\n";
    goto LABEL_3;
  }
  if ( !this[22] )
  {
    v8 = "run initialize() first!\n";
LABEL_3:
    v4 = _iob_func();
    fprintf(v4 + 2, v8);
    exit(1);
  }
  v5 = clock();
  (*(void (__thiscall **)(_BYTE *, int))(*(_DWORD *)this + 20))(this, a2);
  v6 = (double)(clock() - v5);
  result = a3;
  *a3 = v6 / 1000.0;
  return result;
}

//----- (004311F0) --------------------------------------------------------
double __thiscall sub_4311F0(_BYTE *this)
{
  FILE *v2; // eax
  const char *v4; // [esp-4h] [ebp-Ch]
  float v5; // [esp+4h] [ebp-4h]

  if ( !(*(int (__thiscall **)(_BYTE *))(*(_DWORD *)this + 4))(this) )
  {
    v4 = "totalEnergy() cannot be called for invalid energy!\n";
    goto LABEL_3;
  }
  if ( !this[22] )
  {
    v4 = "Call initialize() first!\n";
LABEL_3:
    v2 = _iob_func();
    fprintf(v2 + 2, v4);
    exit(1);
  }
  v5 = ((double (__thiscall *)(_BYTE *))*(_DWORD *)(*(_DWORD *)this + 12))(this);
  return ((double (__thiscall *)(_BYTE *))*(_DWORD *)(*(_DWORD *)this + 8))(this) + v5;
}

//----- (00431250) --------------------------------------------------------
void __thiscall sub_431250(_DWORD *this)
{
  int v2; // esi
  int v3; // eax
  __m128i v4; // [esp+Ch] [ebp-10h] BYREF

  *this = &TdCParagraph::`vftable';
  this[21] = &DwCTwoDimArray<float>::`vftable';
  this[22] = 0;
  this[23] = 0;
  this[25] = 0;
  this[24] = 0;
  this[26] = 0;
  this[27] = 0;
  this[28] = 0;
  this[29] = 0;
  this[30] = &DwCTwoDimArray<int>::`vftable';
  this[31] = 0;
  this[32] = 0;
  this[34] = 0;
  this[33] = 0;
  this[35] = 0;
  this[36] = 0;
  this[37] = 0;
  this[38] = 0;
  this[9] = 0;
  this[10] = 0;
  this[8] = 0;
  this[5] = 0;
  this[3] = 0;
  this[2] = 0;
  *((_BYTE *)this + 80) = 1;
  v4 = (__m128i)COERCE_UNSIGNED_INT64((double)(rand() % 128));
  v2 = rand() % 128;
  v3 = rand() % 128;
  *((__m128d *)this + 3) = _mm_unpacklo_pd((__m128d)_mm_loadu_si128(&v4), (__m128d)COERCE_UNSIGNED_INT64((double)v2));
  *((__m128d *)this + 4) = _mm_unpacklo_pd((__m128d)COERCE_UNSIGNED_INT64((double)v3), (__m128d)0i64);
}
// 43A178: using guessed type void *DwCTwoDimArray<float>::`vftable';
// 43A73C: using guessed type void *DwCTwoDimArray<int>::`vftable';
// 43A744: using guessed type void *TdCParagraph::`vftable';

//----- (004313A0) --------------------------------------------------------
void __thiscall sub_4313A0(_DWORD *this)
{
  int v2; // esi
  int v3; // eax
  __m128d v4; // xmm3
  __m128i v5; // [esp+Ch] [ebp-10h] BYREF

  *this = &TdCTextLine::`vftable';
  sub_42BD70(this + 12);
  this[2] = 0;
  v5 = (__m128i)COERCE_UNSIGNED_INT64((double)(rand() % 128 + 64));
  v2 = rand() % 128;
  v3 = rand() % 128;
  v4 = (__m128d)_mm_loadu_si128(&v5);
  *((_BYTE *)this + 960) = 1;
  *((__m128d *)this + 1) = _mm_unpacklo_pd(v4, (__m128d)COERCE_UNSIGNED_INT64((double)(v2 + 64)));
  *((__m128d *)this + 2) = _mm_unpacklo_pd((__m128d)COERCE_UNSIGNED_INT64((double)(v3 + 64)), (__m128d)0i64);
}
// 43A734: using guessed type void *TdCTextLine::`vftable';

//----- (00431480) --------------------------------------------------------
void __thiscall sub_431480(void *this)
{
  int v2; // ecx
  int v3; // esi
  int v4; // ebx
  _DWORD *v5; // ecx
  _DWORD *v6; // esi
  void **v7; // ebx
  _DWORD *v8; // ecx
  _DWORD *v9; // esi
  void (__thiscall ***v10)(_DWORD, int); // ecx
  void *v11; // eax
  void *v12; // eax
  int v13; // [esp+14h] [ebp-14h]
  int v14; // [esp+18h] [ebp-10h]

  *(_DWORD *)this = &TdCParagraph::`vftable';
  v2 = 0;
  v13 = 0;
  if ( *((int *)this + 2) > 0 )
  {
    v3 = 0;
    v14 = 0;
    do
    {
      v4 = *(_DWORD *)(v3 + *((_DWORD *)this + 5) + 8);
      if ( v4 )
      {
        v5 = **(_DWORD ***)v4;
        **(_DWORD **)v4 = *(_DWORD *)v4;
        *(_DWORD *)(*(_DWORD *)v4 + 4) = *(_DWORD *)v4;
        *(_DWORD *)(v4 + 4) = 0;
        if ( v5 != *(_DWORD **)v4 )
        {
          do
          {
            v6 = (_DWORD *)*v5;
            operator delete(v5);
            v5 = v6;
          }
          while ( v6 != *(_DWORD **)v4 );
          v3 = v14;
        }
        v7 = *(void ***)(v3 + *((_DWORD *)this + 5) + 8);
        if ( v7 )
        {
          v8 = *(_DWORD **)*v7;
          *(_DWORD *)*v7 = *v7;
          *((_DWORD *)*v7 + 1) = *v7;
          v7[1] = 0;
          if ( v8 != *v7 )
          {
            do
            {
              v9 = (_DWORD *)*v8;
              operator delete(v8);
              v8 = v9;
            }
            while ( v9 != *v7 );
            v3 = v14;
          }
          operator delete(*v7);
          operator delete(v7);
        }
        v2 = v13;
        *(_DWORD *)(v3 + *((_DWORD *)this + 5) + 8) = 0;
      }
      ++v2;
      v3 += 984;
      v13 = v2;
      v14 = v3;
    }
    while ( v2 < *((_DWORD *)this + 2) );
  }
  v10 = (void (__thiscall ***)(_DWORD, int))*((_DWORD *)this + 5);
  if ( v10 )
  {
    if ( *(v10 - 1) )
      (**v10)(v10, 3);
    else
      operator delete[](v10 - 1);
  }
  operator delete[](*((void **)this + 8));
  if ( *((_DWORD *)this + 9) )
    operator delete[](*((void **)this + 9));
  operator delete[](*((void **)this + 3));
  v11 = (void *)*((_DWORD *)this + 36);
  *((_DWORD *)this + 30) = &DwCTwoDimArray<int>::`vftable';
  if ( v11 )
    operator delete[](v11);
  if ( *((_DWORD *)this + 38) )
    operator delete[](*((void **)this + 38));
  if ( *((_DWORD *)this + 37) )
    operator delete[](*((void **)this + 37));
  *((_DWORD *)this + 36) = 0;
  *((_DWORD *)this + 37) = 0;
  *((_DWORD *)this + 38) = 0;
  *((_DWORD *)this + 35) = 0;
  *((_DWORD *)this + 34) = 0;
  *((_DWORD *)this + 33) = 0;
  *((_DWORD *)this + 32) = 0;
  *((_DWORD *)this + 31) = 0;
  v12 = (void *)*((_DWORD *)this + 27);
  *((_DWORD *)this + 21) = &DwCTwoDimArray<float>::`vftable';
  if ( v12 )
    operator delete[](v12);
  if ( *((_DWORD *)this + 29) )
    operator delete[](*((void **)this + 29));
  if ( *((_DWORD *)this + 28) )
    operator delete[](*((void **)this + 28));
  *((_DWORD *)this + 27) = 0;
  *((_DWORD *)this + 28) = 0;
  *((_DWORD *)this + 29) = 0;
  *((_DWORD *)this + 26) = 0;
  *((_DWORD *)this + 25) = 0;
  *((_DWORD *)this + 24) = 0;
  *((_DWORD *)this + 23) = 0;
  *((_DWORD *)this + 22) = 0;
}
// 43A178: using guessed type void *DwCTwoDimArray<float>::`vftable';
// 43A73C: using guessed type void *DwCTwoDimArray<int>::`vftable';
// 43A744: using guessed type void *TdCParagraph::`vftable';

//----- (004316D0) --------------------------------------------------------
void __thiscall sub_4316D0(_DWORD *this)
{
  *this = &TdCTextLine::`vftable';
  sub_42BDA0(this + 12);
}
// 43A734: using guessed type void *TdCTextLine::`vftable';

//----- (004316E0) --------------------------------------------------------
char *__thiscall sub_4316E0(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(this, 0x3D8u, *((_DWORD *)this - 1), (void (__thiscall *)(void *))sub_4316D0);
    if ( (a2 & 1) != 0 )
      operator delete[](this - 4);
    return this - 4;
  }
  else
  {
    *(_DWORD *)this = &TdCTextLine::`vftable';
    sub_42BDA0(this + 48);
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}
// 43A734: using guessed type void *TdCTextLine::`vftable';

//----- (00431750) --------------------------------------------------------
void **__thiscall sub_431750(void **this, char a2)
{
  *this = &DwCTwoDimArray<int>::`vftable';
  sub_431900((int)this);
  if ( this[7] )
    operator delete[](this[7]);
  if ( this[8] )
    operator delete[](this[8]);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 43A73C: using guessed type void *DwCTwoDimArray<int>::`vftable';

//----- (004317A0) --------------------------------------------------------
int __thiscall sub_4317A0(_DWORD *this, int a2, int a3, double a4)
{
  int v4; // edx
  int v5; // eax
  float v6; // xmm0_4
  int result; // eax

  v4 = this[28];
  v5 = *(_DWORD *)(v4 + 4 * a2);
  v6 = *(float *)(v5 + 4 * a3) + a4;
  *(float *)(v5 + 4 * a3) = v6;
  result = *(_DWORD *)(v4 + 4 * a3);
  *(float *)(result + 4 * a2) = v6;
  return result;
}

//----- (004317E0) --------------------------------------------------------
void *__thiscall sub_4317E0(int this, int a2)
{
  void *result; // eax

  *(_DWORD *)(this + 32) = a2;
  if ( a2 > 20000 )
    exit(0);
  operator delete[](*(void **)(this + 8));
  operator delete[](*(void **)(this + 12));
  *(_DWORD *)(this + 8) = operator new[](8 * a2);
  result = operator new[](8 * a2);
  *(_DWORD *)(this + 12) = result;
  return result;
}

//----- (00431850) --------------------------------------------------------
void __thiscall sub_431850(void *this, float a2)
{
  sub_432D20((int)this, a2);
}

//----- (00431870) --------------------------------------------------------
void __thiscall sub_431870(int this, float a2)
{
  int v3; // ebx
  int v4; // edi

  if ( *(_DWORD *)(*(_DWORD *)(this + 40) + 4) >= 0xAu )
  {
    sub_431D80(this);
    v3 = 0;
    if ( *(int *)(this + 8) > 0 )
    {
      v4 = 0;
      do
      {
        sub_434990(v4 + *(_DWORD *)(this + 20), *(_DWORD *)(this + 16), *(_DWORD *)(this + 24));
        sub_4348C0((_DWORD *)(v4 + *(_DWORD *)(this + 20)), *(_QWORD *)(this + 160), *(_DWORD *)(this + 16));
        ++v3;
        v4 += 984;
      }
      while ( v3 < *(_DWORD *)(this + 8) );
    }
    sub_432D20(this, a2);
  }
  else
  {
    *(_DWORD *)(this + 8) = 0;
    *(_BYTE *)(this + 80) = 0;
  }
}

//----- (00431900) --------------------------------------------------------
void __thiscall sub_431900(int this)
{
  if ( *(_DWORD *)(this + 24) )
    operator delete[](*(void **)(this + 24));
  if ( *(_DWORD *)(this + 32) )
    operator delete[](*(void **)(this + 32));
  if ( *(_DWORD *)(this + 28) )
    operator delete[](*(void **)(this + 28));
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 4) = 0;
}

//----- (00431970) --------------------------------------------------------
void __thiscall sub_431970(int this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // esi
  int v8; // ebx
  int v9; // edi
  _DWORD *v10; // ecx
  int v11; // eax
  int v12; // eax
  int v13; // ebx
  int v14; // eax
  int v15; // edi
  int v16; // ecx
  int v17; // eax
  int v18; // esi
  int *v19; // edx
  int v20; // eax
  _DWORD *v21; // ecx
  int v22; // edx
  _DWORD *v23; // eax
  int v24; // edi
  int v25; // esi
  int v26; // edx
  int v27; // eax
  int v28; // edi
  int v29; // ebx
  int v31; // [esp+24h] [ebp+1Ch]

  v7 = this;
  if ( *(_BYTE *)(this + 80) )
  {
    v8 = 0;
    if ( *(int *)(this + 8) > 0 )
    {
      v9 = 0;
      do
      {
        v10 = (_DWORD *)(v9 + *(_DWORD *)(v7 + 20));
        v11 = v10[2];
        if ( v11 )
        {
          v12 = *(_DWORD *)(v11 + 4);
          if ( v12 )
          {
            if ( v12 < a7 )
            {
              sub_434AE0(v10, a2);
              sub_4320C0(v9 + *(_DWORD *)(v7 + 20));
            }
          }
        }
        if ( *(_DWORD *)(*(_DWORD *)(v7 + 32) + 4 * v8) == 1 )
          sub_4320C0(v9 + *(_DWORD *)(v7 + 20));
        ++v8;
        v9 += 984;
      }
      while ( v8 < *(_DWORD *)(v7 + 8) );
    }
    sub_4340F0(v7);
    v13 = *(_DWORD *)(v7 + 8);
    v14 = *(_DWORD *)(*(_DWORD *)(v7 + 40) + 4);
    if ( v13 == 1 )
      goto LABEL_14;
    if ( v13 == 2 )
    {
      if ( v14 < 15 )
      {
LABEL_14:
        *(_BYTE *)(v7 + 80) = 0;
        return;
      }
    }
    else if ( v13 == 3 && v14 < 15 )
    {
      goto LABEL_14;
    }
    v15 = 0;
    v16 = 0;
    if ( v13 <= 0 )
      goto LABEL_46;
    v17 = *(_DWORD *)(v7 + 20);
    v18 = *(_DWORD *)(v7 + 8);
    v31 = v17 + 8;
    v19 = (int *)(v17 + 8);
    do
    {
      v20 = *v19;
      if ( *v19 )
        v20 = *(_DWORD *)(v20 + 4);
      if ( v15 >= v20 )
      {
        if ( v16 < v20 )
          v16 = v20;
      }
      else
      {
        v16 = v15;
        v15 = v20;
      }
      v19 += 246;
      --v18;
    }
    while ( v18 );
    if ( (v7 = this, v15 < 20) && v16 < 10 || v16 < 5 )
    {
LABEL_46:
      v28 = 0;
      *(_BYTE *)(v7 + 80) = 0;
      if ( v13 > 0 )
      {
        v29 = 0;
        do
        {
          sub_434AE0((_DWORD *)(v29 + *(_DWORD *)(v7 + 20)), *(_DWORD *)(v7 + 16));
          ++v28;
          v29 += 984;
        }
        while ( v28 < *(_DWORD *)(v7 + 8) );
      }
    }
    else
    {
      v21 = *(_DWORD **)(this + 32);
      v22 = 0;
      v23 = v21;
      v24 = v13;
      do
      {
        if ( *v23 == 1 )
          ++v22;
        ++v23;
        --v24;
      }
      while ( v24 );
      if ( v22 )
      {
        v25 = v31;
        v26 = 0;
        do
        {
          if ( !*v21 )
          {
            if ( *(_DWORD *)v25 )
            {
              v27 = *(_DWORD *)(*(_DWORD *)v25 + 4);
              if ( v27 > 0 )
              {
                ++v26;
                v24 += v27;
              }
            }
          }
          ++v21;
          v25 += 984;
          --v13;
        }
        while ( v13 );
        v7 = this;
        if ( v26 == 1 )
          goto LABEL_14;
        if ( (v26 == 2 || v26 == 3) && v24 < 15 )
          *(_BYTE *)(this + 80) = 0;
      }
    }
  }
}

//----- (00431B10) --------------------------------------------------------
double __thiscall sub_431B10(int this, int a2, int a3, int a4, double a5)
{
  int v6; // eax
  int v7; // ecx
  int v8; // eax
  double v9; // xmm0_8
  double v10; // xmm0_8
  int v11; // esi
  int v12; // ebx
  _DWORD *i; // ecx
  _DWORD *v14; // ecx
  double v15; // st7
  int v17; // [esp+2Ch] [ebp-3A8h]
  int v18; // [esp+34h] [ebp-3A0h]
  _DWORD **v19; // [esp+34h] [ebp-3A0h]
  double v20; // [esp+38h] [ebp-39Ch]
  _DWORD **v21; // [esp+40h] [ebp-394h]
  int v22[224]; // [esp+44h] [ebp-390h] BYREF
  int v23; // [esp+3D0h] [ebp-4h]

  v18 = 984 * a3;
  v6 = *(_DWORD *)(984 * a3 + a2 + 8);
  if ( v6 )
    v7 = *(_DWORD *)(v6 + 4);
  else
    v7 = 0;
  v8 = *(_DWORD *)(984 * a4 + a2 + 8);
  if ( v8 )
    v8 = *(_DWORD *)(v8 + 4);
  v17 = v7 + v8;
  memset(v22, 0, sizeof(v22));
  sub_42BD70(v22);
  v23 = 0;
  sub_4317E0((int)v22, v17);
  v9 = *(double *)(v18 + a2 + 952);
  v19 = *(_DWORD ***)(v18 + a2 + 8);
  v20 = v9;
  v10 = *(double *)(984 * a4 + a2 + 952);
  v11 = 0;
  v12 = v22[2];
  for ( i = (_DWORD *)**v19; i != *v19; i = (_DWORD *)*i )
  {
    *(_DWORD *)(v12 + 8 * v11) = *(_DWORD *)((i[2] << 6) + *(_DWORD *)(this + 16) + 32);
    *(_DWORD *)(v12 + 8 * v11++ + 4) = *(_DWORD *)((i[2] << 6) + *(_DWORD *)(this + 16) + 36);
  }
  v21 = *(_DWORD ***)(984 * a4 + a2 + 8);
  v14 = (_DWORD *)**v21;
  if ( v14 != *v21 )
  {
    v11 = v12 + 8 * v11;
    do
    {
      v11 += 8;
      *(_DWORD *)(v11 - 8) = *(_DWORD *)((v14[2] << 6) + *(_DWORD *)(this + 16) + 32);
      *(_DWORD *)(v11 - 4) = *(_DWORD *)((v14[2] << 6) + *(_DWORD *)(this + 16) + 36);
      v14 = (_DWORD *)*v14;
    }
    while ( v14 != *v21 );
  }
  sub_42BE00((int)v22, 0.0, *(_QWORD *)(this + 160), 3);
  v15 = sub_42D210((int)v22, v11);
  v23 = -1;
  sub_42BDA0(v22);
  return ((v10 + v20) / a5 - v15) * (double)v17;
}

//----- (00431D50) --------------------------------------------------------
double __cdecl sub_431D50(int a1, int a2, int a3, int a4)
{
  if ( a3 == a4 )
    return 0.0;
  else
    return *(float *)(*(_DWORD *)(*(_DWORD *)(dword_50198C + 28) + 4 * a1) + 4 * a2);
}
// 50198C: using guessed type int dword_50198C;

//----- (00431D80) --------------------------------------------------------
int __thiscall sub_431D80(int this)
{
  int v2; // edi
  double v3; // xmm0_8
  int v4; // esi
  double v5; // xmm0_8
  int v6; // ecx
  int v7; // eax
  int v8; // edx
  double *v9; // ecx
  int v10; // esi
  int v11; // eax
  int result; // eax
  __int64 v13[100]; // [esp+14h] [ebp-324h] BYREF

  memset(v13, 0, sizeof(v13));
  v2 = 0;
  v3 = 0.0;
  if ( *(int *)(this + 8) > 0 )
  {
    v4 = 0;
    do
    {
      v5 = sub_434290((_DWORD *)(v4 + *(_DWORD *)(this + 20)), *(_DWORD *)(this + 16));
      if ( v5 <= 0.0 )
      {
        v6 = (int)((v5 - 5.0) / 10.0);
        if ( v6 == -9 )
          v6 = 9;
      }
      else
      {
        v6 = (int)((v5 + 5.0) / 10.0);
      }
      v7 = *(_DWORD *)(*(_DWORD *)(this + 20) + v4 + 8);
      if ( v7 )
        v7 = *(_DWORD *)(v7 + 4);
      ++v2;
      v4 += 984;
      *(double *)&v13[v6 + 50] = (double)v7 + *(double *)&v13[v6 + 50];
    }
    while ( v2 < *(_DWORD *)(this + 8) );
    v3 = 0.0;
  }
  v8 = 0;
  v9 = (double *)&v13[32];
  v10 = -20;
  v11 = -18;
  do
  {
    if ( *(v9 - 2) > v3 )
    {
      v3 = *(v9 - 2);
      v8 = v10;
    }
    if ( *(v9 - 1) > v3 )
    {
      v3 = *(v9 - 1);
      v8 = v11 - 1;
    }
    if ( *v9 > v3 )
    {
      v3 = *v9;
      v8 = v11;
    }
    if ( v9[1] > v3 )
    {
      v3 = v9[1];
      v8 = v11 + 1;
    }
    if ( v9[2] > v3 )
    {
      v3 = v9[2];
      v8 = v11 + 2;
    }
    if ( v9[3] > v3 )
    {
      v3 = v9[3];
      v8 = v11 + 3;
    }
    if ( v9[4] > v3 )
    {
      v3 = v9[4];
      v8 = v11 + 4;
    }
    if ( v9[5] > v3 )
    {
      v3 = v9[5];
      v8 = v11 + 5;
    }
    v11 += 8;
    v10 += 8;
    v9 += 8;
  }
  while ( v11 <= 15 );
  for ( ; v10 <= 20; ++v10 )
  {
    if ( *(double *)&v13[v10 + 50] > v3 )
    {
      v3 = *(double *)&v13[v10 + 50];
      v8 = v10;
    }
  }
  result = 10 * v8;
  *(double *)(this + 160) = (double)(10 * v8) / 180.0 * 3.141592653589793;
  return result;
}

//----- (00431F70) --------------------------------------------------------
char __thiscall sub_431F70(int this, int a2, int a3, int a4)
{
  int v5; // ecx
  int i; // edx
  int v7; // edx

  sub_431900(this);
  v5 = a4;
  *(_DWORD *)(this + 4) = a2;
  if ( !a4 )
    v5 = a2;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 8) = a3;
  *(_DWORD *)(this + 16) = v5;
  *(_DWORD *)(this + 12) = v5 * a3;
  *(_DWORD *)(this + 24) = operator new[](4 * v5 * a3);
  *(_DWORD *)(this + 28) = operator new[](4 * *(_DWORD *)(this + 8));
  *(_DWORD *)(this + 32) = operator new[](4 * (*(_DWORD *)(this + 8) + 1));
  memset(*(void **)(this + 24), 0, 4 * *(_DWORD *)(this + 12));
  for ( i = 0; i < *(_DWORD *)(this + 8); ++i )
    *(_DWORD *)(*(_DWORD *)(this + 28) + 4 * i) = *(_DWORD *)(this + 24) + 4 * i * *(_DWORD *)(this + 16);
  v7 = 1;
  if ( *(_DWORD *)(this + 8) + 1 <= 1 )
    return 1;
  do
  {
    *(_DWORD *)(*(_DWORD *)(this + 32) + 4 * v7) = *(_DWORD *)(this + 24) - 4 + 4 * *(_DWORD *)(this + 16) * (v7 - 1);
    ++v7;
  }
  while ( v7 < *(_DWORD *)(this + 8) + 1 );
  return 1;
}

//----- (00432060) --------------------------------------------------------
int *__cdecl sub_432060(int a1, int *a2, float *a3)
{
  __int64 v3; // rax
  int v4; // ecx
  int *result; // eax

  v3 = a1 - a1 % dword_501978;
  *a3 = 3.141592653589793 / (double)dword_501978 * (double)(a1 % dword_501978);
  v4 = LODWORD(dword_43E048[v3 / dword_501978]);
  result = a2;
  *a2 = v4;
  return result;
}
// 43E048: using guessed type float dword_43E048[10];
// 501978: using guessed type int dword_501978;

//----- (004320C0) --------------------------------------------------------
void __thiscall sub_4320C0(int this)
{
  int v2; // edi
  _DWORD *v3; // edx
  _DWORD *v4; // esi
  void **v5; // edi
  _DWORD *v6; // ecx
  _DWORD *v7; // esi

  v2 = *(_DWORD *)(this + 8);
  if ( v2 )
  {
    v3 = **(_DWORD ***)v2;
    **(_DWORD **)v2 = *(_DWORD *)v2;
    *(_DWORD *)(*(_DWORD *)v2 + 4) = *(_DWORD *)v2;
    *(_DWORD *)(v2 + 4) = 0;
    if ( v3 != *(_DWORD **)v2 )
    {
      do
      {
        v4 = (_DWORD *)*v3;
        operator delete(v3);
        v3 = v4;
      }
      while ( v4 != *(_DWORD **)v2 );
    }
    v5 = *(void ***)(this + 8);
    if ( v5 )
    {
      v6 = *(_DWORD **)*v5;
      *(_DWORD *)*v5 = *v5;
      *((_DWORD *)*v5 + 1) = *v5;
      v5[1] = 0;
      if ( v6 != *v5 )
      {
        do
        {
          v7 = (_DWORD *)*v6;
          operator delete(v6);
          v6 = v7;
        }
        while ( v7 != *v5 );
      }
      operator delete(*v5);
      operator delete(v5);
    }
    *(_DWORD *)(this + 8) = 0;
    *(_BYTE *)(this + 960) = 0;
  }
}

//----- (00432150) --------------------------------------------------------
void __userpurge sub_432150(int a1@<ecx>, __m128d a2@<xmm5>, float a3, float a4, unsigned int a5)
{
  int v5; // ebx
  void ***v6; // ecx
  void ***v7; // esi
  void **v8; // edi
  void **v9; // esi
  _DWORD *v10; // eax
  double v11; // xmm1_8
  void **v12; // ecx
  void *v13; // ebx
  void *v14; // ecx
  float v15; // xmm2_4
  int v16; // edx
  int v17; // eax
  double v18; // xmm0_8
  float v19; // xmm4_4
  void *v20; // ecx
  __int64 v21; // rax
  void *v22; // edi
  int v23; // ecx
  _DWORD *v24; // eax
  int v25; // edi
  int v26; // ecx
  int *v27; // eax
  void *v28; // eax
  void ***v29; // eax
  void **v30; // esi
  int v31; // eax
  _DWORD *v32; // eax
  void *v33; // ecx
  int v34; // eax
  int v35; // eax
  _DWORD *v36; // ecx
  int i; // esi
  int v38; // ecx
  _DWORD *v39; // edx
  void ***v40; // eax
  int v41; // esi
  int v42; // edi
  bool v43; // cc
  void ***v44; // edi
  int v45; // eax
  void **v46; // edx
  int v47; // esi
  _DWORD *v48; // eax
  _DWORD *v49; // edi
  _DWORD *v50; // eax
  void **v51; // edx
  _DWORD *v52; // ecx
  void **v53; // ebx
  _DWORD *v54; // esi
  void **v55; // esi
  _DWORD *v56; // ecx
  void **v57; // edi
  _DWORD *v58; // esi
  int v59; // ecx
  int v60; // eax
  char v61; // al
  void *v62; // [esp+8h] [ebp-7Ch]
  int v63; // [esp+8h] [ebp-7Ch]
  unsigned int v64; // [esp+10h] [ebp-74h]
  int v65; // [esp+10h] [ebp-74h]
  int v66[2]; // [esp+24h] [ebp-60h] BYREF
  float v67; // [esp+2Ch] [ebp-58h]
  float v68; // [esp+30h] [ebp-54h]
  int v69; // [esp+34h] [ebp-50h]
  float v70; // [esp+38h] [ebp-4Ch] BYREF
  __int128 v71; // [esp+3Ch] [ebp-48h]
  int v72; // [esp+4Ch] [ebp-38h]
  int v73; // [esp+50h] [ebp-34h]
  _DWORD *v74; // [esp+54h] [ebp-30h]
  void *v75; // [esp+58h] [ebp-2Ch]
  void ***v76; // [esp+5Ch] [ebp-28h]
  void *v77[2]; // [esp+60h] [ebp-24h] BYREF
  int v78; // [esp+68h] [ebp-1Ch]
  void *v79; // [esp+6Ch] [ebp-18h] BYREF
  int v80; // [esp+70h] [ebp-14h] BYREF
  int v81; // [esp+80h] [ebp-4h]

  v5 = a1;
  v72 = a1;
  v64 = *(_DWORD *)(a1 + 28);
  v76 = *(void ****)(a1 + 40);
  v73 = (int)v76[1];
  *(_QWORD *)v77 = 0i64;
  v78 = 0;
  sub_403D10((int *)v77, v64);
  v6 = (void ***)*v76;
  v7 = v76;
  v81 = 0;
  v8 = *v6;
  if ( *v6 != (void **)v6 )
  {
    do
    {
      if ( *(_BYTE *)(((_DWORD)v8[2] << 6) + *(_DWORD *)(v5 + 16) + 12) != 1 )
      {
        v9 = *v6;
        v80 = (*(_DWORD *)(*(_DWORD *)(v5 + 24) + 4 * (_DWORD)v8[2])
             - *(_DWORD *)(*(_DWORD *)(v5 + 24) + 4 * (_DWORD)v8[2]) % dword_501978)
            / dword_501978;
        if ( v9 == (void **)v6 )
        {
          v7 = v76;
        }
        else
        {
          do
          {
            if ( *(_BYTE *)(((_DWORD)v9[2] << 6) + *(_DWORD *)(v5 + 16) + 12) != 1 )
            {
              v10 = (_DWORD *)sub_403DF0(v77, (int)v8[2]);
              v65 = (int)v9[2];
              v74 = v10;
              v75 = (void *)sub_403DF0(v77, v65);
              if ( v74 != v75 )
              {
                v11 = (double)dword_501978;
                v12 = &v79;
                v79 = (void *)((*(_DWORD *)(*(_DWORD *)(v5 + 24) + 4 * (_DWORD)v9[2])
                              - *(_DWORD *)(*(_DWORD *)(v5 + 24) + 4 * (_DWORD)v9[2]) % dword_501978)
                             / dword_501978);
                if ( (int)v79 >= v80 )
                  v12 = (void **)&v80;
                v13 = *v12;
                v14 = v8[2];
                v15 = dword_43E048[(_DWORD)v13];
                v5 = v72;
                v16 = *(_DWORD *)(*(_DWORD *)(v72 + 24) + 4 * (_DWORD)v14) % dword_501978;
                v14 = (void *)((_DWORD)v14 << 6);
                v17 = *(_DWORD *)(v72 + 16);
                v18 = (double)v16;
                v19 = *(float *)((char *)v14 + v17 + 32);
                a2 = (__m128d)*(unsigned int *)((char *)v14 + v17 + 36);
                v20 = v9[2];
                v21 = *(int *)(*(_DWORD *)(v72 + 24) + 4 * (_DWORD)v20);
                v20 = (void *)((_DWORD)v20 << 6);
                HIDWORD(v21) = v21 % dword_501978;
                LODWORD(v21) = *(_DWORD *)(v72 + 16);
                v67 = v15 * a3;
                *((float *)&v71 + 1) = v15 * a3;
                *(float *)&v18 = v18 * 3.141592653589793 / v11 - 1.570796326794897;
                v66[1] = LODWORD(a2.m128d_f64[0]);
                v69 = LODWORD(v18);
                *(float *)v66 = v19;
                v68 = v15 * a4;
                *((float *)&v71 + 2) = v15 * a4;
                LODWORD(v71) = *(_DWORD *)((char *)v20 + v21 + 36);
                *(float *)&v18 = (double)SHIDWORD(v21) * 3.141592653589793 / v11 - 1.570796326794897;
                HIDWORD(v71) = LODWORD(v18);
                v70 = *(float *)((char *)v20 + v21 + 32);
                *(float *)a2.m128d_f64 = (float)((float)(*(float *)a2.m128d_f64 - *(float *)&v71)
                                               * (float)(*(float *)a2.m128d_f64 - *(float *)&v71))
                                       + (float)((float)(v19 - v70) * (float)(v19 - v70));
                if ( *(float *)a2.m128d_f64 <= (float)((float)((float)((float)(v67 + v67) + v68) + v68)
                                                     * (float)((float)((float)(v67 + v67) + v68) + v68))
                  && sub_4337C0((float *)v66, &v70) )
                {
                  sub_403E20((int *)v77, (int)v74, (int)v75);
                }
              }
            }
            v9 = (void **)*v9;
          }
          while ( v9 != *v76 );
          v7 = v76;
        }
      }
      v8 = (void **)*v8;
      v6 = (void ***)*v7;
    }
    while ( v8 != *v7 );
  }
  v75 = *(void **)(v5 + 28);
  v22 = v75;
  v23 = (984 * (unsigned __int64)(unsigned int)v75) >> 32 != 0 ? -1 : 984 * (_DWORD)v75;
  v24 = operator new[](__CFADD__(v23, 4) ? -1 : v23 + 4);
  v79 = v24;
  LOBYTE(v81) = 1;
  if ( v24 )
  {
    v62 = v75;
    *v24 = v22;
    v25 = (int)(v24 + 1);
    v74 = v24 + 1;
    `eh vector constructor iterator'(
      v24 + 1,
      0x3D8u,
      (int)v62,
      (void (__thiscall *)(void *))sub_4313A0,
      (void (__thiscall *)(void *))sub_4316D0);
  }
  else
  {
    v25 = 0;
    v74 = 0;
  }
  LOBYTE(v81) = 0;
  v26 = (984 * (unsigned __int64)(unsigned int)v73) >> 32 != 0 ? -1 : 984 * v73;
  v27 = (int *)operator new[](__CFADD__(v26, 4) ? -1 : v26 + 4);
  v79 = v27;
  LOBYTE(v81) = 2;
  if ( v27 )
  {
    v63 = v73;
    *v27 = v73;
    v75 = v27 + 1;
    `eh vector constructor iterator'(
      v27 + 1,
      0x3D8u,
      v63,
      (void (__thiscall *)(void *))sub_4313A0,
      (void (__thiscall *)(void *))sub_4316D0);
    v28 = v75;
  }
  else
  {
    v28 = 0;
  }
  *(_DWORD *)(v5 + 20) = v28;
  v29 = (void ***)*v7;
  LOBYTE(v81) = 0;
  v30 = *v29;
  if ( *v29 != (void **)v29 )
  {
    do
    {
      v31 = 984 * sub_403DF0(v77, (int)v30[2]);
      v79 = (void *)v31;
      if ( !*(_DWORD *)(v31 + v25 + 8) )
      {
        v32 = operator new(8u);
        v75 = v32;
        LOBYTE(v81) = 3;
        if ( v32 )
        {
          *(_QWORD *)v32 = 0i64;
          *v32 = 0;
          v32[1] = 0;
          sub_42AD80(0, 0);
          v33 = v75;
          *(_DWORD *)v75 = v34;
        }
        else
        {
          v33 = 0;
        }
        v31 = (int)v79;
        LOBYTE(v81) = 0;
        *(_DWORD *)((char *)v79 + v25 + 8) = v33;
      }
      v75 = *(void **)(v31 + v25 + 8);
      v79 = *(void **)v75;
      v35 = sub_426520(v79, *((_DWORD **)v79 + 1), v30 + 2);
      v73 = v35;
      if ( *((_DWORD *)v75 + 1) == 357913940 )
        std::_Xlength_error("list<T> too long");
      v36 = v79;
      ++*((_DWORD *)v75 + 1);
      v36[1] = v35;
      **(_DWORD **)(v35 + 4) = v73;
      v30 = (void **)*v30;
    }
    while ( v30 != *v76 );
  }
  for ( i = 0; i < *(_DWORD *)(v5 + 28); v25 += 984 )
  {
    if ( *(_DWORD *)(v25 + 8) )
    {
      sub_434990(v25, *(_DWORD *)(v5 + 16), *(_DWORD *)(v5 + 24));
      sub_4345E0(v25, v25, i, a2, *(_DWORD *)(v5 + 160), *(_DWORD *)(v5 + 164), *(_DWORD *)(v5 + 16));
    }
    ++i;
  }
  v71 = xmmword_43A7A0;
  dword_50197C = 0;
  do
  {
    v38 = 0;
    v80 = 0;
    if ( *(int *)(v5 + 28) > 0 )
    {
      v39 = v74;
      v40 = (void ***)v74;
      v76 = (void ***)v74;
      do
      {
        v41 = (int)(v40 + 246);
        if ( v40[2] )
        {
          v42 = v38 + 1;
          if ( v38 + 1 < *(_DWORD *)(v5 + 28) )
          {
            do
            {
              if ( *(_DWORD *)(v41 + 8) )
              {
                if ( sub_4330F0((_DWORD *)v5, (int)v39, v38, v42, *((double *)&v71 + dword_50197C), 0.125, 16.0, 0) )
                {
                  sub_433490(v76, v41, *(_QWORD *)(v5 + 160), *(_DWORD *)(v5 + 16), *(_DWORD *)(v5 + 24));
                  sub_4345E0((int)v76, v42, v41, a2, *(_DWORD *)(v5 + 160), *(_DWORD *)(v5 + 164), *(_DWORD *)(v5 + 16));
                }
                v39 = v74;
                v38 = v80;
              }
              ++v42;
              v41 += 984;
            }
            while ( v42 < *(_DWORD *)(v5 + 28) );
            v40 = v76;
          }
        }
        ++v38;
        v40 += 246;
        v80 = v38;
        v76 = v40;
      }
      while ( v38 < *(_DWORD *)(v5 + 28) );
    }
    ++dword_50197C;
  }
  while ( dword_50197C < 2 );
  v43 = *(_DWORD *)(v5 + 28) <= 0;
  *(_DWORD *)(v5 + 8) = 0;
  v80 = 0;
  if ( !v43 )
  {
    v76 = (void ***)(v74 + 2);
    v44 = (void ***)(v74 + 2);
    v45 = 0;
    do
    {
      v46 = *v44;
      if ( *v44 )
      {
        if ( (unsigned int)v46[1] < a5 )
        {
          v50 = *(_DWORD **)*v46;
          if ( v50 != *v46 )
          {
            do
            {
              *(_BYTE *)((v50[2] << 6) + *(_DWORD *)(v5 + 16) + 12) = 1;
              v50 = (_DWORD *)*v50;
            }
            while ( v50 != **v44 );
          }
          v51 = *v44;
          v75 = v51;
          v52 = *(_DWORD **)*v51;
          *(_DWORD *)*v51 = *v51;
          *((_DWORD *)*v51 + 1) = *v51;
          v51[1] = 0;
          if ( v52 != *v51 )
          {
            v53 = v51;
            do
            {
              v54 = (_DWORD *)*v52;
              operator delete(v52);
              v52 = v54;
            }
            while ( v54 != *v53 );
            v5 = v72;
          }
          v55 = *v44;
          v73 = (int)v55;
          if ( v55 )
          {
            v56 = *(_DWORD **)*v55;
            *(_DWORD *)*v55 = *v55;
            *((_DWORD *)*v55 + 1) = *v55;
            v55[1] = 0;
            if ( v56 != *v55 )
            {
              v57 = v55;
              do
              {
                v58 = (_DWORD *)*v56;
                operator delete(v56);
                v56 = v58;
              }
              while ( v58 != *v57 );
              v55 = (void **)v73;
              v44 = v76;
            }
            operator delete(*v55);
            operator delete(v55);
          }
        }
        else
        {
          *(_DWORD *)(984 * *(_DWORD *)(v5 + 8) + *(_DWORD *)(v5 + 20) + 8) = v46;
          v47 = *(_DWORD *)(v5 + 8);
          v75 = *(void **)(984 * v47 + *(_DWORD *)(v5 + 20) + 8);
          v48 = **(_DWORD ***)v75;
          if ( v48 != *(_DWORD **)v75 )
          {
            v49 = v75;
            do
            {
              *(_DWORD *)((v48[2] << 6) + *(_DWORD *)(v5 + 16) + 20) = v47;
              v48 = (_DWORD *)*v48;
            }
            while ( v48 != (_DWORD *)*v49 );
            v44 = v76;
          }
          ++*(_DWORD *)(v5 + 8);
        }
        v45 = v80;
        *v44 = 0;
      }
      ++v45;
      v44 += 246;
      v80 = v45;
      v76 = v44;
    }
    while ( v45 < *(_DWORD *)(v5 + 28) );
  }
  if ( v74 )
  {
    if ( *(v74 - 1) )
      (*(void (__thiscall **)(_DWORD *, int))*v74)(v74, 3);
    else
      operator delete[](v74 - 1);
  }
  v59 = *(_DWORD *)(*(_DWORD *)(v5 + 40) + 4);
  v60 = *(_DWORD *)(v5 + 8);
  if ( v60 == 1 )
  {
    v61 = 0;
    goto LABEL_83;
  }
  if ( v60 == 2 )
  {
    if ( v59 < 15 )
    {
      v61 = 0;
      goto LABEL_83;
    }
  }
  else if ( v60 == 3 && v59 < 15 )
  {
    v61 = 0;
    goto LABEL_83;
  }
  v61 = 1;
LABEL_83:
  *(_BYTE *)(v5 + 80) = v61;
  if ( v77[0] )
    operator delete(v77[0]);
}
// 4324D7: variable 'v34' is possibly undefined
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);
// 43A7A0: using guessed type __int128 xmmword_43A7A0;
// 43E048: using guessed type float dword_43E048[10];
// 501978: using guessed type int dword_501978;
// 50197C: using guessed type int dword_50197C;

//----- (00432870) --------------------------------------------------------
void __thiscall sub_432870(_DWORD *this, float a2, float a3, int a4, int a5, int a6, int a7)
{
  int v7; // esi
  int v8; // edi
  int v9; // ebx
  int v10; // eax
  int v11; // ecx
  int v12; // eax
  int v13; // edi
  int v14; // eax
  int v15; // ebx
  int v16; // xmm0_4
  float v17; // xmm1_4
  int v18; // esi
  int v19; // edi
  int v20; // eax
  double v21; // xmm1_8
  int v22; // ecx
  float v23; // xmm4_4
  int v24; // xmm3_4
  int v25; // xmm5_4
  int v26; // xmm0_4
  int *v27; // esi
  int v28; // edi
  unsigned int v29; // [esp-4h] [ebp-84h]
  int v30[5]; // [esp+10h] [ebp-70h] BYREF
  int v31[5]; // [esp+24h] [ebp-5Ch] BYREF
  float v32; // [esp+38h] [ebp-48h]
  int v33; // [esp+3Ch] [ebp-44h]
  float v34; // [esp+40h] [ebp-40h]
  float v35; // [esp+44h] [ebp-3Ch]
  int *v36; // [esp+48h] [ebp-38h]
  int v37; // [esp+4Ch] [ebp-34h]
  float v38; // [esp+50h] [ebp-30h]
  int v39; // [esp+54h] [ebp-2Ch]
  int v40; // [esp+58h] [ebp-28h]
  int v41; // [esp+5Ch] [ebp-24h]
  _DWORD *v42; // [esp+60h] [ebp-20h]
  void *v43[2]; // [esp+64h] [ebp-1Ch] BYREF
  int v44; // [esp+6Ch] [ebp-14h]
  int v45; // [esp+7Ch] [ebp-4h]

  v7 = (int)this;
  v42 = this;
  v29 = this[7];
  v8 = a6;
  v40 = a6;
  v36 = (int *)a7;
  *(_QWORD *)v43 = 0i64;
  v44 = 0;
  sub_403D10((int *)v43, v29);
  v9 = a5;
  v10 = 0;
  v45 = 0;
  v39 = 0;
  if ( a5 > 0 )
  {
    do
    {
      v11 = *(_DWORD *)(v8 + 4 * v10);
      v12 = *(_DWORD *)(v7 + 16);
      v13 = v11 << 6;
      v33 = v11;
      v41 = v12;
      if ( *(_BYTE *)((v11 << 6) + v12 + 12) != 1 )
      {
        v14 = *(_DWORD *)(*(_DWORD *)(v7 + 24) + 4 * v11);
        v15 = 0;
        *(float *)&v16 = (double)(v14 % dword_501978) * 3.141592653589793 / (double)dword_501978 - 1.570796326794897;
        v30[4] = v16;
        v34 = *(float *)(v13 + v41 + 32);
        *(float *)v30 = v34;
        v38 = *(float *)(v13 + v41 + 36);
        *(float *)&v30[1] = v38;
        v17 = dword_43E048[(v14 - v14 % dword_501978) / dword_501978];
        v35 = v17 * a3;
        *(float *)&v30[3] = v17 * a3;
        v32 = v17 * a2;
        *(float *)&v30[2] = v17 * a2;
        do
        {
          v18 = *(_DWORD *)(v40 + 4 * v15);
          v19 = v18 << 6;
          if ( *(_BYTE *)((v18 << 6) + v42[4] + 12) == 1
            || (v41 = sub_403DF0(v43, v33), v37 = sub_403DF0(v43, v18), v41 == v37) )
          {
            v7 = (int)v42;
          }
          else
          {
            v20 = *(_DWORD *)(v42[6] + 4 * v18) - *(_DWORD *)(v42[6] + 4 * v18) % dword_501978;
            v21 = (double)(*(_DWORD *)(v42[6] + 4 * v18) % dword_501978);
            v7 = (int)v42;
            v22 = v42[4];
            v23 = *(float *)(v19 + v22 + 36);
            *(float *)&v24 = dword_43E048[v20 / dword_501978] * a2;
            *(float *)&v25 = dword_43E048[v20 / dword_501978] * a3;
            *(float *)&v26 = v21 * 3.141592653589793 / (double)dword_501978 - 1.570796326794897;
            v31[4] = v26;
            *(float *)&v21 = v34 - *(float *)(v19 + v22 + 32);
            v31[0] = *(_DWORD *)(v19 + v22 + 32);
            *(float *)&v31[1] = v23;
            v31[2] = v24;
            v31[3] = v25;
            if ( (float)((float)((float)(v38 - v23) * (float)(v38 - v23)) + (float)(*(float *)&v21 * *(float *)&v21)) <= (float)((float)((float)((float)(v35 + v32) + *(float *)&v24) + *(float *)&v25) * (float)((float)((float)(v35 + v32) + *(float *)&v24) + *(float *)&v25))
              && sub_4337C0((float *)v30, (float *)v31) )
            {
              sub_403E20((int *)v43, v41, v37);
            }
          }
          ++v15;
        }
        while ( v15 < a5 );
        v9 = a5;
      }
      v8 = v40;
      v10 = v39 + 1;
      v39 = v10;
    }
    while ( v10 < v9 );
    if ( v9 > 0 )
    {
      v27 = v36;
      v28 = v40 - (_DWORD)v36;
      do
      {
        *v27 = sub_403DF0(v43, *(int *)((char *)v27 + v28));
        ++v27;
        --v9;
      }
      while ( v9 );
    }
  }
  if ( v43[0] )
    operator delete(v43[0]);
}
// 43E048: using guessed type float dword_43E048[10];
// 501978: using guessed type int dword_501978;

//----- (00432B30) --------------------------------------------------------
float *__thiscall sub_432B30(int *this, int a2, float *a3, float *a4)
{
  int v5; // ecx
  int v6; // esi
  float *result; // eax
  double v8; // st7
  int v9; // ecx
  double v10; // st7
  int v11; // eax
  float v12; // xmm2_4
  double v13; // [esp+10h] [ebp-10h]
  double v14; // [esp+18h] [ebp-8h]
  int v15; // [esp+28h] [ebp+8h]
  float v16; // [esp+28h] [ebp+8h]

  v15 = 984 * a2;
  v5 = this[5] + v15;
  v6 = *(_DWORD *)(v5 + 8);
  if ( v6 )
    v6 = *(_DWORD *)(v6 + 4);
  if ( !*(_DWORD *)(v5 + 8) )
  {
    *a4 = 0.0;
    result = a3;
    *a3 = 0.0;
    return result;
  }
  v8 = sub_434A20(v5, this[4]);
  v9 = this[5] + v15;
  v14 = v8;
  v13 = *(double *)(v9 + 952);
  if ( v13 * 0.05 > v8 )
  {
    v10 = sub_42D2D0(v9 + 48, (int)this, v6, this[4], (_DWORD **)*(_DWORD *)(v9 + 8));
    v9 = this[5] + v15;
    if ( (v14 / v13 * 0.032579890889899 * (v14 / v13)
        - (v14 / v13 * 2.64733466882046 * (v14 / v13) * (v14 / v13) * (v14 / v13)
         + v14 / v13 * 0.009846068014184001 * (v14 / v13) * (v14 / v13))
        - v14 / v13 * 0.00189980856504
        + 0.000031466578083)
       * 10000.0
       - 0.0005 > v10 / (*(double *)(v9 + 912) - *(double *)(v9 + 904)) / v13 )
    {
      *a3 = 500.0;
LABEL_8:
      result = a4;
      *a4 = 0.0;
      return result;
    }
  }
  v11 = *(_DWORD *)(v9 + 8);
  if ( v11 && *(int *)(v11 + 4) >= 3 )
  {
    v16 = sub_434A80(v9);
    if ( v16 >= 0.0 )
      v12 = v16;
    else
      v12 = 0.0;
    *a3 = v12;
    result = a4;
    if ( v16 >= 0.0 )
      *a4 = 0.0;
    else
      *a4 = -v16;
  }
  else if ( v6 == 1 )
  {
    result = a3;
    *a3 = 6000.0;
  }
  else if ( v6 == 2 )
  {
    result = a3;
    *a3 = 60.0;
  }
  else
  {
    if ( v6 <= 0 )
      goto LABEL_8;
    result = a3;
    *a3 = (float)(6 - v6) * 6.0;
  }
  return result;
}

//----- (00432D20) --------------------------------------------------------
void __fastcall sub_432D20(int a1, float a2)
{
  int *v3; // esi
  int v4; // edi
  void *v5; // ecx
  void **v6; // eax
  _DWORD *v7; // eax
  int v8; // ecx
  _OWORD *v9; // eax
  _DWORD *v10; // ecx
  void *v11; // eax
  int *v12; // eax
  int *v13; // eax
  int v14; // ecx
  void *v15; // eax
  int v16; // esi
  int v17; // eax
  int v18; // edx
  int v19; // eax
  int v20; // edx
  void **v21; // [esp+10h] [ebp-58h] BYREF
  __int64 v22; // [esp+14h] [ebp-54h]
  int v23; // [esp+1Ch] [ebp-4Ch]
  void *v24; // [esp+20h] [ebp-48h]
  __int128 v25; // [esp+24h] [ebp-44h]
  void *v26; // [esp+34h] [ebp-34h]
  void *v27; // [esp+38h] [ebp-30h]
  void *v28; // [esp+3Ch] [ebp-2Ch] BYREF
  void *v29; // [esp+40h] [ebp-28h] BYREF
  void *i; // [esp+44h] [ebp-24h]
  int v31; // [esp+48h] [ebp-20h]
  int v32; // [esp+4Ch] [ebp-1Ch]
  int *v33; // [esp+50h] [ebp-18h]
  float v34; // [esp+54h] [ebp-14h] BYREF
  int v35; // [esp+64h] [ebp-4h]

  v3 = (int *)a1;
  v32 = a1;
  v4 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 32) = operator new[](4 * v4);
  v21 = &DwCTwoDimArray<float>::`vftable';
  v22 = 0i64;
  v24 = 0;
  v23 = 0;
  v25 = 0i64;
  v35 = 0;
  sub_431F70((int)&v21, 2, v4, 0);
  v5 = 0;
  for ( i = 0; (int)v5 < v4; v6[1] = v28 )
  {
    sub_432B30(v3, (int)v5, (float *)&v29, (float *)&v28);
    v6 = *(void ***)(DWORD2(v25) + 4 * (_DWORD)i);
    i = (char *)i + 1;
    v5 = i;
    *v6 = v29;
  }
  v7 = operator new(0xCu);
  v28 = v7;
  if ( v7 )
  {
    v8 = DWORD1(v25);
    *(_QWORD *)v7 = 0i64;
    v7[2] = 0;
    *v7 = v8;
    v7[2] = 1;
  }
  else
  {
    v28 = 0;
  }
  v9 = operator new(0x28u);
  v29 = v9;
  if ( v9 )
  {
    *v9 = 0i64;
    v9[1] = 0i64;
    *((_QWORD *)v9 + 4) = 0i64;
    *((_DWORD *)v9 + 3) = sub_431D50;
    *((_DWORD *)v9 + 4) = 0;
    *((_BYTE *)v9 + 32) = 0;
  }
  else
  {
    v29 = 0;
  }
  v10 = operator new(8u);
  i = v10;
  if ( v10 )
  {
    v11 = v28;
    *(_QWORD *)v10 = 0i64;
    *v10 = v11;
    v10[1] = v29;
  }
  else
  {
    i = 0;
  }
  dword_50198C = (int)(v3 + 21);
  v26 = operator new[](0xFA0u);
  v12 = (int *)operator new(0x58u);
  v33 = v12;
  v27 = v12;
  LOBYTE(v35) = 1;
  if ( v12 )
  {
    memset(v12, 0, 0x58u);
    sub_42DA70((int)v33, (void *)v4, 2, i);
    v13 = v33;
    *v33 = (int)&Expansion::`vftable';
  }
  else
  {
    v13 = 0;
    v33 = 0;
  }
  LOBYTE(v35) = 0;
  sub_431090(v13);
  (*(void (__thiscall **)(int *))(*v33 + 36))(v33);
  v14 = 0;
  v31 = 0;
  if ( v4 > 0 )
  {
    do
    {
      v15 = (void *)(v14 + 1);
      v27 = (void *)(v14 + 1);
      v16 = v14 + 1;
      if ( v14 + 1 < v4 )
      {
        do
        {
          if ( *(float *)(*(_DWORD *)(*(_DWORD *)(v32 + 112) + 4 * v14) + 4 * v16) > 0.0 )
          {
            (*(void (__thiscall **)(int *, int, int, int))(*v33 + 16))(v33, v14, v16, 1065353216);
            v14 = v31;
            v17 = *(_DWORD *)(*(_DWORD *)(v32 + 112) + 4 * v31);
            *(float *)(v17 + 4 * v16) = *(float *)(v17 + 4 * v16) * a2;
          }
          ++v16;
        }
        while ( v16 < v4 );
        v15 = v27;
      }
      v14 = (int)v15;
      v31 = (int)v15;
    }
    while ( (int)v15 < v4 );
    v3 = (int *)v32;
  }
  sub_4311F0(v33);
  sub_431170(v33, 1, &v34);
  sub_4311F0(v33);
  v18 = 0;
  v32 = 0;
  if ( v4 > 0 )
  {
    v31 = 0;
    do
    {
      v19 = (*(int (__thiscall **)(int *, int))(*v33 + 28))(v33, v18);
      v20 = v32;
      *(_DWORD *)(v3[8] + 4 * v32) = v19;
      if ( *(_DWORD *)(v3[8] + 4 * v20) == 1 )
      {
        sub_434AE0((_DWORD *)(v31 + v3[5]), v3[4]);
        v20 = v32;
      }
      v31 += 984;
      v18 = v20 + 1;
      v32 = v18;
    }
    while ( v18 < v4 );
  }
  operator delete(v28);
  operator delete(v29);
  operator delete(i);
  (*(void (__thiscall **)(int *, int))*v33)(v33, 1);
  operator delete[](v26);
  if ( DWORD1(v25) )
    operator delete[]((void *)DWORD1(v25));
  if ( HIDWORD(v25) )
    operator delete[]((void *)HIDWORD(v25));
  if ( DWORD2(v25) )
    operator delete[]((void *)DWORD2(v25));
}
// 43A124: using guessed type void *Expansion::`vftable';
// 43A178: using guessed type void *DwCTwoDimArray<float>::`vftable';
// 50198C: using guessed type int dword_50198C;
// 432D20: using guessed type float var_14;

//----- (00433070) --------------------------------------------------------
char __thiscall sub_433070(_DWORD *this)
{
  int v1; // eax

  v1 = this[2];
  if ( v1 )
    LOBYTE(v1) = sub_431F70((int)(this + 21), v1, v1, 0);
  return v1;
}

//----- (00433090) --------------------------------------------------------
void __userpurge sub_433090(int a1@<ecx>, __m128d a2@<xmm5>, int a3, int a4, int a5, __int64 a6, unsigned int a7)
{
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 40) + 4) >= 0xAu )
  {
    *(_DWORD *)(a1 + 24) = a5;
    *(_DWORD *)(a1 + 16) = a3;
    *(_DWORD *)(a1 + 28) = a4;
    sub_431D80(a1);
    sub_432150(a1, a2, *(float *)&a6, *((float *)&a6 + 1), a7);
  }
  else
  {
    *(_BYTE *)(a1 + 80) = 0;
  }
}

//----- (004330F0) --------------------------------------------------------
char __thiscall sub_4330F0(_DWORD *this, int a2, int a3, int a4, float a5, float a6, double a7, char a8)
{
  _DWORD **v8; // ecx
  _DWORD *v9; // eax
  _DWORD *v10; // edi
  int v11; // ebx
  int v12; // ecx
  int v13; // edx
  int v14; // edx
  float v15; // xmm6_4
  int v16; // xmm2_4
  int v17; // xmm7_4
  _DWORD **v18; // eax
  int v19; // xmm6_4
  int v20; // xmm0_4
  _DWORD *v21; // esi
  int v22; // xmm0_4
  int v23; // ecx
  int v24; // edx
  int v25; // eax
  double v26; // xmm1_8
  int v27; // eax
  int v28; // edx
  float v29; // xmm3_4
  float v30; // xmm5_4
  float v31; // xmm0_4
  int v32; // ebx
  double v33; // xmm2_8
  double v34; // xmm0_8
  double v35; // xmm1_8
  double v36; // xmm3_8
  double *v37; // ecx
  __int64 *v38; // eax
  double v39; // xmm4_8
  double v40; // xmm0_8
  int v42[5]; // [esp+14h] [ebp-84h] BYREF
  int v43; // [esp+28h] [ebp-70h] BYREF
  float v44; // [esp+2Ch] [ebp-6Ch]
  float v45; // [esp+30h] [ebp-68h]
  float v46; // [esp+34h] [ebp-64h]
  float v47; // [esp+38h] [ebp-60h]
  double v48; // [esp+3Ch] [ebp-5Ch]
  int v49; // [esp+44h] [ebp-54h]
  float v50; // [esp+48h] [ebp-50h]
  _DWORD *v51; // [esp+4Ch] [ebp-4Ch]
  int v52; // [esp+50h] [ebp-48h]
  int v53; // [esp+54h] [ebp-44h]
  int v54; // [esp+58h] [ebp-40h]
  int v55; // [esp+5Ch] [ebp-3Ch]
  int v56; // [esp+60h] [ebp-38h]
  _DWORD **v57; // [esp+64h] [ebp-34h]
  int v58; // [esp+68h] [ebp-30h]
  _DWORD *v59; // [esp+6Ch] [ebp-2Ch]
  int v60; // [esp+70h] [ebp-28h]
  double v61; // [esp+74h] [ebp-24h] BYREF
  double v62; // [esp+7Ch] [ebp-1Ch] BYREF
  double v63; // [esp+84h] [ebp-14h] BYREF
  double v64; // [esp+8Ch] [ebp-Ch] BYREF

  v59 = this;
  v52 = a3;
  v55 = a2;
  v54 = a4;
  v53 = 984 * a3;
  if ( *(_BYTE *)(984 * a3 + a2 + 960) )
  {
    v49 = 984 * a4;
    if ( *(_BYTE *)(984 * a4 + a2 + 960) )
    {
      v8 = *(_DWORD ***)(984 * a3 + a2 + 8);
      v57 = *(_DWORD ***)(984 * a4 + a2 + 8);
      v9 = *v8;
      v51 = v8;
      v10 = (_DWORD *)*v9;
      if ( (_DWORD *)*v9 != v9 )
      {
        v11 = (int)v59;
        do
        {
          v12 = v10[2];
          v13 = *(_DWORD *)(v11 + 16);
          v60 = v12;
          if ( *(_BYTE *)((v12 << 6) + v13 + 12) != 1 )
          {
            v14 = *(_DWORD *)(v11 + 16);
            v15 = dword_43E048[(*(_DWORD *)(*(_DWORD *)(v11 + 24) + 4 * v12)
                              - *(_DWORD *)(*(_DWORD *)(v11 + 24) + 4 * v12) % dword_501978)
                             / dword_501978];
            v16 = *(int *)((v60 << 6) + v14 + 32);
            *(float *)&v17 = v15 * a5;
            v18 = (_DWORD **)*v57;
            *(float *)&v19 = v15 * a6;
            *(float *)&v20 = (double)(*(_DWORD *)(*(_DWORD *)(v11 + 24) + 4 * v12) % dword_501978)
                           * 3.141592653589793
                           / (double)dword_501978
                           - 1.570796326794897;
            v21 = (_DWORD *)**v57;
            v58 = v16;
            v42[4] = v20;
            v22 = *(int *)((v60 << 6) + v14 + 36);
            v42[0] = v16;
            v50 = *(float *)&v22;
            v42[1] = v22;
            v60 = v17;
            v42[2] = v17;
            v56 = v19;
            v42[3] = v19;
            if ( v21 != v18 )
            {
              do
              {
                v23 = v21[2];
                v24 = *(_DWORD *)(v11 + 16);
                HIDWORD(v64) = v23;
                if ( *(_BYTE *)((v23 << 6) + v24 + 12) != 1 )
                {
                  v25 = *(_DWORD *)(*(_DWORD *)(v11 + 24) + 4 * v23);
                  v26 = (double)(v25 % dword_501978);
                  v11 = (int)v59;
                  v27 = (v25 - v25 % dword_501978) / dword_501978;
                  v28 = v59[4];
                  v29 = dword_43E048[v27] * a5;
                  v30 = dword_43E048[v27] * a6;
                  v31 = v26 * 3.141592653589793 / (double)dword_501978 - 1.570796326794897;
                  v44 = *(float *)((HIDWORD(v64) << 6) + v28 + 36);
                  v47 = v31;
                  *(float *)&v26 = *(float *)&v16 - *(float *)((HIDWORD(v64) << 6) + v28 + 32);
                  v43 = *(_DWORD *)((HIDWORD(v64) << 6) + v28 + 32);
                  v45 = v29;
                  v46 = v30;
                  if ( (float)((float)((float)(v50 - v44) * (float)(v50 - v44))
                             + (float)(*(float *)&v26 * *(float *)&v26)) <= (float)((float)((float)((float)(*(float *)&v19 + *(float *)&v17)
                                                                                                  + v29)
                                                                                          + v30)
                                                                                  * (float)((float)((float)(*(float *)&v19 + *(float *)&v17)
                                                                                                  + v29)
                                                                                          + v30)) )
                  {
                    if ( sub_4337C0((float *)v42, (float *)&v43) )
                    {
                      v32 = v55;
                      v64 = sub_431B10((int)v59, v55, v52, v54, a7);
                      if ( v64 < 0.0 )
                        return 0;
                      v33 = *(double *)(v53 + v32 + 968);
                      v34 = *(double *)(v53 + v32 + 976);
                      v63 = v33;
                      v61 = v34;
                      v35 = *(double *)(v49 + v32 + 968);
                      v36 = *(double *)(v49 + v32 + 976);
                      v62 = v35;
                      v64 = v36;
                      if ( a8 || v33 > v36 || v35 > v34 )
                        return 1;
                      v37 = &v64;
                      if ( v36 <= v34 )
                        v37 = &v61;
                      v38 = (__int64 *)&v62;
                      if ( v33 <= v35 )
                        v38 = (__int64 *)&v63;
                      v39 = *v37 - *(double *)v38;
                      if ( v36 < v33 )
                      {
                        if ( v34 < v35 )
                        {
                          v40 = v48;
                        }
                        else
                        {
                          v40 = v34 - v35;
                          v48 = v40;
                        }
                      }
                      else
                      {
                        v40 = v36 - v33;
                        v48 = v36 - v33;
                      }
                      if ( v40 / v39 < 0.1 )
                        return 1;
                      v11 = (int)v59;
                    }
                    v17 = v60;
                    v19 = v56;
                  }
                  v16 = v58;
                }
                v21 = (_DWORD *)*v21;
              }
              while ( v21 != *v57 );
            }
          }
          v10 = (_DWORD *)*v10;
        }
        while ( v10 != (_DWORD *)*v51 );
      }
      return 0;
    }
  }
  return 0;
}
// 43E048: using guessed type float dword_43E048[10];
// 501978: using guessed type int dword_501978;

//----- (00433490) --------------------------------------------------------
void __thiscall sub_433490(_DWORD *this, int a2, __int64 a3, int a4, int a5)
{
  _DWORD *v5; // ebx
  int v6; // edi
  _DWORD *v7; // eax
  _DWORD *v8; // esi
  int v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // esi
  _DWORD *v12; // edi
  _DWORD *v13; // ebx
  int v14; // edx
  int v15; // eax

  v5 = this;
  v6 = a2;
  if ( !this[2] )
  {
    v7 = operator new(8u);
    v8 = v7;
    if ( v7 )
    {
      *(_QWORD *)v7 = 0i64;
      *v7 = 0;
      v7[1] = 0;
      sub_42AD80(0, 0);
      *v8 = v9;
    }
    else
    {
      v8 = 0;
    }
    v5[2] = v8;
  }
  v10 = **(_DWORD ***)(a2 + 8);
  v11 = (_DWORD *)*v10;
  if ( (_DWORD *)*v10 != v10 )
  {
    do
    {
      v12 = (_DWORD *)v5[2];
      v13 = (_DWORD *)*v12;
      v14 = sub_426520((_DWORD *)*v12, *(_DWORD **)(*v12 + 4), v11 + 2);
      v15 = v12[1];
      if ( v15 == 357913940 )
        std::_Xlength_error("list<T> too long");
      v12[1] = v15 + 1;
      v6 = a2;
      v13[1] = v14;
      v5 = this;
      **(_DWORD **)(v14 + 4) = v14;
      v11 = (_DWORD *)*v11;
    }
    while ( v11 != **(_DWORD ***)(a2 + 8) );
  }
  sub_4320C0(v6);
  sub_434990((int)v5, a4, a5);
  sub_4348C0(v5, a3, a4);
}
// 43350E: variable 'v9' is possibly undefined
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (004335C0) --------------------------------------------------------
int __stdcall sub_4335C0(const __m128i *a1, int a2)
{
  int v2; // ecx
  int v4; // edi
  __m128i v5; // xmm1
  __m128i v6; // xmm2
  const __m128i *v7; // eax
  const __m128i *v8; // edx
  __m128i v9; // xmm0
  __m128i v10; // xmm1
  __m128i v11; // xmm1
  int v12; // eax
  void *v13; // ebx
  int v14; // ecx
  __int32 v15; // eax
  __int32 v16; // edx
  int i; // eax
  int v18; // ecx
  int v19; // edi
  int v20; // ecx
  __m128i v21; // xmm1
  __m128i v22; // xmm2
  const __m128i *v23; // eax
  __m128i v24; // xmm0
  __m128i v25; // xmm1
  __m128i v26; // xmm1
  int v28; // [esp+Ch] [ebp-4h]
  void *v29; // [esp+1Ch] [ebp+Ch]

  v2 = 0;
  v4 = 0;
  v28 = 0;
  if ( a2 > 0 )
  {
    if ( (unsigned int)a2 < 8 || dword_5019B4 < 2 )
    {
      v7 = a1;
    }
    else
    {
      v5 = 0i64;
      v6 = 0i64;
      v7 = a1;
      v8 = a1;
      do
      {
        v9 = _mm_loadu_si128(v8);
        v2 += 8;
        v8 += 2;
        v5 = _mm_max_epi32(v5, v9);
        v6 = _mm_max_epi32(v6, _mm_loadu_si128(v8 - 1));
      }
      while ( v2 < a2 - (a2 & 7) );
      v10 = _mm_max_epi32(v5, v6);
      v11 = _mm_max_epi32(v10, _mm_srli_si128(v10, 8));
      v4 = _mm_cvtsi128_si32(_mm_max_epi32(v11, _mm_srli_si128(v11, 4)));
      v28 = v4;
    }
    if ( v2 < a2 )
    {
      do
      {
        v12 = v7->m128i_i32[v2];
        if ( v12 > v4 )
          v4 = v12;
        v7 = a1;
        ++v2;
      }
      while ( v2 < a2 );
      v28 = v4;
    }
  }
  v13 = operator new[](4 * (v4 + 1));
  v29 = v13;
  memset(v13, 0, 4 * v4);
  v14 = 0;
  if ( a2 > 0 )
  {
    do
    {
      v15 = a1->m128i_i32[v14++];
      *((_DWORD *)v13 + v15) = 1;
    }
    while ( v14 < a2 );
    v4 = v28;
  }
  v16 = 0;
  for ( i = v4; v16 < i; ++v16 )
  {
    if ( !*((_DWORD *)v13 + v16) )
    {
      for ( i = v4; i > v16; --i )
      {
        if ( *((_DWORD *)v13 + i) == 1 )
          break;
      }
      v18 = 0;
      *((_DWORD *)v13 + i) = 0;
      *((_DWORD *)v13 + v16) = 1;
      if ( a2 > 0 )
      {
        do
        {
          if ( a1->m128i_i32[v18] == i )
            a1->m128i_i32[v18] = v16;
          ++v18;
        }
        while ( v18 < a2 );
        v4 = v28;
        v13 = v29;
      }
    }
  }
  v19 = 0;
  v20 = 0;
  if ( a2 > 0 )
  {
    if ( (unsigned int)a2 >= 8 && dword_5019B4 >= 2 )
    {
      v21 = 0i64;
      v22 = 0i64;
      v23 = a1;
      do
      {
        v24 = _mm_loadu_si128(v23);
        v20 += 8;
        v23 += 2;
        v21 = _mm_max_epi32(v21, v24);
        v22 = _mm_max_epi32(v22, _mm_loadu_si128(v23 - 1));
      }
      while ( v20 < a2 - (a2 & 7) );
      v25 = _mm_max_epi32(v21, v22);
      v26 = _mm_max_epi32(v25, _mm_srli_si128(v25, 8));
      v19 = _mm_cvtsi128_si32(_mm_max_epi32(v26, _mm_srli_si128(v26, 4)));
    }
    if ( v20 < a2 )
    {
      do
      {
        if ( a1->m128i_i32[v20] > v19 )
          v19 = a1->m128i_i32[v20];
        ++v20;
      }
      while ( v20 < a2 );
      v13 = v29;
    }
  }
  operator delete[](v13);
  return v19 + 1;
}
// 4335EF: conditional instruction was optimized away because %arg_4.4>=8
// 43372B: conditional instruction was optimized away because esi.4>=8
// 4335EA: mask 0x80000007 is shortened because %arg_4.4 <= 0x7FFFFFFF
// 433726: mask 0x80000007 is shortened because esi.4 <= 0x7FFFFFFF
// 5019B4: using guessed type int dword_5019B4;

//----- (004337C0) --------------------------------------------------------
BOOL __cdecl sub_4337C0(float *a1, float *a2)
{
  float v4; // xmm0_4
  float v5; // xmm0_4
  float v6; // xmm0_4
  float v7; // xmm1_4
  float v8; // xmm6_4
  float v9; // xmm4_4
  float v10; // xmm3_4
  float v11; // xmm1_4
  float v12; // xmm4_4
  float v13; // xmm7_4
  float v14; // xmm0_4
  float v15; // xmm4_4
  float v16; // xmm6_4
  float v17; // xmm4_4
  float v18; // xmm3_4
  float v19; // xmm4_4
  float v20; // xmm1_4
  float v21; // xmm5_4
  float v22; // xmm6_4
  float v23; // xmm0_4
  float v24; // xmm0_4
  float v25; // xmm2_4
  float v26; // xmm1_4
  float v27; // xmm2_4
  float v28; // xmm0_4
  float v29; // xmm1_4
  float v30; // xmm7_4
  float v31; // xmm3_4
  float v32; // xmm3_4
  float v33; // xmm0_4
  int v35; // [esp+0h] [ebp-20h]
  int v36; // [esp+0h] [ebp-20h]
  int v37; // [esp+4h] [ebp-1Ch]
  int v38; // [esp+4h] [ebp-1Ch]
  float v39; // [esp+Ch] [ebp-14h]
  float v40; // [esp+10h] [ebp-10h]
  float v41; // [esp+14h] [ebp-Ch]
  float v42; // [esp+14h] [ebp-Ch]
  float v43; // [esp+1Ch] [ebp-4h]
  float v44; // [esp+1Ch] [ebp-4h]
  float v45; // [esp+28h] [ebp+8h]
  float v46; // [esp+2Ch] [ebp+Ch]
  float v47; // [esp+2Ch] [ebp+Ch]
  float v48; // [esp+2Ch] [ebp+Ch]

  v4 = *(double *)libm_sse2_cos_precise(v35, v37).m128_u64;
  v40 = v4;
  v5 = *(double *)libm_sse2_sin_precise().m128_u64;
  v45 = v5;
  v43 = *a2 - *a1;
  v46 = a2[1] - a1[1];
  v6 = *(double *)libm_sse2_cos_precise(v36, v38).m128_u64;
  v41 = v6;
  v7 = *(double *)libm_sse2_sin_precise().m128_u64;
  v8 = a1[3];
  v9 = v46 * v7;
  v10 = (float)(v46 * v41) - (float)(v43 * v7);
  v11 = a1[2];
  v12 = v9 + (float)(v43 * v41);
  v13 = v12 - a2[2];
  v42 = v10 - a2[3];
  v14 = a2[2] + v12;
  v15 = v8 * v45;
  v16 = v8 * v40;
  v17 = -v15;
  v47 = v14;
  v39 = a2[3] + v10;
  v18 = (float)(v11 * v40) + v17;
  v19 = v17 - (float)(v11 * v40);
  v20 = v11 * v45;
  v21 = v16 + v20;
  v22 = v16 - v20;
  v44 = v45 * v40;
  if ( (float)(v45 * v40) < 0.0 )
  {
    v23 = v18;
    v18 = v19;
    v19 = v23;
    v24 = v21;
    v21 = v22;
    v44 = v24;
    v22 = v24;
  }
  if ( v45 < 0.0 )
  {
    v19 = -v19;
    v22 = -v22;
  }
  if ( v19 > v47 || v19 > (float)-v13 )
    return 0;
  v25 = v21;
  if ( v44 == 0.0 )
  {
    v26 = -v21;
  }
  else
  {
    if ( (float)((float)(v47 - v18) * (float)(v13 - v18)) > 0.0 )
    {
      if ( (float)(v13 - v18) >= 0.0 )
      {
        v27 = v13 - v18;
        v28 = v19 + v18;
        v29 = v22 + v21;
      }
      else
      {
        v27 = v47 - v18;
        v28 = v18 - v19;
        v29 = v21 - v22;
      }
      v25 = (float)((float)(v27 * v29) / v28) + v21;
    }
    v30 = v13 + v18;
    v26 = -v21;
    v48 = v47 + v18;
    if ( (float)(v48 * v30) > 0.0 )
    {
      v31 = -v18;
      if ( v30 >= 0.0 )
      {
        v32 = v31 + v19;
        v33 = v22 - v21;
      }
      else
      {
        v30 = v48;
        v32 = v31 - v19;
        v33 = v26 - v22;
      }
      v26 = (float)((float)(v30 * v33) / v32) - v21;
    }
  }
  return (v42 <= v25 || v42 <= v26) && (v25 <= v39 || v26 <= v39);
}
// 4337E0: variable 'v35' is possibly undefined
// 4337E0: variable 'v37' is possibly undefined
// 433834: variable 'v36' is possibly undefined
// 433834: variable 'v38' is possibly undefined
// 436A62: using guessed type __m128 __stdcall libm_sse2_cos_precise(_DWORD, _DWORD);
// 436A68: using guessed type __m128 libm_sse2_sin_precise(void);

//----- (00433A80) --------------------------------------------------------
void __thiscall sub_433A80(__m128i *this, __int128 a2, __int128 a3)
{
  this[3] = _mm_loadu_si128((const __m128i *)&a2);
  this[4] = _mm_loadu_si128((const __m128i *)&a3);
}

//----- (00433AA0) --------------------------------------------------------
void __thiscall sub_433AA0(int this, int a2, int a3, int a4)
{
  int v5; // edi
  int v6; // edi
  void *v7; // eax
  _DWORD **v8; // ebx
  _DWORD *v9; // ecx
  int v10; // edi
  float v11; // xmm0_4
  int v12; // ebx
  int v13; // ecx
  int *v14; // eax
  _DWORD *v15; // edi
  int v16; // ebx
  _DWORD *v17; // eax
  _DWORD *v18; // edi
  int v19; // eax
  int v20; // edx
  int v21; // edi
  int v22; // edx
  int v23; // eax
  int v24; // edi
  char *v25; // ecx
  _DWORD **v26; // ebx
  _DWORD *i; // eax
  int v28; // ebx
  int v29; // ecx
  int v30; // edi
  int v31; // eax
  int v32; // edx
  char v33; // al
  int v34; // [esp+2Ch] [ebp-14h]
  int v35; // [esp+30h] [ebp-10h]
  _DWORD **v36; // [esp+30h] [ebp-10h]
  char *v37; // [esp+30h] [ebp-10h]

  v5 = *(_DWORD *)(this + 40);
  if ( *(_DWORD *)(v5 + 4) >= 0xAu )
  {
    *(_DWORD *)(this + 24) = a4;
    *(_DWORD *)(this + 16) = a2;
    *(_DWORD *)(this + 28) = a3;
    v6 = *(_DWORD *)(v5 + 4);
    v34 = v6;
    v7 = operator new[](4 * v6);
    v8 = *(_DWORD ***)(this + 40);
    *(_DWORD *)(this + 36) = v7;
    v9 = (_DWORD *)**v8;
    if ( v9 != *v8 )
    {
      v10 = 0;
      do
      {
        v10 += 4;
        *(_DWORD *)(v10 + *(_DWORD *)(this + 36) - 4) = v9[2];
        v9 = (_DWORD *)*v9;
      }
      while ( v9 != *v8 );
      v6 = v34;
    }
    sub_431F70(this + 120, v6, 5, 0);
    v11 = *(double *)&qword_43E0E0;
    sub_432870(
      (_DWORD *)this,
      *(double *)&qword_43E0B8,
      v11,
      4,
      v6,
      *(_DWORD *)(this + 36),
      *(_DWORD *)(*(_DWORD *)(this + 148) + 16));
    v12 = sub_4335C0(*(const __m128i **)(*(_DWORD *)(this + 148) + 16), v6);
    *(_DWORD *)(this + 8) = v12;
    v13 = (984 * (unsigned __int64)(unsigned int)v12) >> 32 != 0 ? -1 : 984 * v12;
    v14 = (int *)operator new[](__CFADD__(v13, 4) ? -1 : v13 + 4);
    if ( v14 )
    {
      v15 = v14 + 1;
      *v14 = v12;
      `eh vector constructor iterator'(
        v14 + 1,
        0x3D8u,
        v12,
        (void (__thiscall *)(void *))sub_4313A0,
        (void (__thiscall *)(void *))sub_4316D0);
    }
    else
    {
      v15 = 0;
    }
    v16 = 0;
    for ( *(_DWORD *)(this + 20) = v15; v16 < v34; **(_DWORD **)(v22 + 4) = v22 )
    {
      v35 = 984 * *(_DWORD *)(4 * v16 + *(_DWORD *)(*(_DWORD *)(this + 148) + 16));
      if ( *(_DWORD *)(v35 + *(_DWORD *)(this + 20) + 8) )
      {
        v20 = 984 * *(_DWORD *)(4 * v16 + *(_DWORD *)(*(_DWORD *)(this + 148) + 16));
      }
      else
      {
        v17 = operator new(8u);
        v18 = v17;
        if ( v17 )
        {
          *(_QWORD *)v17 = 0i64;
          *v17 = 0;
          v17[1] = 0;
          sub_42AD80(0, 0);
          *v18 = v19;
        }
        else
        {
          v18 = 0;
        }
        v20 = v35;
        *(_DWORD *)(v35 + *(_DWORD *)(this + 20) + 8) = v18;
      }
      v21 = *(_DWORD *)(v20 + *(_DWORD *)(this + 20) + 8);
      v36 = *(_DWORD ***)v21;
      v22 = sub_426520(v36, v36[1], (_DWORD *)(4 * v16 + *(_DWORD *)(this + 36)));
      v23 = *(_DWORD *)(v21 + 4);
      if ( v23 == 357913940 )
        std::_Xlength_error("list<T> too long");
      ++v16;
      *(_DWORD *)(v21 + 4) = v23 + 1;
      v36[1] = (_DWORD *)v22;
    }
    v24 = 0;
    if ( *(int *)(this + 8) > 0 )
    {
      v25 = 0;
      v37 = 0;
      do
      {
        v26 = *(_DWORD ***)&v25[*(_DWORD *)(this + 20) + 8];
        for ( i = (_DWORD *)**v26; i != *v26; i = (_DWORD *)*i )
          *(_DWORD *)((i[2] << 6) + *(_DWORD *)(this + 16) + 20) = v24;
        ++v24;
        v25 = v37 + 984;
        v37 += 984;
      }
      while ( v24 < *(_DWORD *)(this + 8) );
    }
    v28 = *(_DWORD *)(this + 8);
    v29 = 0;
    v30 = 0;
    if ( v28 <= 0 )
      goto LABEL_36;
    v31 = *(_DWORD *)(this + 20) + 8;
    do
    {
      if ( *(_DWORD *)v31 )
      {
        v32 = *(_DWORD *)(*(_DWORD *)v31 + 4);
        if ( v32 > 0 )
        {
          ++v29;
          v30 += v32;
        }
      }
      v31 += 984;
      --v28;
    }
    while ( v28 );
    if ( v29 == 1 || (v29 == 2 || v29 == 3) && v30 < 15 )
      v33 = 0;
    else
LABEL_36:
      v33 = 1;
    *(_BYTE *)(this + 80) = v33;
  }
  else
  {
    *(_BYTE *)(this + 80) = 0;
  }
}
// 433C6F: variable 'v19' is possibly undefined
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);
// 43E0B8: using guessed type __int64 qword_43E0B8;
// 43E0E0: using guessed type __int64 qword_43E0E0;

//----- (00433D90) --------------------------------------------------------
int __userpurge sub_433D90@<eax>(int a1@<ecx>, __m128d a2@<xmm5>, int a3)
{
  int result; // eax
  int v5; // ebx
  int v6; // esi
  int v7; // ecx
  int v8; // eax
  int v9; // ecx
  int v10; // edx
  int v11; // ebx
  int v12; // esi
  float v13; // xmm0_4
  int v14; // eax
  int v15; // esi
  int v16; // edx
  int v17; // ebx
  int v18; // esi
  int v19; // eax
  int v20; // ecx
  int v21; // ecx
  int v22; // eax
  int v23; // esi
  int v24; // [esp+20h] [ebp-14h]
  int v25; // [esp+20h] [ebp-14h]
  int v26; // [esp+24h] [ebp-10h]
  int v27; // [esp+24h] [ebp-10h]
  int v28; // [esp+28h] [ebp-Ch]
  int v29; // [esp+28h] [ebp-Ch]
  int v30; // [esp+2Ch] [ebp-8h]
  int v31; // [esp+30h] [ebp-4h]
  int v32; // [esp+30h] [ebp-4h]

  result = *(_DWORD *)(a1 + 40);
  if ( *(_DWORD *)(result + 4) >= 0xAu )
  {
    sub_431D80(a1);
    v5 = 0;
    if ( *(int *)(a1 + 8) > 0 )
    {
      v6 = 0;
      do
      {
        sub_434990(v6 + *(_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 24));
        sub_4348C0((_DWORD *)(v6 + *(_DWORD *)(a1 + 20)), *(_QWORD *)(a1 + 160), *(_DWORD *)(a1 + 16));
        sub_4345E0(
          v6 + *(_DWORD *)(a1 + 20),
          a1,
          v6,
          a2,
          *(_DWORD *)(a1 + 160),
          *(_DWORD *)(a1 + 164),
          *(_DWORD *)(a1 + 16));
        ++v5;
        v6 += 984;
      }
      while ( v5 < *(_DWORD *)(a1 + 8) );
    }
    v7 = 0;
    v28 = 0;
    do
    {
      v8 = 0;
      v26 = 0;
      if ( *(int *)(a1 + 8) > 0 )
      {
        v9 = 0;
        v30 = 0;
        do
        {
          v10 = v8 + 1;
          v11 = v8 + 1;
          v24 = v8 + 1;
          if ( v8 + 1 < *(_DWORD *)(a1 + 8) )
          {
            v12 = v9 + 984;
            v31 = v9 + 984;
            do
            {
              v13 = *(double *)((char *)&qword_43E0D0 + v28);
              if ( sub_4330F0(
                     (_DWORD *)a1,
                     *(_DWORD *)(a1 + 20),
                     v8,
                     v11,
                     *(double *)((char *)&qword_43E0A8 + v28),
                     v13,
                     10.0,
                     0) )
              {
                v14 = *(_DWORD *)(a1 + 20);
                v15 = v14 + v30;
                sub_433490(
                  (_DWORD *)(v14 + v30),
                  v31 + v14,
                  *(_QWORD *)(a1 + 160),
                  *(_DWORD *)(a1 + 16),
                  *(_DWORD *)(a1 + 24));
                sub_4345E0(v15, a1, v15, a2, *(_DWORD *)(a1 + 160), *(_DWORD *)(a1 + 164), *(_DWORD *)(a1 + 16));
                v12 = v31;
              }
              v8 = v26;
              ++v11;
              v12 += 984;
              v31 = v12;
            }
            while ( v11 < *(_DWORD *)(a1 + 8) );
            v9 = v30;
            v10 = v24;
          }
          v8 = v10;
          v9 += 984;
          v26 = v10;
          v30 = v9;
        }
        while ( v10 < *(_DWORD *)(a1 + 8) );
        v7 = v28;
      }
      v7 -= 8;
      v28 = v7;
    }
    while ( v7 >= -16 );
    result = 0;
    v27 = 0;
    if ( *(int *)(a1 + 8) > 0 )
    {
      v16 = 0;
      v32 = 0;
      do
      {
        v17 = ++result;
        v25 = result;
        if ( result < *(_DWORD *)(a1 + 8) )
        {
          v18 = v16 + 984;
          v29 = v16 + 984;
          do
          {
            v19 = *(_DWORD *)(a1 + 20);
            v20 = *(_DWORD *)(v16 + v19 + 8);
            if ( v20 )
            {
              if ( *(int *)(v20 + 4) > 0 )
              {
                v21 = *(_DWORD *)(v18 + v19 + 8);
                if ( v21 )
                {
                  if ( *(int *)(v21 + 4) > 0 )
                  {
                    if ( sub_4330F0((_DWORD *)a1, v19, v27, v17, 1.0, 0.125, 8.0, 1) == 1 )
                    {
                      v22 = *(_DWORD *)(a1 + 20);
                      v23 = v22 + v32;
                      sub_433490(
                        (_DWORD *)(v22 + v32),
                        v29 + v22,
                        *(_QWORD *)(a1 + 160),
                        *(_DWORD *)(a1 + 16),
                        *(_DWORD *)(a1 + 24));
                      sub_4345E0(v23, a1, v23, a2, *(_DWORD *)(a1 + 160), *(_DWORD *)(a1 + 164), *(_DWORD *)(a1 + 16));
                      v18 = v29;
                    }
                    v16 = v32;
                  }
                }
              }
            }
            ++v17;
            v18 += 984;
            v29 = v18;
          }
          while ( v17 < *(_DWORD *)(a1 + 8) );
          result = v25;
        }
        v16 += 984;
        v27 = result;
        v32 = v16;
      }
      while ( result < *(_DWORD *)(a1 + 8) );
    }
  }
  else
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_BYTE *)(a1 + 80) = 0;
  }
  return result;
}
// 43E0A8: using guessed type __int64 qword_43E0A8;
// 43E0D0: using guessed type __int64 qword_43E0D0;

//----- (00434030) --------------------------------------------------------
float *__thiscall sub_434030(_DWORD *this)
{
  float *result; // eax
  int v3; // edx
  int v4; // edi
  float v5; // ecx
  int i; // edx
  int j; // ecx
  int v8; // ebx
  float v9; // edi

  result = (float *)operator new[](4 * this[2]);
  v3 = 0;
  this[3] = result;
  if ( (int)this[2] > 0 )
  {
    v4 = 0;
    do
    {
      result = (float *)this[3];
      LODWORD(v5) = v4 + this[5];
      v4 += 984;
      result[v3++] = v5;
    }
    while ( v3 < this[2] );
  }
  for ( i = 0; i < this[2]; ++i )
  {
    for ( j = i; j < this[2]; ++j )
    {
      v8 = this[3];
      v9 = *(float *)(v8 + 4 * i);
      result = *(float **)(v8 + 4 * j);
      if ( *(float *)(LODWORD(v9) + 96) * *(double *)(LODWORD(v9) + 64)
         - *(float *)(LODWORD(v9) + 88) * *(double *)(LODWORD(v9) + 72) > result[24] * *((double *)result + 8)
                                                                        - result[22] * *((double *)result + 9) )
      {
        *(_DWORD *)(v8 + 4 * i) = result;
        result = (float *)this[3];
        result[j] = v9;
      }
    }
  }
  return result;
}

//----- (004340F0) --------------------------------------------------------
void __thiscall sub_4340F0(int this)
{
  int v2; // edi
  _DWORD *v3; // ecx
  _DWORD *v4; // esi
  int v5; // edi
  int v6; // edx
  _DWORD ***v7; // ecx
  _DWORD *v8; // esi
  _DWORD *v9; // edi
  int v10; // edx
  int v11; // eax
  int v12; // edx
  int v13; // edi
  int v14; // eax
  int v15; // ecx
  int v16; // eax
  int v17; // esi
  int v18; // eax
  _DWORD *v19; // [esp+1Ch] [ebp-10h]
  _DWORD *v20; // [esp+20h] [ebp-Ch]
  _DWORD *v21; // [esp+20h] [ebp-Ch]
  int v22; // [esp+24h] [ebp-8h]
  int v23; // [esp+24h] [ebp-8h]
  int v24; // [esp+28h] [ebp-4h]
  int v25; // [esp+28h] [ebp-4h]

  v2 = *(_DWORD *)(this + 40);
  v3 = **(_DWORD ***)v2;
  **(_DWORD **)v2 = *(_DWORD *)v2;
  *(_DWORD *)(*(_DWORD *)v2 + 4) = *(_DWORD *)v2;
  *(_DWORD *)(v2 + 4) = 0;
  if ( v3 != *(_DWORD **)v2 )
  {
    do
    {
      v4 = (_DWORD *)*v3;
      operator delete(v3);
      v3 = v4;
    }
    while ( v4 != *(_DWORD **)v2 );
  }
  v5 = 0;
  v24 = 0;
  if ( *(int *)(this + 8) > 0 )
  {
    v6 = 0;
    v22 = 0;
    do
    {
      v7 = *(_DWORD ****)(v6 + *(_DWORD *)(this + 20) + 8);
      v20 = v7;
      if ( v7 )
      {
        if ( (int)v7[1] > 0 )
        {
          v8 = **v7;
          if ( v8 != *v7 )
          {
            do
            {
              v9 = *(_DWORD **)(this + 40);
              v19 = (_DWORD *)*v9;
              v10 = sub_426520((_DWORD *)*v9, *(_DWORD **)(*v9 + 4), v8 + 2);
              v11 = v9[1];
              if ( v11 == 357913940 )
                std::_Xlength_error("list<T> too long");
              v9[1] = v11 + 1;
              v19[1] = v10;
              **(_DWORD **)(v10 + 4) = v10;
              v8 = (_DWORD *)*v8;
            }
            while ( v8 != (_DWORD *)*v20 );
            v6 = v22;
            v5 = v24;
          }
        }
      }
      ++v5;
      v6 += 984;
      v24 = v5;
      v22 = v6;
    }
    while ( v5 < *(_DWORD *)(this + 8) );
  }
  v12 = *(_DWORD *)(this + 8);
  v13 = 0;
  if ( v12 > 0 )
  {
    v14 = 0;
    v15 = 1;
    v25 = 0;
    v23 = 1;
    do
    {
      v21 = (_DWORD *)(*(_DWORD *)(this + 20) + v14);
      v16 = v21[2];
      if ( !v16 || !*(_DWORD *)(v16 + 4) )
      {
        v17 = v15;
        if ( v15 < v12 )
        {
          v18 = *(_DWORD *)(this + 20) + v25 + 992;
          while ( !*(_DWORD *)v18 || !*(_DWORD *)(*(_DWORD *)v18 + 4) )
          {
            ++v17;
            v18 += 984;
            if ( v17 >= v12 )
              goto LABEL_24;
          }
          sub_433490(
            v21,
            *(_DWORD *)(this + 20) + 984 * v17,
            *(_QWORD *)(this + 160),
            *(_DWORD *)(this + 16),
            *(_DWORD *)(this + 24));
          *(_DWORD *)(*(_DWORD *)(this + 32) + 4 * v13) = *(_DWORD *)(*(_DWORD *)(this + 32) + 4 * v17);
LABEL_24:
          v15 = v23;
        }
        v12 = *(_DWORD *)(this + 8);
        if ( v17 == v12 )
          break;
      }
      ++v13;
      ++v15;
      v14 = v25 + 984;
      v23 = v15;
      v25 += 984;
    }
    while ( v13 < *(_DWORD *)(this + 8) );
  }
  *(_DWORD *)(this + 8) = v13;
}
// 439038: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (00434290) --------------------------------------------------------
double __thiscall sub_434290(_DWORD *this, int a2)
{
  int v2; // ecx
  double v3; // xmm3_8
  double v4; // xmm6_8
  double v5; // xmm4_8
  double v6; // xmm5_8
  double v7; // xmm7_8
  int v8; // edi
  _DWORD *v9; // eax
  _DWORD **v10; // ecx
  int v11; // edx
  double v12; // xmm2_8
  double v13; // xmm1_8
  double v14; // xmm1_8
  float v15; // xmm0_4
  float v16; // xmm0_4
  float v17; // xmm0_4
  double v19; // [esp+Ch] [ebp-88h]
  double v20; // [esp+14h] [ebp-80h]
  double v21; // [esp+1Ch] [ebp-78h]
  double v22; // [esp+24h] [ebp-70h]
  double v23; // [esp+2Ch] [ebp-68h]
  __int128 v24; // [esp+34h] [ebp-60h] BYREF
  int v25; // [esp+44h] [ebp-50h]
  __int128 v26; // [esp+48h] [ebp-4Ch] BYREF
  int v27; // [esp+58h] [ebp-3Ch]
  __int128 v28; // [esp+5Ch] [ebp-38h] BYREF
  int v29; // [esp+6Ch] [ebp-28h]
  __int128 v30; // [esp+70h] [ebp-24h] BYREF
  int v31; // [esp+80h] [ebp-14h]
  int v32; // [esp+90h] [ebp-4h]

  v2 = this[2];
  v3 = 0.0;
  v4 = 0.0;
  v19 = 0.0;
  v5 = 0.0;
  v22 = 0.0;
  v6 = 0.0;
  v20 = 0.0;
  v7 = 0.0;
  v8 = *(_DWORD *)(v2 + 4);
  v23 = 0.0;
  v21 = 0.0;
  v9 = **(_DWORD ***)v2;
  if ( v9 != *(_DWORD **)v2 )
  {
    v10 = *(_DWORD ***)v2;
    do
    {
      v11 = v9[2] << 6;
      v9 = (_DWORD *)*v9;
      v12 = *(float *)(v11 + a2 + 32);
      v13 = *(float *)(v11 + a2 + 36);
      v3 = v3 + v12;
      v5 = v5 + v13;
      v6 = v6 + v12 * v12;
      v7 = v7 + v13 * v13;
      v4 = v4 + v13 * v12;
    }
    while ( v9 != v10 );
    v23 = v7;
    v21 = v4;
    v20 = v6;
    v22 = v5;
    v19 = v3;
  }
  v31 = 0;
  v30 = 0i64;
  LODWORD(v30) = &CMyMatrix::`vftable';
  DWORD2(v30) = 0;
  sub_403EE0(&v30);
  HIDWORD(v30) = 2;
  v31 = 2;
  DWORD2(v30) = cvCreateMat(2, 2, 5);
  DWORD1(v30) = *(_DWORD *)(DWORD2(v30) + 16);
  v32 = 0;
  v26 = 0i64;
  v27 = 0;
  LODWORD(v26) = &CMyMatrix::`vftable';
  DWORD2(v26) = 0;
  sub_403EE0(&v26);
  HIDWORD(v26) = 2;
  v27 = 1;
  DWORD2(v26) = cvCreateMat(2, 1, 5);
  DWORD1(v26) = *(_DWORD *)(DWORD2(v26) + 16);
  LOBYTE(v32) = 1;
  v28 = 0i64;
  v29 = 0;
  LODWORD(v28) = &CMyMatrix::`vftable';
  DWORD2(v28) = 0;
  sub_403EE0(&v28);
  HIDWORD(v28) = 2;
  v29 = 2;
  DWORD2(v28) = cvCreateMat(2, 2, 5);
  DWORD1(v28) = *(_DWORD *)(DWORD2(v28) + 16);
  LOBYTE(v32) = 2;
  v24 = 0i64;
  v25 = 0;
  LODWORD(v24) = &CMyMatrix::`vftable';
  DWORD2(v24) = 0;
  sub_403EE0(&v24);
  HIDWORD(v24) = 2;
  v25 = 2;
  v14 = (double)v8;
  DWORD2(v24) = cvCreateMat(2, 2, 5);
  DWORD1(v24) = *(_DWORD *)(DWORD2(v24) + 16);
  v15 = (v20 - v19 / v14 * (v19 / v14) * v14) / v14;
  *(float *)DWORD1(v30) = v15;
  v16 = (v21 - v14 * v19 / v14 * v22 / v14) / v14;
  *(float *)(DWORD1(v30) + 4) = v16;
  *(float *)(DWORD1(v30) + 4 * v31) = v16;
  *(float *)(DWORD1(v30) + 4 * v31 + 4) = (v23 - v22 / (double)v8 * (v22 / (double)v8) * (double)v8) / (double)v8;
  cvSVD(DWORD2(v30), DWORD2(v26), DWORD2(v28), DWORD2(v24), 0);
  v17 = *(double *)libm_sse2_atan_precise().m128_u64;
  sub_403E70(&v24);
  LOBYTE(v32) = 1;
  sub_403E70(&v28);
  LOBYTE(v32) = 0;
  sub_403E70(&v26);
  v32 = -1;
  sub_403E70(&v30);
  return v17 * 180.0 / 3.141592653589793;
}
// 436860: using guessed type int __cdecl cvCreateMat(_DWORD, _DWORD, _DWORD);
// 436872: using guessed type int __cdecl cvSVD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4371FC: using guessed type __m128 libm_sse2_atan_precise(void);
// 43931C: using guessed type void *CMyMatrix::`vftable';

//----- (004345E0) --------------------------------------------------------
void __userpurge sub_4345E0(int a1@<ecx>, int a2@<edi>, int a3@<esi>, __m128d a4@<xmm5>, int a5, int a6, int a7)
{
  int v8; // eax
  unsigned int *v9; // eax
  _DWORD **v10; // ecx
  unsigned int *v11; // esi
  _DWORD **v12; // edx
  _DWORD *v13; // ecx
  unsigned int *v14; // edx
  __m128d v15; // xmm0
  double v16; // xmm0_8
  int v17; // edx
  double v18; // xmm6_8
  int v19; // ecx
  __m128d v20; // xmm5
  unsigned int *v21; // eax
  __m128d v22; // xmm3
  __m128d v23; // xmm2
  __m128 v24; // xmm0
  __m128 v25; // xmm0
  __m128 v26; // xmm1
  __m128d v27; // xmm3
  __m128d v28; // xmm2
  __m128 v29; // xmm0
  __m128 v30; // xmm0
  double v31; // xmm3_8
  double v32; // xmm2_8
  unsigned int v33; // xmm0_4
  int v34; // eax
  float v35; // xmm2_4
  float v36; // xmm1_4
  __m128d v39; // [esp-20h] [ebp-2Ch]
  double v40; // [esp-10h] [ebp-1Ch]
  int v41; // [esp-4h] [ebp-10h]
  int v42; // [esp-4h] [ebp-10h]

  v8 = *(_DWORD *)(a1 + 8);
  if ( v8 )
    v8 = *(_DWORD *)(v8 + 4);
  v41 = v8;
  v9 = (unsigned int *)operator new[](8 * (v8 + 1));
  v10 = *(_DWORD ***)(a1 + 8);
  v11 = v9;
  v12 = (_DWORD **)*v10;
  v13 = (_DWORD *)**v10;
  if ( v13 != v12 )
  {
    v14 = v9;
    do
    {
      v14 += 2;
      *(v14 - 2) = *(_DWORD *)((v13[2] << 6) + a7 + 32);
      *(v14 - 1) = *(_DWORD *)((v13[2] << 6) + a7 + 36);
      v13 = (_DWORD *)*v13;
    }
    while ( v13 != **(_DWORD ***)(a1 + 8) );
    v11 = v9;
  }
  v15 = (__m128d)libm_sse2_cos_precise(a2, a3);
  v40 = v15.m128d_f64[0];
  v39 = _mm_unpacklo_pd(v15, v15);
  v16 = *(double *)libm_sse2_sin_precise().m128_u64;
  v17 = v41;
  v18 = v16;
  a4.m128d_f64[0] = v16;
  v19 = 0;
  v20 = _mm_unpacklo_pd(a4, a4);
  if ( v41 > 0 )
  {
    if ( (unsigned int)v41 >= 4 )
    {
      v42 = v41 - v41 % 4;
      v21 = v11 + 1;
      do
      {
        v19 += 4;
        v22 = _mm_sub_pd(_mm_cvtps_pd(_mm_unpacklo_ps((__m128)*(v21 - 1), (__m128)v21[1])), (__m128d)0i64);
        v23 = _mm_sub_pd(_mm_cvtps_pd(_mm_unpacklo_ps((__m128)*v21, (__m128)v21[2])), (__m128d)0i64);
        v24 = _mm_cvtpd_ps(_mm_add_pd(_mm_sub_pd(_mm_mul_pd(v39, v22), _mm_mul_pd(v20, v23)), (__m128d)0i64));
        *(v21 - 1) = v24.m128_i32[0];
        v21[1] = _mm_shuffle_ps(v24, v24, 229).m128_u32[0];
        v25 = _mm_cvtpd_ps(_mm_add_pd(_mm_add_pd(_mm_mul_pd(v39, v23), _mm_mul_pd(v20, v22)), (__m128d)0i64));
        v26 = (__m128)v21[3];
        *v21 = v25.m128_i32[0];
        v21[2] = _mm_shuffle_ps(v25, v25, 229).m128_u32[0];
        v27 = _mm_sub_pd(_mm_cvtps_pd(_mm_unpacklo_ps(v26, (__m128)v21[5])), (__m128d)0i64);
        v28 = _mm_sub_pd(_mm_cvtps_pd(_mm_unpacklo_ps((__m128)v21[4], (__m128)v21[6])), (__m128d)0i64);
        v29 = _mm_cvtpd_ps(_mm_add_pd(_mm_sub_pd(_mm_mul_pd(v27, v39), _mm_mul_pd(v28, v20)), (__m128d)0i64));
        v21[3] = v29.m128_i32[0];
        v21[5] = _mm_shuffle_ps(v29, v29, 229).m128_u32[0];
        v30 = _mm_cvtpd_ps(_mm_add_pd(_mm_add_pd(_mm_mul_pd(v28, v39), _mm_mul_pd(v27, v20)), (__m128d)0i64));
        v21[4] = v30.m128_i32[0];
        v21[6] = _mm_shuffle_ps(v30, v30, 229).m128_u32[0];
        v21 += 8;
      }
      while ( v19 < v42 );
    }
    for ( ; v19 < v17; ++v19 )
    {
      v31 = *(float *)&v11[2 * v19] - 0.0;
      v32 = *(float *)&v11[2 * v19 + 1] - 0.0;
      *(float *)&v33 = v31 * v40 - v32 * v18 + 0.0;
      v11[2 * v19] = v33;
      *(float *)&v11[2 * v19 + 1] = v31 * v18 + v32 * v40 + 0.0;
    }
  }
  v34 = 0;
  for ( *(_OWORD *)(a1 + 968) = xmmword_43A370; v34 < v17; ++v34 )
  {
    v35 = *(float *)&v11[2 * v34];
    if ( *(double *)(a1 + 968) > v35 )
      *(double *)(a1 + 968) = v35;
    v36 = *(float *)&v11[2 * v34];
    if ( v36 > *(double *)(a1 + 976) )
      *(double *)(a1 + 976) = v36;
  }
  operator delete[](v11);
}
// 4345E0: could not find valid save-restore pair for ebp
// 4345E0: could not find valid save-restore pair for edi
// 4345E0: could not find valid save-restore pair for esi
// 436A62: using guessed type __m128 __stdcall libm_sse2_cos_precise(_DWORD, _DWORD);
// 436A68: using guessed type __m128 libm_sse2_sin_precise(void);
// 43A370: using guessed type __int128 xmmword_43A370;

//----- (004348C0) --------------------------------------------------------
void __thiscall sub_4348C0(_DWORD *this, __int64 a2, int a3)
{
  int v4; // esi
  int v5; // esi
  int v6; // ebx
  int v7; // edx
  _DWORD *v8; // ecx
  _DWORD *v9; // eax
  int v10; // eax

  v4 = this[2];
  if ( v4 )
  {
    v5 = *(_DWORD *)(v4 + 4);
    if ( v5 >= 3 )
    {
      v6 = (int)(this + 12);
      sub_4317E0((int)(this + 12), v5);
      v7 = this[14];
      v8 = *(_DWORD **)this[2];
      v9 = (_DWORD *)*v8;
      if ( (_DWORD *)*v8 != v8 )
      {
        do
        {
          v7 += 8;
          *(_DWORD *)(v7 - 8) = *(_DWORD *)((v9[2] << 6) + a3 + 32);
          *(_DWORD *)(v7 - 4) = *(_DWORD *)((v9[2] << 6) + a3 + 36);
          v9 = (_DWORD *)*v9;
        }
        while ( v9 != *(_DWORD **)this[2] );
        v6 = (int)(this + 12);
      }
      v10 = 4;
      if ( v5 >= 10 )
      {
        if ( v5 >= 20 )
        {
          if ( v5 < 30 )
            v10 = 3;
        }
        else
        {
          v10 = 2;
        }
      }
      else
      {
        v10 = 1;
      }
      sub_42BE00(v6, 0.0, a2, v10);
      sub_42D210(v6, v5);
    }
  }
}

//----- (00434990) --------------------------------------------------------
double __thiscall sub_434990(int this, int a2, int a3)
{
  int v3; // ebx
  double v4; // xmm1_8
  _DWORD *v5; // edi
  _DWORD *v6; // esi
  int v7; // eax
  int v8; // eax
  double result; // st7

  v3 = *(_DWORD *)(this + 8);
  v4 = 0.0;
  v5 = *(_DWORD **)v3;
  v6 = **(_DWORD ***)v3;
  if ( (_DWORD *)*v5 != v5 )
  {
    do
    {
      v7 = v6[2];
      v6 = (_DWORD *)*v6;
      v4 = v4 + dword_43E048[(*(_DWORD *)(a3 + 4 * v7) - *(_DWORD *)(a3 + 4 * v7) % dword_501978) / dword_501978];
    }
    while ( v6 != v5 );
    v3 = *(_DWORD *)(this + 8);
  }
  if ( v3 )
    v8 = *(_DWORD *)(v3 + 4);
  else
    v8 = 0;
  result = v4 / (double)v8;
  *(double *)(this + 952) = result;
  return result;
}
// 43E048: using guessed type float dword_43E048[10];
// 501978: using guessed type int dword_501978;

//----- (00434A20) --------------------------------------------------------
double __thiscall sub_434A20(int this, int a2)
{
  double v3; // xmm1_8
  _DWORD *v4; // edx
  _DWORD *v5; // eax
  int v6; // ecx
  double v8; // [esp+4h] [ebp-8h]

  v3 = 0.0;
  v8 = 0.0;
  v4 = **(_DWORD ***)(this + 8);
  v5 = (_DWORD *)*v4;
  if ( (_DWORD *)*v4 != v4 )
  {
    do
    {
      v6 = v5[2];
      v5 = (_DWORD *)*v5;
      v3 = v3 + (double)*(int *)((v6 << 6) + a2 + 8);
    }
    while ( v5 != v4 );
    v8 = v3;
  }
  return v8 / (*(double *)(this + 912) - *(double *)(this + 904) + 0.1);
}

//----- (00434A80) --------------------------------------------------------
double __thiscall sub_434A80(int this)
{
  int v1; // eax
  int v2; // edi

  v1 = *(_DWORD *)(this + 8);
  if ( v1 )
    v2 = *(_DWORD *)(v1 + 4);
  else
    v2 = 0;
  return (float)((sub_42D210(this + 48, this) - *(double *)(this + 952) / 5.0) * (double)v2);
}

//----- (00434AE0) --------------------------------------------------------
void __thiscall sub_434AE0(_DWORD *this, int a2)
{
  _DWORD **v2; // edx
  _DWORD *v3; // edx
  _DWORD *v4; // eax

  v2 = (_DWORD **)this[2];
  if ( v2 )
  {
    v3 = *v2;
    v4 = (_DWORD *)*v3;
    if ( (_DWORD *)*v3 != v3 )
    {
      do
      {
        *(_BYTE *)((v4[2] << 6) + a2 + 12) = 1;
        v4 = (_DWORD *)*v4;
      }
      while ( v4 != *(_DWORD **)this[2] );
    }
  }
}

//----- (00434B20) --------------------------------------------------------
_DWORD *__thiscall sub_434B20(_DWORD *this, int a2)
{
  *this = &CLMInformation::`vftable';
  this[24] = 0;
  this[25] = 0;
  this[26] = 0;
  this[27] = 0;
  this[28] = 0;
  this[29] = 0;
  this[30] = 0;
  this[31] = 0;
  this[32] = 0;
  this[33] = 0;
  this[34] = 0;
  this[35] = 0;
  this[36] = 0;
  this[37] = 0;
  this[38] = 0;
  this[39] = 0;
  this[40] = 0;
  this[41] = 0;
  this[42] = 0;
  this[43] = 0;
  this[44] = 0;
  this[45] = 0;
  this[46] = 0;
  this[47] = 0;
  this[48] = 0;
  this[49] = 0;
  this[50] = 0;
  this[51] = a2;
  return this;
}
// 43A7B4: using guessed type void *CLMInformation::`vftable';

//----- (00434C30) --------------------------------------------------------
void __thiscall sub_434C30(void *this)
{
  void (__thiscall ***v2)(_DWORD, _DWORD); // esi
  void (__thiscall ***i)(_DWORD, _DWORD); // ebx

  *(_DWORD *)this = &CDocument::`vftable';
  v2 = (void (__thiscall ***)(_DWORD, _DWORD))*((_DWORD *)this + 2);
  if ( v2 )
  {
    for ( i = (void (__thiscall ***)(_DWORD, _DWORD))*((_DWORD *)this + 3); v2 != i; v2 += 14 )
      (**v2)(v2, 0);
    operator delete(*((void **)this + 2));
    *((_DWORD *)this + 2) = 0;
    *((_DWORD *)this + 3) = 0;
    *((_DWORD *)this + 4) = 0;
  }
}
// 43A7D0: using guessed type void *CDocument::`vftable';

//----- (00434CA0) --------------------------------------------------------
void __thiscall sub_434CA0(void *this)
{
  int v2; // eax

  *(_DWORD *)this = &CLMInformation::`vftable';
  if ( *((_DWORD *)this + 48) )
  {
    operator delete(*((void **)this + 48));
    *((_DWORD *)this + 48) = 0;
    *((_DWORD *)this + 49) = 0;
    *((_DWORD *)this + 50) = 0;
  }
  if ( *((_DWORD *)this + 45) )
  {
    operator delete(*((void **)this + 45));
    *((_DWORD *)this + 45) = 0;
    *((_DWORD *)this + 46) = 0;
    *((_DWORD *)this + 47) = 0;
  }
  if ( *((_DWORD *)this + 42) )
  {
    operator delete(*((void **)this + 42));
    *((_DWORD *)this + 42) = 0;
    *((_DWORD *)this + 43) = 0;
    *((_DWORD *)this + 44) = 0;
  }
  v2 = *((_DWORD *)this + 39);
  if ( v2 )
  {
    sub_417570(v2, *((_DWORD *)this + 40));
    operator delete(*((void **)this + 39));
    *((_DWORD *)this + 39) = 0;
    *((_DWORD *)this + 40) = 0;
    *((_DWORD *)this + 41) = 0;
  }
  if ( *((_DWORD *)this + 36) )
  {
    operator delete(*((void **)this + 36));
    *((_DWORD *)this + 36) = 0;
    *((_DWORD *)this + 37) = 0;
    *((_DWORD *)this + 38) = 0;
  }
  if ( *((_DWORD *)this + 33) )
  {
    operator delete(*((void **)this + 33));
    *((_DWORD *)this + 33) = 0;
    *((_DWORD *)this + 34) = 0;
    *((_DWORD *)this + 35) = 0;
  }
  if ( *((_DWORD *)this + 30) )
  {
    operator delete(*((void **)this + 30));
    *((_DWORD *)this + 30) = 0;
    *((_DWORD *)this + 31) = 0;
    *((_DWORD *)this + 32) = 0;
  }
  if ( *((_DWORD *)this + 27) )
  {
    operator delete(*((void **)this + 27));
    *((_DWORD *)this + 27) = 0;
    *((_DWORD *)this + 28) = 0;
    *((_DWORD *)this + 29) = 0;
  }
  if ( *((_DWORD *)this + 24) )
  {
    operator delete(*((void **)this + 24));
    *((_DWORD *)this + 24) = 0;
    *((_DWORD *)this + 25) = 0;
    *((_DWORD *)this + 26) = 0;
  }
}
// 43A7B4: using guessed type void *CLMInformation::`vftable';

//----- (00434E70) --------------------------------------------------------
void *__thiscall sub_434E70(void *this, char a2)
{
  sub_434C30(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (00434EA0) --------------------------------------------------------
int __cdecl sub_434EA0(_DWORD *a1, int a2, int a3)
{
  int Size; // eax
  int Image; // esi
  int v5; // edi
  int v6; // edi
  int v7; // eax
  int v8; // ecx
  int v9; // edx
  float v10; // xmm2_4
  float v11; // xmm3_4
  int v13; // [esp+1Ch] [ebp-14h]
  int v14; // [esp+20h] [ebp-10h]
  int v15; // [esp+28h] [ebp-8h] BYREF

  Size = cvGetSize(a1);
  Image = cvCreateImage(Size);
  v5 = a1[11];
  v14 = a1[10];
  v15 = Image;
  cvSmooth(a1, Image, 2, a3, a3, 0, 0, 0, 0);
  cvSetZero(a2);
  v13 = v5 - 1;
  if ( v5 - 1 > 1 )
  {
    v6 = 1;
    v7 = v14 - 1;
    v8 = v13;
    do
    {
      v9 = 1;
      if ( v7 > 1 )
      {
        do
        {
          v10 = (float)*(unsigned __int8 *)(a1[17] + v6 * a1[18] + v9);
          v11 = (float)*(unsigned __int8 *)(*(_DWORD *)(Image + 68) + v6 * *(_DWORD *)(Image + 72) + v9);
          if ( v10 > v11 * 0.9 || (float)fabs((float)(v10 - v11)) < 25.5 )
            *(_BYTE *)(v9 + v6 * *(_DWORD *)(a2 + 72) + *(_DWORD *)(a2 + 68)) = 0;
          else
            *(_BYTE *)(v9 + v6 * *(_DWORD *)(a2 + 72) + *(_DWORD *)(a2 + 68)) = -1;
          ++v9;
          v7 = v14 - 1;
        }
        while ( v9 < v14 - 1 );
        v8 = v13;
      }
      ++v6;
    }
    while ( v6 < v8 );
  }
  return cvReleaseImage(&v15);
}
// 436836: using guessed type int __cdecl cvSmooth(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 436848: using guessed type int __cdecl cvCreateImage(_DWORD);
// 43684E: using guessed type int __cdecl cvReleaseImage(_DWORD);
// 43685A: using guessed type int __cdecl cvSetZero(_DWORD);
// 436866: using guessed type __int64 __cdecl cvGetSize(_DWORD);

//----- (00435000) --------------------------------------------------------
void __usercall sub_435000(__m128d a1@<xmm5>, int a2, int a3, __m128i *a4, double a5, char a6)
{
  int *v6; // eax
  int *v7; // esi
  _QWORD *v8; // ecx
  int v9; // edx
  unsigned int v10; // edi
  void *v11; // eax
  void *v12; // ecx
  void *v13[2]; // [esp+24h] [ebp-34h] BYREF
  int v14; // [esp+2Ch] [ebp-2Ch]
  void *v15[2]; // [esp+30h] [ebp-28h] BYREF
  int v16; // [esp+38h] [ebp-20h]
  void *v17[2]; // [esp+3Ch] [ebp-1Ch] BYREF
  int v18; // [esp+44h] [ebp-14h]
  int v19; // [esp+54h] [ebp-4h]

  v6 = (int *)operator new(0x20u);
  v7 = v6;
  if ( v6 )
  {
    *(_OWORD *)v6 = 0i64;
    *((_OWORD *)v6 + 1) = 0i64;
    *v6 = (int)&CDocument::`vftable';
    v6[2] = 0;
    v6[3] = 0;
    v6[4] = 0;
  }
  else
  {
    v7 = 0;
  }
  v15[0] = 0;
  v16 = 0;
  v19 = 2;
  v17[0] = 0;
  v18 = 0;
  v15[1] = 0;
  v17[1] = 0;
  v13[0] = 0;
  v13[1] = 0;
  v14 = 0;
  sub_4077E0(v13, 0x2710u);
  v8 = v13[0];
  v9 = 0;
  v10 = (unsigned int)(v13[1] - v13[0] + 7) >> 3;
  if ( v13[0] > v13[1] )
    v10 = 0;
  if ( v10 )
  {
    do
    {
      ++v9;
      *v8++ = 0i64;
    }
    while ( v9 != v10 );
  }
  sub_435DD0(a1, a2, v7);
  sub_435A50(a2, v15, (int)v7);
  sub_435B20(a2, (int *)v15, v17, (int)v7);
  if ( a6 == 1 )
    sub_435570(a2, (int)v7, (int *)v17);
  sub_435770(a2, a3, a4, (int *)v13, (int *)v17, v7, a5);
  if ( v7 )
    (*(void (__thiscall **)(int *, int))*v7)(v7, 1);
  v11 = v15[0];
  v12 = v17[0];
  v15[1] = v15[0];
  v17[1] = v17[0];
  if ( v13[0] )
  {
    operator delete(v13[0]);
    v11 = v15[0];
    v12 = v17[0];
  }
  if ( v12 )
  {
    operator delete(v12);
    v11 = v15[0];
    v17[0] = 0;
    v17[1] = 0;
    v18 = 0;
  }
  if ( v11 )
    operator delete(v11);
}
// 43A7D0: using guessed type void *CDocument::`vftable';

//----- (00435200) --------------------------------------------------------
int __cdecl sub_435200(int a1, int a2)
{
  double *v2; // ecx
  double v3; // xmm4_8
  double v4; // xmm3_8
  double *v5; // eax
  __int64 v7; // [esp+0h] [ebp-1Ch] BYREF
  double v8; // [esp+8h] [ebp-14h] BYREF
  double v9; // [esp+10h] [ebp-Ch] BYREF

  v2 = &v9;
  v7 = 0x3FF0000000000000i64;
  v3 = (double)*(int *)(a2 + 40);
  v4 = (double)*(int *)(a2 + 44);
  v8 = 2200.0 / v3;
  v9 = 1000.0 / v4;
  if ( 2200.0 / v3 <= 1000.0 / v4 )
    v2 = &v8;
  v5 = (double *)&v7;
  if ( *v2 <= 1.0 )
    v5 = v2;
  HIDWORD(v9) = cvCreateImage((int)(v3 * *v5));
  cvResize(a2, HIDWORD(v9), 1);
  cvShowImage(a1, HIDWORD(v9));
  return cvReleaseImage((char *)&v9 + 4);
}
// 43681E: using guessed type int __cdecl cvResize(_DWORD, _DWORD, _DWORD);
// 436848: using guessed type int __cdecl cvCreateImage(_DWORD);
// 43684E: using guessed type int __cdecl cvReleaseImage(_DWORD);
// 4368A8: using guessed type int __cdecl cvShowImage(_DWORD, _DWORD);

//----- (004352D0) --------------------------------------------------------
int __cdecl sub_4352D0(int a1, int a2, int *a3, int a4, _DWORD *a5, int a6)
{
  int v6; // ebx
  int v7; // esi
  int v8; // ecx
  int v9; // edi
  int v10; // eax
  int v11; // edx
  int v12; // ecx
  int v13; // eax
  int v14; // ecx
  int v15; // edx
  int v16; // eax
  int v17; // ecx
  int v18; // ecx
  int *v19; // eax
  int v20; // edx
  int v21; // eax
  int v22; // eax
  int v23; // edx
  int v24; // ecx
  int v25; // eax
  int v26; // ecx
  int v27; // eax
  bool v28; // zf
  int *v29; // eax
  int v30; // ebx
  int v31; // edi
  int *v32; // eax
  _DWORD *v33; // ebx
  int v34; // edx
  bool v35; // cc
  double v36; // xmm0_8
  int v37; // eax
  __m128i v38; // xmm0
  int *v39; // eax
  int *v40; // eax
  int result; // eax
  int v42; // [esp+Ch] [ebp-1Ch] BYREF
  int v43; // [esp+10h] [ebp-18h] BYREF
  int *v44; // [esp+14h] [ebp-14h]
  int v45; // [esp+18h] [ebp-10h]
  int v46; // [esp+1Ch] [ebp-Ch]
  int v47; // [esp+20h] [ebp-8h]
  int v48; // [esp+24h] [ebp-4h]

  v6 = a2;
  v7 = a1;
  v8 = *(_DWORD *)(a4 + 4) - *(_DWORD *)a4;
  a4 = *(_DWORD *)a4;
  v9 = -1;
  v48 = -1;
  v10 = v8 / 40;
  v47 = -1;
  v45 = v8 / 40;
  if ( v8 / 40 > 0 )
  {
    v11 = a4;
    v12 = 0;
    v46 = 0;
    do
    {
      if ( *(_BYTE *)(v12 + v11 + 32) == 1 )
      {
        v13 = (int)*(float *)(v12 + v11);
        v14 = (int)*(float *)(v12 + v11 + 4);
        v15 = v47;
        if ( v13 < v7 )
          v7 = v13;
        if ( v13 > v9 )
          v9 = v13;
        v48 = v9;
        if ( v14 < v6 )
          v6 = v14;
        if ( v14 > v47 )
          v15 = v14;
        v16 = (int)*(float *)(v46 + a4 + 16);
        v17 = (int)*(float *)(v46 + a4 + 20);
        v9 = v48;
        if ( v16 < v7 )
          v7 = (int)*(float *)(v46 + a4 + 16);
        if ( v16 > v48 )
          v9 = (int)*(float *)(v46 + a4 + 16);
        v10 = v45;
        v48 = v9;
        if ( v17 < v6 )
          v6 = v17;
        if ( v17 > v15 )
          v15 = v17;
        v12 = v46;
        v47 = v15;
        v11 = a4;
      }
      v12 += 40;
      --v10;
      v46 = v12;
      v45 = v10;
    }
    while ( v10 );
  }
  v18 = (a3[3] - a3[2]) / 56;
  v43 = v18;
  if ( v18 > 0 )
  {
    v19 = (int *)(a3[2] + 8);
    v44 = v19;
    do
    {
      v20 = *v19;
      v21 = v19[1] - *v19;
      v42 = v20;
      v46 = v21 >> 5;
      if ( v21 >> 5 > 0 )
      {
        v22 = 0;
        v45 = 0;
        a3 = (int *)(v20 + 8);
        do
        {
          a4 = (*(_DWORD *)(v20 + v22 + 12) - *(_DWORD *)(v20 + v22 + 8)) / 40;
          if ( a4 > 0 )
          {
            v23 = 0;
            v24 = *a3;
            v48 = *a3;
            do
            {
              v25 = (int)*(double *)(v23 + v24 + 8);
              v23 += 40;
              v26 = (int)*(double *)(v23 + v24 - 24);
              if ( v25 < v7 )
                v7 = v25;
              if ( v25 > v9 )
                v9 = v25;
              v27 = v47;
              if ( v26 < v6 )
                v6 = v26;
              if ( v26 > v47 )
                v27 = v26;
              v28 = a4-- == 1;
              v24 = v48;
              v47 = v27;
            }
            while ( !v28 );
            v48 = v9;
          }
          a3 += 8;
          v22 = v45 + 32;
          v28 = v46-- == 1;
          v20 = v42;
          v45 += 32;
        }
        while ( !v28 );
        v18 = v43;
      }
      v19 = v44 + 14;
      --v18;
      v44 += 14;
      v43 = v18;
    }
    while ( v18 );
  }
  v29 = (int *)&a3;
  a3 = 0;
  a4 = v7 - a6;
  if ( v7 - a6 >= 0 )
    v29 = &a4;
  v30 = v6 - a6;
  v31 = *v29;
  v32 = (int *)&a3;
  if ( v30 >= 0 )
    v32 = &a4;
  a4 = v30;
  v33 = a5;
  v34 = v47 + a6;
  a3 = 0;
  a3 = (int *)*v32;
  a6 += v48;
  v35 = a1 - 1 < a6;
  v42 = a2 - 1;
  a4 = a1 - 1;
  v43 = v34;
  v36 = (double)(int)a3;
  *a5 = (int)((double)v31 * 0.9);
  v37 = (int)(v36 * 0.9);
  v38 = _mm_cvtsi32_si128(a1 - 1);
  v33[1] = v37;
  v39 = &a4;
  if ( !v35 )
    v39 = &a6;
  v33[2] = (int)((double)(*v39 - v31 + 1) * 0.9 + _mm_cvtepi32_pd(v38).m128d_f64[0] * 0.09999999999999998);
  v40 = &v42;
  if ( a2 - 1 >= v34 )
    v40 = &v43;
  result = (int)((double)(*v40 - (int)a3 + 1) * 0.9 + (double)(a2 - 1) * 0.09999999999999998);
  v33[3] = result;
  return result;
}

//----- (00435570) --------------------------------------------------------
int __cdecl sub_435570(int a1, int a2, int *a3)
{
  int v3; // esi
  int v4; // edi
  __int128 v5; // xmm2
  __int128 v6; // xmm1
  int v7; // ebx
  int v8; // ecx
  int v9; // edx
  int result; // eax
  int v11; // edi
  int v12; // ecx
  unsigned __int64 v13; // [esp+Ch] [ebp-54h]
  unsigned __int64 v14; // [esp+1Ch] [ebp-44h]
  __int64 v15; // [esp+2Ch] [ebp-34h]
  unsigned int v16; // [esp+5Ch] [ebp-4h]

  v16 = 0;
  v3 = *a3;
  if ( (a3[1] - *a3) / 40 )
  {
    v4 = 0;
    do
    {
      v13 = _mm_loadu_si128((const __m128i *)(v4 + v3)).m128i_u64[0];
      v14 = _mm_loadu_si128((const __m128i *)(v4 + v3 + 16)).m128i_u64[0];
      v15 = *(_QWORD *)(v4 + v3 + 32);
      rand();
      rand();
      rand();
      if ( (_BYTE)v15 == 1 )
      {
        v5 = xmmword_43A280;
        v6 = 0i64;
      }
      else
      {
        v6 = xmmword_43A280;
        v5 = 0i64;
      }
      cvLine(
        a1,
        (int)*(float *)&v13,
        (int)*((float *)&v13 + 1),
        (int)*(float *)&v14,
        (int)*((float *)&v14 + 1),
        v6,
        DWORD1(v6),
        DWORD2(v6),
        HIDWORD(v6),
        v5,
        DWORD1(v5),
        DWORD2(v5),
        HIDWORD(v5),
        8,
        8,
        0);
      ++v16;
      v4 += 40;
      v3 = *a3;
    }
    while ( v16 < (a3[1] - *a3) / 40 );
  }
  v7 = 0;
  v8 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 8);
  v9 = (int)((unsigned __int64)(2454267027i64 * v8) >> 32) >> 5;
  result = v8 / 56;
  if ( v8 / 56 > 0 )
  {
    v11 = 0;
    do
    {
      sub_425440(v11 + *(_DWORD *)(a2 + 8), v9, a1);
      v12 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 8);
      ++v7;
      v11 += 56;
      v9 = (int)((unsigned __int64)(2454267027i64 * v12) >> 32) >> 5;
      result = v12 / 56;
    }
    while ( v7 < v12 / 56 );
  }
  return result;
}
// 4368A2: using guessed type int __cdecl cvLine(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 43A280: using guessed type __int128 xmmword_43A280;

//----- (00435770) --------------------------------------------------------
int __cdecl sub_435770(int a1, int a2, __m128i *a3, int *a4, int *a5, int *a6, double a7)
{
  int *v7; // edi
  double v8; // xmm0_8
  int v9; // ebx
  unsigned int v10; // eax
  unsigned int v11; // ecx
  unsigned int v12; // edx
  int v13; // edi
  unsigned int v14; // edx
  _QWORD *v15; // esi
  __int64 Size; // rax
  __int64 v17; // rax
  int v18; // esi
  bool v19; // cc
  __int64 v20; // rax
  __int64 v21; // rax
  int *v22; // edx
  __m128i v23; // xmm3
  __m128i v24; // xmm0
  int v26; // [esp+2Ch] [ebp-1C4h]
  int v27; // [esp+30h] [ebp-1C0h]
  int v28; // [esp+34h] [ebp-1BCh]
  int v29; // [esp+38h] [ebp-1B8h]
  double v30[3]; // [esp+68h] [ebp-188h]
  __int128 v31; // [esp+80h] [ebp-170h]
  __int64 v32; // [esp+90h] [ebp-160h]
  unsigned __int64 v33; // [esp+98h] [ebp-158h] BYREF
  char v34[268]; // [esp+A0h] [ebp-150h] BYREF
  int v35; // [esp+1ECh] [ebp-4h]

  v7 = a4;
  LODWORD(v33) = a4;
  sub_403F00(v34, "Run - Parameter Estimation & Dewarping");
  v35 = 0;
  v8 = *(double *)libm_sse2_sqrt_precise(v26, v27, v28, v29).m128_u64;
  v9 = 0;
  v30[1] = v8 * 150.0;
  v30[0] = v8 * 200.0;
  v30[2] = 3.402823466385289e38;
  v31 = xmmword_43A890;
  v32 = 0x3FF0000000000000i64;
  do
  {
    v10 = v7[1];
    v11 = *v7;
    v12 = v10 - *v7 + 7;
    v13 = 0;
    v14 = v12 >> 3;
    v15 = (_QWORD *)v11;
    if ( v11 > v10 )
      v14 = 0;
    if ( v14 )
    {
      do
      {
        ++v13;
        *v15++ = 0i64;
      }
      while ( v13 != v14 );
    }
    *(_QWORD *)(v11 + 64) = 0x3FF0000000000000i64;
    Size = cvGetSize(a1);
    v7 = (int *)v33;
    sub_4363E0(Size, a6, a5, (int *)v33);
    v17 = cvGetSize(a1);
    sub_436030(v17, a6, a5, v7, v30[v9], *(double *)((char *)&v31 + v9 * 8));
    ++v9;
  }
  while ( v9 < 3 );
  v20 = cvGetSize(a1);
  v18 = v20;
  v19 = (int)v20 < SHIDWORD(v20);
  LODWORD(v20) = (char *)&v33 + 4;
  v33 = __PAIR64__(HIDWORD(v20), v18);
  if ( !v19 )
    LODWORD(v20) = &v33;
  sub_425550(
    v18,
    SHIDWORD(v20),
    (int)a6,
    a5,
    (double)v18 * 0.5,
    (double)SHIDWORD(v20) * 0.5,
    *v7,
    (double)*(int *)v20 * *(double *)(*v7 + 64),
    *(double *)&qword_43E0E8,
    a7);
  v21 = cvGetSize(a2);
  sub_4352D0(v21, SHIDWORD(v21), a6, (int)a5, a3, 25);
  v22 = (int *)(a1 + 40);
  v23 = _mm_cvtsi32_si128(*(_DWORD *)(a1 + 40));
  if ( *(_DWORD *)(a1 + 40) < *(_DWORD *)(a1 + 44) )
    v22 = (int *)(a1 + 44);
  v24 = _mm_loadu_si128(a3);
  sub_425F90(
    a1,
    a2,
    v24.m128i_i32[0],
    v24.m128i_i32[1],
    v24.m128i_i32[2],
    v24.m128i_i32[3],
    _mm_cvtepi32_pd(v23).m128d_f64[0] * 0.5,
    (double)*(int *)(a1 + 44) * 0.5,
    *v7,
    (double)*v22 * *(double *)(*v7 + 64),
    *(double *)&qword_43E0E8,
    a7);
  v35 = -1;
  return sub_403F40(v34);
}
// 4357F8: variable 'v26' is possibly undefined
// 4357F8: variable 'v27' is possibly undefined
// 4357F8: variable 'v28' is possibly undefined
// 4357F8: variable 'v29' is possibly undefined
// 436866: using guessed type __int64 __cdecl cvGetSize(_DWORD);
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);
// 43A890: using guessed type __int128 xmmword_43A890;
// 43E0E8: using guessed type __int64 qword_43E0E8;

//----- (00435A50) --------------------------------------------------------
int __cdecl sub_435A50(int a1, _DWORD *a2, int a3)
{
  int Size; // eax
  double v4; // st7
  int Image; // [esp+14h] [ebp-11Ch] BYREF
  char v7[264]; // [esp+18h] [ebp-118h] BYREF
  int v8; // [esp+12Ch] [ebp-4h]

  sub_403F00(v7, "Run - Line Segment Detection");
  v8 = 0;
  Size = cvGetSize(a1);
  Image = cvCreateImage(Size);
  v4 = cvCvtColor(a1, Image, 6);
  sub_416880(v4, Image, a2, *(double *)(a3 + 24) * 4.0);
  cvReleaseImage(&Image);
  v8 = -1;
  return sub_403F40(v7);
}
// 43683C: using guessed type double __cdecl cvCvtColor(_DWORD, _DWORD, _DWORD);
// 436848: using guessed type int __cdecl cvCreateImage(_DWORD);
// 43684E: using guessed type int __cdecl cvReleaseImage(_DWORD);
// 436866: using guessed type __int64 __cdecl cvGetSize(_DWORD);

//----- (00435B20) --------------------------------------------------------
unsigned int __usercall sub_435B20@<eax>(int a1@<edi>, int *a2, _DWORD *a3, int a4)
{
  int v4; // esi
  unsigned int v5; // ebx
  double v6; // xmm3_8
  unsigned int result; // eax
  int v8; // edi
  __m128i v9; // xmm2
  __m128i v10; // xmm1
  int v11; // esi
  signed int v12; // ebx
  float v13; // xmm7_4
  double v14; // xmm4_8
  __m128i v15; // xmm3
  double v16; // xmm2_8
  double v17; // xmm1_8
  double v18; // xmm0_8
  float v19; // xmm0_4
  int v20; // [esp-4h] [ebp-70h]
  int v21; // [esp+0h] [ebp-6Ch]
  int v22; // [esp+4h] [ebp-68h]
  int v23; // [esp+8h] [ebp-64h]
  unsigned int v24; // [esp+Ch] [ebp-60h]
  float v25; // [esp+10h] [ebp-5Ch]
  float v26; // [esp+14h] [ebp-58h]
  float v27; // [esp+18h] [ebp-54h]
  int v28; // [esp+1Ch] [ebp-50h]
  int v29; // [esp+20h] [ebp-4Ch]
  double v30; // [esp+2Ch] [ebp-40h]
  __m128i v31; // [esp+3Ch] [ebp-30h] BYREF
  __m128i v32; // [esp+4Ch] [ebp-20h]
  __int64 v33; // [esp+5Ch] [ebp-10h]

  v4 = *a2;
  v5 = 0;
  v6 = *(double *)(a4 + 24) * 6.0;
  v24 = 0;
  v30 = v6;
  v20 = a1;
  result = (a2[1] - *a2) / 40;
  if ( result )
  {
    v8 = 0;
    v29 = 0;
    do
    {
      v9 = _mm_loadu_si128((const __m128i *)(v8 + v4 + 16));
      v33 = *(_QWORD *)(v8 + v4 + 32);
      v32 = v9;
      LOBYTE(v33) = 1;
      v25 = COERCE_FLOAT(_mm_cvtsi128_si32(v9));
      v10 = _mm_loadu_si128((const __m128i *)(v8 + v4));
      v11 = (int)(*(double *)(v8 + v4 + 24) / v6);
      v31 = v10;
      v27 = COERCE_FLOAT(_mm_cvtsi128_si32(v10));
      v28 = _mm_cvtsi128_si32(_mm_srli_si128(v10, 4));
      v26 = COERCE_FLOAT(_mm_cvtsi128_si32(_mm_srli_si128(v9, 4)));
      if ( v11 < 2 )
      {
        sub_4214D0(a3, &v31);
        v6 = v30;
      }
      else
      {
        v12 = 0;
        v13 = *(float *)&v28;
        v14 = (double)v11;
        do
        {
          v15 = _mm_cvtsi32_si128(v12++);
          *(double *)v15.m128i_i64 = _mm_cvtepi32_pd(v15).m128d_f64[0] / v14;
          v16 = 1.0 - *(double *)v15.m128i_i64;
          v17 = v25 * (1.0 - *(double *)v15.m128i_i64) + v27 * *(double *)v15.m128i_i64;
          v18 = v13 * *(double *)v15.m128i_i64;
          *(double *)v15.m128i_i64 = (double)v12 / v14;
          *(float *)v31.m128i_i32 = v17;
          *(float *)&v31.m128i_i32[1] = v26 * v16 + v18;
          *(float *)v32.m128i_i32 = v25 * (1.0 - *(double *)v15.m128i_i64) + v27 * *(double *)v15.m128i_i64;
          *(float *)&v32.m128i_i32[1] = v26 * (1.0 - *(double *)v15.m128i_i64) + v13 * *(double *)v15.m128i_i64;
          *(float *)&v18 = (float)(*(float *)v32.m128i_i32 + *(float *)v31.m128i_i32) * 0.5;
          v31.m128i_i32[2] = LODWORD(v18);
          *(float *)&v18 = (float)(*(float *)&v32.m128i_i32[1] + *(float *)&v31.m128i_i32[1]) * 0.5;
          v31.m128i_i32[3] = LODWORD(v18);
          v19 = *(double *)libm_sse2_sqrt_precise(v20, v21, v22, v23).m128_u64;
          *(double *)&v32.m128i_i64[1] = v19;
          sub_4214D0(a3, &v31);
          v14 = (double)v11;
          v13 = *(float *)&v28;
        }
        while ( v12 < v11 );
        v6 = v30;
        v8 = v29;
        v5 = v24;
      }
      ++v5;
      v8 += 40;
      v24 = v5;
      v29 = v8;
      v4 = *a2;
      result = (a2[1] - *a2) / 40;
    }
    while ( v5 < result );
  }
  return result;
}
// 435B20: could not find valid save-restore pair for edi
// 435BF9: conditional instruction was optimized away because esi.4>=2
// 435D2C: variable 'v20' is possibly undefined
// 435D2C: variable 'v21' is possibly undefined
// 435D2C: variable 'v22' is possibly undefined
// 435D2C: variable 'v23' is possibly undefined
// 436A50: using guessed type __m128 __stdcall libm_sse2_sqrt_precise(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00435DD0) --------------------------------------------------------
int __usercall sub_435DD0@<eax>(__m128d a1@<xmm5>, int a2, _DWORD *a3)
{
  int Size; // eax
  int v4; // eax
  _DWORD *Image; // [esp+18h] [ebp-1A8h] BYREF
  int v7; // [esp+1Ch] [ebp-1A4h] BYREF
  char v8[264]; // [esp+20h] [ebp-1A0h] BYREF
  int v9[34]; // [esp+128h] [ebp-98h] BYREF
  int v10; // [esp+1BCh] [ebp-4h]

  sub_403F00(v8, "Run - Text Line Detection");
  v10 = 0;
  Size = cvGetSize(a2);
  Image = (_DWORD *)cvCreateImage(Size);
  v4 = cvGetSize(a2);
  v7 = cvCreateImage(v4);
  cvCvtColor(a2, Image, 6);
  sub_434EA0(Image, v7, 31);
  memset(v9, 0, sizeof(v9));
  sub_426F90(v9);
  LOBYTE(v10) = 1;
  sub_42A1D0(v9, v7);
  sub_4276C0(v9);
  sub_42A0F0(v9, 10, 3000);
  sub_42ABA0((int)v9);
  sub_428700(v9, 10, 32);
  sub_429C20((int)v9);
  sub_42A9E0((int)v9, (int)a3);
  sub_428080(v9);
  sub_42A690(v9);
  sub_429EB0(v9, a1, 0x3E0000003ECCCCCDi64, 1u);
  sub_4283B0(v9);
  sub_427CA0(v9, 1.0);
  sub_428080(v9);
  sub_42A690(v9);
  sub_42AAF0(v9);
  sub_42AB30((int)v9, a1, 0);
  sub_4283B0(v9);
  sub_427C60(v9, 1.0);
  sub_428040(v9, 30, 2, 4);
  sub_428190(v9);
  sub_42AB70(v9);
  sub_427CE0(v9, (int)a3);
  sub_4057B0(a3);
  cvReleaseImage(&Image);
  cvReleaseImage(&v7);
  LOBYTE(v10) = 0;
  sub_427250((int)v9);
  v10 = -1;
  return sub_403F40(v8);
}
// 43683C: using guessed type double __cdecl cvCvtColor(_DWORD, _DWORD, _DWORD);
// 436848: using guessed type int __cdecl cvCreateImage(_DWORD);
// 43684E: using guessed type int __cdecl cvReleaseImage(_DWORD);
// 436866: using guessed type __int64 __cdecl cvGetSize(_DWORD);
// 435DD0: using guessed type int var_98[34];

//----- (00436030) --------------------------------------------------------
void __cdecl sub_436030(__int64 a1, _DWORD *a2, _DWORD *a3, int *a4, double a5, double a6)
{
  void *v6; // [esp+Ch] [ebp-140h]
  __int64 v7[26]; // [esp+3Ch] [ebp-110h] BYREF
  int v8[4]; // [esp+10Ch] [ebp-40h] BYREF
  __int128 v9; // [esp+11Ch] [ebp-30h]
  int v10; // [esp+12Ch] [ebp-20h]
  void *v11[2]; // [esp+130h] [ebp-1Ch] BYREF
  int v12; // [esp+138h] [ebp-14h]
  int v13; // [esp+148h] [ebp-4h]

  memset(v7, 0, sizeof(v7));
  sub_434B20(v7, 10);
  LODWORD(v7[0]) = &CLMInformation1P::`vftable';
  *(double *)&v7[4] = (double)(int)a1 * 0.5;
  *(double *)&v7[5] = (double)SHIDWORD(a1) * 0.5;
  v7[7] = 0x408F400000000000i64;
  v7[6] = a1;
  v13 = 1;
  v11[0] = 0;
  v11[1] = 0;
  v12 = 0;
  sub_404F90(a2, v11);
  sub_405120(a2, v7, (_DWORD **)v11);
  sub_404D80(v7, a3);
  sub_4172E0(v7);
  sub_41DA90((int)v7, *a4, 4, *(double *)&qword_43E0E8);
  if ( SHIDWORD(v7[2]) >= 4 )
  {
    *(_OWORD *)v8 = 0i64;
    v9 = 0i64;
    v10 = 0;
    sub_411000(
      v8,
      (LODWORD(v7[20]) - HIDWORD(v7[19])) / 12 + LODWORD(v7[1]) + 10,
      HIDWORD(v7[2]) + 1 + LODWORD(v7[2]) + LODWORD(v7[3]) + HIDWORD(v7[3]),
      4);
    v6 = (void *)*a4;
    LOBYTE(v13) = 3;
    sub_416640((int)v8, v6);
    v8[3] = a1;
    *(_QWORD *)&v9 = __PAIR64__(v7, HIDWORD(a1));
    sub_416680(v8);
    sub_40D630((int)v8, (char *)*a4, 10);
    sub_4122B0(v8, (int)a2, a2, (_DWORD **)v11, a3, a5, a6);
    LOBYTE(v13) = 1;
    sub_411070(v8);
  }
  else
  {
    sub_419BD0((int)v7, *a4, 4, qword_43E0E8);
    *(_OWORD *)v8 = 0i64;
    v9 = 0i64;
    v10 = 0;
    sub_407850(
      v8,
      LODWORD(v7[1]) + 10,
      LODWORD(v7[3]) + HIDWORD(v7[3]) + (LODWORD(v7[17]) - HIDWORD(v7[16])) / 24 + LODWORD(v7[2]) + 1,
      4);
    LOBYTE(v13) = 2;
    sub_416640((int)v8, (void *)*a4);
    v8[3] = a1;
    *(_QWORD *)&v9 = __PAIR64__(v7, HIDWORD(a1));
    sub_40C4E0(v8);
    sub_40D630((int)v8, (char *)*a4, 10);
    sub_4089A0(v8, (int)a2, (_DWORD **)v11, a3, a5, a6);
    LOBYTE(v13) = 1;
    sub_4078C0(v8);
  }
  if ( v11[0] )
  {
    operator delete(v11[0]);
    v11[0] = 0;
    v11[1] = 0;
    v12 = 0;
  }
  sub_434CA0(v7);
}
// 43A7D8: using guessed type void *CLMInformation1P::`vftable';
// 43E0E8: using guessed type __int64 qword_43E0E8;

//----- (004363E0) --------------------------------------------------------
void __cdecl sub_4363E0(__int64 a1, _DWORD *a2, _DWORD *a3, int *a4)
{
  int v4; // esi
  void *v5; // [esp+4h] [ebp-13Ch]
  __int64 v6[26]; // [esp+30h] [ebp-110h] BYREF
  int v7[4]; // [esp+100h] [ebp-40h] BYREF
  __int128 v8; // [esp+110h] [ebp-30h]
  int v9; // [esp+120h] [ebp-20h]
  void *v10[2]; // [esp+124h] [ebp-1Ch] BYREF
  int v11; // [esp+12Ch] [ebp-14h]
  int v12; // [esp+13Ch] [ebp-4h]

  memset(v6, 0, sizeof(v6));
  sub_434B20(v6, 10);
  LODWORD(v6[0]) = &CLMInformation1P::`vftable';
  *(double *)&v6[4] = (double)(int)a1 * 0.5;
  *(double *)&v6[5] = (double)SHIDWORD(a1) * 0.5;
  v6[7] = 0x408F400000000000i64;
  v6[6] = a1;
  v12 = 1;
  v10[0] = 0;
  v10[1] = 0;
  v11 = 0;
  sub_404F90(a2, v10);
  sub_405120(a2, v6, (_DWORD **)v10);
  sub_404D80(v6, a3);
  sub_418880((int)v6, (int)a4, (int)a3, *a4, 4, qword_43E0E8);
  v4 = LODWORD(v6[1]) + 10;
  v9 = 0;
  *(_OWORD *)v7 = 0i64;
  v8 = 0i64;
  sub_40C640(v7, LODWORD(v6[1]) + 10, HIDWORD(v6[3]) + LODWORD(v6[3]) + LODWORD(v6[2]) + 1, 4);
  v5 = (void *)*a4;
  v7[3] = a1;
  *(_QWORD *)&v8 = __PAIR64__(v6, HIDWORD(a1));
  LOBYTE(v12) = 2;
  sub_416640((int)v7, v5);
  sub_410E70(v7);
  sub_40D630((int)v7, (char *)*a4, v4);
  sub_4172E0(v6);
  LOBYTE(v12) = 1;
  sub_40C6B0(v7);
  if ( v10[0] )
  {
    operator delete(v10[0]);
    v10[0] = 0;
    v10[1] = 0;
    v11 = 0;
  }
  sub_434CA0(v6);
}
// 43A7D8: using guessed type void *CLMInformation1P::`vftable';
// 43E0E8: using guessed type __int64 qword_43E0E8;

//----- (00436640) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  __m128d v3; // xmm5
  FILE *v4; // eax
  const char *v6; // ecx
  char *v7; // edx
  char v8; // al
  const char *v9; // ecx
  char *v10; // edx
  char v11; // al
  int v12; // edi
  int v13; // esi
  int Image; // eax
  const char *v15; // [esp+Ch] [ebp-42Ch]
  int v16; // [esp+1Ch] [ebp-41Ch] BYREF
  int v17; // [esp+20h] [ebp-418h] BYREF
  __m128i v18; // [esp+24h] [ebp-414h] BYREF
  char v19[512]; // [esp+34h] [ebp-404h] BYREF
  char v20[512]; // [esp+234h] [ebp-204h] BYREF

  if ( argc == 5 )
  {
    v6 = argv[1];
    v7 = (char *)(v20 - v6);
    do
    {
      v8 = *v6++;
      v6[(_DWORD)v7 - 1] = v8;
    }
    while ( v8 );
    v9 = argv[2];
    v10 = (char *)(v19 - v9);
    do
    {
      v11 = *v9++;
      v9[(_DWORD)v10 - 1] = v11;
    }
    while ( v11 );
    v12 = (int)atof(argv[3]);
    v13 = (int)atof(argv[4]);
    Image = cvLoadImage(v20, 1);
    v17 = Image;
    if ( Image )
    {
      v16 = cvCreateImage((int)((double)*(int *)(Image + 40) * 1.5));
      sub_435000(v3, v17, v16, &v18, 1.5, v13 != 0);
      printf("\n");
      cvSaveImage(v19, v16, 0);
      if ( v12 )
      {
        sub_435200((int)"input", v17);
        sub_435200((int)"output", v16);
        cvWaitKey(0);
        cvDestroyAllWindows();
      }
      cvReleaseImage(&v17);
      cvReleaseImage(&v16);
      return 0;
    }
    else
    {
      printf("There is no input image : (%s)\n", v20);
      return 1;
    }
  }
  else
  {
    v15 = *argv;
    v4 = _iob_func();
    fprintf(v4 + 2, "usage: (%s) (input image) (rectified image) (flag1) (flag2)\n", v15);
    return 1;
  }
}
// 436796: variable 'v3' is possibly undefined
// 436848: using guessed type int __cdecl cvCreateImage(_DWORD);
// 43684E: using guessed type int __cdecl cvReleaseImage(_DWORD);
// 4368AE: using guessed type int cvDestroyAllWindows(void);
// 4368B4: using guessed type int __cdecl cvLoadImage(_DWORD, _DWORD);
// 4368BA: using guessed type int __cdecl cvSaveImage(_DWORD, _DWORD, _DWORD);
// 4368C0: using guessed type int __cdecl cvWaitKey(_DWORD);

//----- (00437697) --------------------------------------------------------
int sub_437697()
{
  _crtSetUnhandledExceptionFilter(__CxxUnhandledExceptionFilter);
  return 0;
}
// 43792C: using guessed type int __cdecl _crtSetUnhandledExceptionFilter(_DWORD);

//----- (0043789D) --------------------------------------------------------
int __cdecl UserMathErrorFunction()
{
  return 0;
}

//----- (004378A0) --------------------------------------------------------
void sub_4378A0()
{
  void (**i)(void); // esi

  for ( i = dword_43B498; i < dword_43B498; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 43B498: using guessed type void (*dword_43B498[2])(void);

//----- (004378C0) --------------------------------------------------------
void __cdecl sub_4378C0()
{
  void (**i)(void); // esi

  for ( i = dword_43B4A0; i < dword_43B4A0; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 43B4A0: using guessed type void (*dword_43B4A0[2])(void);

//----- (00438C40) --------------------------------------------------------
void __cdecl sub_438C40()
{
  off_43E000[0] = (int (__thiscall **)(void *, char))&std::error_category::`vftable';
}
// 43922C: using guessed type void *std::error_category::`vftable';
// 43E000: using guessed type int (__thiscall **off_43E000[3])(void *, char);

//----- (00438C50) --------------------------------------------------------
void __cdecl sub_438C50()
{
  off_43E004[0] = (int (__thiscall **)(void *, char))&std::error_category::`vftable';
}
// 43922C: using guessed type void *std::error_category::`vftable';
// 43E004: using guessed type int (__thiscall **off_43E004[2])(void *, char);

//----- (00438C60) --------------------------------------------------------
void __cdecl sub_438C60()
{
  off_43E008 = (int (__thiscall **)(void *, char))&std::error_category::`vftable';
}
// 43922C: using guessed type void *std::error_category::`vftable';
// 43E008: using guessed type int (__thiscall **off_43E008)(void *, char);

// nfuncs=517 queued=414 decompiled=414 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 414 function(s)"
